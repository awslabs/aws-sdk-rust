// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn acknowledge_job(&self) -> fluent_builders::AcknowledgeJob<C> {
        fluent_builders::AcknowledgeJob::new(self.handle.clone())
    }
    pub fn acknowledge_third_party_job(&self) -> fluent_builders::AcknowledgeThirdPartyJob<C> {
        fluent_builders::AcknowledgeThirdPartyJob::new(self.handle.clone())
    }
    pub fn create_custom_action_type(&self) -> fluent_builders::CreateCustomActionType<C> {
        fluent_builders::CreateCustomActionType::new(self.handle.clone())
    }
    pub fn create_pipeline(&self) -> fluent_builders::CreatePipeline<C> {
        fluent_builders::CreatePipeline::new(self.handle.clone())
    }
    pub fn delete_custom_action_type(&self) -> fluent_builders::DeleteCustomActionType<C> {
        fluent_builders::DeleteCustomActionType::new(self.handle.clone())
    }
    pub fn delete_pipeline(&self) -> fluent_builders::DeletePipeline<C> {
        fluent_builders::DeletePipeline::new(self.handle.clone())
    }
    pub fn delete_webhook(&self) -> fluent_builders::DeleteWebhook<C> {
        fluent_builders::DeleteWebhook::new(self.handle.clone())
    }
    pub fn deregister_webhook_with_third_party(
        &self,
    ) -> fluent_builders::DeregisterWebhookWithThirdParty<C> {
        fluent_builders::DeregisterWebhookWithThirdParty::new(self.handle.clone())
    }
    pub fn disable_stage_transition(&self) -> fluent_builders::DisableStageTransition<C> {
        fluent_builders::DisableStageTransition::new(self.handle.clone())
    }
    pub fn enable_stage_transition(&self) -> fluent_builders::EnableStageTransition<C> {
        fluent_builders::EnableStageTransition::new(self.handle.clone())
    }
    pub fn get_action_type(&self) -> fluent_builders::GetActionType<C> {
        fluent_builders::GetActionType::new(self.handle.clone())
    }
    pub fn get_job_details(&self) -> fluent_builders::GetJobDetails<C> {
        fluent_builders::GetJobDetails::new(self.handle.clone())
    }
    pub fn get_pipeline(&self) -> fluent_builders::GetPipeline<C> {
        fluent_builders::GetPipeline::new(self.handle.clone())
    }
    pub fn get_pipeline_execution(&self) -> fluent_builders::GetPipelineExecution<C> {
        fluent_builders::GetPipelineExecution::new(self.handle.clone())
    }
    pub fn get_pipeline_state(&self) -> fluent_builders::GetPipelineState<C> {
        fluent_builders::GetPipelineState::new(self.handle.clone())
    }
    pub fn get_third_party_job_details(&self) -> fluent_builders::GetThirdPartyJobDetails<C> {
        fluent_builders::GetThirdPartyJobDetails::new(self.handle.clone())
    }
    pub fn list_action_executions(&self) -> fluent_builders::ListActionExecutions<C> {
        fluent_builders::ListActionExecutions::new(self.handle.clone())
    }
    pub fn list_action_types(&self) -> fluent_builders::ListActionTypes<C> {
        fluent_builders::ListActionTypes::new(self.handle.clone())
    }
    pub fn list_pipeline_executions(&self) -> fluent_builders::ListPipelineExecutions<C> {
        fluent_builders::ListPipelineExecutions::new(self.handle.clone())
    }
    pub fn list_pipelines(&self) -> fluent_builders::ListPipelines<C> {
        fluent_builders::ListPipelines::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_webhooks(&self) -> fluent_builders::ListWebhooks<C> {
        fluent_builders::ListWebhooks::new(self.handle.clone())
    }
    pub fn poll_for_jobs(&self) -> fluent_builders::PollForJobs<C> {
        fluent_builders::PollForJobs::new(self.handle.clone())
    }
    pub fn poll_for_third_party_jobs(&self) -> fluent_builders::PollForThirdPartyJobs<C> {
        fluent_builders::PollForThirdPartyJobs::new(self.handle.clone())
    }
    pub fn put_action_revision(&self) -> fluent_builders::PutActionRevision<C> {
        fluent_builders::PutActionRevision::new(self.handle.clone())
    }
    pub fn put_approval_result(&self) -> fluent_builders::PutApprovalResult<C> {
        fluent_builders::PutApprovalResult::new(self.handle.clone())
    }
    pub fn put_job_failure_result(&self) -> fluent_builders::PutJobFailureResult<C> {
        fluent_builders::PutJobFailureResult::new(self.handle.clone())
    }
    pub fn put_job_success_result(&self) -> fluent_builders::PutJobSuccessResult<C> {
        fluent_builders::PutJobSuccessResult::new(self.handle.clone())
    }
    pub fn put_third_party_job_failure_result(
        &self,
    ) -> fluent_builders::PutThirdPartyJobFailureResult<C> {
        fluent_builders::PutThirdPartyJobFailureResult::new(self.handle.clone())
    }
    pub fn put_third_party_job_success_result(
        &self,
    ) -> fluent_builders::PutThirdPartyJobSuccessResult<C> {
        fluent_builders::PutThirdPartyJobSuccessResult::new(self.handle.clone())
    }
    pub fn put_webhook(&self) -> fluent_builders::PutWebhook<C> {
        fluent_builders::PutWebhook::new(self.handle.clone())
    }
    pub fn register_webhook_with_third_party(
        &self,
    ) -> fluent_builders::RegisterWebhookWithThirdParty<C> {
        fluent_builders::RegisterWebhookWithThirdParty::new(self.handle.clone())
    }
    pub fn retry_stage_execution(&self) -> fluent_builders::RetryStageExecution<C> {
        fluent_builders::RetryStageExecution::new(self.handle.clone())
    }
    pub fn start_pipeline_execution(&self) -> fluent_builders::StartPipelineExecution<C> {
        fluent_builders::StartPipelineExecution::new(self.handle.clone())
    }
    pub fn stop_pipeline_execution(&self) -> fluent_builders::StopPipelineExecution<C> {
        fluent_builders::StopPipelineExecution::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_action_type(&self) -> fluent_builders::UpdateActionType<C> {
        fluent_builders::UpdateActionType::new(self.handle.clone())
    }
    pub fn update_pipeline(&self) -> fluent_builders::UpdatePipeline<C> {
        fluent_builders::UpdatePipeline::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcknowledgeJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::acknowledge_job_input::Builder,
    }
    impl<C> AcknowledgeJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcknowledgeJobOutput,
            smithy_http::result::SdkError<crate::error::AcknowledgeJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique system-generated ID of the job for which you want to confirm
        /// receipt.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
        /// is being worked on by only one job worker. Get this number from the response of the
        /// <a>PollForJobs</a> request that returned this job.</p>
        pub fn nonce(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nonce(input);
            self
        }
        pub fn set_nonce(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_nonce(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AcknowledgeThirdPartyJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::acknowledge_third_party_job_input::Builder,
    }
    impl<C> AcknowledgeThirdPartyJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcknowledgeThirdPartyJobOutput,
            smithy_http::result::SdkError<crate::error::AcknowledgeThirdPartyJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique system-generated ID of the job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
        /// is being worked on by only one job worker. Get this number from the response to a <a>GetThirdPartyJobDetails</a> request.</p>
        pub fn nonce(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nonce(input);
            self
        }
        pub fn set_nonce(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_nonce(input);
            self
        }
        /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
        /// the calling entity is allowed access to the job and its details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCustomActionType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_custom_action_type_input::Builder,
    }
    impl<C> CreateCustomActionType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCustomActionTypeOutput,
            smithy_http::result::SdkError<crate::error::CreateCustomActionTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The category of the custom action, such as a build action or a test
        /// action.</p>
        pub fn category(mut self, input: crate::model::ActionCategory) -> Self {
            self.inner = self.inner.category(input);
            self
        }
        pub fn set_category(
            mut self,
            input: std::option::Option<crate::model::ActionCategory>,
        ) -> Self {
            self.inner = self.inner.set_category(input);
            self
        }
        /// <p>The provider of the service used in the custom action, such as AWS
        /// CodeDeploy.</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.provider(input);
            self
        }
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_provider(input);
            self
        }
        /// <p>The version identifier of the custom action.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>URLs that provide users information about this custom action.</p>
        pub fn settings(mut self, input: crate::model::ActionTypeSettings) -> Self {
            self.inner = self.inner.settings(input);
            self
        }
        pub fn set_settings(
            mut self,
            input: std::option::Option<crate::model::ActionTypeSettings>,
        ) -> Self {
            self.inner = self.inner.set_settings(input);
            self
        }
        /// <p>The configuration properties for the custom action.</p>
        /// <note>
        /// <p>You can refer to a name in the configuration properties of the custom action
        /// within the URL templates by following the format of {Config:name}, as long as the
        /// configuration property is both required and not secret. For more information, see
        /// <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/how-to-create-custom-action.html">Create a
        /// Custom Action for a Pipeline</a>.</p>
        /// </note>
        pub fn configuration_properties(
            mut self,
            inp: impl Into<crate::model::ActionConfigurationProperty>,
        ) -> Self {
            self.inner = self.inner.configuration_properties(inp);
            self
        }
        pub fn set_configuration_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ActionConfigurationProperty>>,
        ) -> Self {
            self.inner = self.inner.set_configuration_properties(input);
            self
        }
        /// <p>The details of the input artifact for the action, such as its commit ID.</p>
        pub fn input_artifact_details(mut self, input: crate::model::ArtifactDetails) -> Self {
            self.inner = self.inner.input_artifact_details(input);
            self
        }
        pub fn set_input_artifact_details(
            mut self,
            input: std::option::Option<crate::model::ArtifactDetails>,
        ) -> Self {
            self.inner = self.inner.set_input_artifact_details(input);
            self
        }
        /// <p>The details of the output artifact of the action, such as its commit ID.</p>
        pub fn output_artifact_details(mut self, input: crate::model::ArtifactDetails) -> Self {
            self.inner = self.inner.output_artifact_details(input);
            self
        }
        pub fn set_output_artifact_details(
            mut self,
            input: std::option::Option<crate::model::ArtifactDetails>,
        ) -> Self {
            self.inner = self.inner.set_output_artifact_details(input);
            self
        }
        /// <p>The tags for the custom action.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_pipeline_input::Builder,
    }
    impl<C> CreatePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePipelineOutput,
            smithy_http::result::SdkError<crate::error::CreatePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Represents the structure of actions and stages to be performed in the pipeline.
        /// </p>
        pub fn pipeline(mut self, input: crate::model::PipelineDeclaration) -> Self {
            self.inner = self.inner.pipeline(input);
            self
        }
        pub fn set_pipeline(
            mut self,
            input: std::option::Option<crate::model::PipelineDeclaration>,
        ) -> Self {
            self.inner = self.inner.set_pipeline(input);
            self
        }
        /// <p>The tags for the pipeline.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCustomActionType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_custom_action_type_input::Builder,
    }
    impl<C> DeleteCustomActionType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCustomActionTypeOutput,
            smithy_http::result::SdkError<crate::error::DeleteCustomActionTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The category of the custom action that you want to delete, such as source or
        /// deploy.</p>
        pub fn category(mut self, input: crate::model::ActionCategory) -> Self {
            self.inner = self.inner.category(input);
            self
        }
        pub fn set_category(
            mut self,
            input: std::option::Option<crate::model::ActionCategory>,
        ) -> Self {
            self.inner = self.inner.set_category(input);
            self
        }
        /// <p>The provider of the service used in the custom action, such as AWS
        /// CodeDeploy.</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.provider(input);
            self
        }
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_provider(input);
            self
        }
        /// <p>The version of the custom action to delete.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_pipeline_input::Builder,
    }
    impl<C> DeletePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePipelineOutput,
            smithy_http::result::SdkError<crate::error::DeletePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline to be deleted.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteWebhook<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_webhook_input::Builder,
    }
    impl<C> DeleteWebhook<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteWebhookOutput,
            smithy_http::result::SdkError<crate::error::DeleteWebhookError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the webhook you want to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterWebhookWithThirdParty<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_webhook_with_third_party_input::Builder,
    }
    impl<C> DeregisterWebhookWithThirdParty<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterWebhookWithThirdPartyOutput,
            smithy_http::result::SdkError<crate::error::DeregisterWebhookWithThirdPartyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the webhook you want to deregister.</p>
        pub fn webhook_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.webhook_name(input);
            self
        }
        pub fn set_webhook_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_webhook_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableStageTransition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_stage_transition_input::Builder,
    }
    impl<C> DisableStageTransition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableStageTransitionOutput,
            smithy_http::result::SdkError<crate::error::DisableStageTransitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline in which you want to disable the flow of artifacts from
        /// one stage to another.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The name of the stage where you want to disable the inbound or outbound transition
        /// of artifacts.</p>
        pub fn stage_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stage_name(input);
            self
        }
        pub fn set_stage_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stage_name(input);
            self
        }
        /// <p>Specifies whether artifacts are prevented from transitioning into the stage and
        /// being processed by the actions in that stage (inbound), or prevented from transitioning
        /// from the stage after they have been processed by the actions in that stage
        /// (outbound).</p>
        pub fn transition_type(mut self, input: crate::model::StageTransitionType) -> Self {
            self.inner = self.inner.transition_type(input);
            self
        }
        pub fn set_transition_type(
            mut self,
            input: std::option::Option<crate::model::StageTransitionType>,
        ) -> Self {
            self.inner = self.inner.set_transition_type(input);
            self
        }
        /// <p>The reason given to the user that a stage is disabled, such as waiting for manual
        /// approval or manual tests. This message is displayed in the pipeline console
        /// UI.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableStageTransition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_stage_transition_input::Builder,
    }
    impl<C> EnableStageTransition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableStageTransitionOutput,
            smithy_http::result::SdkError<crate::error::EnableStageTransitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline in which you want to enable the flow of artifacts from one
        /// stage to another.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The name of the stage where you want to enable the transition of artifacts, either
        /// into the stage (inbound) or from that stage to the next stage (outbound).</p>
        pub fn stage_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stage_name(input);
            self
        }
        pub fn set_stage_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stage_name(input);
            self
        }
        /// <p>Specifies whether artifacts are allowed to enter the stage and be processed by the
        /// actions in that stage (inbound) or whether already processed artifacts are allowed to
        /// transition to the next stage (outbound).</p>
        pub fn transition_type(mut self, input: crate::model::StageTransitionType) -> Self {
            self.inner = self.inner.transition_type(input);
            self
        }
        pub fn set_transition_type(
            mut self,
            input: std::option::Option<crate::model::StageTransitionType>,
        ) -> Self {
            self.inner = self.inner.set_transition_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetActionType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_action_type_input::Builder,
    }
    impl<C> GetActionType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetActionTypeOutput,
            smithy_http::result::SdkError<crate::error::GetActionTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Defines what kind of action can be taken in the stage. The following are the valid
        /// values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Source</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Build</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Test</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Deploy</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Approval</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Invoke</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn category(mut self, input: crate::model::ActionCategory) -> Self {
            self.inner = self.inner.category(input);
            self
        }
        pub fn set_category(
            mut self,
            input: std::option::Option<crate::model::ActionCategory>,
        ) -> Self {
            self.inner = self.inner.set_category(input);
            self
        }
        /// <p>The creator of an action type that was created with any supported integration model.
        /// There are two valid values: <code>AWS</code> and <code>ThirdParty</code>.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owner(input);
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_owner(input);
            self
        }
        /// <p>The provider of the action type being called. The provider name is specified when the
        /// action type is created.</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.provider(input);
            self
        }
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_provider(input);
            self
        }
        /// <p>A string that describes the action type version.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobDetails<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_details_input::Builder,
    }
    impl<C> GetJobDetails<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobDetailsOutput,
            smithy_http::result::SdkError<crate::error::GetJobDetailsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique system-generated ID for the job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_pipeline_input::Builder,
    }
    impl<C> GetPipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPipelineOutput,
            smithy_http::result::SdkError<crate::error::GetPipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline for which you want to get information. Pipeline names must
        /// be unique under an AWS user account.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The version number of the pipeline. If you do not specify a version, defaults to
        /// the current version.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPipelineExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_pipeline_execution_input::Builder,
    }
    impl<C> GetPipelineExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPipelineExecutionOutput,
            smithy_http::result::SdkError<crate::error::GetPipelineExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline about which you want to get execution details.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The ID of the pipeline execution about which you want to get execution
        /// details.</p>
        pub fn pipeline_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_execution_id(input);
            self
        }
        pub fn set_pipeline_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_execution_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPipelineState<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_pipeline_state_input::Builder,
    }
    impl<C> GetPipelineState<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPipelineStateOutput,
            smithy_http::result::SdkError<crate::error::GetPipelineStateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline about which you want to get information.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetThirdPartyJobDetails<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_third_party_job_details_input::Builder,
    }
    impl<C> GetThirdPartyJobDetails<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetThirdPartyJobDetailsOutput,
            smithy_http::result::SdkError<crate::error::GetThirdPartyJobDetailsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique system-generated ID used for identifying the job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
        /// the calling entity is allowed access to the job and its details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListActionExecutions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_action_executions_input::Builder,
    }
    impl<C> ListActionExecutions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListActionExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListActionExecutionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of the pipeline for which you want to list action execution history.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>Input information used to filter action execution history.</p>
        pub fn filter(mut self, input: crate::model::ActionExecutionFilter) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<crate::model::ActionExecutionFilter>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned nextToken value. Action execution history
        /// is retained for up to 12 months, based on action execution start times. Default value is
        /// 100. </p>
        /// <note>
        /// <p>Detailed execution history is available for executions run on or after February
        /// 21, 2019.</p>
        /// </note>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token that was returned from the previous <code>ListActionExecutions</code> call,
        /// which can be used to return the next set of action executions in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListActionTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_action_types_input::Builder,
    }
    impl<C> ListActionTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListActionTypesOutput,
            smithy_http::result::SdkError<crate::error::ListActionTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters the list of action types to those created by a specified entity.</p>
        pub fn action_owner_filter(mut self, input: crate::model::ActionOwner) -> Self {
            self.inner = self.inner.action_owner_filter(input);
            self
        }
        pub fn set_action_owner_filter(
            mut self,
            input: std::option::Option<crate::model::ActionOwner>,
        ) -> Self {
            self.inner = self.inner.set_action_owner_filter(input);
            self
        }
        /// <p>An identifier that was returned from the previous list action types call, which can
        /// be used to return the next set of action types in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The Region to filter on for the list of action types.</p>
        pub fn region_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.region_filter(input);
            self
        }
        pub fn set_region_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_region_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPipelineExecutions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_pipeline_executions_input::Builder,
    }
    impl<C> ListPipelineExecutions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPipelineExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListPipelineExecutionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline for which you want to get execution summary
        /// information.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned nextToken value. Pipeline history is
        /// limited to the most recent 12 months, based on pipeline execution start times. Default
        /// value is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token that was returned from the previous <code>ListPipelineExecutions</code>
        /// call, which can be used to return the next set of pipeline executions in the
        /// list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPipelines<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_pipelines_input::Builder,
    }
    impl<C> ListPipelines<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPipelinesOutput,
            smithy_http::result::SdkError<crate::error::ListPipelinesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier that was returned from the previous list pipelines call. It can be
        /// used to return the next set of pipelines in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of pipelines to return in a single call. To retrieve the remaining
        /// pipelines, make another call with the returned nextToken value. The minimum value you
        /// can specify is 1. The maximum accepted value is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The token that was returned from the previous API call, which would be used to return
        /// the next page of the list. The ListTagsforResource call lists all available tags in one
        /// call and does not use pagination.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListWebhooks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_webhooks_input::Builder,
    }
    impl<C> ListWebhooks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListWebhooksOutput,
            smithy_http::result::SdkError<crate::error::ListWebhooksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token that was returned from the previous ListWebhooks call, which can be used
        /// to return the next set of webhooks in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned nextToken value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PollForJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::poll_for_jobs_input::Builder,
    }
    impl<C> PollForJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PollForJobsOutput,
            smithy_http::result::SdkError<crate::error::PollForJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Represents information about an action type.</p>
        pub fn action_type_id(mut self, input: crate::model::ActionTypeId) -> Self {
            self.inner = self.inner.action_type_id(input);
            self
        }
        pub fn set_action_type_id(
            mut self,
            input: std::option::Option<crate::model::ActionTypeId>,
        ) -> Self {
            self.inner = self.inner.set_action_type_id(input);
            self
        }
        /// <p>The maximum number of jobs to return in a poll for jobs call.</p>
        pub fn max_batch_size(mut self, input: i32) -> Self {
            self.inner = self.inner.max_batch_size(input);
            self
        }
        pub fn set_max_batch_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_batch_size(input);
            self
        }
        /// <p>A map of property names and values. For an action type with no queryable
        /// properties, this value must be null or an empty map. For an action type with a queryable
        /// property, you must supply that property as a key in the map. Only jobs whose action
        /// configuration matches the mapped value are returned.</p>
        pub fn query_param(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.query_param(k, v);
            self
        }
        pub fn set_query_param(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_query_param(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PollForThirdPartyJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::poll_for_third_party_jobs_input::Builder,
    }
    impl<C> PollForThirdPartyJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PollForThirdPartyJobsOutput,
            smithy_http::result::SdkError<crate::error::PollForThirdPartyJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Represents information about an action type.</p>
        pub fn action_type_id(mut self, input: crate::model::ActionTypeId) -> Self {
            self.inner = self.inner.action_type_id(input);
            self
        }
        pub fn set_action_type_id(
            mut self,
            input: std::option::Option<crate::model::ActionTypeId>,
        ) -> Self {
            self.inner = self.inner.set_action_type_id(input);
            self
        }
        /// <p>The maximum number of jobs to return in a poll for jobs call.</p>
        pub fn max_batch_size(mut self, input: i32) -> Self {
            self.inner = self.inner.max_batch_size(input);
            self
        }
        pub fn set_max_batch_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_batch_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutActionRevision<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_action_revision_input::Builder,
    }
    impl<C> PutActionRevision<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutActionRevisionOutput,
            smithy_http::result::SdkError<crate::error::PutActionRevisionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline that starts processing the revision to the
        /// source.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The name of the stage that contains the action that acts on the revision.</p>
        pub fn stage_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stage_name(input);
            self
        }
        pub fn set_stage_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stage_name(input);
            self
        }
        /// <p>The name of the action that processes the revision.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_name(input);
            self
        }
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_action_name(input);
            self
        }
        /// <p>Represents information about the version (or revision) of an action.</p>
        pub fn action_revision(mut self, input: crate::model::ActionRevision) -> Self {
            self.inner = self.inner.action_revision(input);
            self
        }
        pub fn set_action_revision(
            mut self,
            input: std::option::Option<crate::model::ActionRevision>,
        ) -> Self {
            self.inner = self.inner.set_action_revision(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutApprovalResult<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_approval_result_input::Builder,
    }
    impl<C> PutApprovalResult<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutApprovalResultOutput,
            smithy_http::result::SdkError<crate::error::PutApprovalResultError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline that contains the action. </p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The name of the stage that contains the action.</p>
        pub fn stage_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stage_name(input);
            self
        }
        pub fn set_stage_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stage_name(input);
            self
        }
        /// <p>The name of the action for which approval is requested.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_name(input);
            self
        }
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_action_name(input);
            self
        }
        /// <p>Represents information about the result of the approval request.</p>
        pub fn result(mut self, input: crate::model::ApprovalResult) -> Self {
            self.inner = self.inner.result(input);
            self
        }
        pub fn set_result(
            mut self,
            input: std::option::Option<crate::model::ApprovalResult>,
        ) -> Self {
            self.inner = self.inner.set_result(input);
            self
        }
        /// <p>The system-generated token used to identify a unique approval request. The token
        /// for each open approval request can be obtained using the <a>GetPipelineState</a> action. It is used to validate that the approval
        /// request corresponding to this token is still valid.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token(input);
            self
        }
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutJobFailureResult<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_job_failure_result_input::Builder,
    }
    impl<C> PutJobFailureResult<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutJobFailureResultOutput,
            smithy_http::result::SdkError<crate::error::PutJobFailureResultError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique system-generated ID of the job that failed. This is the same ID returned
        /// from <code>PollForJobs</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The details about the failure of a job.</p>
        pub fn failure_details(mut self, input: crate::model::FailureDetails) -> Self {
            self.inner = self.inner.failure_details(input);
            self
        }
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::FailureDetails>,
        ) -> Self {
            self.inner = self.inner.set_failure_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutJobSuccessResult<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_job_success_result_input::Builder,
    }
    impl<C> PutJobSuccessResult<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutJobSuccessResultOutput,
            smithy_http::result::SdkError<crate::error::PutJobSuccessResultError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique system-generated ID of the job that succeeded. This is the same ID
        /// returned from <code>PollForJobs</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The ID of the current revision of the artifact successfully worked on by the
        /// job.</p>
        pub fn current_revision(mut self, input: crate::model::CurrentRevision) -> Self {
            self.inner = self.inner.current_revision(input);
            self
        }
        pub fn set_current_revision(
            mut self,
            input: std::option::Option<crate::model::CurrentRevision>,
        ) -> Self {
            self.inner = self.inner.set_current_revision(input);
            self
        }
        /// <p>A token generated by a job worker, such as an AWS CodeDeploy deployment ID, that a
        /// successful job provides to identify a custom action in progress. Future jobs use this
        /// token to identify the running instance of the action. It can be reused to return more
        /// information about the progress of the custom action. When the action is complete, no
        /// continuation token should be supplied.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.continuation_token(input);
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_continuation_token(input);
            self
        }
        /// <p>The execution details of the successful job, such as the actions taken by the job
        /// worker.</p>
        pub fn execution_details(mut self, input: crate::model::ExecutionDetails) -> Self {
            self.inner = self.inner.execution_details(input);
            self
        }
        pub fn set_execution_details(
            mut self,
            input: std::option::Option<crate::model::ExecutionDetails>,
        ) -> Self {
            self.inner = self.inner.set_execution_details(input);
            self
        }
        /// <p>Key-value pairs produced as output by a job worker that can be made available to a
        /// downstream action configuration. <code>outputVariables</code> can be included only when
        /// there is no continuation token on the request.</p>
        pub fn output_variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.output_variables(k, v);
            self
        }
        pub fn set_output_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_output_variables(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutThirdPartyJobFailureResult<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_third_party_job_failure_result_input::Builder,
    }
    impl<C> PutThirdPartyJobFailureResult<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutThirdPartyJobFailureResultOutput,
            smithy_http::result::SdkError<crate::error::PutThirdPartyJobFailureResultError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the job that failed. This is the same ID returned from
        /// <code>PollForThirdPartyJobs</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
        /// the calling entity is allowed access to the job and its details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Represents information about failure details.</p>
        pub fn failure_details(mut self, input: crate::model::FailureDetails) -> Self {
            self.inner = self.inner.failure_details(input);
            self
        }
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::FailureDetails>,
        ) -> Self {
            self.inner = self.inner.set_failure_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutThirdPartyJobSuccessResult<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_third_party_job_success_result_input::Builder,
    }
    impl<C> PutThirdPartyJobSuccessResult<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutThirdPartyJobSuccessResultOutput,
            smithy_http::result::SdkError<crate::error::PutThirdPartyJobSuccessResultError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the job that successfully completed. This is the same ID returned from
        /// <code>PollForThirdPartyJobs</code>.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
        /// the calling entity is allowed access to the job and its details.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Represents information about a current revision.</p>
        pub fn current_revision(mut self, input: crate::model::CurrentRevision) -> Self {
            self.inner = self.inner.current_revision(input);
            self
        }
        pub fn set_current_revision(
            mut self,
            input: std::option::Option<crate::model::CurrentRevision>,
        ) -> Self {
            self.inner = self.inner.set_current_revision(input);
            self
        }
        /// <p>A token generated by a job worker, such as an AWS CodeDeploy deployment ID, that a
        /// successful job provides to identify a partner action in progress. Future jobs use this
        /// token to identify the running instance of the action. It can be reused to return more
        /// information about the progress of the partner action. When the action is complete, no
        /// continuation token should be supplied.</p>
        pub fn continuation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.continuation_token(input);
            self
        }
        pub fn set_continuation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_continuation_token(input);
            self
        }
        /// <p>The details of the actions taken and results produced on an artifact as it passes
        /// through stages in the pipeline. </p>
        pub fn execution_details(mut self, input: crate::model::ExecutionDetails) -> Self {
            self.inner = self.inner.execution_details(input);
            self
        }
        pub fn set_execution_details(
            mut self,
            input: std::option::Option<crate::model::ExecutionDetails>,
        ) -> Self {
            self.inner = self.inner.set_execution_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutWebhook<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_webhook_input::Builder,
    }
    impl<C> PutWebhook<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutWebhookOutput,
            smithy_http::result::SdkError<crate::error::PutWebhookError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The detail provided in an input file to create the webhook, such as the webhook
        /// name, the pipeline name, and the action name. Give the webhook a unique name that helps
        /// you identify it. You might name the webhook after the pipeline and action it targets so
        /// that you can easily recognize what it's used for later.</p>
        pub fn webhook(mut self, input: crate::model::WebhookDefinition) -> Self {
            self.inner = self.inner.webhook(input);
            self
        }
        pub fn set_webhook(
            mut self,
            input: std::option::Option<crate::model::WebhookDefinition>,
        ) -> Self {
            self.inner = self.inner.set_webhook(input);
            self
        }
        /// <p>The tags for the webhook.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterWebhookWithThirdParty<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_webhook_with_third_party_input::Builder,
    }
    impl<C> RegisterWebhookWithThirdParty<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterWebhookWithThirdPartyOutput,
            smithy_http::result::SdkError<crate::error::RegisterWebhookWithThirdPartyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an existing webhook created with PutWebhook to register with a
        /// supported third party. </p>
        pub fn webhook_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.webhook_name(input);
            self
        }
        pub fn set_webhook_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_webhook_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RetryStageExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::retry_stage_execution_input::Builder,
    }
    impl<C> RetryStageExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RetryStageExecutionOutput,
            smithy_http::result::SdkError<crate::error::RetryStageExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline that contains the failed stage.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The name of the failed stage to be retried.</p>
        pub fn stage_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stage_name(input);
            self
        }
        pub fn set_stage_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stage_name(input);
            self
        }
        /// <p>The ID of the pipeline execution in the failed stage to be retried. Use the <a>GetPipelineState</a> action to retrieve the current pipelineExecutionId of
        /// the failed stage</p>
        pub fn pipeline_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_execution_id(input);
            self
        }
        pub fn set_pipeline_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_execution_id(input);
            self
        }
        /// <p>The scope of the retry attempt. Currently, the only supported value is
        /// FAILED_ACTIONS.</p>
        pub fn retry_mode(mut self, input: crate::model::StageRetryMode) -> Self {
            self.inner = self.inner.retry_mode(input);
            self
        }
        pub fn set_retry_mode(
            mut self,
            input: std::option::Option<crate::model::StageRetryMode>,
        ) -> Self {
            self.inner = self.inner.set_retry_mode(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartPipelineExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_pipeline_execution_input::Builder,
    }
    impl<C> StartPipelineExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartPipelineExecutionOutput,
            smithy_http::result::SdkError<crate::error::StartPipelineExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline to start.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The system-generated unique ID used to identify a unique execution
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopPipelineExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_pipeline_execution_input::Builder,
    }
    impl<C> StopPipelineExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopPipelineExecutionOutput,
            smithy_http::result::SdkError<crate::error::StopPipelineExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline to stop.</p>
        pub fn pipeline_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_name(input);
            self
        }
        pub fn set_pipeline_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_name(input);
            self
        }
        /// <p>The ID of the pipeline execution to be stopped in the current stage. Use the
        /// <code>GetPipelineState</code> action to retrieve the current
        /// pipelineExecutionId.</p>
        pub fn pipeline_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pipeline_execution_id(input);
            self
        }
        pub fn set_pipeline_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_execution_id(input);
            self
        }
        /// <p>Use this option to stop the pipeline execution by abandoning, rather than finishing,
        /// in-progress actions.</p>
        /// <note>
        /// <p>This option can lead to failed or out-of-sequence tasks.</p>
        /// </note>
        pub fn abandon(mut self, input: bool) -> Self {
            self.inner = self.inner.abandon(input);
            self
        }
        pub fn set_abandon(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_abandon(input);
            self
        }
        /// <p>Use this option to enter comments, such as the reason the pipeline was stopped.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource you want to add tags to.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tags you want to modify or add to the resource.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The Amazon Resource Name (ARN) of the resource to remove tags from.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The list of keys for the tags to be removed from the resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateActionType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_action_type_input::Builder,
    }
    impl<C> UpdateActionType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateActionTypeOutput,
            smithy_http::result::SdkError<crate::error::UpdateActionTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The action type definition for the action type to be updated.</p>
        pub fn action_type(mut self, input: crate::model::ActionTypeDeclaration) -> Self {
            self.inner = self.inner.action_type(input);
            self
        }
        pub fn set_action_type(
            mut self,
            input: std::option::Option<crate::model::ActionTypeDeclaration>,
        ) -> Self {
            self.inner = self.inner.set_action_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pipeline_input::Builder,
    }
    impl<C> UpdatePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePipelineOutput,
            smithy_http::result::SdkError<crate::error::UpdatePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the pipeline to be updated.</p>
        pub fn pipeline(mut self, input: crate::model::PipelineDeclaration) -> Self {
            self.inner = self.inner.pipeline(input);
            self
        }
        pub fn set_pipeline(
            mut self,
            input: std::option::Option<crate::model::PipelineDeclaration>,
        ) -> Self {
            self.inner = self.inner.set_pipeline(input);
            self
        }
    }
}
