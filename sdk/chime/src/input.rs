// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`AssociatePhoneNumbersWithVoiceConnectorInput`](crate::input::AssociatePhoneNumbersWithVoiceConnectorInput)
pub mod associate_phone_numbers_with_voice_connector_input {

    /// A builder for [`AssociatePhoneNumbersWithVoiceConnectorInput`](crate::input::AssociatePhoneNumbersWithVoiceConnectorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) force_associate: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Appends an item to `e164_phone_numbers`.
        ///
        /// To override the contents of this collection use [`set_e164_phone_numbers`](Self::set_e164_phone_numbers).
        ///
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn e164_phone_numbers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.e164_phone_numbers.unwrap_or_default();
            v.push(input.into());
            self.e164_phone_numbers = Some(v);
            self
        }
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn set_e164_phone_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.e164_phone_numbers = input;
            self
        }
        /// <p>If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.</p>
        pub fn force_associate(mut self, input: bool) -> Self {
            self.force_associate = Some(input);
            self
        }
        /// <p>If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.</p>
        pub fn set_force_associate(mut self, input: std::option::Option<bool>) -> Self {
            self.force_associate = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociatePhoneNumbersWithVoiceConnectorInput`](crate::input::AssociatePhoneNumbersWithVoiceConnectorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociatePhoneNumbersWithVoiceConnectorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociatePhoneNumbersWithVoiceConnectorInput {
                voice_connector_id: self.voice_connector_id,
                e164_phone_numbers: self.e164_phone_numbers,
                force_associate: self.force_associate,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociatePhoneNumbersWithVoiceConnectorInputOperationOutputAlias =
    crate::operation::AssociatePhoneNumbersWithVoiceConnector;
#[doc(hidden)]
pub type AssociatePhoneNumbersWithVoiceConnectorInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl AssociatePhoneNumbersWithVoiceConnectorInput {
    /// Consumes the builder and constructs an Operation<[`AssociatePhoneNumbersWithVoiceConnector`](crate::operation::AssociatePhoneNumbersWithVoiceConnector)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociatePhoneNumbersWithVoiceConnector,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociatePhoneNumbersWithVoiceConnectorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_1 = &_input.voice_connector_id;
                let input_1 = input_1.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_1, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::AssociatePhoneNumbersWithVoiceConnectorInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "associate-phone-numbers");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociatePhoneNumbersWithVoiceConnectorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_phone_numbers_with_voice_connector(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociatePhoneNumbersWithVoiceConnector::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociatePhoneNumbersWithVoiceConnector",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociatePhoneNumbersWithVoiceConnectorInput`](crate::input::AssociatePhoneNumbersWithVoiceConnectorInput)
    pub fn builder() -> crate::input::associate_phone_numbers_with_voice_connector_input::Builder {
        crate::input::associate_phone_numbers_with_voice_connector_input::Builder::default()
    }
}

/// See [`AssociatePhoneNumbersWithVoiceConnectorGroupInput`](crate::input::AssociatePhoneNumbersWithVoiceConnectorGroupInput)
pub mod associate_phone_numbers_with_voice_connector_group_input {

    /// A builder for [`AssociatePhoneNumbersWithVoiceConnectorGroupInput`](crate::input::AssociatePhoneNumbersWithVoiceConnectorGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_group_id: std::option::Option<std::string::String>,
        pub(crate) e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) force_associate: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn voice_connector_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_group_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn set_voice_connector_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_group_id = input;
            self
        }
        /// Appends an item to `e164_phone_numbers`.
        ///
        /// To override the contents of this collection use [`set_e164_phone_numbers`](Self::set_e164_phone_numbers).
        ///
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn e164_phone_numbers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.e164_phone_numbers.unwrap_or_default();
            v.push(input.into());
            self.e164_phone_numbers = Some(v);
            self
        }
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn set_e164_phone_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.e164_phone_numbers = input;
            self
        }
        /// <p>If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector Group and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.</p>
        pub fn force_associate(mut self, input: bool) -> Self {
            self.force_associate = Some(input);
            self
        }
        /// <p>If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector Group and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.</p>
        pub fn set_force_associate(mut self, input: std::option::Option<bool>) -> Self {
            self.force_associate = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociatePhoneNumbersWithVoiceConnectorGroupInput`](crate::input::AssociatePhoneNumbersWithVoiceConnectorGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociatePhoneNumbersWithVoiceConnectorGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::AssociatePhoneNumbersWithVoiceConnectorGroupInput {
                    voice_connector_group_id: self.voice_connector_group_id,
                    e164_phone_numbers: self.e164_phone_numbers,
                    force_associate: self.force_associate,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type AssociatePhoneNumbersWithVoiceConnectorGroupInputOperationOutputAlias =
    crate::operation::AssociatePhoneNumbersWithVoiceConnectorGroup;
#[doc(hidden)]
pub type AssociatePhoneNumbersWithVoiceConnectorGroupInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl AssociatePhoneNumbersWithVoiceConnectorGroupInput {
    /// Consumes the builder and constructs an Operation<[`AssociatePhoneNumbersWithVoiceConnectorGroup`](crate::operation::AssociatePhoneNumbersWithVoiceConnectorGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociatePhoneNumbersWithVoiceConnectorGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociatePhoneNumbersWithVoiceConnectorGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_2 = &_input.voice_connector_group_id;
                let input_2 = input_2.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_group_id = aws_smithy_http::label::fmt_string(input_2, false);
                if voice_connector_group_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connector-groups/{VoiceConnectorGroupId}",
                    VoiceConnectorGroupId = voice_connector_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::AssociatePhoneNumbersWithVoiceConnectorGroupInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "associate-phone-numbers");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociatePhoneNumbersWithVoiceConnectorGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_phone_numbers_with_voice_connector_group(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociatePhoneNumbersWithVoiceConnectorGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociatePhoneNumbersWithVoiceConnectorGroup",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociatePhoneNumbersWithVoiceConnectorGroupInput`](crate::input::AssociatePhoneNumbersWithVoiceConnectorGroupInput)
    pub fn builder(
    ) -> crate::input::associate_phone_numbers_with_voice_connector_group_input::Builder {
        crate::input::associate_phone_numbers_with_voice_connector_group_input::Builder::default()
    }
}

/// See [`AssociatePhoneNumberWithUserInput`](crate::input::AssociatePhoneNumberWithUserInput)
pub mod associate_phone_number_with_user_input {

    /// A builder for [`AssociatePhoneNumberWithUserInput`](crate::input::AssociatePhoneNumberWithUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) e164_phone_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The user ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The user ID.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The phone number, in E.164 format.</p>
        pub fn e164_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.e164_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number, in E.164 format.</p>
        pub fn set_e164_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.e164_phone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociatePhoneNumberWithUserInput`](crate::input::AssociatePhoneNumberWithUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociatePhoneNumberWithUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociatePhoneNumberWithUserInput {
                account_id: self.account_id,
                user_id: self.user_id,
                e164_phone_number: self.e164_phone_number,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociatePhoneNumberWithUserInputOperationOutputAlias =
    crate::operation::AssociatePhoneNumberWithUser;
#[doc(hidden)]
pub type AssociatePhoneNumberWithUserInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl AssociatePhoneNumberWithUserInput {
    /// Consumes the builder and constructs an Operation<[`AssociatePhoneNumberWithUser`](crate::operation::AssociatePhoneNumberWithUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociatePhoneNumberWithUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociatePhoneNumberWithUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_3 = &_input.account_id;
                let input_3 = input_3.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_3, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_4 = &_input.user_id;
                let input_4 = input_4.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let user_id = aws_smithy_http::label::fmt_string(input_4, false);
                if user_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users/{UserId}",
                    AccountId = account_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::AssociatePhoneNumberWithUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "associate-phone-number");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociatePhoneNumberWithUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_phone_number_with_user(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociatePhoneNumberWithUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociatePhoneNumberWithUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociatePhoneNumberWithUserInput`](crate::input::AssociatePhoneNumberWithUserInput)
    pub fn builder() -> crate::input::associate_phone_number_with_user_input::Builder {
        crate::input::associate_phone_number_with_user_input::Builder::default()
    }
}

/// See [`AssociateSigninDelegateGroupsWithAccountInput`](crate::input::AssociateSigninDelegateGroupsWithAccountInput)
pub mod associate_signin_delegate_groups_with_account_input {

    /// A builder for [`AssociateSigninDelegateGroupsWithAccountInput`](crate::input::AssociateSigninDelegateGroupsWithAccountInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) signin_delegate_groups:
            std::option::Option<std::vec::Vec<crate::model::SigninDelegateGroup>>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Appends an item to `signin_delegate_groups`.
        ///
        /// To override the contents of this collection use [`set_signin_delegate_groups`](Self::set_signin_delegate_groups).
        ///
        /// <p>The sign-in delegate groups.</p>
        pub fn signin_delegate_groups(mut self, input: crate::model::SigninDelegateGroup) -> Self {
            let mut v = self.signin_delegate_groups.unwrap_or_default();
            v.push(input);
            self.signin_delegate_groups = Some(v);
            self
        }
        /// <p>The sign-in delegate groups.</p>
        pub fn set_signin_delegate_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SigninDelegateGroup>>,
        ) -> Self {
            self.signin_delegate_groups = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateSigninDelegateGroupsWithAccountInput`](crate::input::AssociateSigninDelegateGroupsWithAccountInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateSigninDelegateGroupsWithAccountInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::AssociateSigninDelegateGroupsWithAccountInput {
                    account_id: self.account_id,
                    signin_delegate_groups: self.signin_delegate_groups,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type AssociateSigninDelegateGroupsWithAccountInputOperationOutputAlias =
    crate::operation::AssociateSigninDelegateGroupsWithAccount;
#[doc(hidden)]
pub type AssociateSigninDelegateGroupsWithAccountInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl AssociateSigninDelegateGroupsWithAccountInput {
    /// Consumes the builder and constructs an Operation<[`AssociateSigninDelegateGroupsWithAccount`](crate::operation::AssociateSigninDelegateGroupsWithAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateSigninDelegateGroupsWithAccount,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateSigninDelegateGroupsWithAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_5 = &_input.account_id;
                let input_5 = input_5.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_5, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/accounts/{AccountId}", AccountId = account_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::AssociateSigninDelegateGroupsWithAccountInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "associate-signin-delegate-groups");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateSigninDelegateGroupsWithAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_signin_delegate_groups_with_account(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateSigninDelegateGroupsWithAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateSigninDelegateGroupsWithAccount",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociateSigninDelegateGroupsWithAccountInput`](crate::input::AssociateSigninDelegateGroupsWithAccountInput)
    pub fn builder() -> crate::input::associate_signin_delegate_groups_with_account_input::Builder {
        crate::input::associate_signin_delegate_groups_with_account_input::Builder::default()
    }
}

/// See [`BatchCreateAttendeeInput`](crate::input::BatchCreateAttendeeInput)
pub mod batch_create_attendee_input {

    /// A builder for [`BatchCreateAttendeeInput`](crate::input::BatchCreateAttendeeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) attendees:
            std::option::Option<std::vec::Vec<crate::model::CreateAttendeeRequestItem>>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// Appends an item to `attendees`.
        ///
        /// To override the contents of this collection use [`set_attendees`](Self::set_attendees).
        ///
        /// <p>The request containing the attendees to create.</p>
        pub fn attendees(mut self, input: crate::model::CreateAttendeeRequestItem) -> Self {
            let mut v = self.attendees.unwrap_or_default();
            v.push(input);
            self.attendees = Some(v);
            self
        }
        /// <p>The request containing the attendees to create.</p>
        pub fn set_attendees(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateAttendeeRequestItem>>,
        ) -> Self {
            self.attendees = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchCreateAttendeeInput`](crate::input::BatchCreateAttendeeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::BatchCreateAttendeeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::BatchCreateAttendeeInput {
                meeting_id: self.meeting_id,
                attendees: self.attendees,
            })
        }
    }
}
#[doc(hidden)]
pub type BatchCreateAttendeeInputOperationOutputAlias = crate::operation::BatchCreateAttendee;
#[doc(hidden)]
pub type BatchCreateAttendeeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl BatchCreateAttendeeInput {
    /// Consumes the builder and constructs an Operation<[`BatchCreateAttendee`](crate::operation::BatchCreateAttendee)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchCreateAttendee,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchCreateAttendeeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_6 = &_input.meeting_id;
                let input_6 = input_6.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_6, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/attendees",
                    MeetingId = meeting_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::BatchCreateAttendeeInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "batch-create");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchCreateAttendeeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_create_attendee(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchCreateAttendee::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchCreateAttendee",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchCreateAttendeeInput`](crate::input::BatchCreateAttendeeInput)
    pub fn builder() -> crate::input::batch_create_attendee_input::Builder {
        crate::input::batch_create_attendee_input::Builder::default()
    }
}

/// See [`BatchCreateChannelMembershipInput`](crate::input::BatchCreateChannelMembershipInput)
pub mod batch_create_channel_membership_input {

    /// A builder for [`BatchCreateChannelMembershipInput`](crate::input::BatchCreateChannelMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ChannelMembershipType>,
        pub(crate) member_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel to which you're adding users.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel to which you're adding users.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.</p>
        pub fn r#type(mut self, input: crate::model::ChannelMembershipType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ChannelMembershipType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `member_arns`.
        ///
        /// To override the contents of this collection use [`set_member_arns`](Self::set_member_arns).
        ///
        /// <p>The ARNs of the members you want to add to the channel.</p>
        pub fn member_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.member_arns.unwrap_or_default();
            v.push(input.into());
            self.member_arns = Some(v);
            self
        }
        /// <p>The ARNs of the members you want to add to the channel.</p>
        pub fn set_member_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.member_arns = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchCreateChannelMembershipInput`](crate::input::BatchCreateChannelMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::BatchCreateChannelMembershipInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::BatchCreateChannelMembershipInput {
                channel_arn: self.channel_arn,
                r#type: self.r#type,
                member_arns: self.member_arns,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type BatchCreateChannelMembershipInputOperationOutputAlias =
    crate::operation::BatchCreateChannelMembership;
#[doc(hidden)]
pub type BatchCreateChannelMembershipInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl BatchCreateChannelMembershipInput {
    /// Consumes the builder and constructs an Operation<[`BatchCreateChannelMembership`](crate::operation::BatchCreateChannelMembership)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchCreateChannelMembership,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchCreateChannelMembershipInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_7 = &_input.channel_arn;
                let input_7 = input_7.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_7, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/memberships",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::BatchCreateChannelMembershipInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "batch-create");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchCreateChannelMembershipInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_batch_create_channel_membership(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_create_channel_membership(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchCreateChannelMembership::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchCreateChannelMembership",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchCreateChannelMembershipInput`](crate::input::BatchCreateChannelMembershipInput)
    pub fn builder() -> crate::input::batch_create_channel_membership_input::Builder {
        crate::input::batch_create_channel_membership_input::Builder::default()
    }
}

/// See [`BatchCreateRoomMembershipInput`](crate::input::BatchCreateRoomMembershipInput)
pub mod batch_create_room_membership_input {

    /// A builder for [`BatchCreateRoomMembershipInput`](crate::input::BatchCreateRoomMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) room_id: std::option::Option<std::string::String>,
        pub(crate) membership_item_list:
            std::option::Option<std::vec::Vec<crate::model::MembershipItem>>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The room ID.</p>
        pub fn room_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.room_id = Some(input.into());
            self
        }
        /// <p>The room ID.</p>
        pub fn set_room_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.room_id = input;
            self
        }
        /// Appends an item to `membership_item_list`.
        ///
        /// To override the contents of this collection use [`set_membership_item_list`](Self::set_membership_item_list).
        ///
        /// <p>The list of membership items.</p>
        pub fn membership_item_list(mut self, input: crate::model::MembershipItem) -> Self {
            let mut v = self.membership_item_list.unwrap_or_default();
            v.push(input);
            self.membership_item_list = Some(v);
            self
        }
        /// <p>The list of membership items.</p>
        pub fn set_membership_item_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MembershipItem>>,
        ) -> Self {
            self.membership_item_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchCreateRoomMembershipInput`](crate::input::BatchCreateRoomMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::BatchCreateRoomMembershipInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::BatchCreateRoomMembershipInput {
                account_id: self.account_id,
                room_id: self.room_id,
                membership_item_list: self.membership_item_list,
            })
        }
    }
}
#[doc(hidden)]
pub type BatchCreateRoomMembershipInputOperationOutputAlias =
    crate::operation::BatchCreateRoomMembership;
#[doc(hidden)]
pub type BatchCreateRoomMembershipInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl BatchCreateRoomMembershipInput {
    /// Consumes the builder and constructs an Operation<[`BatchCreateRoomMembership`](crate::operation::BatchCreateRoomMembership)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchCreateRoomMembership,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchCreateRoomMembershipInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_8 = &_input.account_id;
                let input_8 = input_8.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_8, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_9 = &_input.room_id;
                let input_9 = input_9.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let room_id = aws_smithy_http::label::fmt_string(input_9, false);
                if room_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms/{RoomId}/memberships",
                    AccountId = account_id,
                    RoomId = room_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::BatchCreateRoomMembershipInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "batch-create");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchCreateRoomMembershipInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_create_room_membership(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchCreateRoomMembership::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchCreateRoomMembership",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchCreateRoomMembershipInput`](crate::input::BatchCreateRoomMembershipInput)
    pub fn builder() -> crate::input::batch_create_room_membership_input::Builder {
        crate::input::batch_create_room_membership_input::Builder::default()
    }
}

/// See [`BatchDeletePhoneNumberInput`](crate::input::BatchDeletePhoneNumberInput)
pub mod batch_delete_phone_number_input {

    /// A builder for [`BatchDeletePhoneNumberInput`](crate::input::BatchDeletePhoneNumberInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `phone_number_ids`.
        ///
        /// To override the contents of this collection use [`set_phone_number_ids`](Self::set_phone_number_ids).
        ///
        /// <p>List of phone number IDs.</p>
        pub fn phone_number_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.phone_number_ids.unwrap_or_default();
            v.push(input.into());
            self.phone_number_ids = Some(v);
            self
        }
        /// <p>List of phone number IDs.</p>
        pub fn set_phone_number_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.phone_number_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDeletePhoneNumberInput`](crate::input::BatchDeletePhoneNumberInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::BatchDeletePhoneNumberInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::BatchDeletePhoneNumberInput {
                phone_number_ids: self.phone_number_ids,
            })
        }
    }
}
#[doc(hidden)]
pub type BatchDeletePhoneNumberInputOperationOutputAlias = crate::operation::BatchDeletePhoneNumber;
#[doc(hidden)]
pub type BatchDeletePhoneNumberInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl BatchDeletePhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`BatchDeletePhoneNumber`](crate::operation::BatchDeletePhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchDeletePhoneNumber,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchDeletePhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/phone-numbers").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::BatchDeletePhoneNumberInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "batch-delete");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchDeletePhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_delete_phone_number(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchDeletePhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchDeletePhoneNumber",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchDeletePhoneNumberInput`](crate::input::BatchDeletePhoneNumberInput)
    pub fn builder() -> crate::input::batch_delete_phone_number_input::Builder {
        crate::input::batch_delete_phone_number_input::Builder::default()
    }
}

/// See [`BatchSuspendUserInput`](crate::input::BatchSuspendUserInput)
pub mod batch_suspend_user_input {

    /// A builder for [`BatchSuspendUserInput`](crate::input::BatchSuspendUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Appends an item to `user_id_list`.
        ///
        /// To override the contents of this collection use [`set_user_id_list`](Self::set_user_id_list).
        ///
        /// <p>The request containing the user IDs to suspend.</p>
        pub fn user_id_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.user_id_list.unwrap_or_default();
            v.push(input.into());
            self.user_id_list = Some(v);
            self
        }
        /// <p>The request containing the user IDs to suspend.</p>
        pub fn set_user_id_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.user_id_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchSuspendUserInput`](crate::input::BatchSuspendUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::BatchSuspendUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::BatchSuspendUserInput {
                account_id: self.account_id,
                user_id_list: self.user_id_list,
            })
        }
    }
}
#[doc(hidden)]
pub type BatchSuspendUserInputOperationOutputAlias = crate::operation::BatchSuspendUser;
#[doc(hidden)]
pub type BatchSuspendUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl BatchSuspendUserInput {
    /// Consumes the builder and constructs an Operation<[`BatchSuspendUser`](crate::operation::BatchSuspendUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchSuspendUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchSuspendUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_10 = &_input.account_id;
                let input_10 = input_10.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_10, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::BatchSuspendUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "suspend");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchSuspendUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_suspend_user(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchSuspendUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchSuspendUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchSuspendUserInput`](crate::input::BatchSuspendUserInput)
    pub fn builder() -> crate::input::batch_suspend_user_input::Builder {
        crate::input::batch_suspend_user_input::Builder::default()
    }
}

/// See [`BatchUnsuspendUserInput`](crate::input::BatchUnsuspendUserInput)
pub mod batch_unsuspend_user_input {

    /// A builder for [`BatchUnsuspendUserInput`](crate::input::BatchUnsuspendUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id_list: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Appends an item to `user_id_list`.
        ///
        /// To override the contents of this collection use [`set_user_id_list`](Self::set_user_id_list).
        ///
        /// <p>The request containing the user IDs to unsuspend.</p>
        pub fn user_id_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.user_id_list.unwrap_or_default();
            v.push(input.into());
            self.user_id_list = Some(v);
            self
        }
        /// <p>The request containing the user IDs to unsuspend.</p>
        pub fn set_user_id_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.user_id_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchUnsuspendUserInput`](crate::input::BatchUnsuspendUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::BatchUnsuspendUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::BatchUnsuspendUserInput {
                account_id: self.account_id,
                user_id_list: self.user_id_list,
            })
        }
    }
}
#[doc(hidden)]
pub type BatchUnsuspendUserInputOperationOutputAlias = crate::operation::BatchUnsuspendUser;
#[doc(hidden)]
pub type BatchUnsuspendUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl BatchUnsuspendUserInput {
    /// Consumes the builder and constructs an Operation<[`BatchUnsuspendUser`](crate::operation::BatchUnsuspendUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchUnsuspendUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchUnsuspendUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_11 = &_input.account_id;
                let input_11 = input_11.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_11, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::BatchUnsuspendUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "unsuspend");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchUnsuspendUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_unsuspend_user(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchUnsuspendUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchUnsuspendUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchUnsuspendUserInput`](crate::input::BatchUnsuspendUserInput)
    pub fn builder() -> crate::input::batch_unsuspend_user_input::Builder {
        crate::input::batch_unsuspend_user_input::Builder::default()
    }
}

/// See [`BatchUpdatePhoneNumberInput`](crate::input::BatchUpdatePhoneNumberInput)
pub mod batch_update_phone_number_input {

    /// A builder for [`BatchUpdatePhoneNumberInput`](crate::input::BatchUpdatePhoneNumberInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_phone_number_request_items:
            std::option::Option<std::vec::Vec<crate::model::UpdatePhoneNumberRequestItem>>,
    }
    impl Builder {
        /// Appends an item to `update_phone_number_request_items`.
        ///
        /// To override the contents of this collection use [`set_update_phone_number_request_items`](Self::set_update_phone_number_request_items).
        ///
        /// <p>The request containing the phone number IDs and product types or calling names to update.</p>
        pub fn update_phone_number_request_items(
            mut self,
            input: crate::model::UpdatePhoneNumberRequestItem,
        ) -> Self {
            let mut v = self.update_phone_number_request_items.unwrap_or_default();
            v.push(input);
            self.update_phone_number_request_items = Some(v);
            self
        }
        /// <p>The request containing the phone number IDs and product types or calling names to update.</p>
        pub fn set_update_phone_number_request_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpdatePhoneNumberRequestItem>>,
        ) -> Self {
            self.update_phone_number_request_items = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchUpdatePhoneNumberInput`](crate::input::BatchUpdatePhoneNumberInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::BatchUpdatePhoneNumberInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::BatchUpdatePhoneNumberInput {
                update_phone_number_request_items: self.update_phone_number_request_items,
            })
        }
    }
}
#[doc(hidden)]
pub type BatchUpdatePhoneNumberInputOperationOutputAlias = crate::operation::BatchUpdatePhoneNumber;
#[doc(hidden)]
pub type BatchUpdatePhoneNumberInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl BatchUpdatePhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`BatchUpdatePhoneNumber`](crate::operation::BatchUpdatePhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchUpdatePhoneNumber,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchUpdatePhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/phone-numbers").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::BatchUpdatePhoneNumberInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "batch-update");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchUpdatePhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_update_phone_number(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchUpdatePhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchUpdatePhoneNumber",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchUpdatePhoneNumberInput`](crate::input::BatchUpdatePhoneNumberInput)
    pub fn builder() -> crate::input::batch_update_phone_number_input::Builder {
        crate::input::batch_update_phone_number_input::Builder::default()
    }
}

/// See [`BatchUpdateUserInput`](crate::input::BatchUpdateUserInput)
pub mod batch_update_user_input {

    /// A builder for [`BatchUpdateUserInput`](crate::input::BatchUpdateUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) update_user_request_items:
            std::option::Option<std::vec::Vec<crate::model::UpdateUserRequestItem>>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Appends an item to `update_user_request_items`.
        ///
        /// To override the contents of this collection use [`set_update_user_request_items`](Self::set_update_user_request_items).
        ///
        /// <p>The request containing the user IDs and details to update.</p>
        pub fn update_user_request_items(
            mut self,
            input: crate::model::UpdateUserRequestItem,
        ) -> Self {
            let mut v = self.update_user_request_items.unwrap_or_default();
            v.push(input);
            self.update_user_request_items = Some(v);
            self
        }
        /// <p>The request containing the user IDs and details to update.</p>
        pub fn set_update_user_request_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpdateUserRequestItem>>,
        ) -> Self {
            self.update_user_request_items = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchUpdateUserInput`](crate::input::BatchUpdateUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::BatchUpdateUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::BatchUpdateUserInput {
                account_id: self.account_id,
                update_user_request_items: self.update_user_request_items,
            })
        }
    }
}
#[doc(hidden)]
pub type BatchUpdateUserInputOperationOutputAlias = crate::operation::BatchUpdateUser;
#[doc(hidden)]
pub type BatchUpdateUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl BatchUpdateUserInput {
    /// Consumes the builder and constructs an Operation<[`BatchUpdateUser`](crate::operation::BatchUpdateUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchUpdateUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchUpdateUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_12 = &_input.account_id;
                let input_12 = input_12.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_12, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchUpdateUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_update_user(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchUpdateUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchUpdateUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchUpdateUserInput`](crate::input::BatchUpdateUserInput)
    pub fn builder() -> crate::input::batch_update_user_input::Builder {
        crate::input::batch_update_user_input::Builder::default()
    }
}

/// See [`CreateAccountInput`](crate::input::CreateAccountInput)
pub mod create_account_input {

    /// A builder for [`CreateAccountInput`](crate::input::CreateAccountInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon Chime account.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Chime account.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAccountInput`](crate::input::CreateAccountInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateAccountInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateAccountInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type CreateAccountInputOperationOutputAlias = crate::operation::CreateAccount;
#[doc(hidden)]
pub type CreateAccountInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateAccountInput {
    /// Consumes the builder and constructs an Operation<[`CreateAccount`](crate::operation::CreateAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAccount,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/accounts").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_account(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAccount",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAccountInput`](crate::input::CreateAccountInput)
    pub fn builder() -> crate::input::create_account_input::Builder {
        crate::input::create_account_input::Builder::default()
    }
}

/// See [`CreateAppInstanceInput`](crate::input::CreateAppInstanceInput)
pub mod create_app_instance_input {

    /// A builder for [`CreateAppInstanceInput`](crate::input::CreateAppInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the <code>AppInstance</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the <code>AppInstance</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The metadata of the <code>AppInstance</code>. Limited to a 1KB string in UTF-8.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        /// <p>The metadata of the <code>AppInstance</code>. Limited to a 1KB string in UTF-8.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The <code>ClientRequestToken</code> of the <code>AppInstance</code>.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>The <code>ClientRequestToken</code> of the <code>AppInstance</code>.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags assigned to the <code>AppInstance</code>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Tags assigned to the <code>AppInstance</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAppInstanceInput`](crate::input::CreateAppInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateAppInstanceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateAppInstanceInput {
                name: self.name,
                metadata: self.metadata,
                client_request_token: self.client_request_token,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateAppInstanceInputOperationOutputAlias = crate::operation::CreateAppInstance;
#[doc(hidden)]
pub type CreateAppInstanceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateAppInstanceInput {
    /// Consumes the builder and constructs an Operation<[`CreateAppInstance`](crate::operation::CreateAppInstance)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAppInstance,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAppInstanceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/app-instances").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAppInstanceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_app_instance(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAppInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAppInstance",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAppInstanceInput`](crate::input::CreateAppInstanceInput)
    pub fn builder() -> crate::input::create_app_instance_input::Builder {
        crate::input::create_app_instance_input::Builder::default()
    }
}

/// See [`CreateAppInstanceAdminInput`](crate::input::CreateAppInstanceAdminInput)
pub mod create_app_instance_admin_input {

    /// A builder for [`CreateAppInstanceAdminInput`](crate::input::CreateAppInstanceAdminInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_admin_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the administrator of the current <code>AppInstance</code>.</p>
        pub fn app_instance_admin_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_admin_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the administrator of the current <code>AppInstance</code>.</p>
        pub fn set_app_instance_admin_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_admin_arn = input;
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAppInstanceAdminInput`](crate::input::CreateAppInstanceAdminInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateAppInstanceAdminInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateAppInstanceAdminInput {
                app_instance_admin_arn: self.app_instance_admin_arn,
                app_instance_arn: self.app_instance_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateAppInstanceAdminInputOperationOutputAlias = crate::operation::CreateAppInstanceAdmin;
#[doc(hidden)]
pub type CreateAppInstanceAdminInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateAppInstanceAdminInput {
    /// Consumes the builder and constructs an Operation<[`CreateAppInstanceAdmin`](crate::operation::CreateAppInstanceAdmin)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAppInstanceAdmin,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAppInstanceAdminInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_13 = &_input.app_instance_arn;
                let input_13 = input_13.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_13, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}/admins",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAppInstanceAdminInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_app_instance_admin(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAppInstanceAdmin::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAppInstanceAdmin",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAppInstanceAdminInput`](crate::input::CreateAppInstanceAdminInput)
    pub fn builder() -> crate::input::create_app_instance_admin_input::Builder {
        crate::input::create_app_instance_admin_input::Builder::default()
    }
}

/// See [`CreateAppInstanceUserInput`](crate::input::CreateAppInstanceUserInput)
pub mod create_app_instance_user_input {

    /// A builder for [`CreateAppInstanceUserInput`](crate::input::CreateAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_user_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code> request.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code> request.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// <p>The user ID of the <code>AppInstance</code>.</p>
        pub fn app_instance_user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_id = Some(input.into());
            self
        }
        /// <p>The user ID of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_user_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_id = input;
            self
        }
        /// <p>The user's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The user's name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The request's metadata. Limited to a 1KB string in UTF-8.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        /// <p>The request's metadata. Limited to a 1KB string in UTF-8.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The token assigned to the user requesting an <code>AppInstance</code>.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>The token assigned to the user requesting an <code>AppInstance</code>.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags assigned to the <code>AppInstanceUser</code>.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Tags assigned to the <code>AppInstanceUser</code>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAppInstanceUserInput`](crate::input::CreateAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateAppInstanceUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateAppInstanceUserInput {
                app_instance_arn: self.app_instance_arn,
                app_instance_user_id: self.app_instance_user_id,
                name: self.name,
                metadata: self.metadata,
                client_request_token: self.client_request_token,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateAppInstanceUserInputOperationOutputAlias = crate::operation::CreateAppInstanceUser;
#[doc(hidden)]
pub type CreateAppInstanceUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`CreateAppInstanceUser`](crate::operation::CreateAppInstanceUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAppInstanceUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAppInstanceUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/app-instance-users").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAppInstanceUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_app_instance_user(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAppInstanceUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAppInstanceUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAppInstanceUserInput`](crate::input::CreateAppInstanceUserInput)
    pub fn builder() -> crate::input::create_app_instance_user_input::Builder {
        crate::input::create_app_instance_user_input::Builder::default()
    }
}

/// See [`CreateAttendeeInput`](crate::input::CreateAttendeeInput)
pub mod create_attendee_input {

    /// A builder for [`CreateAttendeeInput`](crate::input::CreateAttendeeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) external_user_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// <p>The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.</p>
        pub fn external_user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_user_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.</p>
        pub fn set_external_user_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.external_user_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag key-value pairs.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tag key-value pairs.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAttendeeInput`](crate::input::CreateAttendeeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateAttendeeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateAttendeeInput {
                meeting_id: self.meeting_id,
                external_user_id: self.external_user_id,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateAttendeeInputOperationOutputAlias = crate::operation::CreateAttendee;
#[doc(hidden)]
pub type CreateAttendeeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateAttendeeInput {
    /// Consumes the builder and constructs an Operation<[`CreateAttendee`](crate::operation::CreateAttendee)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAttendee,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAttendeeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_14 = &_input.meeting_id;
                let input_14 = input_14.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_14, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/attendees",
                    MeetingId = meeting_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAttendeeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_attendee(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAttendee::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAttendee",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAttendeeInput`](crate::input::CreateAttendeeInput)
    pub fn builder() -> crate::input::create_attendee_input::Builder {
        crate::input::create_attendee_input::Builder::default()
    }
}

/// See [`CreateBotInput`](crate::input::CreateBotInput)
pub mod create_bot_input {

    /// A builder for [`CreateBotInput`](crate::input::CreateBotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) domain: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The bot display name.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The bot display name.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The domain of the Amazon Chime Enterprise account.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The domain of the Amazon Chime Enterprise account.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBotInput`](crate::input::CreateBotInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateBotInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateBotInput {
                account_id: self.account_id,
                display_name: self.display_name,
                domain: self.domain,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateBotInputOperationOutputAlias = crate::operation::CreateBot;
#[doc(hidden)]
pub type CreateBotInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateBotInput {
    /// Consumes the builder and constructs an Operation<[`CreateBot`](crate::operation::CreateBot)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateBot,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateBotInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_15 = &_input.account_id;
                let input_15 = input_15.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_15, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/accounts/{AccountId}/bots", AccountId = account_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateBotInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_bot(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::CreateBot::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "CreateBot",
                    "chime",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateBotInput`](crate::input::CreateBotInput)
    pub fn builder() -> crate::input::create_bot_input::Builder {
        crate::input::create_bot_input::Builder::default()
    }
}

/// See [`CreateChannelInput`](crate::input::CreateChannelInput)
pub mod create_channel_input {

    /// A builder for [`CreateChannelInput`](crate::input::CreateChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) mode: std::option::Option<crate::model::ChannelMode>,
        pub(crate) privacy: std::option::Option<crate::model::ChannelPrivacy>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel request.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel request.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// <p>The name of the channel.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the channel.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The channel mode: <code>UNRESTRICTED</code> or <code>RESTRICTED</code>. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.</p>
        pub fn mode(mut self, input: crate::model::ChannelMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>The channel mode: <code>UNRESTRICTED</code> or <code>RESTRICTED</code>. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.</p>
        pub fn set_mode(mut self, input: std::option::Option<crate::model::ChannelMode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>The channel's privacy level: <code>PUBLIC</code> or <code>PRIVATE</code>. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the <code>AppInstance</code>.</p>
        pub fn privacy(mut self, input: crate::model::ChannelPrivacy) -> Self {
            self.privacy = Some(input);
            self
        }
        /// <p>The channel's privacy level: <code>PUBLIC</code> or <code>PRIVATE</code>. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the <code>AppInstance</code>.</p>
        pub fn set_privacy(
            mut self,
            input: std::option::Option<crate::model::ChannelPrivacy>,
        ) -> Self {
            self.privacy = input;
            self
        }
        /// <p>The metadata of the creation request. Limited to 1KB and UTF-8.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        /// <p>The metadata of the creation request. Limited to 1KB and UTF-8.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The client token for the request. An <code>Idempotency</code> token.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>The client token for the request. An <code>Idempotency</code> token.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags for the creation request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags for the creation request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelInput`](crate::input::CreateChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateChannelInput {
                app_instance_arn: self.app_instance_arn,
                name: self.name,
                mode: self.mode,
                privacy: self.privacy,
                metadata: self.metadata,
                client_request_token: self.client_request_token,
                tags: self.tags,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelInputOperationOutputAlias = crate::operation::CreateChannel;
#[doc(hidden)]
pub type CreateChannelInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateChannelInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannel`](crate::operation::CreateChannel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateChannel,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateChannelInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/channels").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateChannelInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_channel(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_channel(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateChannel",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelInput`](crate::input::CreateChannelInput)
    pub fn builder() -> crate::input::create_channel_input::Builder {
        crate::input::create_channel_input::Builder::default()
    }
}

/// See [`CreateChannelBanInput`](crate::input::CreateChannelBanInput)
pub mod create_channel_ban_input {

    /// A builder for [`CreateChannelBanInput`](crate::input::CreateChannelBanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the ban request.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the ban request.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member being banned.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the member being banned.</p>
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelBanInput`](crate::input::CreateChannelBanInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateChannelBanInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateChannelBanInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelBanInputOperationOutputAlias = crate::operation::CreateChannelBan;
#[doc(hidden)]
pub type CreateChannelBanInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateChannelBanInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannelBan`](crate::operation::CreateChannelBan)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateChannelBan,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateChannelBanInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_16 = &_input.channel_arn;
                let input_16 = input_16.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_16, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/bans",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateChannelBanInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_create_channel_ban(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_channel_ban(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateChannelBan::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateChannelBan",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelBanInput`](crate::input::CreateChannelBanInput)
    pub fn builder() -> crate::input::create_channel_ban_input::Builder {
        crate::input::create_channel_ban_input::Builder::default()
    }
}

/// See [`CreateChannelMembershipInput`](crate::input::CreateChannelMembershipInput)
pub mod create_channel_membership_input {

    /// A builder for [`CreateChannelMembershipInput`](crate::input::CreateChannelMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ChannelMembershipType>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel to which you're adding users.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel to which you're adding users.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member you want to add to the channel.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the member you want to add to the channel.</p>
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.</p>
        pub fn r#type(mut self, input: crate::model::ChannelMembershipType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ChannelMembershipType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelMembershipInput`](crate::input::CreateChannelMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateChannelMembershipInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateChannelMembershipInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                r#type: self.r#type,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelMembershipInputOperationOutputAlias =
    crate::operation::CreateChannelMembership;
#[doc(hidden)]
pub type CreateChannelMembershipInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateChannelMembershipInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannelMembership`](crate::operation::CreateChannelMembership)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateChannelMembership,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateChannelMembershipInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_17 = &_input.channel_arn;
                let input_17 = input_17.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_17, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/memberships",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateChannelMembershipInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_create_channel_membership(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_channel_membership(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateChannelMembership::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateChannelMembership",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelMembershipInput`](crate::input::CreateChannelMembershipInput)
    pub fn builder() -> crate::input::create_channel_membership_input::Builder {
        crate::input::create_channel_membership_input::Builder::default()
    }
}

/// See [`CreateChannelModeratorInput`](crate::input::CreateChannelModeratorInput)
pub mod create_channel_moderator_input {

    /// A builder for [`CreateChannelModeratorInput`](crate::input::CreateChannelModeratorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) channel_moderator_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the moderator.</p>
        pub fn channel_moderator_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_moderator_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the moderator.</p>
        pub fn set_channel_moderator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.channel_moderator_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelModeratorInput`](crate::input::CreateChannelModeratorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateChannelModeratorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateChannelModeratorInput {
                channel_arn: self.channel_arn,
                channel_moderator_arn: self.channel_moderator_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelModeratorInputOperationOutputAlias = crate::operation::CreateChannelModerator;
#[doc(hidden)]
pub type CreateChannelModeratorInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateChannelModeratorInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannelModerator`](crate::operation::CreateChannelModerator)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateChannelModerator,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateChannelModeratorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_18 = &_input.channel_arn;
                let input_18 = input_18.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_18, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/moderators",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateChannelModeratorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_create_channel_moderator(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_channel_moderator(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateChannelModerator::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateChannelModerator",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelModeratorInput`](crate::input::CreateChannelModeratorInput)
    pub fn builder() -> crate::input::create_channel_moderator_input::Builder {
        crate::input::create_channel_moderator_input::Builder::default()
    }
}

/// See [`CreateMediaCapturePipelineInput`](crate::input::CreateMediaCapturePipelineInput)
pub mod create_media_capture_pipeline_input {

    /// A builder for [`CreateMediaCapturePipelineInput`](crate::input::CreateMediaCapturePipelineInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_type: std::option::Option<crate::model::MediaPipelineSourceType>,
        pub(crate) source_arn: std::option::Option<std::string::String>,
        pub(crate) sink_type: std::option::Option<crate::model::MediaPipelineSinkType>,
        pub(crate) sink_arn: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) chime_sdk_meeting_configuration:
            std::option::Option<crate::model::ChimeSdkMeetingConfiguration>,
    }
    impl Builder {
        /// <p>Source type from which the media artifacts will be captured. A Chime SDK Meeting is the only supported source.</p>
        pub fn source_type(mut self, input: crate::model::MediaPipelineSourceType) -> Self {
            self.source_type = Some(input);
            self
        }
        /// <p>Source type from which the media artifacts will be captured. A Chime SDK Meeting is the only supported source.</p>
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::MediaPipelineSourceType>,
        ) -> Self {
            self.source_type = input;
            self
        }
        /// <p>ARN of the source from which the media artifacts are captured.</p>
        pub fn source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_arn = Some(input.into());
            self
        }
        /// <p>ARN of the source from which the media artifacts are captured.</p>
        pub fn set_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_arn = input;
            self
        }
        /// <p>Destination type to which the media artifacts are saved. You must use an S3 bucket. </p>
        pub fn sink_type(mut self, input: crate::model::MediaPipelineSinkType) -> Self {
            self.sink_type = Some(input);
            self
        }
        /// <p>Destination type to which the media artifacts are saved. You must use an S3 bucket. </p>
        pub fn set_sink_type(
            mut self,
            input: std::option::Option<crate::model::MediaPipelineSinkType>,
        ) -> Self {
            self.sink_type = input;
            self
        }
        /// <p>The ARN of the sink type.</p>
        pub fn sink_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sink_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the sink type.</p>
        pub fn set_sink_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sink_arn = input;
            self
        }
        /// <p>The token assigned to the client making the pipeline request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>The token assigned to the client making the pipeline request.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The configuration for a specified media capture pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
        pub fn chime_sdk_meeting_configuration(
            mut self,
            input: crate::model::ChimeSdkMeetingConfiguration,
        ) -> Self {
            self.chime_sdk_meeting_configuration = Some(input);
            self
        }
        /// <p>The configuration for a specified media capture pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
        pub fn set_chime_sdk_meeting_configuration(
            mut self,
            input: std::option::Option<crate::model::ChimeSdkMeetingConfiguration>,
        ) -> Self {
            self.chime_sdk_meeting_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMediaCapturePipelineInput`](crate::input::CreateMediaCapturePipelineInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateMediaCapturePipelineInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateMediaCapturePipelineInput {
                source_type: self.source_type,
                source_arn: self.source_arn,
                sink_type: self.sink_type,
                sink_arn: self.sink_arn,
                client_request_token: self.client_request_token,
                chime_sdk_meeting_configuration: self.chime_sdk_meeting_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateMediaCapturePipelineInputOperationOutputAlias =
    crate::operation::CreateMediaCapturePipeline;
#[doc(hidden)]
pub type CreateMediaCapturePipelineInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateMediaCapturePipelineInput {
    /// Consumes the builder and constructs an Operation<[`CreateMediaCapturePipeline`](crate::operation::CreateMediaCapturePipeline)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateMediaCapturePipeline,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateMediaCapturePipelineInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/media-capture-pipelines").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateMediaCapturePipelineInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_media_capture_pipeline(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateMediaCapturePipeline::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateMediaCapturePipeline",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateMediaCapturePipelineInput`](crate::input::CreateMediaCapturePipelineInput)
    pub fn builder() -> crate::input::create_media_capture_pipeline_input::Builder {
        crate::input::create_media_capture_pipeline_input::Builder::default()
    }
}

/// See [`CreateMeetingInput`](crate::input::CreateMeetingInput)
pub mod create_meeting_input {

    /// A builder for [`CreateMeetingInput`](crate::input::CreateMeetingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) external_meeting_id: std::option::Option<std::string::String>,
        pub(crate) meeting_host_id: std::option::Option<std::string::String>,
        pub(crate) media_region: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) notifications_configuration:
            std::option::Option<crate::model::MeetingNotificationConfiguration>,
    }
    impl Builder {
        /// <p>The unique identifier for the client request. Use a different token for different meetings.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>The unique identifier for the client request. Use a different token for different meetings.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The external meeting ID.</p>
        pub fn external_meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_meeting_id = Some(input.into());
            self
        }
        /// <p>The external meeting ID.</p>
        pub fn set_external_meeting_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.external_meeting_id = input;
            self
        }
        /// <p>Reserved.</p>
        pub fn meeting_host_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_host_id = Some(input.into());
            self
        }
        /// <p>Reserved.</p>
        pub fn set_meeting_host_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.meeting_host_id = input;
            self
        }
        /// <p> The Region in which to create the meeting. Default: <code>us-east-1</code>. </p>
        /// <p> Available values: <code>af-south-1</code> , <code>ap-northeast-1</code> , <code>ap-northeast-2</code> , <code>ap-south-1</code> , <code>ap-southeast-1</code> , <code>ap-southeast-2</code> , <code>ca-central-1</code> , <code>eu-central-1</code> , <code>eu-north-1</code> , <code>eu-south-1</code> , <code>eu-west-1</code> , <code>eu-west-2</code> , <code>eu-west-3</code> , <code>sa-east-1</code> , <code>us-east-1</code> , <code>us-east-2</code> , <code>us-west-1</code> , <code>us-west-2</code> . </p>
        pub fn media_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_region = Some(input.into());
            self
        }
        /// <p> The Region in which to create the meeting. Default: <code>us-east-1</code>. </p>
        /// <p> Available values: <code>af-south-1</code> , <code>ap-northeast-1</code> , <code>ap-northeast-2</code> , <code>ap-south-1</code> , <code>ap-southeast-1</code> , <code>ap-southeast-2</code> , <code>ca-central-1</code> , <code>eu-central-1</code> , <code>eu-north-1</code> , <code>eu-south-1</code> , <code>eu-west-1</code> , <code>eu-west-2</code> , <code>eu-west-3</code> , <code>sa-east-1</code> , <code>us-east-1</code> , <code>us-east-2</code> , <code>us-west-1</code> , <code>us-west-2</code> . </p>
        pub fn set_media_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_region = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag key-value pairs.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tag key-value pairs.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The configuration for resource targets to receive notifications when meeting and attendee events occur.</p>
        pub fn notifications_configuration(
            mut self,
            input: crate::model::MeetingNotificationConfiguration,
        ) -> Self {
            self.notifications_configuration = Some(input);
            self
        }
        /// <p>The configuration for resource targets to receive notifications when meeting and attendee events occur.</p>
        pub fn set_notifications_configuration(
            mut self,
            input: std::option::Option<crate::model::MeetingNotificationConfiguration>,
        ) -> Self {
            self.notifications_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMeetingInput`](crate::input::CreateMeetingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateMeetingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateMeetingInput {
                client_request_token: self.client_request_token,
                external_meeting_id: self.external_meeting_id,
                meeting_host_id: self.meeting_host_id,
                media_region: self.media_region,
                tags: self.tags,
                notifications_configuration: self.notifications_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateMeetingInputOperationOutputAlias = crate::operation::CreateMeeting;
#[doc(hidden)]
pub type CreateMeetingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateMeetingInput {
    /// Consumes the builder and constructs an Operation<[`CreateMeeting`](crate::operation::CreateMeeting)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateMeeting,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateMeetingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/meetings").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateMeetingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_meeting(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateMeeting::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateMeeting",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateMeetingInput`](crate::input::CreateMeetingInput)
    pub fn builder() -> crate::input::create_meeting_input::Builder {
        crate::input::create_meeting_input::Builder::default()
    }
}

/// See [`CreateMeetingDialOutInput`](crate::input::CreateMeetingDialOutInput)
pub mod create_meeting_dial_out_input {

    /// A builder for [`CreateMeetingDialOutInput`](crate::input::CreateMeetingDialOutInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) from_phone_number: std::option::Option<std::string::String>,
        pub(crate) to_phone_number: std::option::Option<std::string::String>,
        pub(crate) join_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// <p>Phone number used as the caller ID when the remote party receives a call.</p>
        pub fn from_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_phone_number = Some(input.into());
            self
        }
        /// <p>Phone number used as the caller ID when the remote party receives a call.</p>
        pub fn set_from_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.from_phone_number = input;
            self
        }
        /// <p>Phone number called when inviting someone to a meeting.</p>
        pub fn to_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.to_phone_number = Some(input.into());
            self
        }
        /// <p>Phone number called when inviting someone to a meeting.</p>
        pub fn set_to_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.to_phone_number = input;
            self
        }
        /// <p>Token used by the Amazon Chime SDK attendee. Call the <a href="https://docs.aws.amazon.com/chime/latest/APIReference/API_CreateAttendee.html">CreateAttendee</a> action to get a join token.</p>
        pub fn join_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.join_token = Some(input.into());
            self
        }
        /// <p>Token used by the Amazon Chime SDK attendee. Call the <a href="https://docs.aws.amazon.com/chime/latest/APIReference/API_CreateAttendee.html">CreateAttendee</a> action to get a join token.</p>
        pub fn set_join_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.join_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMeetingDialOutInput`](crate::input::CreateMeetingDialOutInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateMeetingDialOutInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateMeetingDialOutInput {
                meeting_id: self.meeting_id,
                from_phone_number: self.from_phone_number,
                to_phone_number: self.to_phone_number,
                join_token: self.join_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateMeetingDialOutInputOperationOutputAlias = crate::operation::CreateMeetingDialOut;
#[doc(hidden)]
pub type CreateMeetingDialOutInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateMeetingDialOutInput {
    /// Consumes the builder and constructs an Operation<[`CreateMeetingDialOut`](crate::operation::CreateMeetingDialOut)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateMeetingDialOut,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateMeetingDialOutInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_19 = &_input.meeting_id;
                let input_19 = input_19.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_19, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/dial-outs",
                    MeetingId = meeting_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateMeetingDialOutInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_meeting_dial_out(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateMeetingDialOut::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateMeetingDialOut",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateMeetingDialOutInput`](crate::input::CreateMeetingDialOutInput)
    pub fn builder() -> crate::input::create_meeting_dial_out_input::Builder {
        crate::input::create_meeting_dial_out_input::Builder::default()
    }
}

/// See [`CreateMeetingWithAttendeesInput`](crate::input::CreateMeetingWithAttendeesInput)
pub mod create_meeting_with_attendees_input {

    /// A builder for [`CreateMeetingWithAttendeesInput`](crate::input::CreateMeetingWithAttendeesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) external_meeting_id: std::option::Option<std::string::String>,
        pub(crate) meeting_host_id: std::option::Option<std::string::String>,
        pub(crate) media_region: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) notifications_configuration:
            std::option::Option<crate::model::MeetingNotificationConfiguration>,
        pub(crate) attendees:
            std::option::Option<std::vec::Vec<crate::model::CreateAttendeeRequestItem>>,
    }
    impl Builder {
        /// <p>The unique identifier for the client request. Use a different token for different meetings.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>The unique identifier for the client request. Use a different token for different meetings.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The external meeting ID.</p>
        pub fn external_meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_meeting_id = Some(input.into());
            self
        }
        /// <p>The external meeting ID.</p>
        pub fn set_external_meeting_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.external_meeting_id = input;
            self
        }
        /// <p>Reserved.</p>
        pub fn meeting_host_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_host_id = Some(input.into());
            self
        }
        /// <p>Reserved.</p>
        pub fn set_meeting_host_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.meeting_host_id = input;
            self
        }
        /// <p> The Region in which to create the meeting. Default: <code>us-east-1</code> . </p>
        /// <p> Available values: <code>af-south-1</code> , <code>ap-northeast-1</code> , <code>ap-northeast-2</code> , <code>ap-south-1</code> , <code>ap-southeast-1</code> , <code>ap-southeast-2</code> , <code>ca-central-1</code> , <code>eu-central-1</code> , <code>eu-north-1</code> , <code>eu-south-1</code> , <code>eu-west-1</code> , <code>eu-west-2</code> , <code>eu-west-3</code> , <code>sa-east-1</code> , <code>us-east-1</code> , <code>us-east-2</code> , <code>us-west-1</code> , <code>us-west-2</code> . </p>
        pub fn media_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_region = Some(input.into());
            self
        }
        /// <p> The Region in which to create the meeting. Default: <code>us-east-1</code> . </p>
        /// <p> Available values: <code>af-south-1</code> , <code>ap-northeast-1</code> , <code>ap-northeast-2</code> , <code>ap-south-1</code> , <code>ap-southeast-1</code> , <code>ap-southeast-2</code> , <code>ca-central-1</code> , <code>eu-central-1</code> , <code>eu-north-1</code> , <code>eu-south-1</code> , <code>eu-west-1</code> , <code>eu-west-2</code> , <code>eu-west-3</code> , <code>sa-east-1</code> , <code>us-east-1</code> , <code>us-east-2</code> , <code>us-west-1</code> , <code>us-west-2</code> . </p>
        pub fn set_media_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_region = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag key-value pairs.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tag key-value pairs.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p> The resource target configurations for receiving Amazon Chime SDK meeting and attendee event notifications. The Amazon Chime SDK supports resource targets located in the US East (N. Virginia) AWS Region (<code>us-east-1</code>). </p>
        pub fn notifications_configuration(
            mut self,
            input: crate::model::MeetingNotificationConfiguration,
        ) -> Self {
            self.notifications_configuration = Some(input);
            self
        }
        /// <p> The resource target configurations for receiving Amazon Chime SDK meeting and attendee event notifications. The Amazon Chime SDK supports resource targets located in the US East (N. Virginia) AWS Region (<code>us-east-1</code>). </p>
        pub fn set_notifications_configuration(
            mut self,
            input: std::option::Option<crate::model::MeetingNotificationConfiguration>,
        ) -> Self {
            self.notifications_configuration = input;
            self
        }
        /// Appends an item to `attendees`.
        ///
        /// To override the contents of this collection use [`set_attendees`](Self::set_attendees).
        ///
        /// <p>The request containing the attendees to create.</p>
        pub fn attendees(mut self, input: crate::model::CreateAttendeeRequestItem) -> Self {
            let mut v = self.attendees.unwrap_or_default();
            v.push(input);
            self.attendees = Some(v);
            self
        }
        /// <p>The request containing the attendees to create.</p>
        pub fn set_attendees(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateAttendeeRequestItem>>,
        ) -> Self {
            self.attendees = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMeetingWithAttendeesInput`](crate::input::CreateMeetingWithAttendeesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateMeetingWithAttendeesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateMeetingWithAttendeesInput {
                client_request_token: self.client_request_token,
                external_meeting_id: self.external_meeting_id,
                meeting_host_id: self.meeting_host_id,
                media_region: self.media_region,
                tags: self.tags,
                notifications_configuration: self.notifications_configuration,
                attendees: self.attendees,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateMeetingWithAttendeesInputOperationOutputAlias =
    crate::operation::CreateMeetingWithAttendees;
#[doc(hidden)]
pub type CreateMeetingWithAttendeesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateMeetingWithAttendeesInput {
    /// Consumes the builder and constructs an Operation<[`CreateMeetingWithAttendees`](crate::operation::CreateMeetingWithAttendees)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateMeetingWithAttendees,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateMeetingWithAttendeesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/meetings").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CreateMeetingWithAttendeesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "create-attendees");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateMeetingWithAttendeesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_meeting_with_attendees(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateMeetingWithAttendees::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateMeetingWithAttendees",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateMeetingWithAttendeesInput`](crate::input::CreateMeetingWithAttendeesInput)
    pub fn builder() -> crate::input::create_meeting_with_attendees_input::Builder {
        crate::input::create_meeting_with_attendees_input::Builder::default()
    }
}

/// See [`CreatePhoneNumberOrderInput`](crate::input::CreatePhoneNumberOrderInput)
pub mod create_phone_number_order_input {

    /// A builder for [`CreatePhoneNumberOrderInput`](crate::input::CreatePhoneNumberOrderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_type: std::option::Option<crate::model::PhoneNumberProductType>,
        pub(crate) e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The phone number product type.</p>
        pub fn product_type(mut self, input: crate::model::PhoneNumberProductType) -> Self {
            self.product_type = Some(input);
            self
        }
        /// <p>The phone number product type.</p>
        pub fn set_product_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberProductType>,
        ) -> Self {
            self.product_type = input;
            self
        }
        /// Appends an item to `e164_phone_numbers`.
        ///
        /// To override the contents of this collection use [`set_e164_phone_numbers`](Self::set_e164_phone_numbers).
        ///
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn e164_phone_numbers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.e164_phone_numbers.unwrap_or_default();
            v.push(input.into());
            self.e164_phone_numbers = Some(v);
            self
        }
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn set_e164_phone_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.e164_phone_numbers = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatePhoneNumberOrderInput`](crate::input::CreatePhoneNumberOrderInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreatePhoneNumberOrderInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreatePhoneNumberOrderInput {
                product_type: self.product_type,
                e164_phone_numbers: self.e164_phone_numbers,
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePhoneNumberOrderInputOperationOutputAlias = crate::operation::CreatePhoneNumberOrder;
#[doc(hidden)]
pub type CreatePhoneNumberOrderInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreatePhoneNumberOrderInput {
    /// Consumes the builder and constructs an Operation<[`CreatePhoneNumberOrder`](crate::operation::CreatePhoneNumberOrder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreatePhoneNumberOrder,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreatePhoneNumberOrderInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/phone-number-orders").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreatePhoneNumberOrderInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_phone_number_order(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreatePhoneNumberOrder::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreatePhoneNumberOrder",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreatePhoneNumberOrderInput`](crate::input::CreatePhoneNumberOrderInput)
    pub fn builder() -> crate::input::create_phone_number_order_input::Builder {
        crate::input::create_phone_number_order_input::Builder::default()
    }
}

/// See [`CreateProxySessionInput`](crate::input::CreateProxySessionInput)
pub mod create_proxy_session_input {

    /// A builder for [`CreateProxySessionInput`](crate::input::CreateProxySessionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) participant_phone_numbers:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) expiry_minutes: std::option::Option<i32>,
        pub(crate) capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        pub(crate) number_selection_behavior:
            std::option::Option<crate::model::NumberSelectionBehavior>,
        pub(crate) geo_match_level: std::option::Option<crate::model::GeoMatchLevel>,
        pub(crate) geo_match_params: std::option::Option<crate::model::GeoMatchParams>,
    }
    impl Builder {
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Appends an item to `participant_phone_numbers`.
        ///
        /// To override the contents of this collection use [`set_participant_phone_numbers`](Self::set_participant_phone_numbers).
        ///
        /// <p>The participant phone numbers.</p>
        pub fn participant_phone_numbers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.participant_phone_numbers.unwrap_or_default();
            v.push(input.into());
            self.participant_phone_numbers = Some(v);
            self
        }
        /// <p>The participant phone numbers.</p>
        pub fn set_participant_phone_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.participant_phone_numbers = input;
            self
        }
        /// <p>The name of the proxy session.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the proxy session.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The number of minutes allowed for the proxy session.</p>
        pub fn expiry_minutes(mut self, input: i32) -> Self {
            self.expiry_minutes = Some(input);
            self
        }
        /// <p>The number of minutes allowed for the proxy session.</p>
        pub fn set_expiry_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.expiry_minutes = input;
            self
        }
        /// Appends an item to `capabilities`.
        ///
        /// To override the contents of this collection use [`set_capabilities`](Self::set_capabilities).
        ///
        /// <p>The proxy session capabilities.</p>
        pub fn capabilities(mut self, input: crate::model::Capability) -> Self {
            let mut v = self.capabilities.unwrap_or_default();
            v.push(input);
            self.capabilities = Some(v);
            self
        }
        /// <p>The proxy session capabilities.</p>
        pub fn set_capabilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        ) -> Self {
            self.capabilities = input;
            self
        }
        /// <p>The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.</p>
        pub fn number_selection_behavior(
            mut self,
            input: crate::model::NumberSelectionBehavior,
        ) -> Self {
            self.number_selection_behavior = Some(input);
            self
        }
        /// <p>The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.</p>
        pub fn set_number_selection_behavior(
            mut self,
            input: std::option::Option<crate::model::NumberSelectionBehavior>,
        ) -> Self {
            self.number_selection_behavior = input;
            self
        }
        /// <p>The preference for matching the country or area code of the proxy phone number with that of the first participant.</p>
        pub fn geo_match_level(mut self, input: crate::model::GeoMatchLevel) -> Self {
            self.geo_match_level = Some(input);
            self
        }
        /// <p>The preference for matching the country or area code of the proxy phone number with that of the first participant.</p>
        pub fn set_geo_match_level(
            mut self,
            input: std::option::Option<crate::model::GeoMatchLevel>,
        ) -> Self {
            self.geo_match_level = input;
            self
        }
        /// <p>The country and area code for the proxy phone number.</p>
        pub fn geo_match_params(mut self, input: crate::model::GeoMatchParams) -> Self {
            self.geo_match_params = Some(input);
            self
        }
        /// <p>The country and area code for the proxy phone number.</p>
        pub fn set_geo_match_params(
            mut self,
            input: std::option::Option<crate::model::GeoMatchParams>,
        ) -> Self {
            self.geo_match_params = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProxySessionInput`](crate::input::CreateProxySessionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateProxySessionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateProxySessionInput {
                voice_connector_id: self.voice_connector_id,
                participant_phone_numbers: self.participant_phone_numbers,
                name: self.name,
                expiry_minutes: self.expiry_minutes,
                capabilities: self.capabilities,
                number_selection_behavior: self.number_selection_behavior,
                geo_match_level: self.geo_match_level,
                geo_match_params: self.geo_match_params,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateProxySessionInputOperationOutputAlias = crate::operation::CreateProxySession;
#[doc(hidden)]
pub type CreateProxySessionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateProxySessionInput {
    /// Consumes the builder and constructs an Operation<[`CreateProxySession`](crate::operation::CreateProxySession)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateProxySession,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateProxySessionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_20 = &_input.voice_connector_id;
                let input_20 = input_20.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_20, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/proxy-sessions",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateProxySessionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_proxy_session(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProxySession::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateProxySession",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateProxySessionInput`](crate::input::CreateProxySessionInput)
    pub fn builder() -> crate::input::create_proxy_session_input::Builder {
        crate::input::create_proxy_session_input::Builder::default()
    }
}

/// See [`CreateRoomInput`](crate::input::CreateRoomInput)
pub mod create_room_input {

    /// A builder for [`CreateRoomInput`](crate::input::CreateRoomInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The room name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The room name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The idempotency token for the request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>The idempotency token for the request.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRoomInput`](crate::input::CreateRoomInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateRoomInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateRoomInput {
                account_id: self.account_id,
                name: self.name,
                client_request_token: self.client_request_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateRoomInputOperationOutputAlias = crate::operation::CreateRoom;
#[doc(hidden)]
pub type CreateRoomInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateRoomInput {
    /// Consumes the builder and constructs an Operation<[`CreateRoom`](crate::operation::CreateRoom)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRoom,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateRoomInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_21 = &_input.account_id;
                let input_21 = input_21.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_21, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateRoomInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_room(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRoom::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRoom",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateRoomInput`](crate::input::CreateRoomInput)
    pub fn builder() -> crate::input::create_room_input::Builder {
        crate::input::create_room_input::Builder::default()
    }
}

/// See [`CreateRoomMembershipInput`](crate::input::CreateRoomMembershipInput)
pub mod create_room_membership_input {

    /// A builder for [`CreateRoomMembershipInput`](crate::input::CreateRoomMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) room_id: std::option::Option<std::string::String>,
        pub(crate) member_id: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<crate::model::RoomMembershipRole>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The room ID.</p>
        pub fn room_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.room_id = Some(input.into());
            self
        }
        /// <p>The room ID.</p>
        pub fn set_room_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.room_id = input;
            self
        }
        /// <p>The Amazon Chime member ID (user ID or bot ID).</p>
        pub fn member_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime member ID (user ID or bot ID).</p>
        pub fn set_member_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_id = input;
            self
        }
        /// <p>The role of the member.</p>
        pub fn role(mut self, input: crate::model::RoomMembershipRole) -> Self {
            self.role = Some(input);
            self
        }
        /// <p>The role of the member.</p>
        pub fn set_role(
            mut self,
            input: std::option::Option<crate::model::RoomMembershipRole>,
        ) -> Self {
            self.role = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRoomMembershipInput`](crate::input::CreateRoomMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateRoomMembershipInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateRoomMembershipInput {
                account_id: self.account_id,
                room_id: self.room_id,
                member_id: self.member_id,
                role: self.role,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateRoomMembershipInputOperationOutputAlias = crate::operation::CreateRoomMembership;
#[doc(hidden)]
pub type CreateRoomMembershipInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateRoomMembershipInput {
    /// Consumes the builder and constructs an Operation<[`CreateRoomMembership`](crate::operation::CreateRoomMembership)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRoomMembership,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateRoomMembershipInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_22 = &_input.account_id;
                let input_22 = input_22.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_22, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_23 = &_input.room_id;
                let input_23 = input_23.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let room_id = aws_smithy_http::label::fmt_string(input_23, false);
                if room_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms/{RoomId}/memberships",
                    AccountId = account_id,
                    RoomId = room_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateRoomMembershipInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_room_membership(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRoomMembership::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRoomMembership",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateRoomMembershipInput`](crate::input::CreateRoomMembershipInput)
    pub fn builder() -> crate::input::create_room_membership_input::Builder {
        crate::input::create_room_membership_input::Builder::default()
    }
}

/// See [`CreateSipMediaApplicationInput`](crate::input::CreateSipMediaApplicationInput)
pub mod create_sip_media_application_input {

    /// A builder for [`CreateSipMediaApplicationInput`](crate::input::CreateSipMediaApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) endpoints:
            std::option::Option<std::vec::Vec<crate::model::SipMediaApplicationEndpoint>>,
    }
    impl Builder {
        /// <p>The AWS Region assigned to the SIP media application.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The AWS Region assigned to the SIP media application.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The SIP media application name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The SIP media application name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>List of endpoints (Lambda Amazon Resource Names) specified for the SIP media application. Currently, only one endpoint is supported.</p>
        pub fn endpoints(mut self, input: crate::model::SipMediaApplicationEndpoint) -> Self {
            let mut v = self.endpoints.unwrap_or_default();
            v.push(input);
            self.endpoints = Some(v);
            self
        }
        /// <p>List of endpoints (Lambda Amazon Resource Names) specified for the SIP media application. Currently, only one endpoint is supported.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SipMediaApplicationEndpoint>>,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSipMediaApplicationInput`](crate::input::CreateSipMediaApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateSipMediaApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateSipMediaApplicationInput {
                aws_region: self.aws_region,
                name: self.name,
                endpoints: self.endpoints,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateSipMediaApplicationInputOperationOutputAlias =
    crate::operation::CreateSipMediaApplication;
#[doc(hidden)]
pub type CreateSipMediaApplicationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateSipMediaApplicationInput {
    /// Consumes the builder and constructs an Operation<[`CreateSipMediaApplication`](crate::operation::CreateSipMediaApplication)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSipMediaApplication,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateSipMediaApplicationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/sip-media-applications").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateSipMediaApplicationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_sip_media_application(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSipMediaApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSipMediaApplication",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSipMediaApplicationInput`](crate::input::CreateSipMediaApplicationInput)
    pub fn builder() -> crate::input::create_sip_media_application_input::Builder {
        crate::input::create_sip_media_application_input::Builder::default()
    }
}

/// See [`CreateSipMediaApplicationCallInput`](crate::input::CreateSipMediaApplicationCallInput)
pub mod create_sip_media_application_call_input {

    /// A builder for [`CreateSipMediaApplicationCallInput`](crate::input::CreateSipMediaApplicationCallInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from_phone_number: std::option::Option<std::string::String>,
        pub(crate) to_phone_number: std::option::Option<std::string::String>,
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
        pub(crate) sip_headers: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The phone number that a user calls from. This is a phone number in your Amazon Chime phone number inventory.</p>
        pub fn from_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number that a user calls from. This is a phone number in your Amazon Chime phone number inventory.</p>
        pub fn set_from_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.from_phone_number = input;
            self
        }
        /// <p>The phone number that the service should call.</p>
        pub fn to_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.to_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number that the service should call.</p>
        pub fn set_to_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.to_phone_number = input;
            self
        }
        /// <p>The ID of the SIP media application.</p>
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        /// <p>The ID of the SIP media application.</p>
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        /// Adds a key-value pair to `sip_headers`.
        ///
        /// To override the contents of this collection use [`set_sip_headers`](Self::set_sip_headers).
        ///
        /// <p>The SIP headers added to an outbound call leg.</p>
        pub fn sip_headers(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.sip_headers.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.sip_headers = Some(hash_map);
            self
        }
        /// <p>The SIP headers added to an outbound call leg.</p>
        pub fn set_sip_headers(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.sip_headers = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSipMediaApplicationCallInput`](crate::input::CreateSipMediaApplicationCallInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateSipMediaApplicationCallInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateSipMediaApplicationCallInput {
                from_phone_number: self.from_phone_number,
                to_phone_number: self.to_phone_number,
                sip_media_application_id: self.sip_media_application_id,
                sip_headers: self.sip_headers,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateSipMediaApplicationCallInputOperationOutputAlias =
    crate::operation::CreateSipMediaApplicationCall;
#[doc(hidden)]
pub type CreateSipMediaApplicationCallInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl CreateSipMediaApplicationCallInput {
    /// Consumes the builder and constructs an Operation<[`CreateSipMediaApplicationCall`](crate::operation::CreateSipMediaApplicationCall)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSipMediaApplicationCall,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateSipMediaApplicationCallInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_24 = &_input.sip_media_application_id;
                let input_24 = input_24.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_media_application_id = aws_smithy_http::label::fmt_string(input_24, false);
                if sip_media_application_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/sip-media-applications/{SipMediaApplicationId}/calls",
                    SipMediaApplicationId = sip_media_application_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateSipMediaApplicationCallInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_sip_media_application_call(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSipMediaApplicationCall::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSipMediaApplicationCall",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSipMediaApplicationCallInput`](crate::input::CreateSipMediaApplicationCallInput)
    pub fn builder() -> crate::input::create_sip_media_application_call_input::Builder {
        crate::input::create_sip_media_application_call_input::Builder::default()
    }
}

/// See [`CreateSipRuleInput`](crate::input::CreateSipRuleInput)
pub mod create_sip_rule_input {

    /// A builder for [`CreateSipRuleInput`](crate::input::CreateSipRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) trigger_type: std::option::Option<crate::model::SipRuleTriggerType>,
        pub(crate) trigger_value: std::option::Option<std::string::String>,
        pub(crate) disabled: std::option::Option<bool>,
        pub(crate) target_applications:
            std::option::Option<std::vec::Vec<crate::model::SipRuleTargetApplication>>,
    }
    impl Builder {
        /// <p>The name of the SIP rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the SIP rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of trigger assigned to the SIP rule in <code>TriggerValue</code>, currently <code>RequestUriHostname</code> or <code>ToPhoneNumber</code>.</p>
        pub fn trigger_type(mut self, input: crate::model::SipRuleTriggerType) -> Self {
            self.trigger_type = Some(input);
            self
        }
        /// <p>The type of trigger assigned to the SIP rule in <code>TriggerValue</code>, currently <code>RequestUriHostname</code> or <code>ToPhoneNumber</code>.</p>
        pub fn set_trigger_type(
            mut self,
            input: std::option::Option<crate::model::SipRuleTriggerType>,
        ) -> Self {
            self.trigger_type = input;
            self
        }
        /// <p>If <code>TriggerType</code> is <code>RequestUriHostname</code>, the value can be the outbound host name of an Amazon Chime Voice Connector. If <code>TriggerType</code> is <code>ToPhoneNumber</code>, the value can be a customer-owned phone number in the E164 format. The <code>SipMediaApplication</code> specified in the <code>SipRule</code> is triggered if the request URI in an incoming SIP request matches the <code>RequestUriHostname</code>, or if the <code>To</code> header in the incoming SIP request matches the <code>ToPhoneNumber</code> value.</p>
        pub fn trigger_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.trigger_value = Some(input.into());
            self
        }
        /// <p>If <code>TriggerType</code> is <code>RequestUriHostname</code>, the value can be the outbound host name of an Amazon Chime Voice Connector. If <code>TriggerType</code> is <code>ToPhoneNumber</code>, the value can be a customer-owned phone number in the E164 format. The <code>SipMediaApplication</code> specified in the <code>SipRule</code> is triggered if the request URI in an incoming SIP request matches the <code>RequestUriHostname</code>, or if the <code>To</code> header in the incoming SIP request matches the <code>ToPhoneNumber</code> value.</p>
        pub fn set_trigger_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.trigger_value = input;
            self
        }
        /// <p>Enables or disables a rule. You must disable rules before you can delete them.</p>
        pub fn disabled(mut self, input: bool) -> Self {
            self.disabled = Some(input);
            self
        }
        /// <p>Enables or disables a rule. You must disable rules before you can delete them.</p>
        pub fn set_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.disabled = input;
            self
        }
        /// Appends an item to `target_applications`.
        ///
        /// To override the contents of this collection use [`set_target_applications`](Self::set_target_applications).
        ///
        /// <p>List of SIP media applications with priority and AWS Region. Only one SIP application per AWS Region can be used.</p>
        pub fn target_applications(
            mut self,
            input: crate::model::SipRuleTargetApplication,
        ) -> Self {
            let mut v = self.target_applications.unwrap_or_default();
            v.push(input);
            self.target_applications = Some(v);
            self
        }
        /// <p>List of SIP media applications with priority and AWS Region. Only one SIP application per AWS Region can be used.</p>
        pub fn set_target_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SipRuleTargetApplication>>,
        ) -> Self {
            self.target_applications = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSipRuleInput`](crate::input::CreateSipRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateSipRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateSipRuleInput {
                name: self.name,
                trigger_type: self.trigger_type,
                trigger_value: self.trigger_value,
                disabled: self.disabled,
                target_applications: self.target_applications,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateSipRuleInputOperationOutputAlias = crate::operation::CreateSipRule;
#[doc(hidden)]
pub type CreateSipRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateSipRuleInput {
    /// Consumes the builder and constructs an Operation<[`CreateSipRule`](crate::operation::CreateSipRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSipRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateSipRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/sip-rules").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateSipRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_sip_rule(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSipRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSipRule",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSipRuleInput`](crate::input::CreateSipRuleInput)
    pub fn builder() -> crate::input::create_sip_rule_input::Builder {
        crate::input::create_sip_rule_input::Builder::default()
    }
}

/// See [`CreateUserInput`](crate::input::CreateUserInput)
pub mod create_user_input {

    /// A builder for [`CreateUserInput`](crate::input::CreateUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) username: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
        pub(crate) user_type: std::option::Option<crate::model::UserType>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The user name.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.username = Some(input.into());
            self
        }
        /// <p>The user name.</p>
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.username = input;
            self
        }
        /// <p>The user's email address.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>The user's email address.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// <p>The user type.</p>
        pub fn user_type(mut self, input: crate::model::UserType) -> Self {
            self.user_type = Some(input);
            self
        }
        /// <p>The user type.</p>
        pub fn set_user_type(mut self, input: std::option::Option<crate::model::UserType>) -> Self {
            self.user_type = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateUserInput`](crate::input::CreateUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateUserInput {
                account_id: self.account_id,
                username: self.username,
                email: self.email,
                user_type: self.user_type,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateUserInputOperationOutputAlias = crate::operation::CreateUser;
#[doc(hidden)]
pub type CreateUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateUserInput {
    /// Consumes the builder and constructs an Operation<[`CreateUser`](crate::operation::CreateUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_25 = &_input.account_id;
                let input_25 = input_25.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_25, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::CreateUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "create");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_user(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateUserInput`](crate::input::CreateUserInput)
    pub fn builder() -> crate::input::create_user_input::Builder {
        crate::input::create_user_input::Builder::default()
    }
}

/// See [`CreateVoiceConnectorInput`](crate::input::CreateVoiceConnectorInput)
pub mod create_voice_connector_input {

    /// A builder for [`CreateVoiceConnectorInput`](crate::input::CreateVoiceConnectorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<crate::model::VoiceConnectorAwsRegion>,
        pub(crate) require_encryption: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the Amazon Chime Voice Connector.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Chime Voice Connector.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> The AWS Region in which the Amazon Chime Voice Connector is created. Default value: <code>us-east-1</code> . </p>
        pub fn aws_region(mut self, input: crate::model::VoiceConnectorAwsRegion) -> Self {
            self.aws_region = Some(input);
            self
        }
        /// <p> The AWS Region in which the Amazon Chime Voice Connector is created. Default value: <code>us-east-1</code> . </p>
        pub fn set_aws_region(
            mut self,
            input: std::option::Option<crate::model::VoiceConnectorAwsRegion>,
        ) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>When enabled, requires encryption for the Amazon Chime Voice Connector.</p>
        pub fn require_encryption(mut self, input: bool) -> Self {
            self.require_encryption = Some(input);
            self
        }
        /// <p>When enabled, requires encryption for the Amazon Chime Voice Connector.</p>
        pub fn set_require_encryption(mut self, input: std::option::Option<bool>) -> Self {
            self.require_encryption = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVoiceConnectorInput`](crate::input::CreateVoiceConnectorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateVoiceConnectorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateVoiceConnectorInput {
                name: self.name,
                aws_region: self.aws_region,
                require_encryption: self.require_encryption,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateVoiceConnectorInputOperationOutputAlias = crate::operation::CreateVoiceConnector;
#[doc(hidden)]
pub type CreateVoiceConnectorInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateVoiceConnectorInput {
    /// Consumes the builder and constructs an Operation<[`CreateVoiceConnector`](crate::operation::CreateVoiceConnector)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateVoiceConnector,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateVoiceConnectorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/voice-connectors").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateVoiceConnectorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_voice_connector(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateVoiceConnector::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateVoiceConnector",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateVoiceConnectorInput`](crate::input::CreateVoiceConnectorInput)
    pub fn builder() -> crate::input::create_voice_connector_input::Builder {
        crate::input::create_voice_connector_input::Builder::default()
    }
}

/// See [`CreateVoiceConnectorGroupInput`](crate::input::CreateVoiceConnectorGroupInput)
pub mod create_voice_connector_group_input {

    /// A builder for [`CreateVoiceConnectorGroupInput`](crate::input::CreateVoiceConnectorGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) voice_connector_items:
            std::option::Option<std::vec::Vec<crate::model::VoiceConnectorItem>>,
    }
    impl Builder {
        /// <p>The name of the Amazon Chime Voice Connector group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Chime Voice Connector group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `voice_connector_items`.
        ///
        /// To override the contents of this collection use [`set_voice_connector_items`](Self::set_voice_connector_items).
        ///
        /// <p>The Amazon Chime Voice Connectors to route inbound calls to.</p>
        pub fn voice_connector_items(mut self, input: crate::model::VoiceConnectorItem) -> Self {
            let mut v = self.voice_connector_items.unwrap_or_default();
            v.push(input);
            self.voice_connector_items = Some(v);
            self
        }
        /// <p>The Amazon Chime Voice Connectors to route inbound calls to.</p>
        pub fn set_voice_connector_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VoiceConnectorItem>>,
        ) -> Self {
            self.voice_connector_items = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVoiceConnectorGroupInput`](crate::input::CreateVoiceConnectorGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateVoiceConnectorGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateVoiceConnectorGroupInput {
                name: self.name,
                voice_connector_items: self.voice_connector_items,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateVoiceConnectorGroupInputOperationOutputAlias =
    crate::operation::CreateVoiceConnectorGroup;
#[doc(hidden)]
pub type CreateVoiceConnectorGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateVoiceConnectorGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateVoiceConnectorGroup`](crate::operation::CreateVoiceConnectorGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateVoiceConnectorGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateVoiceConnectorGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/voice-connector-groups").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateVoiceConnectorGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_voice_connector_group(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateVoiceConnectorGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateVoiceConnectorGroup",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateVoiceConnectorGroupInput`](crate::input::CreateVoiceConnectorGroupInput)
    pub fn builder() -> crate::input::create_voice_connector_group_input::Builder {
        crate::input::create_voice_connector_group_input::Builder::default()
    }
}

/// See [`DeleteAccountInput`](crate::input::DeleteAccountInput)
pub mod delete_account_input {

    /// A builder for [`DeleteAccountInput`](crate::input::DeleteAccountInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAccountInput`](crate::input::DeleteAccountInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAccountInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAccountInput {
                account_id: self.account_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAccountInputOperationOutputAlias = crate::operation::DeleteAccount;
#[doc(hidden)]
pub type DeleteAccountInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAccountInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAccount`](crate::operation::DeleteAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAccount,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_26 = &_input.account_id;
                let input_26 = input_26.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_26, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/accounts/{AccountId}", AccountId = account_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAccount",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAccountInput`](crate::input::DeleteAccountInput)
    pub fn builder() -> crate::input::delete_account_input::Builder {
        crate::input::delete_account_input::Builder::default()
    }
}

/// See [`DeleteAppInstanceInput`](crate::input::DeleteAppInstanceInput)
pub mod delete_app_instance_input {

    /// A builder for [`DeleteAppInstanceInput`](crate::input::DeleteAppInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAppInstanceInput`](crate::input::DeleteAppInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAppInstanceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAppInstanceInput {
                app_instance_arn: self.app_instance_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAppInstanceInputOperationOutputAlias = crate::operation::DeleteAppInstance;
#[doc(hidden)]
pub type DeleteAppInstanceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAppInstanceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAppInstance`](crate::operation::DeleteAppInstance)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAppInstance,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAppInstanceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_27 = &_input.app_instance_arn;
                let input_27 = input_27.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_27, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAppInstanceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAppInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAppInstance",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAppInstanceInput`](crate::input::DeleteAppInstanceInput)
    pub fn builder() -> crate::input::delete_app_instance_input::Builder {
        crate::input::delete_app_instance_input::Builder::default()
    }
}

/// See [`DeleteAppInstanceAdminInput`](crate::input::DeleteAppInstanceAdminInput)
pub mod delete_app_instance_admin_input {

    /// A builder for [`DeleteAppInstanceAdminInput`](crate::input::DeleteAppInstanceAdminInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_admin_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>'s administrator.</p>
        pub fn app_instance_admin_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_admin_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>'s administrator.</p>
        pub fn set_app_instance_admin_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_admin_arn = input;
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAppInstanceAdminInput`](crate::input::DeleteAppInstanceAdminInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAppInstanceAdminInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAppInstanceAdminInput {
                app_instance_admin_arn: self.app_instance_admin_arn,
                app_instance_arn: self.app_instance_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAppInstanceAdminInputOperationOutputAlias = crate::operation::DeleteAppInstanceAdmin;
#[doc(hidden)]
pub type DeleteAppInstanceAdminInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAppInstanceAdminInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAppInstanceAdmin`](crate::operation::DeleteAppInstanceAdmin)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAppInstanceAdmin,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAppInstanceAdminInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_28 = &_input.app_instance_arn;
                let input_28 = input_28.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_28, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_29 = &_input.app_instance_admin_arn;
                let input_29 = input_29.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_admin_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_admin_arn = aws_smithy_http::label::fmt_string(input_29, false);
                if app_instance_admin_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_admin_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}/admins/{AppInstanceAdminArn}",
                    AppInstanceArn = app_instance_arn,
                    AppInstanceAdminArn = app_instance_admin_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAppInstanceAdminInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAppInstanceAdmin::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAppInstanceAdmin",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAppInstanceAdminInput`](crate::input::DeleteAppInstanceAdminInput)
    pub fn builder() -> crate::input::delete_app_instance_admin_input::Builder {
        crate::input::delete_app_instance_admin_input::Builder::default()
    }
}

/// See [`DeleteAppInstanceStreamingConfigurationsInput`](crate::input::DeleteAppInstanceStreamingConfigurationsInput)
pub mod delete_app_instance_streaming_configurations_input {

    /// A builder for [`DeleteAppInstanceStreamingConfigurationsInput`](crate::input::DeleteAppInstanceStreamingConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the streaming configurations being deleted.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the streaming configurations being deleted.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAppInstanceStreamingConfigurationsInput`](crate::input::DeleteAppInstanceStreamingConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAppInstanceStreamingConfigurationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DeleteAppInstanceStreamingConfigurationsInput {
                    app_instance_arn: self.app_instance_arn,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DeleteAppInstanceStreamingConfigurationsInputOperationOutputAlias =
    crate::operation::DeleteAppInstanceStreamingConfigurations;
#[doc(hidden)]
pub type DeleteAppInstanceStreamingConfigurationsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAppInstanceStreamingConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAppInstanceStreamingConfigurations`](crate::operation::DeleteAppInstanceStreamingConfigurations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAppInstanceStreamingConfigurations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAppInstanceStreamingConfigurationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_30 = &_input.app_instance_arn;
                let input_30 = input_30.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_30, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}/streaming-configurations",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAppInstanceStreamingConfigurationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAppInstanceStreamingConfigurations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAppInstanceStreamingConfigurations",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAppInstanceStreamingConfigurationsInput`](crate::input::DeleteAppInstanceStreamingConfigurationsInput)
    pub fn builder() -> crate::input::delete_app_instance_streaming_configurations_input::Builder {
        crate::input::delete_app_instance_streaming_configurations_input::Builder::default()
    }
}

/// See [`DeleteAppInstanceUserInput`](crate::input::DeleteAppInstanceUserInput)
pub mod delete_app_instance_user_input {

    /// A builder for [`DeleteAppInstanceUserInput`](crate::input::DeleteAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the user request being deleted.</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the user request being deleted.</p>
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAppInstanceUserInput`](crate::input::DeleteAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAppInstanceUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAppInstanceUserInput {
                app_instance_user_arn: self.app_instance_user_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAppInstanceUserInputOperationOutputAlias = crate::operation::DeleteAppInstanceUser;
#[doc(hidden)]
pub type DeleteAppInstanceUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAppInstanceUser`](crate::operation::DeleteAppInstanceUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAppInstanceUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAppInstanceUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_31 = &_input.app_instance_user_arn;
                let input_31 = input_31.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_user_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_user_arn = aws_smithy_http::label::fmt_string(input_31, false);
                if app_instance_user_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_user_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instance-users/{AppInstanceUserArn}",
                    AppInstanceUserArn = app_instance_user_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAppInstanceUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAppInstanceUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAppInstanceUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAppInstanceUserInput`](crate::input::DeleteAppInstanceUserInput)
    pub fn builder() -> crate::input::delete_app_instance_user_input::Builder {
        crate::input::delete_app_instance_user_input::Builder::default()
    }
}

/// See [`DeleteAttendeeInput`](crate::input::DeleteAttendeeInput)
pub mod delete_attendee_input {

    /// A builder for [`DeleteAttendeeInput`](crate::input::DeleteAttendeeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) attendee_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn attendee_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attendee_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn set_attendee_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attendee_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAttendeeInput`](crate::input::DeleteAttendeeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAttendeeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAttendeeInput {
                meeting_id: self.meeting_id,
                attendee_id: self.attendee_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAttendeeInputOperationOutputAlias = crate::operation::DeleteAttendee;
#[doc(hidden)]
pub type DeleteAttendeeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAttendeeInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAttendee`](crate::operation::DeleteAttendee)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAttendee,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAttendeeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_32 = &_input.meeting_id;
                let input_32 = input_32.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_32, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_33 = &_input.attendee_id;
                let input_33 = input_33.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let attendee_id = aws_smithy_http::label::fmt_string(input_33, false);
                if attendee_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/attendees/{AttendeeId}",
                    MeetingId = meeting_id,
                    AttendeeId = attendee_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAttendeeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAttendee::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAttendee",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAttendeeInput`](crate::input::DeleteAttendeeInput)
    pub fn builder() -> crate::input::delete_attendee_input::Builder {
        crate::input::delete_attendee_input::Builder::default()
    }
}

/// See [`DeleteChannelInput`](crate::input::DeleteChannelInput)
pub mod delete_channel_input {

    /// A builder for [`DeleteChannelInput`](crate::input::DeleteChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel being deleted.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel being deleted.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelInput`](crate::input::DeleteChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelInput {
                channel_arn: self.channel_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelInputOperationOutputAlias = crate::operation::DeleteChannel;
#[doc(hidden)]
pub type DeleteChannelInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteChannelInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannel`](crate::operation::DeleteChannel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteChannel,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteChannelInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_34 = &_input.channel_arn;
                let input_34 = input_34.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_34, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteChannelInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_delete_channel(input, builder)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteChannel",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelInput`](crate::input::DeleteChannelInput)
    pub fn builder() -> crate::input::delete_channel_input::Builder {
        crate::input::delete_channel_input::Builder::default()
    }
}

/// See [`DeleteChannelBanInput`](crate::input::DeleteChannelBanInput)
pub mod delete_channel_ban_input {

    /// A builder for [`DeleteChannelBanInput`](crate::input::DeleteChannelBanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel from which the <code>AppInstanceUser</code> was banned.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel from which the <code>AppInstanceUser</code> was banned.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the <code>AppInstanceUser</code> that you want to reinstate.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstanceUser</code> that you want to reinstate.</p>
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelBanInput`](crate::input::DeleteChannelBanInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelBanInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelBanInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelBanInputOperationOutputAlias = crate::operation::DeleteChannelBan;
#[doc(hidden)]
pub type DeleteChannelBanInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteChannelBanInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelBan`](crate::operation::DeleteChannelBan)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteChannelBan,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteChannelBanInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_35 = &_input.channel_arn;
                let input_35 = input_35.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_35, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_36 = &_input.member_arn;
                let input_36 = input_36.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let member_arn = aws_smithy_http::label::fmt_string(input_36, false);
                if member_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/bans/{MemberArn}",
                    ChannelArn = channel_arn,
                    MemberArn = member_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteChannelBanInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_delete_channel_ban(input, builder)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannelBan::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteChannelBan",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelBanInput`](crate::input::DeleteChannelBanInput)
    pub fn builder() -> crate::input::delete_channel_ban_input::Builder {
        crate::input::delete_channel_ban_input::Builder::default()
    }
}

/// See [`DeleteChannelMembershipInput`](crate::input::DeleteChannelMembershipInput)
pub mod delete_channel_membership_input {

    /// A builder for [`DeleteChannelMembershipInput`](crate::input::DeleteChannelMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel from which you want to remove the user.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel from which you want to remove the user.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member that you're removing from the channel.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the member that you're removing from the channel.</p>
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelMembershipInput`](crate::input::DeleteChannelMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelMembershipInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelMembershipInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelMembershipInputOperationOutputAlias =
    crate::operation::DeleteChannelMembership;
#[doc(hidden)]
pub type DeleteChannelMembershipInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteChannelMembershipInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelMembership`](crate::operation::DeleteChannelMembership)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteChannelMembership,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteChannelMembershipInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_37 = &_input.channel_arn;
                let input_37 = input_37.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_37, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_38 = &_input.member_arn;
                let input_38 = input_38.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let member_arn = aws_smithy_http::label::fmt_string(input_38, false);
                if member_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/memberships/{MemberArn}",
                    ChannelArn = channel_arn,
                    MemberArn = member_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteChannelMembershipInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_delete_channel_membership(input, builder)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannelMembership::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteChannelMembership",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelMembershipInput`](crate::input::DeleteChannelMembershipInput)
    pub fn builder() -> crate::input::delete_channel_membership_input::Builder {
        crate::input::delete_channel_membership_input::Builder::default()
    }
}

/// See [`DeleteChannelMessageInput`](crate::input::DeleteChannelMessageInput)
pub mod delete_channel_message_input {

    /// A builder for [`DeleteChannelMessageInput`](crate::input::DeleteChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ID of the message being deleted.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p>The ID of the message being deleted.</p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelMessageInput`](crate::input::DeleteChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelMessageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelMessageInput {
                channel_arn: self.channel_arn,
                message_id: self.message_id,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelMessageInputOperationOutputAlias = crate::operation::DeleteChannelMessage;
#[doc(hidden)]
pub type DeleteChannelMessageInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelMessage`](crate::operation::DeleteChannelMessage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteChannelMessage,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteChannelMessageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_39 = &_input.channel_arn;
                let input_39 = input_39.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_39, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_40 = &_input.message_id;
                let input_40 = input_40.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let message_id = aws_smithy_http::label::fmt_string(input_40, false);
                if message_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/messages/{MessageId}",
                    ChannelArn = channel_arn,
                    MessageId = message_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteChannelMessageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_delete_channel_message(input, builder)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannelMessage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteChannelMessage",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelMessageInput`](crate::input::DeleteChannelMessageInput)
    pub fn builder() -> crate::input::delete_channel_message_input::Builder {
        crate::input::delete_channel_message_input::Builder::default()
    }
}

/// See [`DeleteChannelModeratorInput`](crate::input::DeleteChannelModeratorInput)
pub mod delete_channel_moderator_input {

    /// A builder for [`DeleteChannelModeratorInput`](crate::input::DeleteChannelModeratorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) channel_moderator_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the moderator being deleted.</p>
        pub fn channel_moderator_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_moderator_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the moderator being deleted.</p>
        pub fn set_channel_moderator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.channel_moderator_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelModeratorInput`](crate::input::DeleteChannelModeratorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelModeratorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelModeratorInput {
                channel_arn: self.channel_arn,
                channel_moderator_arn: self.channel_moderator_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelModeratorInputOperationOutputAlias = crate::operation::DeleteChannelModerator;
#[doc(hidden)]
pub type DeleteChannelModeratorInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteChannelModeratorInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelModerator`](crate::operation::DeleteChannelModerator)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteChannelModerator,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteChannelModeratorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_41 = &_input.channel_arn;
                let input_41 = input_41.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_41, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_42 = &_input.channel_moderator_arn;
                let input_42 = input_42.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_moderator_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_moderator_arn = aws_smithy_http::label::fmt_string(input_42, false);
                if channel_moderator_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_moderator_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/moderators/{ChannelModeratorArn}",
                    ChannelArn = channel_arn,
                    ChannelModeratorArn = channel_moderator_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteChannelModeratorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_delete_channel_moderator(input, builder)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannelModerator::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteChannelModerator",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelModeratorInput`](crate::input::DeleteChannelModeratorInput)
    pub fn builder() -> crate::input::delete_channel_moderator_input::Builder {
        crate::input::delete_channel_moderator_input::Builder::default()
    }
}

/// See [`DeleteEventsConfigurationInput`](crate::input::DeleteEventsConfigurationInput)
pub mod delete_events_configuration_input {

    /// A builder for [`DeleteEventsConfigurationInput`](crate::input::DeleteEventsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) bot_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The bot ID.</p>
        pub fn bot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bot_id = Some(input.into());
            self
        }
        /// <p>The bot ID.</p>
        pub fn set_bot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bot_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteEventsConfigurationInput`](crate::input::DeleteEventsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteEventsConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteEventsConfigurationInput {
                account_id: self.account_id,
                bot_id: self.bot_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteEventsConfigurationInputOperationOutputAlias =
    crate::operation::DeleteEventsConfiguration;
#[doc(hidden)]
pub type DeleteEventsConfigurationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteEventsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteEventsConfiguration`](crate::operation::DeleteEventsConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteEventsConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteEventsConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_43 = &_input.account_id;
                let input_43 = input_43.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_43, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_44 = &_input.bot_id;
                let input_44 = input_44.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let bot_id = aws_smithy_http::label::fmt_string(input_44, false);
                if bot_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/bots/{BotId}/events-configuration",
                    AccountId = account_id,
                    BotId = bot_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteEventsConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteEventsConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteEventsConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteEventsConfigurationInput`](crate::input::DeleteEventsConfigurationInput)
    pub fn builder() -> crate::input::delete_events_configuration_input::Builder {
        crate::input::delete_events_configuration_input::Builder::default()
    }
}

/// See [`DeleteMediaCapturePipelineInput`](crate::input::DeleteMediaCapturePipelineInput)
pub mod delete_media_capture_pipeline_input {

    /// A builder for [`DeleteMediaCapturePipelineInput`](crate::input::DeleteMediaCapturePipelineInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) media_pipeline_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the media capture pipeline being deleted. </p>
        pub fn media_pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_pipeline_id = Some(input.into());
            self
        }
        /// <p>The ID of the media capture pipeline being deleted. </p>
        pub fn set_media_pipeline_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.media_pipeline_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteMediaCapturePipelineInput`](crate::input::DeleteMediaCapturePipelineInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteMediaCapturePipelineInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteMediaCapturePipelineInput {
                media_pipeline_id: self.media_pipeline_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteMediaCapturePipelineInputOperationOutputAlias =
    crate::operation::DeleteMediaCapturePipeline;
#[doc(hidden)]
pub type DeleteMediaCapturePipelineInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteMediaCapturePipelineInput {
    /// Consumes the builder and constructs an Operation<[`DeleteMediaCapturePipeline`](crate::operation::DeleteMediaCapturePipeline)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteMediaCapturePipeline,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteMediaCapturePipelineInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_45 = &_input.media_pipeline_id;
                let input_45 = input_45.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "media_pipeline_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let media_pipeline_id = aws_smithy_http::label::fmt_string(input_45, false);
                if media_pipeline_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "media_pipeline_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/media-capture-pipelines/{MediaPipelineId}",
                    MediaPipelineId = media_pipeline_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteMediaCapturePipelineInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteMediaCapturePipeline::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteMediaCapturePipeline",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteMediaCapturePipelineInput`](crate::input::DeleteMediaCapturePipelineInput)
    pub fn builder() -> crate::input::delete_media_capture_pipeline_input::Builder {
        crate::input::delete_media_capture_pipeline_input::Builder::default()
    }
}

/// See [`DeleteMeetingInput`](crate::input::DeleteMeetingInput)
pub mod delete_meeting_input {

    /// A builder for [`DeleteMeetingInput`](crate::input::DeleteMeetingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteMeetingInput`](crate::input::DeleteMeetingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteMeetingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteMeetingInput {
                meeting_id: self.meeting_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteMeetingInputOperationOutputAlias = crate::operation::DeleteMeeting;
#[doc(hidden)]
pub type DeleteMeetingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteMeetingInput {
    /// Consumes the builder and constructs an Operation<[`DeleteMeeting`](crate::operation::DeleteMeeting)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteMeeting,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteMeetingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_46 = &_input.meeting_id;
                let input_46 = input_46.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_46, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/meetings/{MeetingId}", MeetingId = meeting_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteMeetingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteMeeting::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteMeeting",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteMeetingInput`](crate::input::DeleteMeetingInput)
    pub fn builder() -> crate::input::delete_meeting_input::Builder {
        crate::input::delete_meeting_input::Builder::default()
    }
}

/// See [`DeletePhoneNumberInput`](crate::input::DeletePhoneNumberInput)
pub mod delete_phone_number_input {

    /// A builder for [`DeletePhoneNumberInput`](crate::input::DeletePhoneNumberInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The phone number ID.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>The phone number ID.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePhoneNumberInput`](crate::input::DeletePhoneNumberInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeletePhoneNumberInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeletePhoneNumberInput {
                phone_number_id: self.phone_number_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeletePhoneNumberInputOperationOutputAlias = crate::operation::DeletePhoneNumber;
#[doc(hidden)]
pub type DeletePhoneNumberInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeletePhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`DeletePhoneNumber`](crate::operation::DeletePhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeletePhoneNumber,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeletePhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_47 = &_input.phone_number_id;
                let input_47 = input_47.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let phone_number_id = aws_smithy_http::label::fmt_string(input_47, false);
                if phone_number_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/phone-numbers/{PhoneNumberId}",
                    PhoneNumberId = phone_number_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeletePhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeletePhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeletePhoneNumber",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeletePhoneNumberInput`](crate::input::DeletePhoneNumberInput)
    pub fn builder() -> crate::input::delete_phone_number_input::Builder {
        crate::input::delete_phone_number_input::Builder::default()
    }
}

/// See [`DeleteProxySessionInput`](crate::input::DeleteProxySessionInput)
pub mod delete_proxy_session_input {

    /// A builder for [`DeleteProxySessionInput`](crate::input::DeleteProxySessionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) proxy_session_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The proxy session ID.</p>
        pub fn proxy_session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.proxy_session_id = Some(input.into());
            self
        }
        /// <p>The proxy session ID.</p>
        pub fn set_proxy_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.proxy_session_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteProxySessionInput`](crate::input::DeleteProxySessionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteProxySessionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteProxySessionInput {
                voice_connector_id: self.voice_connector_id,
                proxy_session_id: self.proxy_session_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteProxySessionInputOperationOutputAlias = crate::operation::DeleteProxySession;
#[doc(hidden)]
pub type DeleteProxySessionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteProxySessionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProxySession`](crate::operation::DeleteProxySession)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteProxySession,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteProxySessionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_48 = &_input.voice_connector_id;
                let input_48 = input_48.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_48, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_49 = &_input.proxy_session_id;
                let input_49 = input_49.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "proxy_session_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let proxy_session_id = aws_smithy_http::label::fmt_string(input_49, false);
                if proxy_session_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "proxy_session_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/proxy-sessions/{ProxySessionId}",
                    VoiceConnectorId = voice_connector_id,
                    ProxySessionId = proxy_session_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteProxySessionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteProxySession::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteProxySession",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteProxySessionInput`](crate::input::DeleteProxySessionInput)
    pub fn builder() -> crate::input::delete_proxy_session_input::Builder {
        crate::input::delete_proxy_session_input::Builder::default()
    }
}

/// See [`DeleteRoomInput`](crate::input::DeleteRoomInput)
pub mod delete_room_input {

    /// A builder for [`DeleteRoomInput`](crate::input::DeleteRoomInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) room_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The chat room ID.</p>
        pub fn room_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.room_id = Some(input.into());
            self
        }
        /// <p>The chat room ID.</p>
        pub fn set_room_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.room_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRoomInput`](crate::input::DeleteRoomInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRoomInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRoomInput {
                account_id: self.account_id,
                room_id: self.room_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRoomInputOperationOutputAlias = crate::operation::DeleteRoom;
#[doc(hidden)]
pub type DeleteRoomInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteRoomInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRoom`](crate::operation::DeleteRoom)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteRoom,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteRoomInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_50 = &_input.account_id;
                let input_50 = input_50.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_50, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_51 = &_input.room_id;
                let input_51 = input_51.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let room_id = aws_smithy_http::label::fmt_string(input_51, false);
                if room_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms/{RoomId}",
                    AccountId = account_id,
                    RoomId = room_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteRoomInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteRoom::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteRoom",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteRoomInput`](crate::input::DeleteRoomInput)
    pub fn builder() -> crate::input::delete_room_input::Builder {
        crate::input::delete_room_input::Builder::default()
    }
}

/// See [`DeleteRoomMembershipInput`](crate::input::DeleteRoomMembershipInput)
pub mod delete_room_membership_input {

    /// A builder for [`DeleteRoomMembershipInput`](crate::input::DeleteRoomMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) room_id: std::option::Option<std::string::String>,
        pub(crate) member_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The room ID.</p>
        pub fn room_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.room_id = Some(input.into());
            self
        }
        /// <p>The room ID.</p>
        pub fn set_room_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.room_id = input;
            self
        }
        /// <p>The member ID (user ID or bot ID).</p>
        pub fn member_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_id = Some(input.into());
            self
        }
        /// <p>The member ID (user ID or bot ID).</p>
        pub fn set_member_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRoomMembershipInput`](crate::input::DeleteRoomMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRoomMembershipInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRoomMembershipInput {
                account_id: self.account_id,
                room_id: self.room_id,
                member_id: self.member_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRoomMembershipInputOperationOutputAlias = crate::operation::DeleteRoomMembership;
#[doc(hidden)]
pub type DeleteRoomMembershipInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteRoomMembershipInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRoomMembership`](crate::operation::DeleteRoomMembership)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteRoomMembership,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteRoomMembershipInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_52 = &_input.account_id;
                let input_52 = input_52.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_52, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_53 = &_input.room_id;
                let input_53 = input_53.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let room_id = aws_smithy_http::label::fmt_string(input_53, false);
                if room_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_54 = &_input.member_id;
                let input_54 = input_54.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let member_id = aws_smithy_http::label::fmt_string(input_54, false);
                if member_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms/{RoomId}/memberships/{MemberId}",
                    AccountId = account_id,
                    RoomId = room_id,
                    MemberId = member_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteRoomMembershipInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteRoomMembership::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteRoomMembership",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteRoomMembershipInput`](crate::input::DeleteRoomMembershipInput)
    pub fn builder() -> crate::input::delete_room_membership_input::Builder {
        crate::input::delete_room_membership_input::Builder::default()
    }
}

/// See [`DeleteSipMediaApplicationInput`](crate::input::DeleteSipMediaApplicationInput)
pub mod delete_sip_media_application_input {

    /// A builder for [`DeleteSipMediaApplicationInput`](crate::input::DeleteSipMediaApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The SIP media application ID.</p>
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        /// <p>The SIP media application ID.</p>
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSipMediaApplicationInput`](crate::input::DeleteSipMediaApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteSipMediaApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteSipMediaApplicationInput {
                sip_media_application_id: self.sip_media_application_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSipMediaApplicationInputOperationOutputAlias =
    crate::operation::DeleteSipMediaApplication;
#[doc(hidden)]
pub type DeleteSipMediaApplicationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteSipMediaApplicationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSipMediaApplication`](crate::operation::DeleteSipMediaApplication)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteSipMediaApplication,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteSipMediaApplicationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_55 = &_input.sip_media_application_id;
                let input_55 = input_55.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_media_application_id = aws_smithy_http::label::fmt_string(input_55, false);
                if sip_media_application_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/sip-media-applications/{SipMediaApplicationId}",
                    SipMediaApplicationId = sip_media_application_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteSipMediaApplicationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteSipMediaApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteSipMediaApplication",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteSipMediaApplicationInput`](crate::input::DeleteSipMediaApplicationInput)
    pub fn builder() -> crate::input::delete_sip_media_application_input::Builder {
        crate::input::delete_sip_media_application_input::Builder::default()
    }
}

/// See [`DeleteSipRuleInput`](crate::input::DeleteSipRuleInput)
pub mod delete_sip_rule_input {

    /// A builder for [`DeleteSipRuleInput`](crate::input::DeleteSipRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_rule_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The SIP rule ID.</p>
        pub fn sip_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_rule_id = Some(input.into());
            self
        }
        /// <p>The SIP rule ID.</p>
        pub fn set_sip_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sip_rule_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSipRuleInput`](crate::input::DeleteSipRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteSipRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteSipRuleInput {
                sip_rule_id: self.sip_rule_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSipRuleInputOperationOutputAlias = crate::operation::DeleteSipRule;
#[doc(hidden)]
pub type DeleteSipRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteSipRuleInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSipRule`](crate::operation::DeleteSipRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteSipRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteSipRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_56 = &_input.sip_rule_id;
                let input_56 = input_56.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_rule_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_rule_id = aws_smithy_http::label::fmt_string(input_56, false);
                if sip_rule_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_rule_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/sip-rules/{SipRuleId}", SipRuleId = sip_rule_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteSipRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteSipRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteSipRule",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteSipRuleInput`](crate::input::DeleteSipRuleInput)
    pub fn builder() -> crate::input::delete_sip_rule_input::Builder {
        crate::input::delete_sip_rule_input::Builder::default()
    }
}

/// See [`DeleteVoiceConnectorInput`](crate::input::DeleteVoiceConnectorInput)
pub mod delete_voice_connector_input {

    /// A builder for [`DeleteVoiceConnectorInput`](crate::input::DeleteVoiceConnectorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVoiceConnectorInput`](crate::input::DeleteVoiceConnectorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVoiceConnectorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteVoiceConnectorInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVoiceConnectorInputOperationOutputAlias = crate::operation::DeleteVoiceConnector;
#[doc(hidden)]
pub type DeleteVoiceConnectorInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteVoiceConnectorInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVoiceConnector`](crate::operation::DeleteVoiceConnector)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVoiceConnector,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVoiceConnectorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_57 = &_input.voice_connector_id;
                let input_57 = input_57.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_57, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVoiceConnectorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVoiceConnector::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVoiceConnector",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteVoiceConnectorInput`](crate::input::DeleteVoiceConnectorInput)
    pub fn builder() -> crate::input::delete_voice_connector_input::Builder {
        crate::input::delete_voice_connector_input::Builder::default()
    }
}

/// See [`DeleteVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::DeleteVoiceConnectorEmergencyCallingConfigurationInput)
pub mod delete_voice_connector_emergency_calling_configuration_input {

    /// A builder for [`DeleteVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::DeleteVoiceConnectorEmergencyCallingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::DeleteVoiceConnectorEmergencyCallingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVoiceConnectorEmergencyCallingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DeleteVoiceConnectorEmergencyCallingConfigurationInput {
                    voice_connector_id: self.voice_connector_id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DeleteVoiceConnectorEmergencyCallingConfigurationInputOperationOutputAlias =
    crate::operation::DeleteVoiceConnectorEmergencyCallingConfiguration;
#[doc(hidden)]
pub type DeleteVoiceConnectorEmergencyCallingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DeleteVoiceConnectorEmergencyCallingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVoiceConnectorEmergencyCallingConfiguration`](crate::operation::DeleteVoiceConnectorEmergencyCallingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVoiceConnectorEmergencyCallingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVoiceConnectorEmergencyCallingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_58 = &_input.voice_connector_id;
                let input_58 = input_58.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_58, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/emergency-calling-configuration",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVoiceConnectorEmergencyCallingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVoiceConnectorEmergencyCallingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVoiceConnectorEmergencyCallingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::DeleteVoiceConnectorEmergencyCallingConfigurationInput)
    pub fn builder(
    ) -> crate::input::delete_voice_connector_emergency_calling_configuration_input::Builder {
        crate::input::delete_voice_connector_emergency_calling_configuration_input::Builder::default(
        )
    }
}

/// See [`DeleteVoiceConnectorGroupInput`](crate::input::DeleteVoiceConnectorGroupInput)
pub mod delete_voice_connector_group_input {

    /// A builder for [`DeleteVoiceConnectorGroupInput`](crate::input::DeleteVoiceConnectorGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn voice_connector_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_group_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn set_voice_connector_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVoiceConnectorGroupInput`](crate::input::DeleteVoiceConnectorGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVoiceConnectorGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteVoiceConnectorGroupInput {
                voice_connector_group_id: self.voice_connector_group_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVoiceConnectorGroupInputOperationOutputAlias =
    crate::operation::DeleteVoiceConnectorGroup;
#[doc(hidden)]
pub type DeleteVoiceConnectorGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteVoiceConnectorGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVoiceConnectorGroup`](crate::operation::DeleteVoiceConnectorGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVoiceConnectorGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVoiceConnectorGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_59 = &_input.voice_connector_group_id;
                let input_59 = input_59.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_group_id = aws_smithy_http::label::fmt_string(input_59, false);
                if voice_connector_group_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connector-groups/{VoiceConnectorGroupId}",
                    VoiceConnectorGroupId = voice_connector_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVoiceConnectorGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVoiceConnectorGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVoiceConnectorGroup",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteVoiceConnectorGroupInput`](crate::input::DeleteVoiceConnectorGroupInput)
    pub fn builder() -> crate::input::delete_voice_connector_group_input::Builder {
        crate::input::delete_voice_connector_group_input::Builder::default()
    }
}

/// See [`DeleteVoiceConnectorOriginationInput`](crate::input::DeleteVoiceConnectorOriginationInput)
pub mod delete_voice_connector_origination_input {

    /// A builder for [`DeleteVoiceConnectorOriginationInput`](crate::input::DeleteVoiceConnectorOriginationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVoiceConnectorOriginationInput`](crate::input::DeleteVoiceConnectorOriginationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVoiceConnectorOriginationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteVoiceConnectorOriginationInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVoiceConnectorOriginationInputOperationOutputAlias =
    crate::operation::DeleteVoiceConnectorOrigination;
#[doc(hidden)]
pub type DeleteVoiceConnectorOriginationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DeleteVoiceConnectorOriginationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVoiceConnectorOrigination`](crate::operation::DeleteVoiceConnectorOrigination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVoiceConnectorOrigination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVoiceConnectorOriginationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_60 = &_input.voice_connector_id;
                let input_60 = input_60.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_60, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/origination",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVoiceConnectorOriginationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVoiceConnectorOrigination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVoiceConnectorOrigination",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteVoiceConnectorOriginationInput`](crate::input::DeleteVoiceConnectorOriginationInput)
    pub fn builder() -> crate::input::delete_voice_connector_origination_input::Builder {
        crate::input::delete_voice_connector_origination_input::Builder::default()
    }
}

/// See [`DeleteVoiceConnectorProxyInput`](crate::input::DeleteVoiceConnectorProxyInput)
pub mod delete_voice_connector_proxy_input {

    /// A builder for [`DeleteVoiceConnectorProxyInput`](crate::input::DeleteVoiceConnectorProxyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVoiceConnectorProxyInput`](crate::input::DeleteVoiceConnectorProxyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVoiceConnectorProxyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteVoiceConnectorProxyInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVoiceConnectorProxyInputOperationOutputAlias =
    crate::operation::DeleteVoiceConnectorProxy;
#[doc(hidden)]
pub type DeleteVoiceConnectorProxyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteVoiceConnectorProxyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVoiceConnectorProxy`](crate::operation::DeleteVoiceConnectorProxy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVoiceConnectorProxy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVoiceConnectorProxyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_61 = &_input.voice_connector_id;
                let input_61 = input_61.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_61, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/programmable-numbers/proxy",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVoiceConnectorProxyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVoiceConnectorProxy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVoiceConnectorProxy",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteVoiceConnectorProxyInput`](crate::input::DeleteVoiceConnectorProxyInput)
    pub fn builder() -> crate::input::delete_voice_connector_proxy_input::Builder {
        crate::input::delete_voice_connector_proxy_input::Builder::default()
    }
}

/// See [`DeleteVoiceConnectorStreamingConfigurationInput`](crate::input::DeleteVoiceConnectorStreamingConfigurationInput)
pub mod delete_voice_connector_streaming_configuration_input {

    /// A builder for [`DeleteVoiceConnectorStreamingConfigurationInput`](crate::input::DeleteVoiceConnectorStreamingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVoiceConnectorStreamingConfigurationInput`](crate::input::DeleteVoiceConnectorStreamingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVoiceConnectorStreamingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DeleteVoiceConnectorStreamingConfigurationInput {
                    voice_connector_id: self.voice_connector_id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DeleteVoiceConnectorStreamingConfigurationInputOperationOutputAlias =
    crate::operation::DeleteVoiceConnectorStreamingConfiguration;
#[doc(hidden)]
pub type DeleteVoiceConnectorStreamingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DeleteVoiceConnectorStreamingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVoiceConnectorStreamingConfiguration`](crate::operation::DeleteVoiceConnectorStreamingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVoiceConnectorStreamingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVoiceConnectorStreamingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_62 = &_input.voice_connector_id;
                let input_62 = input_62.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_62, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/streaming-configuration",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVoiceConnectorStreamingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVoiceConnectorStreamingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVoiceConnectorStreamingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteVoiceConnectorStreamingConfigurationInput`](crate::input::DeleteVoiceConnectorStreamingConfigurationInput)
    pub fn builder() -> crate::input::delete_voice_connector_streaming_configuration_input::Builder
    {
        crate::input::delete_voice_connector_streaming_configuration_input::Builder::default()
    }
}

/// See [`DeleteVoiceConnectorTerminationInput`](crate::input::DeleteVoiceConnectorTerminationInput)
pub mod delete_voice_connector_termination_input {

    /// A builder for [`DeleteVoiceConnectorTerminationInput`](crate::input::DeleteVoiceConnectorTerminationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVoiceConnectorTerminationInput`](crate::input::DeleteVoiceConnectorTerminationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVoiceConnectorTerminationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteVoiceConnectorTerminationInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteVoiceConnectorTerminationInputOperationOutputAlias =
    crate::operation::DeleteVoiceConnectorTermination;
#[doc(hidden)]
pub type DeleteVoiceConnectorTerminationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DeleteVoiceConnectorTerminationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVoiceConnectorTermination`](crate::operation::DeleteVoiceConnectorTermination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVoiceConnectorTermination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVoiceConnectorTerminationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_63 = &_input.voice_connector_id;
                let input_63 = input_63.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_63, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/termination",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVoiceConnectorTerminationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVoiceConnectorTermination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVoiceConnectorTermination",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteVoiceConnectorTerminationInput`](crate::input::DeleteVoiceConnectorTerminationInput)
    pub fn builder() -> crate::input::delete_voice_connector_termination_input::Builder {
        crate::input::delete_voice_connector_termination_input::Builder::default()
    }
}

/// See [`DeleteVoiceConnectorTerminationCredentialsInput`](crate::input::DeleteVoiceConnectorTerminationCredentialsInput)
pub mod delete_voice_connector_termination_credentials_input {

    /// A builder for [`DeleteVoiceConnectorTerminationCredentialsInput`](crate::input::DeleteVoiceConnectorTerminationCredentialsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) usernames: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Appends an item to `usernames`.
        ///
        /// To override the contents of this collection use [`set_usernames`](Self::set_usernames).
        ///
        /// <p>The RFC2617 compliant username associated with the SIP credentials, in US-ASCII format.</p>
        pub fn usernames(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.usernames.unwrap_or_default();
            v.push(input.into());
            self.usernames = Some(v);
            self
        }
        /// <p>The RFC2617 compliant username associated with the SIP credentials, in US-ASCII format.</p>
        pub fn set_usernames(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.usernames = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVoiceConnectorTerminationCredentialsInput`](crate::input::DeleteVoiceConnectorTerminationCredentialsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteVoiceConnectorTerminationCredentialsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DeleteVoiceConnectorTerminationCredentialsInput {
                    voice_connector_id: self.voice_connector_id,
                    usernames: self.usernames,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DeleteVoiceConnectorTerminationCredentialsInputOperationOutputAlias =
    crate::operation::DeleteVoiceConnectorTerminationCredentials;
#[doc(hidden)]
pub type DeleteVoiceConnectorTerminationCredentialsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DeleteVoiceConnectorTerminationCredentialsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVoiceConnectorTerminationCredentials`](crate::operation::DeleteVoiceConnectorTerminationCredentials)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVoiceConnectorTerminationCredentials,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVoiceConnectorTerminationCredentialsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_64 = &_input.voice_connector_id;
                let input_64 = input_64.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_64, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/termination/credentials",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteVoiceConnectorTerminationCredentialsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "delete");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVoiceConnectorTerminationCredentialsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_voice_connector_termination_credentials(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVoiceConnectorTerminationCredentials::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVoiceConnectorTerminationCredentials",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteVoiceConnectorTerminationCredentialsInput`](crate::input::DeleteVoiceConnectorTerminationCredentialsInput)
    pub fn builder() -> crate::input::delete_voice_connector_termination_credentials_input::Builder
    {
        crate::input::delete_voice_connector_termination_credentials_input::Builder::default()
    }
}

/// See [`DescribeAppInstanceInput`](crate::input::DescribeAppInstanceInput)
pub mod describe_app_instance_input {

    /// A builder for [`DescribeAppInstanceInput`](crate::input::DescribeAppInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAppInstanceInput`](crate::input::DescribeAppInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAppInstanceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAppInstanceInput {
                app_instance_arn: self.app_instance_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAppInstanceInputOperationOutputAlias = crate::operation::DescribeAppInstance;
#[doc(hidden)]
pub type DescribeAppInstanceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeAppInstanceInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAppInstance`](crate::operation::DescribeAppInstance)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAppInstance,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAppInstanceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_65 = &_input.app_instance_arn;
                let input_65 = input_65.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_65, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAppInstanceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAppInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAppInstance",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAppInstanceInput`](crate::input::DescribeAppInstanceInput)
    pub fn builder() -> crate::input::describe_app_instance_input::Builder {
        crate::input::describe_app_instance_input::Builder::default()
    }
}

/// See [`DescribeAppInstanceAdminInput`](crate::input::DescribeAppInstanceAdminInput)
pub mod describe_app_instance_admin_input {

    /// A builder for [`DescribeAppInstanceAdminInput`](crate::input::DescribeAppInstanceAdminInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_admin_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstanceAdmin</code>.</p>
        pub fn app_instance_admin_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_admin_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstanceAdmin</code>.</p>
        pub fn set_app_instance_admin_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_admin_arn = input;
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAppInstanceAdminInput`](crate::input::DescribeAppInstanceAdminInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAppInstanceAdminInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAppInstanceAdminInput {
                app_instance_admin_arn: self.app_instance_admin_arn,
                app_instance_arn: self.app_instance_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAppInstanceAdminInputOperationOutputAlias =
    crate::operation::DescribeAppInstanceAdmin;
#[doc(hidden)]
pub type DescribeAppInstanceAdminInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeAppInstanceAdminInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAppInstanceAdmin`](crate::operation::DescribeAppInstanceAdmin)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAppInstanceAdmin,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAppInstanceAdminInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_66 = &_input.app_instance_arn;
                let input_66 = input_66.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_66, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_67 = &_input.app_instance_admin_arn;
                let input_67 = input_67.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_admin_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_admin_arn = aws_smithy_http::label::fmt_string(input_67, false);
                if app_instance_admin_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_admin_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}/admins/{AppInstanceAdminArn}",
                    AppInstanceArn = app_instance_arn,
                    AppInstanceAdminArn = app_instance_admin_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAppInstanceAdminInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAppInstanceAdmin::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAppInstanceAdmin",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAppInstanceAdminInput`](crate::input::DescribeAppInstanceAdminInput)
    pub fn builder() -> crate::input::describe_app_instance_admin_input::Builder {
        crate::input::describe_app_instance_admin_input::Builder::default()
    }
}

/// See [`DescribeAppInstanceUserInput`](crate::input::DescribeAppInstanceUserInput)
pub mod describe_app_instance_user_input {

    /// A builder for [`DescribeAppInstanceUserInput`](crate::input::DescribeAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstanceUser</code>.</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstanceUser</code>.</p>
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAppInstanceUserInput`](crate::input::DescribeAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAppInstanceUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAppInstanceUserInput {
                app_instance_user_arn: self.app_instance_user_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAppInstanceUserInputOperationOutputAlias =
    crate::operation::DescribeAppInstanceUser;
#[doc(hidden)]
pub type DescribeAppInstanceUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAppInstanceUser`](crate::operation::DescribeAppInstanceUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAppInstanceUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeAppInstanceUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_68 = &_input.app_instance_user_arn;
                let input_68 = input_68.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_user_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_user_arn = aws_smithy_http::label::fmt_string(input_68, false);
                if app_instance_user_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_user_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instance-users/{AppInstanceUserArn}",
                    AppInstanceUserArn = app_instance_user_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeAppInstanceUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAppInstanceUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAppInstanceUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeAppInstanceUserInput`](crate::input::DescribeAppInstanceUserInput)
    pub fn builder() -> crate::input::describe_app_instance_user_input::Builder {
        crate::input::describe_app_instance_user_input::Builder::default()
    }
}

/// See [`DescribeChannelInput`](crate::input::DescribeChannelInput)
pub mod describe_channel_input {

    /// A builder for [`DescribeChannelInput`](crate::input::DescribeChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelInput`](crate::input::DescribeChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelInput {
                channel_arn: self.channel_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelInputOperationOutputAlias = crate::operation::DescribeChannel;
#[doc(hidden)]
pub type DescribeChannelInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeChannelInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannel`](crate::operation::DescribeChannel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeChannel,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeChannelInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_69 = &_input.channel_arn;
                let input_69 = input_69.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_69, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeChannelInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_describe_channel(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeChannel",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelInput`](crate::input::DescribeChannelInput)
    pub fn builder() -> crate::input::describe_channel_input::Builder {
        crate::input::describe_channel_input::Builder::default()
    }
}

/// See [`DescribeChannelBanInput`](crate::input::DescribeChannelBanInput)
pub mod describe_channel_ban_input {

    /// A builder for [`DescribeChannelBanInput`](crate::input::DescribeChannelBanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel from which the user is banned.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel from which the user is banned.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member being banned.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the member being banned.</p>
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelBanInput`](crate::input::DescribeChannelBanInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelBanInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelBanInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelBanInputOperationOutputAlias = crate::operation::DescribeChannelBan;
#[doc(hidden)]
pub type DescribeChannelBanInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeChannelBanInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelBan`](crate::operation::DescribeChannelBan)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeChannelBan,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeChannelBanInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_70 = &_input.channel_arn;
                let input_70 = input_70.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_70, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_71 = &_input.member_arn;
                let input_71 = input_71.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let member_arn = aws_smithy_http::label::fmt_string(input_71, false);
                if member_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/bans/{MemberArn}",
                    ChannelArn = channel_arn,
                    MemberArn = member_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeChannelBanInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_describe_channel_ban(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelBan::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeChannelBan",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelBanInput`](crate::input::DescribeChannelBanInput)
    pub fn builder() -> crate::input::describe_channel_ban_input::Builder {
        crate::input::describe_channel_ban_input::Builder::default()
    }
}

/// See [`DescribeChannelMembershipInput`](crate::input::DescribeChannelMembershipInput)
pub mod describe_channel_membership_input {

    /// A builder for [`DescribeChannelMembershipInput`](crate::input::DescribeChannelMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the member.</p>
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelMembershipInput`](crate::input::DescribeChannelMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelMembershipInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelMembershipInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelMembershipInputOperationOutputAlias =
    crate::operation::DescribeChannelMembership;
#[doc(hidden)]
pub type DescribeChannelMembershipInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeChannelMembershipInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelMembership`](crate::operation::DescribeChannelMembership)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeChannelMembership,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeChannelMembershipInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_72 = &_input.channel_arn;
                let input_72 = input_72.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_72, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_73 = &_input.member_arn;
                let input_73 = input_73.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let member_arn = aws_smithy_http::label::fmt_string(input_73, false);
                if member_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/memberships/{MemberArn}",
                    ChannelArn = channel_arn,
                    MemberArn = member_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeChannelMembershipInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_describe_channel_membership(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelMembership::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeChannelMembership",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelMembershipInput`](crate::input::DescribeChannelMembershipInput)
    pub fn builder() -> crate::input::describe_channel_membership_input::Builder {
        crate::input::describe_channel_membership_input::Builder::default()
    }
}

/// See [`DescribeChannelMembershipForAppInstanceUserInput`](crate::input::DescribeChannelMembershipForAppInstanceUserInput)
pub mod describe_channel_membership_for_app_instance_user_input {

    /// A builder for [`DescribeChannelMembershipForAppInstanceUserInput`](crate::input::DescribeChannelMembershipForAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel to which the user belongs.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel to which the user belongs.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the user in a channel.</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the user in a channel.</p>
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelMembershipForAppInstanceUserInput`](crate::input::DescribeChannelMembershipForAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelMembershipForAppInstanceUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DescribeChannelMembershipForAppInstanceUserInput {
                    channel_arn: self.channel_arn,
                    app_instance_user_arn: self.app_instance_user_arn,
                    chime_bearer: self.chime_bearer,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelMembershipForAppInstanceUserInputOperationOutputAlias =
    crate::operation::DescribeChannelMembershipForAppInstanceUser;
#[doc(hidden)]
pub type DescribeChannelMembershipForAppInstanceUserInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DescribeChannelMembershipForAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelMembershipForAppInstanceUser`](crate::operation::DescribeChannelMembershipForAppInstanceUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeChannelMembershipForAppInstanceUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeChannelMembershipForAppInstanceUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_74 = &_input.channel_arn;
                let input_74 = input_74.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_74, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribeChannelMembershipForAppInstanceUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("scope", "app-instance-user-membership");
                if let Some(inner_75) = &_input.app_instance_user_arn {
                    query.push_kv(
                        "app-instance-user-arn",
                        &aws_smithy_http::query::fmt_string(&inner_75),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeChannelMembershipForAppInstanceUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_describe_channel_membership_for_app_instance_user(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelMembershipForAppInstanceUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeChannelMembershipForAppInstanceUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelMembershipForAppInstanceUserInput`](crate::input::DescribeChannelMembershipForAppInstanceUserInput)
    pub fn builder(
    ) -> crate::input::describe_channel_membership_for_app_instance_user_input::Builder {
        crate::input::describe_channel_membership_for_app_instance_user_input::Builder::default()
    }
}

/// See [`DescribeChannelModeratedByAppInstanceUserInput`](crate::input::DescribeChannelModeratedByAppInstanceUserInput)
pub mod describe_channel_moderated_by_app_instance_user_input {

    /// A builder for [`DescribeChannelModeratedByAppInstanceUserInput`](crate::input::DescribeChannelModeratedByAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the moderated channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the moderated channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the <code>AppInstanceUser</code> in the moderated channel.</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstanceUser</code> in the moderated channel.</p>
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelModeratedByAppInstanceUserInput`](crate::input::DescribeChannelModeratedByAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelModeratedByAppInstanceUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DescribeChannelModeratedByAppInstanceUserInput {
                    channel_arn: self.channel_arn,
                    app_instance_user_arn: self.app_instance_user_arn,
                    chime_bearer: self.chime_bearer,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelModeratedByAppInstanceUserInputOperationOutputAlias =
    crate::operation::DescribeChannelModeratedByAppInstanceUser;
#[doc(hidden)]
pub type DescribeChannelModeratedByAppInstanceUserInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DescribeChannelModeratedByAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelModeratedByAppInstanceUser`](crate::operation::DescribeChannelModeratedByAppInstanceUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeChannelModeratedByAppInstanceUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeChannelModeratedByAppInstanceUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_76 = &_input.channel_arn;
                let input_76 = input_76.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_76, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribeChannelModeratedByAppInstanceUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("scope", "app-instance-user-moderated-channel");
                if let Some(inner_77) = &_input.app_instance_user_arn {
                    query.push_kv(
                        "app-instance-user-arn",
                        &aws_smithy_http::query::fmt_string(&inner_77),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeChannelModeratedByAppInstanceUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_describe_channel_moderated_by_app_instance_user(
                        input, builder,
                    )?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelModeratedByAppInstanceUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeChannelModeratedByAppInstanceUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelModeratedByAppInstanceUserInput`](crate::input::DescribeChannelModeratedByAppInstanceUserInput)
    pub fn builder() -> crate::input::describe_channel_moderated_by_app_instance_user_input::Builder
    {
        crate::input::describe_channel_moderated_by_app_instance_user_input::Builder::default()
    }
}

/// See [`DescribeChannelModeratorInput`](crate::input::DescribeChannelModeratorInput)
pub mod describe_channel_moderator_input {

    /// A builder for [`DescribeChannelModeratorInput`](crate::input::DescribeChannelModeratorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) channel_moderator_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the channel moderator.</p>
        pub fn channel_moderator_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_moderator_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel moderator.</p>
        pub fn set_channel_moderator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.channel_moderator_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelModeratorInput`](crate::input::DescribeChannelModeratorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelModeratorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelModeratorInput {
                channel_arn: self.channel_arn,
                channel_moderator_arn: self.channel_moderator_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelModeratorInputOperationOutputAlias =
    crate::operation::DescribeChannelModerator;
#[doc(hidden)]
pub type DescribeChannelModeratorInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeChannelModeratorInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelModerator`](crate::operation::DescribeChannelModerator)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeChannelModerator,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeChannelModeratorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_78 = &_input.channel_arn;
                let input_78 = input_78.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_78, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_79 = &_input.channel_moderator_arn;
                let input_79 = input_79.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_moderator_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_moderator_arn = aws_smithy_http::label::fmt_string(input_79, false);
                if channel_moderator_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_moderator_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/moderators/{ChannelModeratorArn}",
                    ChannelArn = channel_arn,
                    ChannelModeratorArn = channel_moderator_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeChannelModeratorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_describe_channel_moderator(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelModerator::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeChannelModerator",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelModeratorInput`](crate::input::DescribeChannelModeratorInput)
    pub fn builder() -> crate::input::describe_channel_moderator_input::Builder {
        crate::input::describe_channel_moderator_input::Builder::default()
    }
}

/// See [`DisassociatePhoneNumberFromUserInput`](crate::input::DisassociatePhoneNumberFromUserInput)
pub mod disassociate_phone_number_from_user_input {

    /// A builder for [`DisassociatePhoneNumberFromUserInput`](crate::input::DisassociatePhoneNumberFromUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The user ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The user ID.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociatePhoneNumberFromUserInput`](crate::input::DisassociatePhoneNumberFromUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociatePhoneNumberFromUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociatePhoneNumberFromUserInput {
                account_id: self.account_id,
                user_id: self.user_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociatePhoneNumberFromUserInputOperationOutputAlias =
    crate::operation::DisassociatePhoneNumberFromUser;
#[doc(hidden)]
pub type DisassociatePhoneNumberFromUserInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DisassociatePhoneNumberFromUserInput {
    /// Consumes the builder and constructs an Operation<[`DisassociatePhoneNumberFromUser`](crate::operation::DisassociatePhoneNumberFromUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociatePhoneNumberFromUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociatePhoneNumberFromUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_80 = &_input.account_id;
                let input_80 = input_80.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_80, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_81 = &_input.user_id;
                let input_81 = input_81.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let user_id = aws_smithy_http::label::fmt_string(input_81, false);
                if user_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users/{UserId}",
                    AccountId = account_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociatePhoneNumberFromUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "disassociate-phone-number");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociatePhoneNumberFromUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociatePhoneNumberFromUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociatePhoneNumberFromUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociatePhoneNumberFromUserInput`](crate::input::DisassociatePhoneNumberFromUserInput)
    pub fn builder() -> crate::input::disassociate_phone_number_from_user_input::Builder {
        crate::input::disassociate_phone_number_from_user_input::Builder::default()
    }
}

/// See [`DisassociatePhoneNumbersFromVoiceConnectorInput`](crate::input::DisassociatePhoneNumbersFromVoiceConnectorInput)
pub mod disassociate_phone_numbers_from_voice_connector_input {

    /// A builder for [`DisassociatePhoneNumbersFromVoiceConnectorInput`](crate::input::DisassociatePhoneNumbersFromVoiceConnectorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Appends an item to `e164_phone_numbers`.
        ///
        /// To override the contents of this collection use [`set_e164_phone_numbers`](Self::set_e164_phone_numbers).
        ///
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn e164_phone_numbers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.e164_phone_numbers.unwrap_or_default();
            v.push(input.into());
            self.e164_phone_numbers = Some(v);
            self
        }
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn set_e164_phone_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.e164_phone_numbers = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociatePhoneNumbersFromVoiceConnectorInput`](crate::input::DisassociatePhoneNumbersFromVoiceConnectorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociatePhoneNumbersFromVoiceConnectorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DisassociatePhoneNumbersFromVoiceConnectorInput {
                    voice_connector_id: self.voice_connector_id,
                    e164_phone_numbers: self.e164_phone_numbers,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DisassociatePhoneNumbersFromVoiceConnectorInputOperationOutputAlias =
    crate::operation::DisassociatePhoneNumbersFromVoiceConnector;
#[doc(hidden)]
pub type DisassociatePhoneNumbersFromVoiceConnectorInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DisassociatePhoneNumbersFromVoiceConnectorInput {
    /// Consumes the builder and constructs an Operation<[`DisassociatePhoneNumbersFromVoiceConnector`](crate::operation::DisassociatePhoneNumbersFromVoiceConnector)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociatePhoneNumbersFromVoiceConnector,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociatePhoneNumbersFromVoiceConnectorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_82 = &_input.voice_connector_id;
                let input_82 = input_82.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_82, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociatePhoneNumbersFromVoiceConnectorInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "disassociate-phone-numbers");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociatePhoneNumbersFromVoiceConnectorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_disassociate_phone_numbers_from_voice_connector(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociatePhoneNumbersFromVoiceConnector::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociatePhoneNumbersFromVoiceConnector",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociatePhoneNumbersFromVoiceConnectorInput`](crate::input::DisassociatePhoneNumbersFromVoiceConnectorInput)
    pub fn builder() -> crate::input::disassociate_phone_numbers_from_voice_connector_input::Builder
    {
        crate::input::disassociate_phone_numbers_from_voice_connector_input::Builder::default()
    }
}

/// See [`DisassociatePhoneNumbersFromVoiceConnectorGroupInput`](crate::input::DisassociatePhoneNumbersFromVoiceConnectorGroupInput)
pub mod disassociate_phone_numbers_from_voice_connector_group_input {

    /// A builder for [`DisassociatePhoneNumbersFromVoiceConnectorGroupInput`](crate::input::DisassociatePhoneNumbersFromVoiceConnectorGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_group_id: std::option::Option<std::string::String>,
        pub(crate) e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn voice_connector_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_group_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn set_voice_connector_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_group_id = input;
            self
        }
        /// Appends an item to `e164_phone_numbers`.
        ///
        /// To override the contents of this collection use [`set_e164_phone_numbers`](Self::set_e164_phone_numbers).
        ///
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn e164_phone_numbers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.e164_phone_numbers.unwrap_or_default();
            v.push(input.into());
            self.e164_phone_numbers = Some(v);
            self
        }
        /// <p>List of phone numbers, in E.164 format.</p>
        pub fn set_e164_phone_numbers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.e164_phone_numbers = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociatePhoneNumbersFromVoiceConnectorGroupInput`](crate::input::DisassociatePhoneNumbersFromVoiceConnectorGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociatePhoneNumbersFromVoiceConnectorGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DisassociatePhoneNumbersFromVoiceConnectorGroupInput {
                    voice_connector_group_id: self.voice_connector_group_id,
                    e164_phone_numbers: self.e164_phone_numbers,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DisassociatePhoneNumbersFromVoiceConnectorGroupInputOperationOutputAlias =
    crate::operation::DisassociatePhoneNumbersFromVoiceConnectorGroup;
#[doc(hidden)]
pub type DisassociatePhoneNumbersFromVoiceConnectorGroupInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DisassociatePhoneNumbersFromVoiceConnectorGroupInput {
    /// Consumes the builder and constructs an Operation<[`DisassociatePhoneNumbersFromVoiceConnectorGroup`](crate::operation::DisassociatePhoneNumbersFromVoiceConnectorGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociatePhoneNumbersFromVoiceConnectorGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociatePhoneNumbersFromVoiceConnectorGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_83 = &_input.voice_connector_group_id;
                let input_83 = input_83.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_group_id = aws_smithy_http::label::fmt_string(input_83, false);
                if voice_connector_group_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connector-groups/{VoiceConnectorGroupId}",
                    VoiceConnectorGroupId = voice_connector_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociatePhoneNumbersFromVoiceConnectorGroupInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "disassociate-phone-numbers");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociatePhoneNumbersFromVoiceConnectorGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_disassociate_phone_numbers_from_voice_connector_group(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociatePhoneNumbersFromVoiceConnectorGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociatePhoneNumbersFromVoiceConnectorGroup",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociatePhoneNumbersFromVoiceConnectorGroupInput`](crate::input::DisassociatePhoneNumbersFromVoiceConnectorGroupInput)
    pub fn builder(
    ) -> crate::input::disassociate_phone_numbers_from_voice_connector_group_input::Builder {
        crate::input::disassociate_phone_numbers_from_voice_connector_group_input::Builder::default(
        )
    }
}

/// See [`DisassociateSigninDelegateGroupsFromAccountInput`](crate::input::DisassociateSigninDelegateGroupsFromAccountInput)
pub mod disassociate_signin_delegate_groups_from_account_input {

    /// A builder for [`DisassociateSigninDelegateGroupsFromAccountInput`](crate::input::DisassociateSigninDelegateGroupsFromAccountInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) group_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Appends an item to `group_names`.
        ///
        /// To override the contents of this collection use [`set_group_names`](Self::set_group_names).
        ///
        /// <p>The sign-in delegate group names.</p>
        pub fn group_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.group_names.unwrap_or_default();
            v.push(input.into());
            self.group_names = Some(v);
            self
        }
        /// <p>The sign-in delegate group names.</p>
        pub fn set_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.group_names = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateSigninDelegateGroupsFromAccountInput`](crate::input::DisassociateSigninDelegateGroupsFromAccountInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateSigninDelegateGroupsFromAccountInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DisassociateSigninDelegateGroupsFromAccountInput {
                    account_id: self.account_id,
                    group_names: self.group_names,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DisassociateSigninDelegateGroupsFromAccountInputOperationOutputAlias =
    crate::operation::DisassociateSigninDelegateGroupsFromAccount;
#[doc(hidden)]
pub type DisassociateSigninDelegateGroupsFromAccountInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DisassociateSigninDelegateGroupsFromAccountInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateSigninDelegateGroupsFromAccount`](crate::operation::DisassociateSigninDelegateGroupsFromAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateSigninDelegateGroupsFromAccount,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateSigninDelegateGroupsFromAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_84 = &_input.account_id;
                let input_84 = input_84.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_84, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/accounts/{AccountId}", AccountId = account_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociateSigninDelegateGroupsFromAccountInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "disassociate-signin-delegate-groups");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateSigninDelegateGroupsFromAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_disassociate_signin_delegate_groups_from_account(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateSigninDelegateGroupsFromAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateSigninDelegateGroupsFromAccount",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociateSigninDelegateGroupsFromAccountInput`](crate::input::DisassociateSigninDelegateGroupsFromAccountInput)
    pub fn builder() -> crate::input::disassociate_signin_delegate_groups_from_account_input::Builder
    {
        crate::input::disassociate_signin_delegate_groups_from_account_input::Builder::default()
    }
}

/// See [`GetAccountInput`](crate::input::GetAccountInput)
pub mod get_account_input {

    /// A builder for [`GetAccountInput`](crate::input::GetAccountInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAccountInput`](crate::input::GetAccountInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetAccountInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetAccountInput {
                account_id: self.account_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAccountInputOperationOutputAlias = crate::operation::GetAccount;
#[doc(hidden)]
pub type GetAccountInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetAccountInput {
    /// Consumes the builder and constructs an Operation<[`GetAccount`](crate::operation::GetAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAccount,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_85 = &_input.account_id;
                let input_85 = input_85.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_85, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/accounts/{AccountId}", AccountId = account_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAccount",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAccountInput`](crate::input::GetAccountInput)
    pub fn builder() -> crate::input::get_account_input::Builder {
        crate::input::get_account_input::Builder::default()
    }
}

/// See [`GetAccountSettingsInput`](crate::input::GetAccountSettingsInput)
pub mod get_account_settings_input {

    /// A builder for [`GetAccountSettingsInput`](crate::input::GetAccountSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAccountSettingsInput`](crate::input::GetAccountSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetAccountSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetAccountSettingsInput {
                account_id: self.account_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAccountSettingsInputOperationOutputAlias = crate::operation::GetAccountSettings;
#[doc(hidden)]
pub type GetAccountSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetAccountSettingsInput {
    /// Consumes the builder and constructs an Operation<[`GetAccountSettings`](crate::operation::GetAccountSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAccountSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAccountSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_86 = &_input.account_id;
                let input_86 = input_86.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_86, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/settings",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAccountSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAccountSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAccountSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAccountSettingsInput`](crate::input::GetAccountSettingsInput)
    pub fn builder() -> crate::input::get_account_settings_input::Builder {
        crate::input::get_account_settings_input::Builder::default()
    }
}

/// See [`GetAppInstanceRetentionSettingsInput`](crate::input::GetAppInstanceRetentionSettingsInput)
pub mod get_app_instance_retention_settings_input {

    /// A builder for [`GetAppInstanceRetentionSettingsInput`](crate::input::GetAppInstanceRetentionSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAppInstanceRetentionSettingsInput`](crate::input::GetAppInstanceRetentionSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetAppInstanceRetentionSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetAppInstanceRetentionSettingsInput {
                app_instance_arn: self.app_instance_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAppInstanceRetentionSettingsInputOperationOutputAlias =
    crate::operation::GetAppInstanceRetentionSettings;
#[doc(hidden)]
pub type GetAppInstanceRetentionSettingsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetAppInstanceRetentionSettingsInput {
    /// Consumes the builder and constructs an Operation<[`GetAppInstanceRetentionSettings`](crate::operation::GetAppInstanceRetentionSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAppInstanceRetentionSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAppInstanceRetentionSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_87 = &_input.app_instance_arn;
                let input_87 = input_87.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_87, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}/retention-settings",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAppInstanceRetentionSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAppInstanceRetentionSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAppInstanceRetentionSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAppInstanceRetentionSettingsInput`](crate::input::GetAppInstanceRetentionSettingsInput)
    pub fn builder() -> crate::input::get_app_instance_retention_settings_input::Builder {
        crate::input::get_app_instance_retention_settings_input::Builder::default()
    }
}

/// See [`GetAppInstanceStreamingConfigurationsInput`](crate::input::GetAppInstanceStreamingConfigurationsInput)
pub mod get_app_instance_streaming_configurations_input {

    /// A builder for [`GetAppInstanceStreamingConfigurationsInput`](crate::input::GetAppInstanceStreamingConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAppInstanceStreamingConfigurationsInput`](crate::input::GetAppInstanceStreamingConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetAppInstanceStreamingConfigurationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetAppInstanceStreamingConfigurationsInput {
                app_instance_arn: self.app_instance_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAppInstanceStreamingConfigurationsInputOperationOutputAlias =
    crate::operation::GetAppInstanceStreamingConfigurations;
#[doc(hidden)]
pub type GetAppInstanceStreamingConfigurationsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetAppInstanceStreamingConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`GetAppInstanceStreamingConfigurations`](crate::operation::GetAppInstanceStreamingConfigurations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAppInstanceStreamingConfigurations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAppInstanceStreamingConfigurationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_88 = &_input.app_instance_arn;
                let input_88 = input_88.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_88, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}/streaming-configurations",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAppInstanceStreamingConfigurationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAppInstanceStreamingConfigurations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAppInstanceStreamingConfigurations",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAppInstanceStreamingConfigurationsInput`](crate::input::GetAppInstanceStreamingConfigurationsInput)
    pub fn builder() -> crate::input::get_app_instance_streaming_configurations_input::Builder {
        crate::input::get_app_instance_streaming_configurations_input::Builder::default()
    }
}

/// See [`GetAttendeeInput`](crate::input::GetAttendeeInput)
pub mod get_attendee_input {

    /// A builder for [`GetAttendeeInput`](crate::input::GetAttendeeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) attendee_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn attendee_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attendee_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn set_attendee_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attendee_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAttendeeInput`](crate::input::GetAttendeeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetAttendeeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetAttendeeInput {
                meeting_id: self.meeting_id,
                attendee_id: self.attendee_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAttendeeInputOperationOutputAlias = crate::operation::GetAttendee;
#[doc(hidden)]
pub type GetAttendeeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetAttendeeInput {
    /// Consumes the builder and constructs an Operation<[`GetAttendee`](crate::operation::GetAttendee)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAttendee,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAttendeeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_89 = &_input.meeting_id;
                let input_89 = input_89.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_89, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_90 = &_input.attendee_id;
                let input_90 = input_90.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let attendee_id = aws_smithy_http::label::fmt_string(input_90, false);
                if attendee_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/attendees/{AttendeeId}",
                    MeetingId = meeting_id,
                    AttendeeId = attendee_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAttendeeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAttendee::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAttendee",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAttendeeInput`](crate::input::GetAttendeeInput)
    pub fn builder() -> crate::input::get_attendee_input::Builder {
        crate::input::get_attendee_input::Builder::default()
    }
}

/// See [`GetBotInput`](crate::input::GetBotInput)
pub mod get_bot_input {

    /// A builder for [`GetBotInput`](crate::input::GetBotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) bot_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The bot ID.</p>
        pub fn bot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bot_id = Some(input.into());
            self
        }
        /// <p>The bot ID.</p>
        pub fn set_bot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bot_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBotInput`](crate::input::GetBotInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetBotInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetBotInput {
                account_id: self.account_id,
                bot_id: self.bot_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBotInputOperationOutputAlias = crate::operation::GetBot;
#[doc(hidden)]
pub type GetBotInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetBotInput {
    /// Consumes the builder and constructs an Operation<[`GetBot`](crate::operation::GetBot)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetBot,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetBotInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_91 = &_input.account_id;
                let input_91 = input_91.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_91, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_92 = &_input.bot_id;
                let input_92 = input_92.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let bot_id = aws_smithy_http::label::fmt_string(input_92, false);
                if bot_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/bots/{BotId}",
                    AccountId = account_id,
                    BotId = bot_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetBotInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetBot::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new("GetBot", "chime"));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetBotInput`](crate::input::GetBotInput)
    pub fn builder() -> crate::input::get_bot_input::Builder {
        crate::input::get_bot_input::Builder::default()
    }
}

/// See [`GetChannelMessageInput`](crate::input::GetChannelMessageInput)
pub mod get_channel_message_input {

    /// A builder for [`GetChannelMessageInput`](crate::input::GetChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ID of the message.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p>The ID of the message.</p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`GetChannelMessageInput`](crate::input::GetChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetChannelMessageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetChannelMessageInput {
                channel_arn: self.channel_arn,
                message_id: self.message_id,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type GetChannelMessageInputOperationOutputAlias = crate::operation::GetChannelMessage;
#[doc(hidden)]
pub type GetChannelMessageInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`GetChannelMessage`](crate::operation::GetChannelMessage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetChannelMessage,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetChannelMessageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_93 = &_input.channel_arn;
                let input_93 = input_93.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_93, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_94 = &_input.message_id;
                let input_94 = input_94.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let message_id = aws_smithy_http::label::fmt_string(input_94, false);
                if message_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/messages/{MessageId}",
                    ChannelArn = channel_arn,
                    MessageId = message_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetChannelMessageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_get_channel_message(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetChannelMessage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetChannelMessage",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetChannelMessageInput`](crate::input::GetChannelMessageInput)
    pub fn builder() -> crate::input::get_channel_message_input::Builder {
        crate::input::get_channel_message_input::Builder::default()
    }
}

/// See [`GetEventsConfigurationInput`](crate::input::GetEventsConfigurationInput)
pub mod get_events_configuration_input {

    /// A builder for [`GetEventsConfigurationInput`](crate::input::GetEventsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) bot_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The bot ID.</p>
        pub fn bot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bot_id = Some(input.into());
            self
        }
        /// <p>The bot ID.</p>
        pub fn set_bot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bot_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetEventsConfigurationInput`](crate::input::GetEventsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetEventsConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetEventsConfigurationInput {
                account_id: self.account_id,
                bot_id: self.bot_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetEventsConfigurationInputOperationOutputAlias = crate::operation::GetEventsConfiguration;
#[doc(hidden)]
pub type GetEventsConfigurationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetEventsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetEventsConfiguration`](crate::operation::GetEventsConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetEventsConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetEventsConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_95 = &_input.account_id;
                let input_95 = input_95.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_95, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_96 = &_input.bot_id;
                let input_96 = input_96.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let bot_id = aws_smithy_http::label::fmt_string(input_96, false);
                if bot_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/bots/{BotId}/events-configuration",
                    AccountId = account_id,
                    BotId = bot_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetEventsConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetEventsConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetEventsConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetEventsConfigurationInput`](crate::input::GetEventsConfigurationInput)
    pub fn builder() -> crate::input::get_events_configuration_input::Builder {
        crate::input::get_events_configuration_input::Builder::default()
    }
}

/// See [`GetGlobalSettingsInput`](crate::input::GetGlobalSettingsInput)
pub mod get_global_settings_input {

    /// A builder for [`GetGlobalSettingsInput`](crate::input::GetGlobalSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetGlobalSettingsInput`](crate::input::GetGlobalSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetGlobalSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetGlobalSettingsInput {})
        }
    }
}
#[doc(hidden)]
pub type GetGlobalSettingsInputOperationOutputAlias = crate::operation::GetGlobalSettings;
#[doc(hidden)]
pub type GetGlobalSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetGlobalSettingsInput {
    /// Consumes the builder and constructs an Operation<[`GetGlobalSettings`](crate::operation::GetGlobalSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetGlobalSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetGlobalSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/settings").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetGlobalSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetGlobalSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetGlobalSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetGlobalSettingsInput`](crate::input::GetGlobalSettingsInput)
    pub fn builder() -> crate::input::get_global_settings_input::Builder {
        crate::input::get_global_settings_input::Builder::default()
    }
}

/// See [`GetMediaCapturePipelineInput`](crate::input::GetMediaCapturePipelineInput)
pub mod get_media_capture_pipeline_input {

    /// A builder for [`GetMediaCapturePipelineInput`](crate::input::GetMediaCapturePipelineInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) media_pipeline_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the pipeline that you want to get.</p>
        pub fn media_pipeline_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_pipeline_id = Some(input.into());
            self
        }
        /// <p>The ID of the pipeline that you want to get.</p>
        pub fn set_media_pipeline_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.media_pipeline_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMediaCapturePipelineInput`](crate::input::GetMediaCapturePipelineInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMediaCapturePipelineInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMediaCapturePipelineInput {
                media_pipeline_id: self.media_pipeline_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetMediaCapturePipelineInputOperationOutputAlias =
    crate::operation::GetMediaCapturePipeline;
#[doc(hidden)]
pub type GetMediaCapturePipelineInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetMediaCapturePipelineInput {
    /// Consumes the builder and constructs an Operation<[`GetMediaCapturePipeline`](crate::operation::GetMediaCapturePipeline)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMediaCapturePipeline,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetMediaCapturePipelineInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_97 = &_input.media_pipeline_id;
                let input_97 = input_97.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "media_pipeline_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let media_pipeline_id = aws_smithy_http::label::fmt_string(input_97, false);
                if media_pipeline_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "media_pipeline_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/media-capture-pipelines/{MediaPipelineId}",
                    MediaPipelineId = media_pipeline_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetMediaCapturePipelineInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMediaCapturePipeline::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMediaCapturePipeline",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetMediaCapturePipelineInput`](crate::input::GetMediaCapturePipelineInput)
    pub fn builder() -> crate::input::get_media_capture_pipeline_input::Builder {
        crate::input::get_media_capture_pipeline_input::Builder::default()
    }
}

/// See [`GetMeetingInput`](crate::input::GetMeetingInput)
pub mod get_meeting_input {

    /// A builder for [`GetMeetingInput`](crate::input::GetMeetingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMeetingInput`](crate::input::GetMeetingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMeetingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMeetingInput {
                meeting_id: self.meeting_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetMeetingInputOperationOutputAlias = crate::operation::GetMeeting;
#[doc(hidden)]
pub type GetMeetingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetMeetingInput {
    /// Consumes the builder and constructs an Operation<[`GetMeeting`](crate::operation::GetMeeting)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMeeting,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetMeetingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_98 = &_input.meeting_id;
                let input_98 = input_98.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_98, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/meetings/{MeetingId}", MeetingId = meeting_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetMeetingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMeeting::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMeeting",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetMeetingInput`](crate::input::GetMeetingInput)
    pub fn builder() -> crate::input::get_meeting_input::Builder {
        crate::input::get_meeting_input::Builder::default()
    }
}

/// See [`GetMessagingSessionEndpointInput`](crate::input::GetMessagingSessionEndpointInput)
pub mod get_messaging_session_endpoint_input {

    /// A builder for [`GetMessagingSessionEndpointInput`](crate::input::GetMessagingSessionEndpointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetMessagingSessionEndpointInput`](crate::input::GetMessagingSessionEndpointInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMessagingSessionEndpointInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMessagingSessionEndpointInput {})
        }
    }
}
#[doc(hidden)]
pub type GetMessagingSessionEndpointInputOperationOutputAlias =
    crate::operation::GetMessagingSessionEndpoint;
#[doc(hidden)]
pub type GetMessagingSessionEndpointInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetMessagingSessionEndpointInput {
    /// Consumes the builder and constructs an Operation<[`GetMessagingSessionEndpoint`](crate::operation::GetMessagingSessionEndpoint)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMessagingSessionEndpoint,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetMessagingSessionEndpointInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/endpoints/messaging-session").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetMessagingSessionEndpointInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMessagingSessionEndpoint::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMessagingSessionEndpoint",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetMessagingSessionEndpointInput`](crate::input::GetMessagingSessionEndpointInput)
    pub fn builder() -> crate::input::get_messaging_session_endpoint_input::Builder {
        crate::input::get_messaging_session_endpoint_input::Builder::default()
    }
}

/// See [`GetPhoneNumberInput`](crate::input::GetPhoneNumberInput)
pub mod get_phone_number_input {

    /// A builder for [`GetPhoneNumberInput`](crate::input::GetPhoneNumberInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The phone number ID.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>The phone number ID.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPhoneNumberInput`](crate::input::GetPhoneNumberInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPhoneNumberInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPhoneNumberInput {
                phone_number_id: self.phone_number_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPhoneNumberInputOperationOutputAlias = crate::operation::GetPhoneNumber;
#[doc(hidden)]
pub type GetPhoneNumberInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetPhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`GetPhoneNumber`](crate::operation::GetPhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPhoneNumber,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetPhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_99 = &_input.phone_number_id;
                let input_99 = input_99.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let phone_number_id = aws_smithy_http::label::fmt_string(input_99, false);
                if phone_number_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/phone-numbers/{PhoneNumberId}",
                    PhoneNumberId = phone_number_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetPhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPhoneNumber",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetPhoneNumberInput`](crate::input::GetPhoneNumberInput)
    pub fn builder() -> crate::input::get_phone_number_input::Builder {
        crate::input::get_phone_number_input::Builder::default()
    }
}

/// See [`GetPhoneNumberOrderInput`](crate::input::GetPhoneNumberOrderInput)
pub mod get_phone_number_order_input {

    /// A builder for [`GetPhoneNumberOrderInput`](crate::input::GetPhoneNumberOrderInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_order_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID for the phone number order.</p>
        pub fn phone_number_order_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_order_id = Some(input.into());
            self
        }
        /// <p>The ID for the phone number order.</p>
        pub fn set_phone_number_order_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_order_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetPhoneNumberOrderInput`](crate::input::GetPhoneNumberOrderInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPhoneNumberOrderInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPhoneNumberOrderInput {
                phone_number_order_id: self.phone_number_order_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetPhoneNumberOrderInputOperationOutputAlias = crate::operation::GetPhoneNumberOrder;
#[doc(hidden)]
pub type GetPhoneNumberOrderInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetPhoneNumberOrderInput {
    /// Consumes the builder and constructs an Operation<[`GetPhoneNumberOrder`](crate::operation::GetPhoneNumberOrder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPhoneNumberOrder,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetPhoneNumberOrderInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_100 = &_input.phone_number_order_id;
                let input_100 = input_100.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_order_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let phone_number_order_id = aws_smithy_http::label::fmt_string(input_100, false);
                if phone_number_order_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_order_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/phone-number-orders/{PhoneNumberOrderId}",
                    PhoneNumberOrderId = phone_number_order_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetPhoneNumberOrderInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPhoneNumberOrder::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPhoneNumberOrder",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetPhoneNumberOrderInput`](crate::input::GetPhoneNumberOrderInput)
    pub fn builder() -> crate::input::get_phone_number_order_input::Builder {
        crate::input::get_phone_number_order_input::Builder::default()
    }
}

/// See [`GetPhoneNumberSettingsInput`](crate::input::GetPhoneNumberSettingsInput)
pub mod get_phone_number_settings_input {

    /// A builder for [`GetPhoneNumberSettingsInput`](crate::input::GetPhoneNumberSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetPhoneNumberSettingsInput`](crate::input::GetPhoneNumberSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetPhoneNumberSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetPhoneNumberSettingsInput {})
        }
    }
}
#[doc(hidden)]
pub type GetPhoneNumberSettingsInputOperationOutputAlias = crate::operation::GetPhoneNumberSettings;
#[doc(hidden)]
pub type GetPhoneNumberSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetPhoneNumberSettingsInput {
    /// Consumes the builder and constructs an Operation<[`GetPhoneNumberSettings`](crate::operation::GetPhoneNumberSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetPhoneNumberSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetPhoneNumberSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/settings/phone-number").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetPhoneNumberSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetPhoneNumberSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetPhoneNumberSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetPhoneNumberSettingsInput`](crate::input::GetPhoneNumberSettingsInput)
    pub fn builder() -> crate::input::get_phone_number_settings_input::Builder {
        crate::input::get_phone_number_settings_input::Builder::default()
    }
}

/// See [`GetProxySessionInput`](crate::input::GetProxySessionInput)
pub mod get_proxy_session_input {

    /// A builder for [`GetProxySessionInput`](crate::input::GetProxySessionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) proxy_session_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The proxy session ID.</p>
        pub fn proxy_session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.proxy_session_id = Some(input.into());
            self
        }
        /// <p>The proxy session ID.</p>
        pub fn set_proxy_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.proxy_session_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetProxySessionInput`](crate::input::GetProxySessionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetProxySessionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetProxySessionInput {
                voice_connector_id: self.voice_connector_id,
                proxy_session_id: self.proxy_session_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetProxySessionInputOperationOutputAlias = crate::operation::GetProxySession;
#[doc(hidden)]
pub type GetProxySessionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetProxySessionInput {
    /// Consumes the builder and constructs an Operation<[`GetProxySession`](crate::operation::GetProxySession)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetProxySession,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetProxySessionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_101 = &_input.voice_connector_id;
                let input_101 = input_101.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_101, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_102 = &_input.proxy_session_id;
                let input_102 = input_102.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "proxy_session_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let proxy_session_id = aws_smithy_http::label::fmt_string(input_102, false);
                if proxy_session_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "proxy_session_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/proxy-sessions/{ProxySessionId}",
                    VoiceConnectorId = voice_connector_id,
                    ProxySessionId = proxy_session_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetProxySessionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetProxySession::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetProxySession",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetProxySessionInput`](crate::input::GetProxySessionInput)
    pub fn builder() -> crate::input::get_proxy_session_input::Builder {
        crate::input::get_proxy_session_input::Builder::default()
    }
}

/// See [`GetRetentionSettingsInput`](crate::input::GetRetentionSettingsInput)
pub mod get_retention_settings_input {

    /// A builder for [`GetRetentionSettingsInput`](crate::input::GetRetentionSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRetentionSettingsInput`](crate::input::GetRetentionSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRetentionSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRetentionSettingsInput {
                account_id: self.account_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRetentionSettingsInputOperationOutputAlias = crate::operation::GetRetentionSettings;
#[doc(hidden)]
pub type GetRetentionSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetRetentionSettingsInput {
    /// Consumes the builder and constructs an Operation<[`GetRetentionSettings`](crate::operation::GetRetentionSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRetentionSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetRetentionSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_103 = &_input.account_id;
                let input_103 = input_103.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_103, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/retention-settings",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetRetentionSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRetentionSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRetentionSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetRetentionSettingsInput`](crate::input::GetRetentionSettingsInput)
    pub fn builder() -> crate::input::get_retention_settings_input::Builder {
        crate::input::get_retention_settings_input::Builder::default()
    }
}

/// See [`GetRoomInput`](crate::input::GetRoomInput)
pub mod get_room_input {

    /// A builder for [`GetRoomInput`](crate::input::GetRoomInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) room_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The room ID.</p>
        pub fn room_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.room_id = Some(input.into());
            self
        }
        /// <p>The room ID.</p>
        pub fn set_room_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.room_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRoomInput`](crate::input::GetRoomInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetRoomInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetRoomInput {
                account_id: self.account_id,
                room_id: self.room_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRoomInputOperationOutputAlias = crate::operation::GetRoom;
#[doc(hidden)]
pub type GetRoomInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetRoomInput {
    /// Consumes the builder and constructs an Operation<[`GetRoom`](crate::operation::GetRoom)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRoom,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetRoomInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_104 = &_input.account_id;
                let input_104 = input_104.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_104, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_105 = &_input.room_id;
                let input_105 = input_105.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let room_id = aws_smithy_http::label::fmt_string(input_105, false);
                if room_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms/{RoomId}",
                    AccountId = account_id,
                    RoomId = room_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetRoomInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetRoom::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetRoom", "chime",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetRoomInput`](crate::input::GetRoomInput)
    pub fn builder() -> crate::input::get_room_input::Builder {
        crate::input::get_room_input::Builder::default()
    }
}

/// See [`GetSipMediaApplicationInput`](crate::input::GetSipMediaApplicationInput)
pub mod get_sip_media_application_input {

    /// A builder for [`GetSipMediaApplicationInput`](crate::input::GetSipMediaApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The SIP media application ID.</p>
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        /// <p>The SIP media application ID.</p>
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSipMediaApplicationInput`](crate::input::GetSipMediaApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetSipMediaApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetSipMediaApplicationInput {
                sip_media_application_id: self.sip_media_application_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetSipMediaApplicationInputOperationOutputAlias = crate::operation::GetSipMediaApplication;
#[doc(hidden)]
pub type GetSipMediaApplicationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetSipMediaApplicationInput {
    /// Consumes the builder and constructs an Operation<[`GetSipMediaApplication`](crate::operation::GetSipMediaApplication)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSipMediaApplication,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSipMediaApplicationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_106 = &_input.sip_media_application_id;
                let input_106 = input_106.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_media_application_id = aws_smithy_http::label::fmt_string(input_106, false);
                if sip_media_application_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/sip-media-applications/{SipMediaApplicationId}",
                    SipMediaApplicationId = sip_media_application_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSipMediaApplicationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSipMediaApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSipMediaApplication",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSipMediaApplicationInput`](crate::input::GetSipMediaApplicationInput)
    pub fn builder() -> crate::input::get_sip_media_application_input::Builder {
        crate::input::get_sip_media_application_input::Builder::default()
    }
}

/// See [`GetSipMediaApplicationLoggingConfigurationInput`](crate::input::GetSipMediaApplicationLoggingConfigurationInput)
pub mod get_sip_media_application_logging_configuration_input {

    /// A builder for [`GetSipMediaApplicationLoggingConfigurationInput`](crate::input::GetSipMediaApplicationLoggingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The SIP media application ID.</p>
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        /// <p>The SIP media application ID.</p>
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSipMediaApplicationLoggingConfigurationInput`](crate::input::GetSipMediaApplicationLoggingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetSipMediaApplicationLoggingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::GetSipMediaApplicationLoggingConfigurationInput {
                    sip_media_application_id: self.sip_media_application_id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type GetSipMediaApplicationLoggingConfigurationInputOperationOutputAlias =
    crate::operation::GetSipMediaApplicationLoggingConfiguration;
#[doc(hidden)]
pub type GetSipMediaApplicationLoggingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetSipMediaApplicationLoggingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetSipMediaApplicationLoggingConfiguration`](crate::operation::GetSipMediaApplicationLoggingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSipMediaApplicationLoggingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSipMediaApplicationLoggingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_107 = &_input.sip_media_application_id;
                let input_107 = input_107.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_media_application_id = aws_smithy_http::label::fmt_string(input_107, false);
                if sip_media_application_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/sip-media-applications/{SipMediaApplicationId}/logging-configuration",
                    SipMediaApplicationId = sip_media_application_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSipMediaApplicationLoggingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSipMediaApplicationLoggingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSipMediaApplicationLoggingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSipMediaApplicationLoggingConfigurationInput`](crate::input::GetSipMediaApplicationLoggingConfigurationInput)
    pub fn builder() -> crate::input::get_sip_media_application_logging_configuration_input::Builder
    {
        crate::input::get_sip_media_application_logging_configuration_input::Builder::default()
    }
}

/// See [`GetSipRuleInput`](crate::input::GetSipRuleInput)
pub mod get_sip_rule_input {

    /// A builder for [`GetSipRuleInput`](crate::input::GetSipRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_rule_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The SIP rule ID.</p>
        pub fn sip_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_rule_id = Some(input.into());
            self
        }
        /// <p>The SIP rule ID.</p>
        pub fn set_sip_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sip_rule_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSipRuleInput`](crate::input::GetSipRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetSipRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetSipRuleInput {
                sip_rule_id: self.sip_rule_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetSipRuleInputOperationOutputAlias = crate::operation::GetSipRule;
#[doc(hidden)]
pub type GetSipRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetSipRuleInput {
    /// Consumes the builder and constructs an Operation<[`GetSipRule`](crate::operation::GetSipRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSipRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSipRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_108 = &_input.sip_rule_id;
                let input_108 = input_108.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_rule_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_rule_id = aws_smithy_http::label::fmt_string(input_108, false);
                if sip_rule_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_rule_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/sip-rules/{SipRuleId}", SipRuleId = sip_rule_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSipRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSipRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSipRule",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSipRuleInput`](crate::input::GetSipRuleInput)
    pub fn builder() -> crate::input::get_sip_rule_input::Builder {
        crate::input::get_sip_rule_input::Builder::default()
    }
}

/// See [`GetUserInput`](crate::input::GetUserInput)
pub mod get_user_input {

    /// A builder for [`GetUserInput`](crate::input::GetUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The user ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The user ID.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetUserInput`](crate::input::GetUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetUserInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetUserInput {
                account_id: self.account_id,
                user_id: self.user_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetUserInputOperationOutputAlias = crate::operation::GetUser;
#[doc(hidden)]
pub type GetUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetUserInput {
    /// Consumes the builder and constructs an Operation<[`GetUser`](crate::operation::GetUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_109 = &_input.account_id;
                let input_109 = input_109.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_109, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_110 = &_input.user_id;
                let input_110 = input_110.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let user_id = aws_smithy_http::label::fmt_string(input_110, false);
                if user_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users/{UserId}",
                    AccountId = account_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetUser::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetUser", "chime",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetUserInput`](crate::input::GetUserInput)
    pub fn builder() -> crate::input::get_user_input::Builder {
        crate::input::get_user_input::Builder::default()
    }
}

/// See [`GetUserSettingsInput`](crate::input::GetUserSettingsInput)
pub mod get_user_settings_input {

    /// A builder for [`GetUserSettingsInput`](crate::input::GetUserSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The user ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The user ID.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetUserSettingsInput`](crate::input::GetUserSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetUserSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetUserSettingsInput {
                account_id: self.account_id,
                user_id: self.user_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetUserSettingsInputOperationOutputAlias = crate::operation::GetUserSettings;
#[doc(hidden)]
pub type GetUserSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetUserSettingsInput {
    /// Consumes the builder and constructs an Operation<[`GetUserSettings`](crate::operation::GetUserSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetUserSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetUserSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_111 = &_input.account_id;
                let input_111 = input_111.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_111, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_112 = &_input.user_id;
                let input_112 = input_112.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let user_id = aws_smithy_http::label::fmt_string(input_112, false);
                if user_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users/{UserId}/settings",
                    AccountId = account_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetUserSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetUserSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetUserSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetUserSettingsInput`](crate::input::GetUserSettingsInput)
    pub fn builder() -> crate::input::get_user_settings_input::Builder {
        crate::input::get_user_settings_input::Builder::default()
    }
}

/// See [`GetVoiceConnectorInput`](crate::input::GetVoiceConnectorInput)
pub mod get_voice_connector_input {

    /// A builder for [`GetVoiceConnectorInput`](crate::input::GetVoiceConnectorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVoiceConnectorInput`](crate::input::GetVoiceConnectorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVoiceConnectorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVoiceConnectorInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVoiceConnectorInputOperationOutputAlias = crate::operation::GetVoiceConnector;
#[doc(hidden)]
pub type GetVoiceConnectorInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetVoiceConnectorInput {
    /// Consumes the builder and constructs an Operation<[`GetVoiceConnector`](crate::operation::GetVoiceConnector)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVoiceConnector,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVoiceConnectorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_113 = &_input.voice_connector_id;
                let input_113 = input_113.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_113, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVoiceConnectorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVoiceConnector::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVoiceConnector",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVoiceConnectorInput`](crate::input::GetVoiceConnectorInput)
    pub fn builder() -> crate::input::get_voice_connector_input::Builder {
        crate::input::get_voice_connector_input::Builder::default()
    }
}

/// See [`GetVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::GetVoiceConnectorEmergencyCallingConfigurationInput)
pub mod get_voice_connector_emergency_calling_configuration_input {

    /// A builder for [`GetVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::GetVoiceConnectorEmergencyCallingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::GetVoiceConnectorEmergencyCallingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVoiceConnectorEmergencyCallingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::GetVoiceConnectorEmergencyCallingConfigurationInput {
                    voice_connector_id: self.voice_connector_id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type GetVoiceConnectorEmergencyCallingConfigurationInputOperationOutputAlias =
    crate::operation::GetVoiceConnectorEmergencyCallingConfiguration;
#[doc(hidden)]
pub type GetVoiceConnectorEmergencyCallingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetVoiceConnectorEmergencyCallingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetVoiceConnectorEmergencyCallingConfiguration`](crate::operation::GetVoiceConnectorEmergencyCallingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVoiceConnectorEmergencyCallingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVoiceConnectorEmergencyCallingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_114 = &_input.voice_connector_id;
                let input_114 = input_114.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_114, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/emergency-calling-configuration",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVoiceConnectorEmergencyCallingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVoiceConnectorEmergencyCallingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVoiceConnectorEmergencyCallingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::GetVoiceConnectorEmergencyCallingConfigurationInput)
    pub fn builder(
    ) -> crate::input::get_voice_connector_emergency_calling_configuration_input::Builder {
        crate::input::get_voice_connector_emergency_calling_configuration_input::Builder::default()
    }
}

/// See [`GetVoiceConnectorGroupInput`](crate::input::GetVoiceConnectorGroupInput)
pub mod get_voice_connector_group_input {

    /// A builder for [`GetVoiceConnectorGroupInput`](crate::input::GetVoiceConnectorGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn voice_connector_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_group_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn set_voice_connector_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVoiceConnectorGroupInput`](crate::input::GetVoiceConnectorGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVoiceConnectorGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVoiceConnectorGroupInput {
                voice_connector_group_id: self.voice_connector_group_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVoiceConnectorGroupInputOperationOutputAlias = crate::operation::GetVoiceConnectorGroup;
#[doc(hidden)]
pub type GetVoiceConnectorGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetVoiceConnectorGroupInput {
    /// Consumes the builder and constructs an Operation<[`GetVoiceConnectorGroup`](crate::operation::GetVoiceConnectorGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVoiceConnectorGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVoiceConnectorGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_115 = &_input.voice_connector_group_id;
                let input_115 = input_115.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_group_id = aws_smithy_http::label::fmt_string(input_115, false);
                if voice_connector_group_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connector-groups/{VoiceConnectorGroupId}",
                    VoiceConnectorGroupId = voice_connector_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVoiceConnectorGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVoiceConnectorGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVoiceConnectorGroup",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVoiceConnectorGroupInput`](crate::input::GetVoiceConnectorGroupInput)
    pub fn builder() -> crate::input::get_voice_connector_group_input::Builder {
        crate::input::get_voice_connector_group_input::Builder::default()
    }
}

/// See [`GetVoiceConnectorLoggingConfigurationInput`](crate::input::GetVoiceConnectorLoggingConfigurationInput)
pub mod get_voice_connector_logging_configuration_input {

    /// A builder for [`GetVoiceConnectorLoggingConfigurationInput`](crate::input::GetVoiceConnectorLoggingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVoiceConnectorLoggingConfigurationInput`](crate::input::GetVoiceConnectorLoggingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVoiceConnectorLoggingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVoiceConnectorLoggingConfigurationInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVoiceConnectorLoggingConfigurationInputOperationOutputAlias =
    crate::operation::GetVoiceConnectorLoggingConfiguration;
#[doc(hidden)]
pub type GetVoiceConnectorLoggingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetVoiceConnectorLoggingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetVoiceConnectorLoggingConfiguration`](crate::operation::GetVoiceConnectorLoggingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVoiceConnectorLoggingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVoiceConnectorLoggingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_116 = &_input.voice_connector_id;
                let input_116 = input_116.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_116, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/logging-configuration",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVoiceConnectorLoggingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVoiceConnectorLoggingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVoiceConnectorLoggingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVoiceConnectorLoggingConfigurationInput`](crate::input::GetVoiceConnectorLoggingConfigurationInput)
    pub fn builder() -> crate::input::get_voice_connector_logging_configuration_input::Builder {
        crate::input::get_voice_connector_logging_configuration_input::Builder::default()
    }
}

/// See [`GetVoiceConnectorOriginationInput`](crate::input::GetVoiceConnectorOriginationInput)
pub mod get_voice_connector_origination_input {

    /// A builder for [`GetVoiceConnectorOriginationInput`](crate::input::GetVoiceConnectorOriginationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVoiceConnectorOriginationInput`](crate::input::GetVoiceConnectorOriginationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVoiceConnectorOriginationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVoiceConnectorOriginationInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVoiceConnectorOriginationInputOperationOutputAlias =
    crate::operation::GetVoiceConnectorOrigination;
#[doc(hidden)]
pub type GetVoiceConnectorOriginationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetVoiceConnectorOriginationInput {
    /// Consumes the builder and constructs an Operation<[`GetVoiceConnectorOrigination`](crate::operation::GetVoiceConnectorOrigination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVoiceConnectorOrigination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVoiceConnectorOriginationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_117 = &_input.voice_connector_id;
                let input_117 = input_117.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_117, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/origination",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVoiceConnectorOriginationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVoiceConnectorOrigination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVoiceConnectorOrigination",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVoiceConnectorOriginationInput`](crate::input::GetVoiceConnectorOriginationInput)
    pub fn builder() -> crate::input::get_voice_connector_origination_input::Builder {
        crate::input::get_voice_connector_origination_input::Builder::default()
    }
}

/// See [`GetVoiceConnectorProxyInput`](crate::input::GetVoiceConnectorProxyInput)
pub mod get_voice_connector_proxy_input {

    /// A builder for [`GetVoiceConnectorProxyInput`](crate::input::GetVoiceConnectorProxyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVoiceConnectorProxyInput`](crate::input::GetVoiceConnectorProxyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVoiceConnectorProxyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVoiceConnectorProxyInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVoiceConnectorProxyInputOperationOutputAlias = crate::operation::GetVoiceConnectorProxy;
#[doc(hidden)]
pub type GetVoiceConnectorProxyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetVoiceConnectorProxyInput {
    /// Consumes the builder and constructs an Operation<[`GetVoiceConnectorProxy`](crate::operation::GetVoiceConnectorProxy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVoiceConnectorProxy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVoiceConnectorProxyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_118 = &_input.voice_connector_id;
                let input_118 = input_118.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_118, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/programmable-numbers/proxy",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVoiceConnectorProxyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVoiceConnectorProxy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVoiceConnectorProxy",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVoiceConnectorProxyInput`](crate::input::GetVoiceConnectorProxyInput)
    pub fn builder() -> crate::input::get_voice_connector_proxy_input::Builder {
        crate::input::get_voice_connector_proxy_input::Builder::default()
    }
}

/// See [`GetVoiceConnectorStreamingConfigurationInput`](crate::input::GetVoiceConnectorStreamingConfigurationInput)
pub mod get_voice_connector_streaming_configuration_input {

    /// A builder for [`GetVoiceConnectorStreamingConfigurationInput`](crate::input::GetVoiceConnectorStreamingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVoiceConnectorStreamingConfigurationInput`](crate::input::GetVoiceConnectorStreamingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVoiceConnectorStreamingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVoiceConnectorStreamingConfigurationInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVoiceConnectorStreamingConfigurationInputOperationOutputAlias =
    crate::operation::GetVoiceConnectorStreamingConfiguration;
#[doc(hidden)]
pub type GetVoiceConnectorStreamingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetVoiceConnectorStreamingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetVoiceConnectorStreamingConfiguration`](crate::operation::GetVoiceConnectorStreamingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVoiceConnectorStreamingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVoiceConnectorStreamingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_119 = &_input.voice_connector_id;
                let input_119 = input_119.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_119, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/streaming-configuration",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVoiceConnectorStreamingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVoiceConnectorStreamingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVoiceConnectorStreamingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVoiceConnectorStreamingConfigurationInput`](crate::input::GetVoiceConnectorStreamingConfigurationInput)
    pub fn builder() -> crate::input::get_voice_connector_streaming_configuration_input::Builder {
        crate::input::get_voice_connector_streaming_configuration_input::Builder::default()
    }
}

/// See [`GetVoiceConnectorTerminationInput`](crate::input::GetVoiceConnectorTerminationInput)
pub mod get_voice_connector_termination_input {

    /// A builder for [`GetVoiceConnectorTerminationInput`](crate::input::GetVoiceConnectorTerminationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVoiceConnectorTerminationInput`](crate::input::GetVoiceConnectorTerminationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVoiceConnectorTerminationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVoiceConnectorTerminationInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVoiceConnectorTerminationInputOperationOutputAlias =
    crate::operation::GetVoiceConnectorTermination;
#[doc(hidden)]
pub type GetVoiceConnectorTerminationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetVoiceConnectorTerminationInput {
    /// Consumes the builder and constructs an Operation<[`GetVoiceConnectorTermination`](crate::operation::GetVoiceConnectorTermination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVoiceConnectorTermination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVoiceConnectorTerminationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_120 = &_input.voice_connector_id;
                let input_120 = input_120.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_120, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/termination",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVoiceConnectorTerminationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVoiceConnectorTermination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVoiceConnectorTermination",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVoiceConnectorTerminationInput`](crate::input::GetVoiceConnectorTerminationInput)
    pub fn builder() -> crate::input::get_voice_connector_termination_input::Builder {
        crate::input::get_voice_connector_termination_input::Builder::default()
    }
}

/// See [`GetVoiceConnectorTerminationHealthInput`](crate::input::GetVoiceConnectorTerminationHealthInput)
pub mod get_voice_connector_termination_health_input {

    /// A builder for [`GetVoiceConnectorTerminationHealthInput`](crate::input::GetVoiceConnectorTerminationHealthInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVoiceConnectorTerminationHealthInput`](crate::input::GetVoiceConnectorTerminationHealthInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVoiceConnectorTerminationHealthInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVoiceConnectorTerminationHealthInput {
                voice_connector_id: self.voice_connector_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVoiceConnectorTerminationHealthInputOperationOutputAlias =
    crate::operation::GetVoiceConnectorTerminationHealth;
#[doc(hidden)]
pub type GetVoiceConnectorTerminationHealthInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetVoiceConnectorTerminationHealthInput {
    /// Consumes the builder and constructs an Operation<[`GetVoiceConnectorTerminationHealth`](crate::operation::GetVoiceConnectorTerminationHealth)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVoiceConnectorTerminationHealth,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVoiceConnectorTerminationHealthInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_121 = &_input.voice_connector_id;
                let input_121 = input_121.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_121, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/termination/health",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVoiceConnectorTerminationHealthInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVoiceConnectorTerminationHealth::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVoiceConnectorTerminationHealth",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetVoiceConnectorTerminationHealthInput`](crate::input::GetVoiceConnectorTerminationHealthInput)
    pub fn builder() -> crate::input::get_voice_connector_termination_health_input::Builder {
        crate::input::get_voice_connector_termination_health_input::Builder::default()
    }
}

/// See [`InviteUsersInput`](crate::input::InviteUsersInput)
pub mod invite_users_input {

    /// A builder for [`InviteUsersInput`](crate::input::InviteUsersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_email_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) user_type: std::option::Option<crate::model::UserType>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Appends an item to `user_email_list`.
        ///
        /// To override the contents of this collection use [`set_user_email_list`](Self::set_user_email_list).
        ///
        /// <p>The user email addresses to which to send the email invitation.</p>
        pub fn user_email_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.user_email_list.unwrap_or_default();
            v.push(input.into());
            self.user_email_list = Some(v);
            self
        }
        /// <p>The user email addresses to which to send the email invitation.</p>
        pub fn set_user_email_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.user_email_list = input;
            self
        }
        /// <p>The user type.</p>
        pub fn user_type(mut self, input: crate::model::UserType) -> Self {
            self.user_type = Some(input);
            self
        }
        /// <p>The user type.</p>
        pub fn set_user_type(mut self, input: std::option::Option<crate::model::UserType>) -> Self {
            self.user_type = input;
            self
        }
        /// Consumes the builder and constructs a [`InviteUsersInput`](crate::input::InviteUsersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::InviteUsersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::InviteUsersInput {
                account_id: self.account_id,
                user_email_list: self.user_email_list,
                user_type: self.user_type,
            })
        }
    }
}
#[doc(hidden)]
pub type InviteUsersInputOperationOutputAlias = crate::operation::InviteUsers;
#[doc(hidden)]
pub type InviteUsersInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl InviteUsersInput {
    /// Consumes the builder and constructs an Operation<[`InviteUsers`](crate::operation::InviteUsers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::InviteUsers,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::InviteUsersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_122 = &_input.account_id;
                let input_122 = input_122.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_122, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::InviteUsersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "add");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::InviteUsersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_invite_users(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::InviteUsers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "InviteUsers",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`InviteUsersInput`](crate::input::InviteUsersInput)
    pub fn builder() -> crate::input::invite_users_input::Builder {
        crate::input::invite_users_input::Builder::default()
    }
}

/// See [`ListAccountsInput`](crate::input::ListAccountsInput)
pub mod list_accounts_input {

    /// A builder for [`ListAccountsInput`](crate::input::ListAccountsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) user_email: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Amazon Chime account name prefix with which to filter results.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Amazon Chime account name prefix with which to filter results.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>User email address with which to filter results.</p>
        pub fn user_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_email = Some(input.into());
            self
        }
        /// <p>User email address with which to filter results.</p>
        pub fn set_user_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_email = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAccountsInput`](crate::input::ListAccountsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAccountsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAccountsInput {
                name: self.name,
                user_email: self.user_email,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAccountsInputOperationOutputAlias = crate::operation::ListAccounts;
#[doc(hidden)]
pub type ListAccountsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAccountsInput {
    /// Consumes the builder and constructs an Operation<[`ListAccounts`](crate::operation::ListAccounts)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAccounts,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAccountsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/accounts").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAccountsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_123) = &_input.name {
                    query.push_kv("name", &aws_smithy_http::query::fmt_string(&inner_123));
                }
                if let Some(inner_124) = &_input.user_email {
                    query.push_kv(
                        "user-email",
                        &aws_smithy_http::query::fmt_string(&inner_124),
                    );
                }
                if let Some(inner_125) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_125),
                    );
                }
                if let Some(inner_126) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_126).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAccountsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAccounts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAccounts",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAccountsInput`](crate::input::ListAccountsInput)
    pub fn builder() -> crate::input::list_accounts_input::Builder {
        crate::input::list_accounts_input::Builder::default()
    }
}

/// See [`ListAppInstanceAdminsInput`](crate::input::ListAppInstanceAdminsInput)
pub mod list_app_instance_admins_input {

    /// A builder for [`ListAppInstanceAdminsInput`](crate::input::ListAppInstanceAdminsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// <p>The maximum number of administrators that you want to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of administrators that you want to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token returned from previous API requests until the number of administrators is reached.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token returned from previous API requests until the number of administrators is reached.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAppInstanceAdminsInput`](crate::input::ListAppInstanceAdminsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAppInstanceAdminsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAppInstanceAdminsInput {
                app_instance_arn: self.app_instance_arn,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAppInstanceAdminsInputOperationOutputAlias = crate::operation::ListAppInstanceAdmins;
#[doc(hidden)]
pub type ListAppInstanceAdminsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAppInstanceAdminsInput {
    /// Consumes the builder and constructs an Operation<[`ListAppInstanceAdmins`](crate::operation::ListAppInstanceAdmins)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAppInstanceAdmins,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAppInstanceAdminsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_127 = &_input.app_instance_arn;
                let input_127 = input_127.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_127, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}/admins",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAppInstanceAdminsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_128) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_128).encode(),
                    );
                }
                if let Some(inner_129) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_129),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAppInstanceAdminsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAppInstanceAdmins::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAppInstanceAdmins",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAppInstanceAdminsInput`](crate::input::ListAppInstanceAdminsInput)
    pub fn builder() -> crate::input::list_app_instance_admins_input::Builder {
        crate::input::list_app_instance_admins_input::Builder::default()
    }
}

/// See [`ListAppInstancesInput`](crate::input::ListAppInstancesInput)
pub mod list_app_instances_input {

    /// A builder for [`ListAppInstancesInput`](crate::input::ListAppInstancesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of <code>AppInstance</code>s that you want to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of <code>AppInstance</code>s that you want to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API requests until you reach the maximum number of <code>AppInstance</code>s.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token passed by previous API requests until you reach the maximum number of <code>AppInstance</code>s.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAppInstancesInput`](crate::input::ListAppInstancesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAppInstancesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAppInstancesInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAppInstancesInputOperationOutputAlias = crate::operation::ListAppInstances;
#[doc(hidden)]
pub type ListAppInstancesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAppInstancesInput {
    /// Consumes the builder and constructs an Operation<[`ListAppInstances`](crate::operation::ListAppInstances)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAppInstances,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAppInstancesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/app-instances").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAppInstancesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_130) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_130).encode(),
                    );
                }
                if let Some(inner_131) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_131),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAppInstancesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAppInstances::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAppInstances",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAppInstancesInput`](crate::input::ListAppInstancesInput)
    pub fn builder() -> crate::input::list_app_instances_input::Builder {
        crate::input::list_app_instances_input::Builder::default()
    }
}

/// See [`ListAppInstanceUsersInput`](crate::input::ListAppInstanceUsersInput)
pub mod list_app_instance_users_input {

    /// A builder for [`ListAppInstanceUsersInput`](crate::input::ListAppInstanceUsersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// <p>The maximum number of requests that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of requests that you want returned.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested users are returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token passed by previous API calls until all requested users are returned.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAppInstanceUsersInput`](crate::input::ListAppInstanceUsersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAppInstanceUsersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAppInstanceUsersInput {
                app_instance_arn: self.app_instance_arn,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAppInstanceUsersInputOperationOutputAlias = crate::operation::ListAppInstanceUsers;
#[doc(hidden)]
pub type ListAppInstanceUsersInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAppInstanceUsersInput {
    /// Consumes the builder and constructs an Operation<[`ListAppInstanceUsers`](crate::operation::ListAppInstanceUsers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAppInstanceUsers,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAppInstanceUsersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/app-instance-users").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAppInstanceUsersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_132) = &_input.app_instance_arn {
                    query.push_kv(
                        "app-instance-arn",
                        &aws_smithy_http::query::fmt_string(&inner_132),
                    );
                }
                if let Some(inner_133) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_133).encode(),
                    );
                }
                if let Some(inner_134) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_134),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAppInstanceUsersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAppInstanceUsers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAppInstanceUsers",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAppInstanceUsersInput`](crate::input::ListAppInstanceUsersInput)
    pub fn builder() -> crate::input::list_app_instance_users_input::Builder {
        crate::input::list_app_instance_users_input::Builder::default()
    }
}

/// See [`ListAttendeesInput`](crate::input::ListAttendeesInput)
pub mod list_attendees_input {

    /// A builder for [`ListAttendeesInput`](crate::input::ListAttendeesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAttendeesInput`](crate::input::ListAttendeesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAttendeesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAttendeesInput {
                meeting_id: self.meeting_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAttendeesInputOperationOutputAlias = crate::operation::ListAttendees;
#[doc(hidden)]
pub type ListAttendeesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAttendeesInput {
    /// Consumes the builder and constructs an Operation<[`ListAttendees`](crate::operation::ListAttendees)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAttendees,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAttendeesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_135 = &_input.meeting_id;
                let input_135 = input_135.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_135, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/attendees",
                    MeetingId = meeting_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAttendeesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_136) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_136),
                    );
                }
                if let Some(inner_137) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_137).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAttendeesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAttendees::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAttendees",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAttendeesInput`](crate::input::ListAttendeesInput)
    pub fn builder() -> crate::input::list_attendees_input::Builder {
        crate::input::list_attendees_input::Builder::default()
    }
}

/// See [`ListAttendeeTagsInput`](crate::input::ListAttendeeTagsInput)
pub mod list_attendee_tags_input {

    /// A builder for [`ListAttendeeTagsInput`](crate::input::ListAttendeeTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) attendee_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn attendee_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attendee_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn set_attendee_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attendee_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAttendeeTagsInput`](crate::input::ListAttendeeTagsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAttendeeTagsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAttendeeTagsInput {
                meeting_id: self.meeting_id,
                attendee_id: self.attendee_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAttendeeTagsInputOperationOutputAlias = crate::operation::ListAttendeeTags;
#[doc(hidden)]
pub type ListAttendeeTagsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAttendeeTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListAttendeeTags`](crate::operation::ListAttendeeTags)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAttendeeTags,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAttendeeTagsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_138 = &_input.meeting_id;
                let input_138 = input_138.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_138, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_139 = &_input.attendee_id;
                let input_139 = input_139.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let attendee_id = aws_smithy_http::label::fmt_string(input_139, false);
                if attendee_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/attendees/{AttendeeId}/tags",
                    MeetingId = meeting_id,
                    AttendeeId = attendee_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAttendeeTagsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAttendeeTags::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAttendeeTags",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAttendeeTagsInput`](crate::input::ListAttendeeTagsInput)
    pub fn builder() -> crate::input::list_attendee_tags_input::Builder {
        crate::input::list_attendee_tags_input::Builder::default()
    }
}

/// See [`ListBotsInput`](crate::input::ListBotsInput)
pub mod list_bots_input {

    /// A builder for [`ListBotsInput`](crate::input::ListBotsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The maximum number of results to return in a single call. The default is 10.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. The default is 10.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBotsInput`](crate::input::ListBotsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListBotsInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListBotsInput {
                account_id: self.account_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListBotsInputOperationOutputAlias = crate::operation::ListBots;
#[doc(hidden)]
pub type ListBotsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListBotsInput {
    /// Consumes the builder and constructs an Operation<[`ListBots`](crate::operation::ListBots)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListBots,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListBotsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_140 = &_input.account_id;
                let input_140 = input_140.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_140, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/accounts/{AccountId}/bots", AccountId = account_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListBotsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_141) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_141).encode(),
                    );
                }
                if let Some(inner_142) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_142),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListBotsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::ListBots::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "ListBots", "chime",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListBotsInput`](crate::input::ListBotsInput)
    pub fn builder() -> crate::input::list_bots_input::Builder {
        crate::input::list_bots_input::Builder::default()
    }
}

/// See [`ListChannelBansInput`](crate::input::ListChannelBansInput)
pub mod list_channel_bans_input {

    /// A builder for [`ListChannelBansInput`](crate::input::ListChannelBansInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The maximum number of bans that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of bans that you want returned.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested bans are returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token passed by previous API calls until all requested bans are returned.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelBansInput`](crate::input::ListChannelBansInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelBansInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelBansInput {
                channel_arn: self.channel_arn,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelBansInputOperationOutputAlias = crate::operation::ListChannelBans;
#[doc(hidden)]
pub type ListChannelBansInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListChannelBansInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelBans`](crate::operation::ListChannelBans)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListChannelBans,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListChannelBansInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_143 = &_input.channel_arn;
                let input_143 = input_143.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_143, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/bans",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListChannelBansInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_144) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_144).encode(),
                    );
                }
                if let Some(inner_145) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_145),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListChannelBansInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_list_channel_bans(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelBans::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListChannelBans",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListChannelBansInput`](crate::input::ListChannelBansInput)
    pub fn builder() -> crate::input::list_channel_bans_input::Builder {
        crate::input::list_channel_bans_input::Builder::default()
    }
}

/// See [`ListChannelMembershipsInput`](crate::input::ListChannelMembershipsInput)
pub mod list_channel_memberships_input {

    /// A builder for [`ListChannelMembershipsInput`](crate::input::ListChannelMembershipsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ChannelMembershipType>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of channel memberships that you want returned.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The maximum number of channel memberships that you want returned.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned.</p>
        pub fn r#type(mut self, input: crate::model::ChannelMembershipType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ChannelMembershipType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The maximum number of channel memberships that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of channel memberships that you want returned.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested channel memberships are returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token passed by previous API calls until all requested channel memberships are returned.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelMembershipsInput`](crate::input::ListChannelMembershipsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelMembershipsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelMembershipsInput {
                channel_arn: self.channel_arn,
                r#type: self.r#type,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelMembershipsInputOperationOutputAlias = crate::operation::ListChannelMemberships;
#[doc(hidden)]
pub type ListChannelMembershipsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListChannelMembershipsInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelMemberships`](crate::operation::ListChannelMemberships)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListChannelMemberships,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListChannelMembershipsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_146 = &_input.channel_arn;
                let input_146 = input_146.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_146, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/memberships",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListChannelMembershipsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_147) = &_input.r#type {
                    query.push_kv("type", &aws_smithy_http::query::fmt_string(&inner_147));
                }
                if let Some(inner_148) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_148).encode(),
                    );
                }
                if let Some(inner_149) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_149),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListChannelMembershipsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_list_channel_memberships(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelMemberships::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListChannelMemberships",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListChannelMembershipsInput`](crate::input::ListChannelMembershipsInput)
    pub fn builder() -> crate::input::list_channel_memberships_input::Builder {
        crate::input::list_channel_memberships_input::Builder::default()
    }
}

/// See [`ListChannelMembershipsForAppInstanceUserInput`](crate::input::ListChannelMembershipsForAppInstanceUserInput)
pub mod list_channel_memberships_for_app_instance_user_input {

    /// A builder for [`ListChannelMembershipsForAppInstanceUserInput`](crate::input::ListChannelMembershipsForAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstanceUser</code>s</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstanceUser</code>s</p>
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// <p>The maximum number of users that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of users that you want returned.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token returned from previous API requests until the number of channel memberships is reached.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token returned from previous API requests until the number of channel memberships is reached.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelMembershipsForAppInstanceUserInput`](crate::input::ListChannelMembershipsForAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelMembershipsForAppInstanceUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::ListChannelMembershipsForAppInstanceUserInput {
                    app_instance_user_arn: self.app_instance_user_arn,
                    max_results: self.max_results,
                    next_token: self.next_token,
                    chime_bearer: self.chime_bearer,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type ListChannelMembershipsForAppInstanceUserInputOperationOutputAlias =
    crate::operation::ListChannelMembershipsForAppInstanceUser;
#[doc(hidden)]
pub type ListChannelMembershipsForAppInstanceUserInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListChannelMembershipsForAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelMembershipsForAppInstanceUser`](crate::operation::ListChannelMembershipsForAppInstanceUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListChannelMembershipsForAppInstanceUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListChannelMembershipsForAppInstanceUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/channels").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListChannelMembershipsForAppInstanceUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("scope", "app-instance-user-memberships");
                if let Some(inner_150) = &_input.app_instance_user_arn {
                    query.push_kv(
                        "app-instance-user-arn",
                        &aws_smithy_http::query::fmt_string(&inner_150),
                    );
                }
                if let Some(inner_151) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_151).encode(),
                    );
                }
                if let Some(inner_152) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_152),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListChannelMembershipsForAppInstanceUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_list_channel_memberships_for_app_instance_user(
                        input, builder,
                    )?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelMembershipsForAppInstanceUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListChannelMembershipsForAppInstanceUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListChannelMembershipsForAppInstanceUserInput`](crate::input::ListChannelMembershipsForAppInstanceUserInput)
    pub fn builder() -> crate::input::list_channel_memberships_for_app_instance_user_input::Builder
    {
        crate::input::list_channel_memberships_for_app_instance_user_input::Builder::default()
    }
}

/// See [`ListChannelMessagesInput`](crate::input::ListChannelMessagesInput)
pub mod list_channel_messages_input {

    /// A builder for [`ListChannelMessagesInput`](crate::input::ListChannelMessagesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) sort_order: std::option::Option<crate::model::SortOrder>,
        pub(crate) not_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) not_after: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The order in which you want messages sorted. Default is Descending, based on time created.</p>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.sort_order = Some(input);
            self
        }
        /// <p>The order in which you want messages sorted. Default is Descending, based on time created.</p>
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.sort_order = input;
            self
        }
        /// <p>The initial or starting time stamp for your requested messages.</p>
        pub fn not_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.not_before = Some(input);
            self
        }
        /// <p>The initial or starting time stamp for your requested messages.</p>
        pub fn set_not_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.not_before = input;
            self
        }
        /// <p>The final or ending time stamp for your requested messages.</p>
        pub fn not_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.not_after = Some(input);
            self
        }
        /// <p>The final or ending time stamp for your requested messages.</p>
        pub fn set_not_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.not_after = input;
            self
        }
        /// <p>The maximum number of messages that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of messages that you want returned.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested messages are returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token passed by previous API calls until all requested messages are returned.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelMessagesInput`](crate::input::ListChannelMessagesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelMessagesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelMessagesInput {
                channel_arn: self.channel_arn,
                sort_order: self.sort_order,
                not_before: self.not_before,
                not_after: self.not_after,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelMessagesInputOperationOutputAlias = crate::operation::ListChannelMessages;
#[doc(hidden)]
pub type ListChannelMessagesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListChannelMessagesInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelMessages`](crate::operation::ListChannelMessages)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListChannelMessages,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListChannelMessagesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_153 = &_input.channel_arn;
                let input_153 = input_153.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_153, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/messages",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListChannelMessagesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_154) = &_input.sort_order {
                    query.push_kv(
                        "sort-order",
                        &aws_smithy_http::query::fmt_string(&inner_154),
                    );
                }
                if let Some(inner_155) = &_input.not_before {
                    query.push_kv(
                        "not-before",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_155,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_156) = &_input.not_after {
                    query.push_kv(
                        "not-after",
                        &aws_smithy_http::query::fmt_timestamp(
                            inner_156,
                            aws_smithy_types::date_time::Format::DateTime,
                        )?,
                    );
                }
                if let Some(inner_157) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_157).encode(),
                    );
                }
                if let Some(inner_158) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_158),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListChannelMessagesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_list_channel_messages(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelMessages::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListChannelMessages",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListChannelMessagesInput`](crate::input::ListChannelMessagesInput)
    pub fn builder() -> crate::input::list_channel_messages_input::Builder {
        crate::input::list_channel_messages_input::Builder::default()
    }
}

/// See [`ListChannelModeratorsInput`](crate::input::ListChannelModeratorsInput)
pub mod list_channel_moderators_input {

    /// A builder for [`ListChannelModeratorsInput`](crate::input::ListChannelModeratorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The maximum number of moderators that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of moderators that you want returned.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested moderators are returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token passed by previous API calls until all requested moderators are returned.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelModeratorsInput`](crate::input::ListChannelModeratorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelModeratorsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelModeratorsInput {
                channel_arn: self.channel_arn,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelModeratorsInputOperationOutputAlias = crate::operation::ListChannelModerators;
#[doc(hidden)]
pub type ListChannelModeratorsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListChannelModeratorsInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelModerators`](crate::operation::ListChannelModerators)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListChannelModerators,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListChannelModeratorsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_159 = &_input.channel_arn;
                let input_159 = input_159.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_159, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/moderators",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListChannelModeratorsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_160) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_160).encode(),
                    );
                }
                if let Some(inner_161) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_161),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListChannelModeratorsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_list_channel_moderators(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelModerators::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListChannelModerators",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListChannelModeratorsInput`](crate::input::ListChannelModeratorsInput)
    pub fn builder() -> crate::input::list_channel_moderators_input::Builder {
        crate::input::list_channel_moderators_input::Builder::default()
    }
}

/// See [`ListChannelsInput`](crate::input::ListChannelsInput)
pub mod list_channels_input {

    /// A builder for [`ListChannelsInput`](crate::input::ListChannelsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) privacy: std::option::Option<crate::model::ChannelPrivacy>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// <p>The privacy setting. <code>PUBLIC</code> retrieves all the public channels. <code>PRIVATE</code> retrieves private channels. Only an <code>AppInstanceAdmin</code> can retrieve private channels. </p>
        pub fn privacy(mut self, input: crate::model::ChannelPrivacy) -> Self {
            self.privacy = Some(input);
            self
        }
        /// <p>The privacy setting. <code>PUBLIC</code> retrieves all the public channels. <code>PRIVATE</code> retrieves private channels. Only an <code>AppInstanceAdmin</code> can retrieve private channels. </p>
        pub fn set_privacy(
            mut self,
            input: std::option::Option<crate::model::ChannelPrivacy>,
        ) -> Self {
            self.privacy = input;
            self
        }
        /// <p>The maximum number of channels that you want to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of channels that you want to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested channels are returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token passed by previous API calls until all requested channels are returned.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelsInput`](crate::input::ListChannelsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelsInput {
                app_instance_arn: self.app_instance_arn,
                privacy: self.privacy,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelsInputOperationOutputAlias = crate::operation::ListChannels;
#[doc(hidden)]
pub type ListChannelsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListChannelsInput {
    /// Consumes the builder and constructs an Operation<[`ListChannels`](crate::operation::ListChannels)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListChannels,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListChannelsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/channels").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListChannelsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_162) = &_input.app_instance_arn {
                    query.push_kv(
                        "app-instance-arn",
                        &aws_smithy_http::query::fmt_string(&inner_162),
                    );
                }
                if let Some(inner_163) = &_input.privacy {
                    query.push_kv("privacy", &aws_smithy_http::query::fmt_string(&inner_163));
                }
                if let Some(inner_164) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_164).encode(),
                    );
                }
                if let Some(inner_165) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_165),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListChannelsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_list_channels(input, builder)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannels::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListChannels",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListChannelsInput`](crate::input::ListChannelsInput)
    pub fn builder() -> crate::input::list_channels_input::Builder {
        crate::input::list_channels_input::Builder::default()
    }
}

/// See [`ListChannelsModeratedByAppInstanceUserInput`](crate::input::ListChannelsModeratedByAppInstanceUserInput)
pub mod list_channels_moderated_by_app_instance_user_input {

    /// A builder for [`ListChannelsModeratedByAppInstanceUserInput`](crate::input::ListChannelsModeratedByAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the user in the moderated channel.</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the user in the moderated channel.</p>
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// <p>The maximum number of channels in the request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of channels in the request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token returned from previous API requests until the number of channels moderated by the user is reached.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token returned from previous API requests until the number of channels moderated by the user is reached.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelsModeratedByAppInstanceUserInput`](crate::input::ListChannelsModeratedByAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelsModeratedByAppInstanceUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelsModeratedByAppInstanceUserInput {
                app_instance_user_arn: self.app_instance_user_arn,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelsModeratedByAppInstanceUserInputOperationOutputAlias =
    crate::operation::ListChannelsModeratedByAppInstanceUser;
#[doc(hidden)]
pub type ListChannelsModeratedByAppInstanceUserInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListChannelsModeratedByAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelsModeratedByAppInstanceUser`](crate::operation::ListChannelsModeratedByAppInstanceUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListChannelsModeratedByAppInstanceUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListChannelsModeratedByAppInstanceUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/channels").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListChannelsModeratedByAppInstanceUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("scope", "app-instance-user-moderated-channels");
                if let Some(inner_166) = &_input.app_instance_user_arn {
                    query.push_kv(
                        "app-instance-user-arn",
                        &aws_smithy_http::query::fmt_string(&inner_166),
                    );
                }
                if let Some(inner_167) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_167).encode(),
                    );
                }
                if let Some(inner_168) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_168),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListChannelsModeratedByAppInstanceUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_list_channels_moderated_by_app_instance_user(
                        input, builder,
                    )?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelsModeratedByAppInstanceUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListChannelsModeratedByAppInstanceUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListChannelsModeratedByAppInstanceUserInput`](crate::input::ListChannelsModeratedByAppInstanceUserInput)
    pub fn builder() -> crate::input::list_channels_moderated_by_app_instance_user_input::Builder {
        crate::input::list_channels_moderated_by_app_instance_user_input::Builder::default()
    }
}

/// See [`ListMediaCapturePipelinesInput`](crate::input::ListMediaCapturePipelinesInput)
pub mod list_media_capture_pipelines_input {

    /// A builder for [`ListMediaCapturePipelinesInput`](crate::input::ListMediaCapturePipelinesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token used to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token used to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in a single call. Valid Range: 1 - 99.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Valid Range: 1 - 99.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMediaCapturePipelinesInput`](crate::input::ListMediaCapturePipelinesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMediaCapturePipelinesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMediaCapturePipelinesInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMediaCapturePipelinesInputOperationOutputAlias =
    crate::operation::ListMediaCapturePipelines;
#[doc(hidden)]
pub type ListMediaCapturePipelinesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListMediaCapturePipelinesInput {
    /// Consumes the builder and constructs an Operation<[`ListMediaCapturePipelines`](crate::operation::ListMediaCapturePipelines)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMediaCapturePipelines,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListMediaCapturePipelinesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/media-capture-pipelines").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListMediaCapturePipelinesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_169) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_169),
                    );
                }
                if let Some(inner_170) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_170).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListMediaCapturePipelinesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMediaCapturePipelines::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMediaCapturePipelines",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListMediaCapturePipelinesInput`](crate::input::ListMediaCapturePipelinesInput)
    pub fn builder() -> crate::input::list_media_capture_pipelines_input::Builder {
        crate::input::list_media_capture_pipelines_input::Builder::default()
    }
}

/// See [`ListMeetingsInput`](crate::input::ListMeetingsInput)
pub mod list_meetings_input {

    /// A builder for [`ListMeetingsInput`](crate::input::ListMeetingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMeetingsInput`](crate::input::ListMeetingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMeetingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMeetingsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMeetingsInputOperationOutputAlias = crate::operation::ListMeetings;
#[doc(hidden)]
pub type ListMeetingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListMeetingsInput {
    /// Consumes the builder and constructs an Operation<[`ListMeetings`](crate::operation::ListMeetings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMeetings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListMeetingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/meetings").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListMeetingsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_171) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_171),
                    );
                }
                if let Some(inner_172) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_172).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListMeetingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMeetings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMeetings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListMeetingsInput`](crate::input::ListMeetingsInput)
    pub fn builder() -> crate::input::list_meetings_input::Builder {
        crate::input::list_meetings_input::Builder::default()
    }
}

/// See [`ListMeetingTagsInput`](crate::input::ListMeetingTagsInput)
pub mod list_meeting_tags_input {

    /// A builder for [`ListMeetingTagsInput`](crate::input::ListMeetingTagsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMeetingTagsInput`](crate::input::ListMeetingTagsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMeetingTagsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMeetingTagsInput {
                meeting_id: self.meeting_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMeetingTagsInputOperationOutputAlias = crate::operation::ListMeetingTags;
#[doc(hidden)]
pub type ListMeetingTagsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListMeetingTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListMeetingTags`](crate::operation::ListMeetingTags)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMeetingTags,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListMeetingTagsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_173 = &_input.meeting_id;
                let input_173 = input_173.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_173, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/meetings/{MeetingId}/tags", MeetingId = meeting_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListMeetingTagsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMeetingTags::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMeetingTags",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListMeetingTagsInput`](crate::input::ListMeetingTagsInput)
    pub fn builder() -> crate::input::list_meeting_tags_input::Builder {
        crate::input::list_meeting_tags_input::Builder::default()
    }
}

/// See [`ListPhoneNumberOrdersInput`](crate::input::ListPhoneNumberOrdersInput)
pub mod list_phone_number_orders_input {

    /// A builder for [`ListPhoneNumberOrdersInput`](crate::input::ListPhoneNumberOrdersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPhoneNumberOrdersInput`](crate::input::ListPhoneNumberOrdersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPhoneNumberOrdersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPhoneNumberOrdersInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPhoneNumberOrdersInputOperationOutputAlias = crate::operation::ListPhoneNumberOrders;
#[doc(hidden)]
pub type ListPhoneNumberOrdersInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListPhoneNumberOrdersInput {
    /// Consumes the builder and constructs an Operation<[`ListPhoneNumberOrders`](crate::operation::ListPhoneNumberOrders)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPhoneNumberOrders,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPhoneNumberOrdersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/phone-number-orders").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPhoneNumberOrdersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_174) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_174),
                    );
                }
                if let Some(inner_175) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_175).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPhoneNumberOrdersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPhoneNumberOrders::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPhoneNumberOrders",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListPhoneNumberOrdersInput`](crate::input::ListPhoneNumberOrdersInput)
    pub fn builder() -> crate::input::list_phone_number_orders_input::Builder {
        crate::input::list_phone_number_orders_input::Builder::default()
    }
}

/// See [`ListPhoneNumbersInput`](crate::input::ListPhoneNumbersInput)
pub mod list_phone_numbers_input {

    /// A builder for [`ListPhoneNumbersInput`](crate::input::ListPhoneNumbersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::PhoneNumberStatus>,
        pub(crate) product_type: std::option::Option<crate::model::PhoneNumberProductType>,
        pub(crate) filter_name: std::option::Option<crate::model::PhoneNumberAssociationName>,
        pub(crate) filter_value: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The phone number status.</p>
        pub fn status(mut self, input: crate::model::PhoneNumberStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The phone number status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The phone number product type.</p>
        pub fn product_type(mut self, input: crate::model::PhoneNumberProductType) -> Self {
            self.product_type = Some(input);
            self
        }
        /// <p>The phone number product type.</p>
        pub fn set_product_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberProductType>,
        ) -> Self {
            self.product_type = input;
            self
        }
        /// <p>The filter to use to limit the number of results.</p>
        pub fn filter_name(mut self, input: crate::model::PhoneNumberAssociationName) -> Self {
            self.filter_name = Some(input);
            self
        }
        /// <p>The filter to use to limit the number of results.</p>
        pub fn set_filter_name(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberAssociationName>,
        ) -> Self {
            self.filter_name = input;
            self
        }
        /// <p>The value to use for the filter.</p>
        pub fn filter_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_value = Some(input.into());
            self
        }
        /// <p>The value to use for the filter.</p>
        pub fn set_filter_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_value = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPhoneNumbersInput`](crate::input::ListPhoneNumbersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListPhoneNumbersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListPhoneNumbersInput {
                status: self.status,
                product_type: self.product_type,
                filter_name: self.filter_name,
                filter_value: self.filter_value,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListPhoneNumbersInputOperationOutputAlias = crate::operation::ListPhoneNumbers;
#[doc(hidden)]
pub type ListPhoneNumbersInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListPhoneNumbersInput {
    /// Consumes the builder and constructs an Operation<[`ListPhoneNumbers`](crate::operation::ListPhoneNumbers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPhoneNumbers,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPhoneNumbersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/phone-numbers").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPhoneNumbersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_176) = &_input.status {
                    query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_176));
                }
                if let Some(inner_177) = &_input.product_type {
                    query.push_kv(
                        "product-type",
                        &aws_smithy_http::query::fmt_string(&inner_177),
                    );
                }
                if let Some(inner_178) = &_input.filter_name {
                    query.push_kv(
                        "filter-name",
                        &aws_smithy_http::query::fmt_string(&inner_178),
                    );
                }
                if let Some(inner_179) = &_input.filter_value {
                    query.push_kv(
                        "filter-value",
                        &aws_smithy_http::query::fmt_string(&inner_179),
                    );
                }
                if let Some(inner_180) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_180).encode(),
                    );
                }
                if let Some(inner_181) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_181),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPhoneNumbersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPhoneNumbers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPhoneNumbers",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListPhoneNumbersInput`](crate::input::ListPhoneNumbersInput)
    pub fn builder() -> crate::input::list_phone_numbers_input::Builder {
        crate::input::list_phone_numbers_input::Builder::default()
    }
}

/// See [`ListProxySessionsInput`](crate::input::ListProxySessionsInput)
pub mod list_proxy_sessions_input {

    /// A builder for [`ListProxySessionsInput`](crate::input::ListProxySessionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ProxySessionStatus>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The proxy session status.</p>
        pub fn status(mut self, input: crate::model::ProxySessionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The proxy session status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ProxySessionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProxySessionsInput`](crate::input::ListProxySessionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListProxySessionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListProxySessionsInput {
                voice_connector_id: self.voice_connector_id,
                status: self.status,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListProxySessionsInputOperationOutputAlias = crate::operation::ListProxySessions;
#[doc(hidden)]
pub type ListProxySessionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListProxySessionsInput {
    /// Consumes the builder and constructs an Operation<[`ListProxySessions`](crate::operation::ListProxySessions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListProxySessions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListProxySessionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_182 = &_input.voice_connector_id;
                let input_182 = input_182.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_182, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/proxy-sessions",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListProxySessionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_183) = &_input.status {
                    query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_183));
                }
                if let Some(inner_184) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_184),
                    );
                }
                if let Some(inner_185) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_185).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListProxySessionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListProxySessions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListProxySessions",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListProxySessionsInput`](crate::input::ListProxySessionsInput)
    pub fn builder() -> crate::input::list_proxy_sessions_input::Builder {
        crate::input::list_proxy_sessions_input::Builder::default()
    }
}

/// See [`ListRoomMembershipsInput`](crate::input::ListRoomMembershipsInput)
pub mod list_room_memberships_input {

    /// A builder for [`ListRoomMembershipsInput`](crate::input::ListRoomMembershipsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) room_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The room ID.</p>
        pub fn room_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.room_id = Some(input.into());
            self
        }
        /// <p>The room ID.</p>
        pub fn set_room_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.room_id = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRoomMembershipsInput`](crate::input::ListRoomMembershipsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListRoomMembershipsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListRoomMembershipsInput {
                account_id: self.account_id,
                room_id: self.room_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRoomMembershipsInputOperationOutputAlias = crate::operation::ListRoomMemberships;
#[doc(hidden)]
pub type ListRoomMembershipsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListRoomMembershipsInput {
    /// Consumes the builder and constructs an Operation<[`ListRoomMemberships`](crate::operation::ListRoomMemberships)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListRoomMemberships,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListRoomMembershipsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_186 = &_input.account_id;
                let input_186 = input_186.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_186, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_187 = &_input.room_id;
                let input_187 = input_187.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let room_id = aws_smithy_http::label::fmt_string(input_187, false);
                if room_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms/{RoomId}/memberships",
                    AccountId = account_id,
                    RoomId = room_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListRoomMembershipsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_188) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_188).encode(),
                    );
                }
                if let Some(inner_189) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_189),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListRoomMembershipsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListRoomMemberships::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListRoomMemberships",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListRoomMembershipsInput`](crate::input::ListRoomMembershipsInput)
    pub fn builder() -> crate::input::list_room_memberships_input::Builder {
        crate::input::list_room_memberships_input::Builder::default()
    }
}

/// See [`ListRoomsInput`](crate::input::ListRoomsInput)
pub mod list_rooms_input {

    /// A builder for [`ListRoomsInput`](crate::input::ListRoomsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) member_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The member ID (user ID or bot ID).</p>
        pub fn member_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_id = Some(input.into());
            self
        }
        /// <p>The member ID (user ID or bot ID).</p>
        pub fn set_member_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_id = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRoomsInput`](crate::input::ListRoomsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListRoomsInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListRoomsInput {
                account_id: self.account_id,
                member_id: self.member_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListRoomsInputOperationOutputAlias = crate::operation::ListRooms;
#[doc(hidden)]
pub type ListRoomsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListRoomsInput {
    /// Consumes the builder and constructs an Operation<[`ListRooms`](crate::operation::ListRooms)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListRooms,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListRoomsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_190 = &_input.account_id;
                let input_190 = input_190.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_190, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListRoomsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_191) = &_input.member_id {
                    query.push_kv("member-id", &aws_smithy_http::query::fmt_string(&inner_191));
                }
                if let Some(inner_192) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_192).encode(),
                    );
                }
                if let Some(inner_193) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_193),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListRoomsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::ListRooms::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "ListRooms",
                    "chime",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListRoomsInput`](crate::input::ListRoomsInput)
    pub fn builder() -> crate::input::list_rooms_input::Builder {
        crate::input::list_rooms_input::Builder::default()
    }
}

/// See [`ListSipMediaApplicationsInput`](crate::input::ListSipMediaApplicationsInput)
pub mod list_sip_media_applications_input {

    /// A builder for [`ListSipMediaApplicationsInput`](crate::input::ListSipMediaApplicationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSipMediaApplicationsInput`](crate::input::ListSipMediaApplicationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListSipMediaApplicationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListSipMediaApplicationsInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSipMediaApplicationsInputOperationOutputAlias =
    crate::operation::ListSipMediaApplications;
#[doc(hidden)]
pub type ListSipMediaApplicationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListSipMediaApplicationsInput {
    /// Consumes the builder and constructs an Operation<[`ListSipMediaApplications`](crate::operation::ListSipMediaApplications)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSipMediaApplications,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSipMediaApplicationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/sip-media-applications").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSipMediaApplicationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_194) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_194).encode(),
                    );
                }
                if let Some(inner_195) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_195),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSipMediaApplicationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSipMediaApplications::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSipMediaApplications",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSipMediaApplicationsInput`](crate::input::ListSipMediaApplicationsInput)
    pub fn builder() -> crate::input::list_sip_media_applications_input::Builder {
        crate::input::list_sip_media_applications_input::Builder::default()
    }
}

/// See [`ListSipRulesInput`](crate::input::ListSipRulesInput)
pub mod list_sip_rules_input {

    /// A builder for [`ListSipRulesInput`](crate::input::ListSipRulesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The SIP media application ID.</p>
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        /// <p>The SIP media application ID.</p>
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSipRulesInput`](crate::input::ListSipRulesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListSipRulesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListSipRulesInput {
                sip_media_application_id: self.sip_media_application_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSipRulesInputOperationOutputAlias = crate::operation::ListSipRules;
#[doc(hidden)]
pub type ListSipRulesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListSipRulesInput {
    /// Consumes the builder and constructs an Operation<[`ListSipRules`](crate::operation::ListSipRules)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSipRules,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSipRulesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/sip-rules").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSipRulesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_196) = &_input.sip_media_application_id {
                    query.push_kv(
                        "sip-media-application",
                        &aws_smithy_http::query::fmt_string(&inner_196),
                    );
                }
                if let Some(inner_197) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_197).encode(),
                    );
                }
                if let Some(inner_198) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_198),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSipRulesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSipRules::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSipRules",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSipRulesInput`](crate::input::ListSipRulesInput)
    pub fn builder() -> crate::input::list_sip_rules_input::Builder {
        crate::input::list_sip_rules_input::Builder::default()
    }
}

/// See [`ListSupportedPhoneNumberCountriesInput`](crate::input::ListSupportedPhoneNumberCountriesInput)
pub mod list_supported_phone_number_countries_input {

    /// A builder for [`ListSupportedPhoneNumberCountriesInput`](crate::input::ListSupportedPhoneNumberCountriesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_type: std::option::Option<crate::model::PhoneNumberProductType>,
    }
    impl Builder {
        /// <p>The phone number product type.</p>
        pub fn product_type(mut self, input: crate::model::PhoneNumberProductType) -> Self {
            self.product_type = Some(input);
            self
        }
        /// <p>The phone number product type.</p>
        pub fn set_product_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberProductType>,
        ) -> Self {
            self.product_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSupportedPhoneNumberCountriesInput`](crate::input::ListSupportedPhoneNumberCountriesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListSupportedPhoneNumberCountriesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListSupportedPhoneNumberCountriesInput {
                product_type: self.product_type,
            })
        }
    }
}
#[doc(hidden)]
pub type ListSupportedPhoneNumberCountriesInputOperationOutputAlias =
    crate::operation::ListSupportedPhoneNumberCountries;
#[doc(hidden)]
pub type ListSupportedPhoneNumberCountriesInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListSupportedPhoneNumberCountriesInput {
    /// Consumes the builder and constructs an Operation<[`ListSupportedPhoneNumberCountries`](crate::operation::ListSupportedPhoneNumberCountries)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSupportedPhoneNumberCountries,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSupportedPhoneNumberCountriesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/phone-number-countries").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSupportedPhoneNumberCountriesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_199) = &_input.product_type {
                    query.push_kv(
                        "product-type",
                        &aws_smithy_http::query::fmt_string(&inner_199),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSupportedPhoneNumberCountriesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSupportedPhoneNumberCountries::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSupportedPhoneNumberCountries",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSupportedPhoneNumberCountriesInput`](crate::input::ListSupportedPhoneNumberCountriesInput)
    pub fn builder() -> crate::input::list_supported_phone_number_countries_input::Builder {
        crate::input::list_supported_phone_number_countries_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The resource ARN.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/tags").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTagsForResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_200) = &_input.resource_arn {
                    query.push_kv("arn", &aws_smithy_http::query::fmt_string(&inner_200));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListUsersInput`](crate::input::ListUsersInput)
pub mod list_users_input {

    /// A builder for [`ListUsersInput`](crate::input::ListUsersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_email: std::option::Option<std::string::String>,
        pub(crate) user_type: std::option::Option<crate::model::UserType>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>Optional. The user email address used to filter results. Maximum 1.</p>
        pub fn user_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_email = Some(input.into());
            self
        }
        /// <p>Optional. The user email address used to filter results. Maximum 1.</p>
        pub fn set_user_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_email = input;
            self
        }
        /// <p>The user type.</p>
        pub fn user_type(mut self, input: crate::model::UserType) -> Self {
            self.user_type = Some(input);
            self
        }
        /// <p>The user type.</p>
        pub fn set_user_type(mut self, input: std::option::Option<crate::model::UserType>) -> Self {
            self.user_type = input;
            self
        }
        /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListUsersInput`](crate::input::ListUsersInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListUsersInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListUsersInput {
                account_id: self.account_id,
                user_email: self.user_email,
                user_type: self.user_type,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListUsersInputOperationOutputAlias = crate::operation::ListUsers;
#[doc(hidden)]
pub type ListUsersInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListUsersInput {
    /// Consumes the builder and constructs an Operation<[`ListUsers`](crate::operation::ListUsers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListUsers,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListUsersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_201 = &_input.account_id;
                let input_201 = input_201.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_201, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListUsersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_202) = &_input.user_email {
                    query.push_kv(
                        "user-email",
                        &aws_smithy_http::query::fmt_string(&inner_202),
                    );
                }
                if let Some(inner_203) = &_input.user_type {
                    query.push_kv("user-type", &aws_smithy_http::query::fmt_string(&inner_203));
                }
                if let Some(inner_204) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_204).encode(),
                    );
                }
                if let Some(inner_205) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_205),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListUsersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::ListUsers::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "ListUsers",
                    "chime",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListUsersInput`](crate::input::ListUsersInput)
    pub fn builder() -> crate::input::list_users_input::Builder {
        crate::input::list_users_input::Builder::default()
    }
}

/// See [`ListVoiceConnectorGroupsInput`](crate::input::ListVoiceConnectorGroupsInput)
pub mod list_voice_connector_groups_input {

    /// A builder for [`ListVoiceConnectorGroupsInput`](crate::input::ListVoiceConnectorGroupsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVoiceConnectorGroupsInput`](crate::input::ListVoiceConnectorGroupsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListVoiceConnectorGroupsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListVoiceConnectorGroupsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListVoiceConnectorGroupsInputOperationOutputAlias =
    crate::operation::ListVoiceConnectorGroups;
#[doc(hidden)]
pub type ListVoiceConnectorGroupsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListVoiceConnectorGroupsInput {
    /// Consumes the builder and constructs an Operation<[`ListVoiceConnectorGroups`](crate::operation::ListVoiceConnectorGroups)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListVoiceConnectorGroups,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListVoiceConnectorGroupsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/voice-connector-groups").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListVoiceConnectorGroupsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_206) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_206),
                    );
                }
                if let Some(inner_207) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_207).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListVoiceConnectorGroupsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListVoiceConnectorGroups::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListVoiceConnectorGroups",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListVoiceConnectorGroupsInput`](crate::input::ListVoiceConnectorGroupsInput)
    pub fn builder() -> crate::input::list_voice_connector_groups_input::Builder {
        crate::input::list_voice_connector_groups_input::Builder::default()
    }
}

/// See [`ListVoiceConnectorsInput`](crate::input::ListVoiceConnectorsInput)
pub mod list_voice_connectors_input {

    /// A builder for [`ListVoiceConnectorsInput`](crate::input::ListVoiceConnectorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVoiceConnectorsInput`](crate::input::ListVoiceConnectorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListVoiceConnectorsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListVoiceConnectorsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListVoiceConnectorsInputOperationOutputAlias = crate::operation::ListVoiceConnectors;
#[doc(hidden)]
pub type ListVoiceConnectorsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListVoiceConnectorsInput {
    /// Consumes the builder and constructs an Operation<[`ListVoiceConnectors`](crate::operation::ListVoiceConnectors)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListVoiceConnectors,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListVoiceConnectorsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/voice-connectors").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListVoiceConnectorsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_208) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_208),
                    );
                }
                if let Some(inner_209) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_209).encode(),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListVoiceConnectorsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListVoiceConnectors::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListVoiceConnectors",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListVoiceConnectorsInput`](crate::input::ListVoiceConnectorsInput)
    pub fn builder() -> crate::input::list_voice_connectors_input::Builder {
        crate::input::list_voice_connectors_input::Builder::default()
    }
}

/// See [`ListVoiceConnectorTerminationCredentialsInput`](crate::input::ListVoiceConnectorTerminationCredentialsInput)
pub mod list_voice_connector_termination_credentials_input {

    /// A builder for [`ListVoiceConnectorTerminationCredentialsInput`](crate::input::ListVoiceConnectorTerminationCredentialsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVoiceConnectorTerminationCredentialsInput`](crate::input::ListVoiceConnectorTerminationCredentialsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListVoiceConnectorTerminationCredentialsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::ListVoiceConnectorTerminationCredentialsInput {
                    voice_connector_id: self.voice_connector_id,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type ListVoiceConnectorTerminationCredentialsInputOperationOutputAlias =
    crate::operation::ListVoiceConnectorTerminationCredentials;
#[doc(hidden)]
pub type ListVoiceConnectorTerminationCredentialsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListVoiceConnectorTerminationCredentialsInput {
    /// Consumes the builder and constructs an Operation<[`ListVoiceConnectorTerminationCredentials`](crate::operation::ListVoiceConnectorTerminationCredentials)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListVoiceConnectorTerminationCredentials,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListVoiceConnectorTerminationCredentialsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_210 = &_input.voice_connector_id;
                let input_210 = input_210.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_210, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/termination/credentials",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListVoiceConnectorTerminationCredentialsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListVoiceConnectorTerminationCredentials::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListVoiceConnectorTerminationCredentials",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListVoiceConnectorTerminationCredentialsInput`](crate::input::ListVoiceConnectorTerminationCredentialsInput)
    pub fn builder() -> crate::input::list_voice_connector_termination_credentials_input::Builder {
        crate::input::list_voice_connector_termination_credentials_input::Builder::default()
    }
}

/// See [`LogoutUserInput`](crate::input::LogoutUserInput)
pub mod logout_user_input {

    /// A builder for [`LogoutUserInput`](crate::input::LogoutUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The user ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The user ID.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LogoutUserInput`](crate::input::LogoutUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::LogoutUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::LogoutUserInput {
                account_id: self.account_id,
                user_id: self.user_id,
            })
        }
    }
}
#[doc(hidden)]
pub type LogoutUserInputOperationOutputAlias = crate::operation::LogoutUser;
#[doc(hidden)]
pub type LogoutUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl LogoutUserInput {
    /// Consumes the builder and constructs an Operation<[`LogoutUser`](crate::operation::LogoutUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::LogoutUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::LogoutUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_211 = &_input.account_id;
                let input_211 = input_211.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_211, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_212 = &_input.user_id;
                let input_212 = input_212.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let user_id = aws_smithy_http::label::fmt_string(input_212, false);
                if user_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users/{UserId}",
                    AccountId = account_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::LogoutUserInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "logout");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::LogoutUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::LogoutUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "LogoutUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`LogoutUserInput`](crate::input::LogoutUserInput)
    pub fn builder() -> crate::input::logout_user_input::Builder {
        crate::input::logout_user_input::Builder::default()
    }
}

/// See [`PutAppInstanceRetentionSettingsInput`](crate::input::PutAppInstanceRetentionSettingsInput)
pub mod put_app_instance_retention_settings_input {

    /// A builder for [`PutAppInstanceRetentionSettingsInput`](crate::input::PutAppInstanceRetentionSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_retention_settings:
            std::option::Option<crate::model::AppInstanceRetentionSettings>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// <p>The time in days to retain data. Data type: number.</p>
        pub fn app_instance_retention_settings(
            mut self,
            input: crate::model::AppInstanceRetentionSettings,
        ) -> Self {
            self.app_instance_retention_settings = Some(input);
            self
        }
        /// <p>The time in days to retain data. Data type: number.</p>
        pub fn set_app_instance_retention_settings(
            mut self,
            input: std::option::Option<crate::model::AppInstanceRetentionSettings>,
        ) -> Self {
            self.app_instance_retention_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`PutAppInstanceRetentionSettingsInput`](crate::input::PutAppInstanceRetentionSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutAppInstanceRetentionSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutAppInstanceRetentionSettingsInput {
                app_instance_arn: self.app_instance_arn,
                app_instance_retention_settings: self.app_instance_retention_settings,
            })
        }
    }
}
#[doc(hidden)]
pub type PutAppInstanceRetentionSettingsInputOperationOutputAlias =
    crate::operation::PutAppInstanceRetentionSettings;
#[doc(hidden)]
pub type PutAppInstanceRetentionSettingsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutAppInstanceRetentionSettingsInput {
    /// Consumes the builder and constructs an Operation<[`PutAppInstanceRetentionSettings`](crate::operation::PutAppInstanceRetentionSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutAppInstanceRetentionSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutAppInstanceRetentionSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_213 = &_input.app_instance_arn;
                let input_213 = input_213.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_213, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}/retention-settings",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutAppInstanceRetentionSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_app_instance_retention_settings(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutAppInstanceRetentionSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutAppInstanceRetentionSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutAppInstanceRetentionSettingsInput`](crate::input::PutAppInstanceRetentionSettingsInput)
    pub fn builder() -> crate::input::put_app_instance_retention_settings_input::Builder {
        crate::input::put_app_instance_retention_settings_input::Builder::default()
    }
}

/// See [`PutAppInstanceStreamingConfigurationsInput`](crate::input::PutAppInstanceStreamingConfigurationsInput)
pub mod put_app_instance_streaming_configurations_input {

    /// A builder for [`PutAppInstanceStreamingConfigurationsInput`](crate::input::PutAppInstanceStreamingConfigurationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_streaming_configurations:
            std::option::Option<std::vec::Vec<crate::model::AppInstanceStreamingConfiguration>>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// Appends an item to `app_instance_streaming_configurations`.
        ///
        /// To override the contents of this collection use [`set_app_instance_streaming_configurations`](Self::set_app_instance_streaming_configurations).
        ///
        /// <p>The streaming configurations set for an <code>AppInstance</code>.</p>
        pub fn app_instance_streaming_configurations(
            mut self,
            input: crate::model::AppInstanceStreamingConfiguration,
        ) -> Self {
            let mut v = self
                .app_instance_streaming_configurations
                .unwrap_or_default();
            v.push(input);
            self.app_instance_streaming_configurations = Some(v);
            self
        }
        /// <p>The streaming configurations set for an <code>AppInstance</code>.</p>
        pub fn set_app_instance_streaming_configurations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AppInstanceStreamingConfiguration>,
            >,
        ) -> Self {
            self.app_instance_streaming_configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`PutAppInstanceStreamingConfigurationsInput`](crate::input::PutAppInstanceStreamingConfigurationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutAppInstanceStreamingConfigurationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutAppInstanceStreamingConfigurationsInput {
                app_instance_arn: self.app_instance_arn,
                app_instance_streaming_configurations: self.app_instance_streaming_configurations,
            })
        }
    }
}
#[doc(hidden)]
pub type PutAppInstanceStreamingConfigurationsInputOperationOutputAlias =
    crate::operation::PutAppInstanceStreamingConfigurations;
#[doc(hidden)]
pub type PutAppInstanceStreamingConfigurationsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutAppInstanceStreamingConfigurationsInput {
    /// Consumes the builder and constructs an Operation<[`PutAppInstanceStreamingConfigurations`](crate::operation::PutAppInstanceStreamingConfigurations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutAppInstanceStreamingConfigurations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutAppInstanceStreamingConfigurationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_214 = &_input.app_instance_arn;
                let input_214 = input_214.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_214, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}/streaming-configurations",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutAppInstanceStreamingConfigurationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_app_instance_streaming_configurations(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutAppInstanceStreamingConfigurations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutAppInstanceStreamingConfigurations",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutAppInstanceStreamingConfigurationsInput`](crate::input::PutAppInstanceStreamingConfigurationsInput)
    pub fn builder() -> crate::input::put_app_instance_streaming_configurations_input::Builder {
        crate::input::put_app_instance_streaming_configurations_input::Builder::default()
    }
}

/// See [`PutEventsConfigurationInput`](crate::input::PutEventsConfigurationInput)
pub mod put_events_configuration_input {

    /// A builder for [`PutEventsConfigurationInput`](crate::input::PutEventsConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) bot_id: std::option::Option<std::string::String>,
        pub(crate) outbound_events_https_endpoint: std::option::Option<std::string::String>,
        pub(crate) lambda_function_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The bot ID.</p>
        pub fn bot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bot_id = Some(input.into());
            self
        }
        /// <p>The bot ID.</p>
        pub fn set_bot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bot_id = input;
            self
        }
        /// <p>HTTPS endpoint that allows the bot to receive outgoing events.</p>
        pub fn outbound_events_https_endpoint(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.outbound_events_https_endpoint = Some(input.into());
            self
        }
        /// <p>HTTPS endpoint that allows the bot to receive outgoing events.</p>
        pub fn set_outbound_events_https_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.outbound_events_https_endpoint = input;
            self
        }
        /// <p>Lambda function ARN that allows the bot to receive outgoing events.</p>
        pub fn lambda_function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lambda_function_arn = Some(input.into());
            self
        }
        /// <p>Lambda function ARN that allows the bot to receive outgoing events.</p>
        pub fn set_lambda_function_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lambda_function_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`PutEventsConfigurationInput`](crate::input::PutEventsConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutEventsConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutEventsConfigurationInput {
                account_id: self.account_id,
                bot_id: self.bot_id,
                outbound_events_https_endpoint: self.outbound_events_https_endpoint,
                lambda_function_arn: self.lambda_function_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type PutEventsConfigurationInputOperationOutputAlias = crate::operation::PutEventsConfiguration;
#[doc(hidden)]
pub type PutEventsConfigurationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl PutEventsConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutEventsConfiguration`](crate::operation::PutEventsConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutEventsConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutEventsConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_215 = &_input.account_id;
                let input_215 = input_215.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_215, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_216 = &_input.bot_id;
                let input_216 = input_216.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let bot_id = aws_smithy_http::label::fmt_string(input_216, false);
                if bot_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/bots/{BotId}/events-configuration",
                    AccountId = account_id,
                    BotId = bot_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutEventsConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_events_configuration(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutEventsConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutEventsConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutEventsConfigurationInput`](crate::input::PutEventsConfigurationInput)
    pub fn builder() -> crate::input::put_events_configuration_input::Builder {
        crate::input::put_events_configuration_input::Builder::default()
    }
}

/// See [`PutRetentionSettingsInput`](crate::input::PutRetentionSettingsInput)
pub mod put_retention_settings_input {

    /// A builder for [`PutRetentionSettingsInput`](crate::input::PutRetentionSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) retention_settings: std::option::Option<crate::model::RetentionSettings>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The retention settings.</p>
        pub fn retention_settings(mut self, input: crate::model::RetentionSettings) -> Self {
            self.retention_settings = Some(input);
            self
        }
        /// <p>The retention settings.</p>
        pub fn set_retention_settings(
            mut self,
            input: std::option::Option<crate::model::RetentionSettings>,
        ) -> Self {
            self.retention_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`PutRetentionSettingsInput`](crate::input::PutRetentionSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutRetentionSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutRetentionSettingsInput {
                account_id: self.account_id,
                retention_settings: self.retention_settings,
            })
        }
    }
}
#[doc(hidden)]
pub type PutRetentionSettingsInputOperationOutputAlias = crate::operation::PutRetentionSettings;
#[doc(hidden)]
pub type PutRetentionSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl PutRetentionSettingsInput {
    /// Consumes the builder and constructs an Operation<[`PutRetentionSettings`](crate::operation::PutRetentionSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutRetentionSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutRetentionSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_217 = &_input.account_id;
                let input_217 = input_217.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_217, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/retention-settings",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutRetentionSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_retention_settings(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutRetentionSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutRetentionSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutRetentionSettingsInput`](crate::input::PutRetentionSettingsInput)
    pub fn builder() -> crate::input::put_retention_settings_input::Builder {
        crate::input::put_retention_settings_input::Builder::default()
    }
}

/// See [`PutSipMediaApplicationLoggingConfigurationInput`](crate::input::PutSipMediaApplicationLoggingConfigurationInput)
pub mod put_sip_media_application_logging_configuration_input {

    /// A builder for [`PutSipMediaApplicationLoggingConfigurationInput`](crate::input::PutSipMediaApplicationLoggingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
        pub(crate) sip_media_application_logging_configuration:
            std::option::Option<crate::model::SipMediaApplicationLoggingConfiguration>,
    }
    impl Builder {
        /// <p>The SIP media application ID.</p>
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        /// <p>The SIP media application ID.</p>
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        /// <p>The actual logging configuration.</p>
        pub fn sip_media_application_logging_configuration(
            mut self,
            input: crate::model::SipMediaApplicationLoggingConfiguration,
        ) -> Self {
            self.sip_media_application_logging_configuration = Some(input);
            self
        }
        /// <p>The actual logging configuration.</p>
        pub fn set_sip_media_application_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::SipMediaApplicationLoggingConfiguration>,
        ) -> Self {
            self.sip_media_application_logging_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutSipMediaApplicationLoggingConfigurationInput`](crate::input::PutSipMediaApplicationLoggingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutSipMediaApplicationLoggingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::PutSipMediaApplicationLoggingConfigurationInput {
                    sip_media_application_id: self.sip_media_application_id,
                    sip_media_application_logging_configuration: self
                        .sip_media_application_logging_configuration,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type PutSipMediaApplicationLoggingConfigurationInputOperationOutputAlias =
    crate::operation::PutSipMediaApplicationLoggingConfiguration;
#[doc(hidden)]
pub type PutSipMediaApplicationLoggingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutSipMediaApplicationLoggingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutSipMediaApplicationLoggingConfiguration`](crate::operation::PutSipMediaApplicationLoggingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutSipMediaApplicationLoggingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutSipMediaApplicationLoggingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_218 = &_input.sip_media_application_id;
                let input_218 = input_218.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_media_application_id = aws_smithy_http::label::fmt_string(input_218, false);
                if sip_media_application_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/sip-media-applications/{SipMediaApplicationId}/logging-configuration",
                    SipMediaApplicationId = sip_media_application_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutSipMediaApplicationLoggingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_sip_media_application_logging_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutSipMediaApplicationLoggingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutSipMediaApplicationLoggingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutSipMediaApplicationLoggingConfigurationInput`](crate::input::PutSipMediaApplicationLoggingConfigurationInput)
    pub fn builder() -> crate::input::put_sip_media_application_logging_configuration_input::Builder
    {
        crate::input::put_sip_media_application_logging_configuration_input::Builder::default()
    }
}

/// See [`PutVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::PutVoiceConnectorEmergencyCallingConfigurationInput)
pub mod put_voice_connector_emergency_calling_configuration_input {

    /// A builder for [`PutVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::PutVoiceConnectorEmergencyCallingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) emergency_calling_configuration:
            std::option::Option<crate::model::EmergencyCallingConfiguration>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The emergency calling configuration details.</p>
        pub fn emergency_calling_configuration(
            mut self,
            input: crate::model::EmergencyCallingConfiguration,
        ) -> Self {
            self.emergency_calling_configuration = Some(input);
            self
        }
        /// <p>The emergency calling configuration details.</p>
        pub fn set_emergency_calling_configuration(
            mut self,
            input: std::option::Option<crate::model::EmergencyCallingConfiguration>,
        ) -> Self {
            self.emergency_calling_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::PutVoiceConnectorEmergencyCallingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutVoiceConnectorEmergencyCallingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::PutVoiceConnectorEmergencyCallingConfigurationInput {
                    voice_connector_id: self.voice_connector_id,
                    emergency_calling_configuration: self.emergency_calling_configuration,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type PutVoiceConnectorEmergencyCallingConfigurationInputOperationOutputAlias =
    crate::operation::PutVoiceConnectorEmergencyCallingConfiguration;
#[doc(hidden)]
pub type PutVoiceConnectorEmergencyCallingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutVoiceConnectorEmergencyCallingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutVoiceConnectorEmergencyCallingConfiguration`](crate::operation::PutVoiceConnectorEmergencyCallingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutVoiceConnectorEmergencyCallingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutVoiceConnectorEmergencyCallingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_219 = &_input.voice_connector_id;
                let input_219 = input_219.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_219, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/emergency-calling-configuration",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutVoiceConnectorEmergencyCallingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_voice_connector_emergency_calling_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutVoiceConnectorEmergencyCallingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutVoiceConnectorEmergencyCallingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutVoiceConnectorEmergencyCallingConfigurationInput`](crate::input::PutVoiceConnectorEmergencyCallingConfigurationInput)
    pub fn builder(
    ) -> crate::input::put_voice_connector_emergency_calling_configuration_input::Builder {
        crate::input::put_voice_connector_emergency_calling_configuration_input::Builder::default()
    }
}

/// See [`PutVoiceConnectorLoggingConfigurationInput`](crate::input::PutVoiceConnectorLoggingConfigurationInput)
pub mod put_voice_connector_logging_configuration_input {

    /// A builder for [`PutVoiceConnectorLoggingConfigurationInput`](crate::input::PutVoiceConnectorLoggingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The logging configuration details to add.</p>
        pub fn logging_configuration(mut self, input: crate::model::LoggingConfiguration) -> Self {
            self.logging_configuration = Some(input);
            self
        }
        /// <p>The logging configuration details to add.</p>
        pub fn set_logging_configuration(
            mut self,
            input: std::option::Option<crate::model::LoggingConfiguration>,
        ) -> Self {
            self.logging_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutVoiceConnectorLoggingConfigurationInput`](crate::input::PutVoiceConnectorLoggingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutVoiceConnectorLoggingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutVoiceConnectorLoggingConfigurationInput {
                voice_connector_id: self.voice_connector_id,
                logging_configuration: self.logging_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutVoiceConnectorLoggingConfigurationInputOperationOutputAlias =
    crate::operation::PutVoiceConnectorLoggingConfiguration;
#[doc(hidden)]
pub type PutVoiceConnectorLoggingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutVoiceConnectorLoggingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutVoiceConnectorLoggingConfiguration`](crate::operation::PutVoiceConnectorLoggingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutVoiceConnectorLoggingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutVoiceConnectorLoggingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_220 = &_input.voice_connector_id;
                let input_220 = input_220.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_220, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/logging-configuration",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutVoiceConnectorLoggingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_voice_connector_logging_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutVoiceConnectorLoggingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutVoiceConnectorLoggingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutVoiceConnectorLoggingConfigurationInput`](crate::input::PutVoiceConnectorLoggingConfigurationInput)
    pub fn builder() -> crate::input::put_voice_connector_logging_configuration_input::Builder {
        crate::input::put_voice_connector_logging_configuration_input::Builder::default()
    }
}

/// See [`PutVoiceConnectorOriginationInput`](crate::input::PutVoiceConnectorOriginationInput)
pub mod put_voice_connector_origination_input {

    /// A builder for [`PutVoiceConnectorOriginationInput`](crate::input::PutVoiceConnectorOriginationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) origination: std::option::Option<crate::model::Origination>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The origination setting details to add.</p>
        pub fn origination(mut self, input: crate::model::Origination) -> Self {
            self.origination = Some(input);
            self
        }
        /// <p>The origination setting details to add.</p>
        pub fn set_origination(
            mut self,
            input: std::option::Option<crate::model::Origination>,
        ) -> Self {
            self.origination = input;
            self
        }
        /// Consumes the builder and constructs a [`PutVoiceConnectorOriginationInput`](crate::input::PutVoiceConnectorOriginationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutVoiceConnectorOriginationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutVoiceConnectorOriginationInput {
                voice_connector_id: self.voice_connector_id,
                origination: self.origination,
            })
        }
    }
}
#[doc(hidden)]
pub type PutVoiceConnectorOriginationInputOperationOutputAlias =
    crate::operation::PutVoiceConnectorOrigination;
#[doc(hidden)]
pub type PutVoiceConnectorOriginationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutVoiceConnectorOriginationInput {
    /// Consumes the builder and constructs an Operation<[`PutVoiceConnectorOrigination`](crate::operation::PutVoiceConnectorOrigination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutVoiceConnectorOrigination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutVoiceConnectorOriginationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_221 = &_input.voice_connector_id;
                let input_221 = input_221.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_221, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/origination",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutVoiceConnectorOriginationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_voice_connector_origination(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutVoiceConnectorOrigination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutVoiceConnectorOrigination",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutVoiceConnectorOriginationInput`](crate::input::PutVoiceConnectorOriginationInput)
    pub fn builder() -> crate::input::put_voice_connector_origination_input::Builder {
        crate::input::put_voice_connector_origination_input::Builder::default()
    }
}

/// See [`PutVoiceConnectorProxyInput`](crate::input::PutVoiceConnectorProxyInput)
pub mod put_voice_connector_proxy_input {

    /// A builder for [`PutVoiceConnectorProxyInput`](crate::input::PutVoiceConnectorProxyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) default_session_expiry_minutes: std::option::Option<i32>,
        pub(crate) phone_number_pool_countries:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) fall_back_phone_number: std::option::Option<std::string::String>,
        pub(crate) disabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The default number of minutes allowed for proxy sessions.</p>
        pub fn default_session_expiry_minutes(mut self, input: i32) -> Self {
            self.default_session_expiry_minutes = Some(input);
            self
        }
        /// <p>The default number of minutes allowed for proxy sessions.</p>
        pub fn set_default_session_expiry_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.default_session_expiry_minutes = input;
            self
        }
        /// Appends an item to `phone_number_pool_countries`.
        ///
        /// To override the contents of this collection use [`set_phone_number_pool_countries`](Self::set_phone_number_pool_countries).
        ///
        /// <p>The countries for proxy phone numbers to be selected from.</p>
        pub fn phone_number_pool_countries(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.phone_number_pool_countries.unwrap_or_default();
            v.push(input.into());
            self.phone_number_pool_countries = Some(v);
            self
        }
        /// <p>The countries for proxy phone numbers to be selected from.</p>
        pub fn set_phone_number_pool_countries(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.phone_number_pool_countries = input;
            self
        }
        /// <p>The phone number to route calls to after a proxy session expires.</p>
        pub fn fall_back_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.fall_back_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number to route calls to after a proxy session expires.</p>
        pub fn set_fall_back_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fall_back_phone_number = input;
            self
        }
        /// <p>When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.</p>
        pub fn disabled(mut self, input: bool) -> Self {
            self.disabled = Some(input);
            self
        }
        /// <p>When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.</p>
        pub fn set_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.disabled = input;
            self
        }
        /// Consumes the builder and constructs a [`PutVoiceConnectorProxyInput`](crate::input::PutVoiceConnectorProxyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutVoiceConnectorProxyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutVoiceConnectorProxyInput {
                voice_connector_id: self.voice_connector_id,
                default_session_expiry_minutes: self.default_session_expiry_minutes,
                phone_number_pool_countries: self.phone_number_pool_countries,
                fall_back_phone_number: self.fall_back_phone_number,
                disabled: self.disabled,
            })
        }
    }
}
#[doc(hidden)]
pub type PutVoiceConnectorProxyInputOperationOutputAlias = crate::operation::PutVoiceConnectorProxy;
#[doc(hidden)]
pub type PutVoiceConnectorProxyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl PutVoiceConnectorProxyInput {
    /// Consumes the builder and constructs an Operation<[`PutVoiceConnectorProxy`](crate::operation::PutVoiceConnectorProxy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutVoiceConnectorProxy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutVoiceConnectorProxyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_222 = &_input.voice_connector_id;
                let input_222 = input_222.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_222, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/programmable-numbers/proxy",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutVoiceConnectorProxyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_voice_connector_proxy(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutVoiceConnectorProxy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutVoiceConnectorProxy",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutVoiceConnectorProxyInput`](crate::input::PutVoiceConnectorProxyInput)
    pub fn builder() -> crate::input::put_voice_connector_proxy_input::Builder {
        crate::input::put_voice_connector_proxy_input::Builder::default()
    }
}

/// See [`PutVoiceConnectorStreamingConfigurationInput`](crate::input::PutVoiceConnectorStreamingConfigurationInput)
pub mod put_voice_connector_streaming_configuration_input {

    /// A builder for [`PutVoiceConnectorStreamingConfigurationInput`](crate::input::PutVoiceConnectorStreamingConfigurationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) streaming_configuration:
            std::option::Option<crate::model::StreamingConfiguration>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The streaming configuration details to add.</p>
        pub fn streaming_configuration(
            mut self,
            input: crate::model::StreamingConfiguration,
        ) -> Self {
            self.streaming_configuration = Some(input);
            self
        }
        /// <p>The streaming configuration details to add.</p>
        pub fn set_streaming_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamingConfiguration>,
        ) -> Self {
            self.streaming_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutVoiceConnectorStreamingConfigurationInput`](crate::input::PutVoiceConnectorStreamingConfigurationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutVoiceConnectorStreamingConfigurationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutVoiceConnectorStreamingConfigurationInput {
                voice_connector_id: self.voice_connector_id,
                streaming_configuration: self.streaming_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutVoiceConnectorStreamingConfigurationInputOperationOutputAlias =
    crate::operation::PutVoiceConnectorStreamingConfiguration;
#[doc(hidden)]
pub type PutVoiceConnectorStreamingConfigurationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutVoiceConnectorStreamingConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutVoiceConnectorStreamingConfiguration`](crate::operation::PutVoiceConnectorStreamingConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutVoiceConnectorStreamingConfiguration,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutVoiceConnectorStreamingConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_223 = &_input.voice_connector_id;
                let input_223 = input_223.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_223, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/streaming-configuration",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutVoiceConnectorStreamingConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_voice_connector_streaming_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutVoiceConnectorStreamingConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutVoiceConnectorStreamingConfiguration",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutVoiceConnectorStreamingConfigurationInput`](crate::input::PutVoiceConnectorStreamingConfigurationInput)
    pub fn builder() -> crate::input::put_voice_connector_streaming_configuration_input::Builder {
        crate::input::put_voice_connector_streaming_configuration_input::Builder::default()
    }
}

/// See [`PutVoiceConnectorTerminationInput`](crate::input::PutVoiceConnectorTerminationInput)
pub mod put_voice_connector_termination_input {

    /// A builder for [`PutVoiceConnectorTerminationInput`](crate::input::PutVoiceConnectorTerminationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) termination: std::option::Option<crate::model::Termination>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The termination setting details to add.</p>
        pub fn termination(mut self, input: crate::model::Termination) -> Self {
            self.termination = Some(input);
            self
        }
        /// <p>The termination setting details to add.</p>
        pub fn set_termination(
            mut self,
            input: std::option::Option<crate::model::Termination>,
        ) -> Self {
            self.termination = input;
            self
        }
        /// Consumes the builder and constructs a [`PutVoiceConnectorTerminationInput`](crate::input::PutVoiceConnectorTerminationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutVoiceConnectorTerminationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutVoiceConnectorTerminationInput {
                voice_connector_id: self.voice_connector_id,
                termination: self.termination,
            })
        }
    }
}
#[doc(hidden)]
pub type PutVoiceConnectorTerminationInputOperationOutputAlias =
    crate::operation::PutVoiceConnectorTermination;
#[doc(hidden)]
pub type PutVoiceConnectorTerminationInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutVoiceConnectorTerminationInput {
    /// Consumes the builder and constructs an Operation<[`PutVoiceConnectorTermination`](crate::operation::PutVoiceConnectorTermination)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutVoiceConnectorTermination,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutVoiceConnectorTerminationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_224 = &_input.voice_connector_id;
                let input_224 = input_224.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_224, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/termination",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutVoiceConnectorTerminationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_voice_connector_termination(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutVoiceConnectorTermination::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutVoiceConnectorTermination",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutVoiceConnectorTerminationInput`](crate::input::PutVoiceConnectorTerminationInput)
    pub fn builder() -> crate::input::put_voice_connector_termination_input::Builder {
        crate::input::put_voice_connector_termination_input::Builder::default()
    }
}

/// See [`PutVoiceConnectorTerminationCredentialsInput`](crate::input::PutVoiceConnectorTerminationCredentialsInput)
pub mod put_voice_connector_termination_credentials_input {

    /// A builder for [`PutVoiceConnectorTerminationCredentialsInput`](crate::input::PutVoiceConnectorTerminationCredentialsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) credentials: std::option::Option<std::vec::Vec<crate::model::Credential>>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// Appends an item to `credentials`.
        ///
        /// To override the contents of this collection use [`set_credentials`](Self::set_credentials).
        ///
        /// <p>The termination SIP credentials.</p>
        pub fn credentials(mut self, input: crate::model::Credential) -> Self {
            let mut v = self.credentials.unwrap_or_default();
            v.push(input);
            self.credentials = Some(v);
            self
        }
        /// <p>The termination SIP credentials.</p>
        pub fn set_credentials(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Credential>>,
        ) -> Self {
            self.credentials = input;
            self
        }
        /// Consumes the builder and constructs a [`PutVoiceConnectorTerminationCredentialsInput`](crate::input::PutVoiceConnectorTerminationCredentialsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutVoiceConnectorTerminationCredentialsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutVoiceConnectorTerminationCredentialsInput {
                voice_connector_id: self.voice_connector_id,
                credentials: self.credentials,
            })
        }
    }
}
#[doc(hidden)]
pub type PutVoiceConnectorTerminationCredentialsInputOperationOutputAlias =
    crate::operation::PutVoiceConnectorTerminationCredentials;
#[doc(hidden)]
pub type PutVoiceConnectorTerminationCredentialsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl PutVoiceConnectorTerminationCredentialsInput {
    /// Consumes the builder and constructs an Operation<[`PutVoiceConnectorTerminationCredentials`](crate::operation::PutVoiceConnectorTerminationCredentials)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutVoiceConnectorTerminationCredentials,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutVoiceConnectorTerminationCredentialsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_225 = &_input.voice_connector_id;
                let input_225 = input_225.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_225, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/termination/credentials",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::PutVoiceConnectorTerminationCredentialsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "put");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutVoiceConnectorTerminationCredentialsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_voice_connector_termination_credentials(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutVoiceConnectorTerminationCredentials::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutVoiceConnectorTerminationCredentials",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutVoiceConnectorTerminationCredentialsInput`](crate::input::PutVoiceConnectorTerminationCredentialsInput)
    pub fn builder() -> crate::input::put_voice_connector_termination_credentials_input::Builder {
        crate::input::put_voice_connector_termination_credentials_input::Builder::default()
    }
}

/// See [`RedactChannelMessageInput`](crate::input::RedactChannelMessageInput)
pub mod redact_channel_message_input {

    /// A builder for [`RedactChannelMessageInput`](crate::input::RedactChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel containing the messages that you want to redact.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel containing the messages that you want to redact.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ID of the message being redacted.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p>The ID of the message being redacted.</p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`RedactChannelMessageInput`](crate::input::RedactChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RedactChannelMessageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RedactChannelMessageInput {
                channel_arn: self.channel_arn,
                message_id: self.message_id,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type RedactChannelMessageInputOperationOutputAlias = crate::operation::RedactChannelMessage;
#[doc(hidden)]
pub type RedactChannelMessageInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RedactChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`RedactChannelMessage`](crate::operation::RedactChannelMessage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RedactChannelMessage,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RedactChannelMessageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_226 = &_input.channel_arn;
                let input_226 = input_226.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_226, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_227 = &_input.message_id;
                let input_227 = input_227.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let message_id = aws_smithy_http::label::fmt_string(input_227, false);
                if message_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/messages/{MessageId}",
                    ChannelArn = channel_arn,
                    MessageId = message_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::RedactChannelMessageInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "redact");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RedactChannelMessageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_redact_channel_message(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RedactChannelMessage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RedactChannelMessage",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RedactChannelMessageInput`](crate::input::RedactChannelMessageInput)
    pub fn builder() -> crate::input::redact_channel_message_input::Builder {
        crate::input::redact_channel_message_input::Builder::default()
    }
}

/// See [`RedactConversationMessageInput`](crate::input::RedactConversationMessageInput)
pub mod redact_conversation_message_input {

    /// A builder for [`RedactConversationMessageInput`](crate::input::RedactConversationMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) conversation_id: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The conversation ID.</p>
        pub fn conversation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.conversation_id = Some(input.into());
            self
        }
        /// <p>The conversation ID.</p>
        pub fn set_conversation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conversation_id = input;
            self
        }
        /// <p>The message ID.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p>The message ID.</p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RedactConversationMessageInput`](crate::input::RedactConversationMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RedactConversationMessageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RedactConversationMessageInput {
                account_id: self.account_id,
                conversation_id: self.conversation_id,
                message_id: self.message_id,
            })
        }
    }
}
#[doc(hidden)]
pub type RedactConversationMessageInputOperationOutputAlias =
    crate::operation::RedactConversationMessage;
#[doc(hidden)]
pub type RedactConversationMessageInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RedactConversationMessageInput {
    /// Consumes the builder and constructs an Operation<[`RedactConversationMessage`](crate::operation::RedactConversationMessage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RedactConversationMessage,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RedactConversationMessageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_228 = &_input.account_id;
                let input_228 = input_228.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_228, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_229 = &_input.conversation_id;
                let input_229 = input_229.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "conversation_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let conversation_id = aws_smithy_http::label::fmt_string(input_229, false);
                if conversation_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "conversation_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_230 = &_input.message_id;
                let input_230 = input_230.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let message_id = aws_smithy_http::label::fmt_string(input_230, false);
                if message_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/conversations/{ConversationId}/messages/{MessageId}",
                    AccountId = account_id,
                    ConversationId = conversation_id,
                    MessageId = message_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::RedactConversationMessageInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "redact");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RedactConversationMessageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RedactConversationMessage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RedactConversationMessage",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RedactConversationMessageInput`](crate::input::RedactConversationMessageInput)
    pub fn builder() -> crate::input::redact_conversation_message_input::Builder {
        crate::input::redact_conversation_message_input::Builder::default()
    }
}

/// See [`RedactRoomMessageInput`](crate::input::RedactRoomMessageInput)
pub mod redact_room_message_input {

    /// A builder for [`RedactRoomMessageInput`](crate::input::RedactRoomMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) room_id: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The room ID.</p>
        pub fn room_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.room_id = Some(input.into());
            self
        }
        /// <p>The room ID.</p>
        pub fn set_room_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.room_id = input;
            self
        }
        /// <p>The message ID.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p>The message ID.</p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RedactRoomMessageInput`](crate::input::RedactRoomMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RedactRoomMessageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RedactRoomMessageInput {
                account_id: self.account_id,
                room_id: self.room_id,
                message_id: self.message_id,
            })
        }
    }
}
#[doc(hidden)]
pub type RedactRoomMessageInputOperationOutputAlias = crate::operation::RedactRoomMessage;
#[doc(hidden)]
pub type RedactRoomMessageInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RedactRoomMessageInput {
    /// Consumes the builder and constructs an Operation<[`RedactRoomMessage`](crate::operation::RedactRoomMessage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RedactRoomMessage,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RedactRoomMessageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_231 = &_input.account_id;
                let input_231 = input_231.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_231, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_232 = &_input.room_id;
                let input_232 = input_232.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let room_id = aws_smithy_http::label::fmt_string(input_232, false);
                if room_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_233 = &_input.message_id;
                let input_233 = input_233.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let message_id = aws_smithy_http::label::fmt_string(input_233, false);
                if message_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms/{RoomId}/messages/{MessageId}",
                    AccountId = account_id,
                    RoomId = room_id,
                    MessageId = message_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::RedactRoomMessageInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "redact");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RedactRoomMessageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RedactRoomMessage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RedactRoomMessage",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RedactRoomMessageInput`](crate::input::RedactRoomMessageInput)
    pub fn builder() -> crate::input::redact_room_message_input::Builder {
        crate::input::redact_room_message_input::Builder::default()
    }
}

/// See [`RegenerateSecurityTokenInput`](crate::input::RegenerateSecurityTokenInput)
pub mod regenerate_security_token_input {

    /// A builder for [`RegenerateSecurityTokenInput`](crate::input::RegenerateSecurityTokenInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) bot_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The bot ID.</p>
        pub fn bot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bot_id = Some(input.into());
            self
        }
        /// <p>The bot ID.</p>
        pub fn set_bot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bot_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RegenerateSecurityTokenInput`](crate::input::RegenerateSecurityTokenInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RegenerateSecurityTokenInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RegenerateSecurityTokenInput {
                account_id: self.account_id,
                bot_id: self.bot_id,
            })
        }
    }
}
#[doc(hidden)]
pub type RegenerateSecurityTokenInputOperationOutputAlias =
    crate::operation::RegenerateSecurityToken;
#[doc(hidden)]
pub type RegenerateSecurityTokenInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RegenerateSecurityTokenInput {
    /// Consumes the builder and constructs an Operation<[`RegenerateSecurityToken`](crate::operation::RegenerateSecurityToken)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegenerateSecurityToken,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RegenerateSecurityTokenInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_234 = &_input.account_id;
                let input_234 = input_234.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_234, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_235 = &_input.bot_id;
                let input_235 = input_235.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let bot_id = aws_smithy_http::label::fmt_string(input_235, false);
                if bot_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/bots/{BotId}",
                    AccountId = account_id,
                    BotId = bot_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::RegenerateSecurityTokenInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "regenerate-security-token");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RegenerateSecurityTokenInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegenerateSecurityToken::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegenerateSecurityToken",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RegenerateSecurityTokenInput`](crate::input::RegenerateSecurityTokenInput)
    pub fn builder() -> crate::input::regenerate_security_token_input::Builder {
        crate::input::regenerate_security_token_input::Builder::default()
    }
}

/// See [`ResetPersonalPinInput`](crate::input::ResetPersonalPinInput)
pub mod reset_personal_pin_input {

    /// A builder for [`ResetPersonalPinInput`](crate::input::ResetPersonalPinInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The user ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The user ID.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ResetPersonalPinInput`](crate::input::ResetPersonalPinInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ResetPersonalPinInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ResetPersonalPinInput {
                account_id: self.account_id,
                user_id: self.user_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ResetPersonalPinInputOperationOutputAlias = crate::operation::ResetPersonalPIN;
#[doc(hidden)]
pub type ResetPersonalPinInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ResetPersonalPinInput {
    /// Consumes the builder and constructs an Operation<[`ResetPersonalPIN`](crate::operation::ResetPersonalPIN)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ResetPersonalPIN,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::ResetPersonalPinInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_236 = &_input.account_id;
                let input_236 = input_236.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_236, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_237 = &_input.user_id;
                let input_237 = input_237.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let user_id = aws_smithy_http::label::fmt_string(input_237, false);
                if user_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users/{UserId}",
                    AccountId = account_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ResetPersonalPinInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "reset-personal-pin");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ResetPersonalPinInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ResetPersonalPIN::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ResetPersonalPIN",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ResetPersonalPinInput`](crate::input::ResetPersonalPinInput)
    pub fn builder() -> crate::input::reset_personal_pin_input::Builder {
        crate::input::reset_personal_pin_input::Builder::default()
    }
}

/// See [`RestorePhoneNumberInput`](crate::input::RestorePhoneNumberInput)
pub mod restore_phone_number_input {

    /// A builder for [`RestorePhoneNumberInput`](crate::input::RestorePhoneNumberInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The phone number.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>The phone number.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RestorePhoneNumberInput`](crate::input::RestorePhoneNumberInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RestorePhoneNumberInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RestorePhoneNumberInput {
                phone_number_id: self.phone_number_id,
            })
        }
    }
}
#[doc(hidden)]
pub type RestorePhoneNumberInputOperationOutputAlias = crate::operation::RestorePhoneNumber;
#[doc(hidden)]
pub type RestorePhoneNumberInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RestorePhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`RestorePhoneNumber`](crate::operation::RestorePhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RestorePhoneNumber,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::RestorePhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_238 = &_input.phone_number_id;
                let input_238 = input_238.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let phone_number_id = aws_smithy_http::label::fmt_string(input_238, false);
                if phone_number_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/phone-numbers/{PhoneNumberId}",
                    PhoneNumberId = phone_number_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::RestorePhoneNumberInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "restore");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RestorePhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RestorePhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RestorePhoneNumber",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RestorePhoneNumberInput`](crate::input::RestorePhoneNumberInput)
    pub fn builder() -> crate::input::restore_phone_number_input::Builder {
        crate::input::restore_phone_number_input::Builder::default()
    }
}

/// See [`SearchAvailablePhoneNumbersInput`](crate::input::SearchAvailablePhoneNumbersInput)
pub mod search_available_phone_numbers_input {

    /// A builder for [`SearchAvailablePhoneNumbersInput`](crate::input::SearchAvailablePhoneNumbersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) area_code: std::option::Option<std::string::String>,
        pub(crate) city: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) toll_free_prefix: std::option::Option<std::string::String>,
        pub(crate) phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The area code used to filter results. Only applies to the US.</p>
        pub fn area_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.area_code = Some(input.into());
            self
        }
        /// <p>The area code used to filter results. Only applies to the US.</p>
        pub fn set_area_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.area_code = input;
            self
        }
        /// <p>The city used to filter results. Only applies to the US.</p>
        pub fn city(mut self, input: impl Into<std::string::String>) -> Self {
            self.city = Some(input.into());
            self
        }
        /// <p>The city used to filter results. Only applies to the US.</p>
        pub fn set_city(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.city = input;
            self
        }
        /// <p>The country used to filter results. Defaults to the US Format: ISO 3166-1 alpha-2.</p>
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        /// <p>The country used to filter results. Defaults to the US Format: ISO 3166-1 alpha-2.</p>
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// <p>The state used to filter results. Required only if you provide <code>City</code>. Only applies to the US.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The state used to filter results. Required only if you provide <code>City</code>. Only applies to the US.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The toll-free prefix that you use to filter results. Only applies to the US.</p>
        pub fn toll_free_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.toll_free_prefix = Some(input.into());
            self
        }
        /// <p>The toll-free prefix that you use to filter results. Only applies to the US.</p>
        pub fn set_toll_free_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.toll_free_prefix = input;
            self
        }
        /// <p>The phone number type used to filter results. Required for non-US numbers.</p>
        pub fn phone_number_type(mut self, input: crate::model::PhoneNumberType) -> Self {
            self.phone_number_type = Some(input);
            self
        }
        /// <p>The phone number type used to filter results. Required for non-US numbers.</p>
        pub fn set_phone_number_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberType>,
        ) -> Self {
            self.phone_number_type = input;
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token used to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token used to retrieve the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchAvailablePhoneNumbersInput`](crate::input::SearchAvailablePhoneNumbersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SearchAvailablePhoneNumbersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SearchAvailablePhoneNumbersInput {
                area_code: self.area_code,
                city: self.city,
                country: self.country,
                state: self.state,
                toll_free_prefix: self.toll_free_prefix,
                phone_number_type: self.phone_number_type,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type SearchAvailablePhoneNumbersInputOperationOutputAlias =
    crate::operation::SearchAvailablePhoneNumbers;
#[doc(hidden)]
pub type SearchAvailablePhoneNumbersInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl SearchAvailablePhoneNumbersInput {
    /// Consumes the builder and constructs an Operation<[`SearchAvailablePhoneNumbers`](crate::operation::SearchAvailablePhoneNumbers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchAvailablePhoneNumbers,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchAvailablePhoneNumbersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/search").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::SearchAvailablePhoneNumbersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("type", "phone-numbers");
                if let Some(inner_239) = &_input.area_code {
                    query.push_kv("area-code", &aws_smithy_http::query::fmt_string(&inner_239));
                }
                if let Some(inner_240) = &_input.city {
                    query.push_kv("city", &aws_smithy_http::query::fmt_string(&inner_240));
                }
                if let Some(inner_241) = &_input.country {
                    query.push_kv("country", &aws_smithy_http::query::fmt_string(&inner_241));
                }
                if let Some(inner_242) = &_input.state {
                    query.push_kv("state", &aws_smithy_http::query::fmt_string(&inner_242));
                }
                if let Some(inner_243) = &_input.toll_free_prefix {
                    query.push_kv(
                        "toll-free-prefix",
                        &aws_smithy_http::query::fmt_string(&inner_243),
                    );
                }
                if let Some(inner_244) = &_input.phone_number_type {
                    query.push_kv(
                        "phone-number-type",
                        &aws_smithy_http::query::fmt_string(&inner_244),
                    );
                }
                if let Some(inner_245) = &_input.max_results {
                    query.push_kv(
                        "max-results",
                        aws_smithy_types::primitive::Encoder::from(*inner_245).encode(),
                    );
                }
                if let Some(inner_246) = &_input.next_token {
                    query.push_kv(
                        "next-token",
                        &aws_smithy_http::query::fmt_string(&inner_246),
                    );
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchAvailablePhoneNumbersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchAvailablePhoneNumbers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchAvailablePhoneNumbers",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SearchAvailablePhoneNumbersInput`](crate::input::SearchAvailablePhoneNumbersInput)
    pub fn builder() -> crate::input::search_available_phone_numbers_input::Builder {
        crate::input::search_available_phone_numbers_input::Builder::default()
    }
}

/// See [`SendChannelMessageInput`](crate::input::SendChannelMessageInput)
pub mod send_channel_message_input {

    /// A builder for [`SendChannelMessageInput`](crate::input::SendChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ChannelMessageType>,
        pub(crate) persistence: std::option::Option<crate::model::ChannelMessagePersistenceType>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The content of the message.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the message.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
        pub fn r#type(mut self, input: crate::model::ChannelMessageType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ChannelMessageType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
        pub fn persistence(mut self, input: crate::model::ChannelMessagePersistenceType) -> Self {
            self.persistence = Some(input);
            self
        }
        /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
        pub fn set_persistence(
            mut self,
            input: std::option::Option<crate::model::ChannelMessagePersistenceType>,
        ) -> Self {
            self.persistence = input;
            self
        }
        /// <p>The optional metadata for each message.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        /// <p>The optional metadata for each message.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The <code>Idempotency</code> token for each client request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        /// <p>The <code>Idempotency</code> token for each client request.</p>
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`SendChannelMessageInput`](crate::input::SendChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SendChannelMessageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SendChannelMessageInput {
                channel_arn: self.channel_arn,
                content: self.content,
                r#type: self.r#type,
                persistence: self.persistence,
                metadata: self.metadata,
                client_request_token: self.client_request_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type SendChannelMessageInputOperationOutputAlias = crate::operation::SendChannelMessage;
#[doc(hidden)]
pub type SendChannelMessageInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl SendChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`SendChannelMessage`](crate::operation::SendChannelMessage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SendChannelMessage,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::SendChannelMessageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_247 = &_input.channel_arn;
                let input_247 = input_247.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_247, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/messages",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SendChannelMessageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_send_channel_message(input, builder)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_send_channel_message(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SendChannelMessage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SendChannelMessage",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SendChannelMessageInput`](crate::input::SendChannelMessageInput)
    pub fn builder() -> crate::input::send_channel_message_input::Builder {
        crate::input::send_channel_message_input::Builder::default()
    }
}

/// See [`StartMeetingTranscriptionInput`](crate::input::StartMeetingTranscriptionInput)
pub mod start_meeting_transcription_input {

    /// A builder for [`StartMeetingTranscriptionInput`](crate::input::StartMeetingTranscriptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) transcription_configuration:
            std::option::Option<crate::model::TranscriptionConfiguration>,
    }
    impl Builder {
        /// <p>The unique ID of the meeting being transcribed.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the meeting being transcribed.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// <p>The configuration for the current transcription operation. Must contain <code>EngineTranscribeSettings</code> or <code>EngineTranscribeMedicalSettings</code>.</p>
        pub fn transcription_configuration(
            mut self,
            input: crate::model::TranscriptionConfiguration,
        ) -> Self {
            self.transcription_configuration = Some(input);
            self
        }
        /// <p>The configuration for the current transcription operation. Must contain <code>EngineTranscribeSettings</code> or <code>EngineTranscribeMedicalSettings</code>.</p>
        pub fn set_transcription_configuration(
            mut self,
            input: std::option::Option<crate::model::TranscriptionConfiguration>,
        ) -> Self {
            self.transcription_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`StartMeetingTranscriptionInput`](crate::input::StartMeetingTranscriptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartMeetingTranscriptionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartMeetingTranscriptionInput {
                meeting_id: self.meeting_id,
                transcription_configuration: self.transcription_configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type StartMeetingTranscriptionInputOperationOutputAlias =
    crate::operation::StartMeetingTranscription;
#[doc(hidden)]
pub type StartMeetingTranscriptionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl StartMeetingTranscriptionInput {
    /// Consumes the builder and constructs an Operation<[`StartMeetingTranscription`](crate::operation::StartMeetingTranscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartMeetingTranscription,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartMeetingTranscriptionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_248 = &_input.meeting_id;
                let input_248 = input_248.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_248, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/transcription",
                    MeetingId = meeting_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::StartMeetingTranscriptionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "start");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartMeetingTranscriptionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_meeting_transcription(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartMeetingTranscription::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartMeetingTranscription",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartMeetingTranscriptionInput`](crate::input::StartMeetingTranscriptionInput)
    pub fn builder() -> crate::input::start_meeting_transcription_input::Builder {
        crate::input::start_meeting_transcription_input::Builder::default()
    }
}

/// See [`StopMeetingTranscriptionInput`](crate::input::StopMeetingTranscriptionInput)
pub mod stop_meeting_transcription_input {

    /// A builder for [`StopMeetingTranscriptionInput`](crate::input::StopMeetingTranscriptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the meeting for which you stop transcription.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the meeting for which you stop transcription.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopMeetingTranscriptionInput`](crate::input::StopMeetingTranscriptionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StopMeetingTranscriptionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StopMeetingTranscriptionInput {
                meeting_id: self.meeting_id,
            })
        }
    }
}
#[doc(hidden)]
pub type StopMeetingTranscriptionInputOperationOutputAlias =
    crate::operation::StopMeetingTranscription;
#[doc(hidden)]
pub type StopMeetingTranscriptionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl StopMeetingTranscriptionInput {
    /// Consumes the builder and constructs an Operation<[`StopMeetingTranscription`](crate::operation::StopMeetingTranscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopMeetingTranscription,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::StopMeetingTranscriptionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_249 = &_input.meeting_id;
                let input_249 = input_249.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_249, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/transcription",
                    MeetingId = meeting_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::StopMeetingTranscriptionInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "stop");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StopMeetingTranscriptionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopMeetingTranscription::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopMeetingTranscription",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StopMeetingTranscriptionInput`](crate::input::StopMeetingTranscriptionInput)
    pub fn builder() -> crate::input::stop_meeting_transcription_input::Builder {
        crate::input::stop_meeting_transcription_input::Builder::default()
    }
}

/// See [`TagAttendeeInput`](crate::input::TagAttendeeInput)
pub mod tag_attendee_input {

    /// A builder for [`TagAttendeeInput`](crate::input::TagAttendeeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) attendee_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn attendee_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attendee_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn set_attendee_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attendee_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag key-value pairs.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tag key-value pairs.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagAttendeeInput`](crate::input::TagAttendeeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagAttendeeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagAttendeeInput {
                meeting_id: self.meeting_id,
                attendee_id: self.attendee_id,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagAttendeeInputOperationOutputAlias = crate::operation::TagAttendee;
#[doc(hidden)]
pub type TagAttendeeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl TagAttendeeInput {
    /// Consumes the builder and constructs an Operation<[`TagAttendee`](crate::operation::TagAttendee)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagAttendee,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagAttendeeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_250 = &_input.meeting_id;
                let input_250 = input_250.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_250, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_251 = &_input.attendee_id;
                let input_251 = input_251.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let attendee_id = aws_smithy_http::label::fmt_string(input_251, false);
                if attendee_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/attendees/{AttendeeId}/tags",
                    MeetingId = meeting_id,
                    AttendeeId = attendee_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::TagAttendeeInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "add");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagAttendeeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_attendee(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagAttendee::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagAttendee",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagAttendeeInput`](crate::input::TagAttendeeInput)
    pub fn builder() -> crate::input::tag_attendee_input::Builder {
        crate::input::tag_attendee_input::Builder::default()
    }
}

/// See [`TagMeetingInput`](crate::input::TagMeetingInput)
pub mod tag_meeting_input {

    /// A builder for [`TagMeetingInput`](crate::input::TagMeetingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag key-value pairs.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tag key-value pairs.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagMeetingInput`](crate::input::TagMeetingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagMeetingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagMeetingInput {
                meeting_id: self.meeting_id,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagMeetingInputOperationOutputAlias = crate::operation::TagMeeting;
#[doc(hidden)]
pub type TagMeetingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl TagMeetingInput {
    /// Consumes the builder and constructs an Operation<[`TagMeeting`](crate::operation::TagMeeting)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagMeeting,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagMeetingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_252 = &_input.meeting_id;
                let input_252 = input_252.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_252, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/meetings/{MeetingId}/tags", MeetingId = meeting_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::TagMeetingInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "add");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagMeetingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_meeting(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagMeeting::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagMeeting",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagMeetingInput`](crate::input::TagMeetingInput)
    pub fn builder() -> crate::input::tag_meeting_input::Builder {
        crate::input::tag_meeting_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The resource ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The resource ARN.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag key-value pairs.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tag key-value pairs.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/tags").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::TagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "tag-resource");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagAttendeeInput`](crate::input::UntagAttendeeInput)
pub mod untag_attendee_input {

    /// A builder for [`UntagAttendeeInput`](crate::input::UntagAttendeeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) attendee_id: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn attendee_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attendee_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK attendee ID.</p>
        pub fn set_attendee_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attendee_id = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The tag keys.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The tag keys.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagAttendeeInput`](crate::input::UntagAttendeeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagAttendeeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagAttendeeInput {
                meeting_id: self.meeting_id,
                attendee_id: self.attendee_id,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagAttendeeInputOperationOutputAlias = crate::operation::UntagAttendee;
#[doc(hidden)]
pub type UntagAttendeeInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UntagAttendeeInput {
    /// Consumes the builder and constructs an Operation<[`UntagAttendee`](crate::operation::UntagAttendee)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagAttendee,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagAttendeeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_253 = &_input.meeting_id;
                let input_253 = input_253.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_253, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_254 = &_input.attendee_id;
                let input_254 = input_254.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let attendee_id = aws_smithy_http::label::fmt_string(input_254, false);
                if attendee_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attendee_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/meetings/{MeetingId}/attendees/{AttendeeId}/tags",
                    MeetingId = meeting_id,
                    AttendeeId = attendee_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagAttendeeInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "delete");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagAttendeeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_untag_attendee(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagAttendee::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagAttendee",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagAttendeeInput`](crate::input::UntagAttendeeInput)
    pub fn builder() -> crate::input::untag_attendee_input::Builder {
        crate::input::untag_attendee_input::Builder::default()
    }
}

/// See [`UntagMeetingInput`](crate::input::UntagMeetingInput)
pub mod untag_meeting_input {

    /// A builder for [`UntagMeetingInput`](crate::input::UntagMeetingInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) meeting_id: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn meeting_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.meeting_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime SDK meeting ID.</p>
        pub fn set_meeting_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meeting_id = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The tag keys.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The tag keys.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagMeetingInput`](crate::input::UntagMeetingInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagMeetingInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagMeetingInput {
                meeting_id: self.meeting_id,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagMeetingInputOperationOutputAlias = crate::operation::UntagMeeting;
#[doc(hidden)]
pub type UntagMeetingInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UntagMeetingInput {
    /// Consumes the builder and constructs an Operation<[`UntagMeeting`](crate::operation::UntagMeeting)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagMeeting,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagMeetingInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_255 = &_input.meeting_id;
                let input_255 = input_255.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let meeting_id = aws_smithy_http::label::fmt_string(input_255, false);
                if meeting_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "meeting_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/meetings/{MeetingId}/tags", MeetingId = meeting_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagMeetingInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "delete");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagMeetingInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_untag_meeting(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagMeeting::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagMeeting",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagMeetingInput`](crate::input::UntagMeetingInput)
    pub fn builder() -> crate::input::untag_meeting_input::Builder {
        crate::input::untag_meeting_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The resource ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The resource ARN.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The tag keys.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The tag keys.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/tags").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                query.push_kv("operation", "untag-resource");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateAccountInput`](crate::input::UpdateAccountInput)
pub mod update_account_input {

    /// A builder for [`UpdateAccountInput`](crate::input::UpdateAccountInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) default_license: std::option::Option<crate::model::License>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The new name for the specified Amazon Chime account.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The new name for the specified Amazon Chime account.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The default license applied when you add users to an Amazon Chime account.</p>
        pub fn default_license(mut self, input: crate::model::License) -> Self {
            self.default_license = Some(input);
            self
        }
        /// <p>The default license applied when you add users to an Amazon Chime account.</p>
        pub fn set_default_license(
            mut self,
            input: std::option::Option<crate::model::License>,
        ) -> Self {
            self.default_license = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAccountInput`](crate::input::UpdateAccountInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateAccountInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateAccountInput {
                account_id: self.account_id,
                name: self.name,
                default_license: self.default_license,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAccountInputOperationOutputAlias = crate::operation::UpdateAccount;
#[doc(hidden)]
pub type UpdateAccountInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateAccountInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAccount`](crate::operation::UpdateAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAccount,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_256 = &_input.account_id;
                let input_256 = input_256.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_256, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/accounts/{AccountId}", AccountId = account_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_account(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAccount",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAccountInput`](crate::input::UpdateAccountInput)
    pub fn builder() -> crate::input::update_account_input::Builder {
        crate::input::update_account_input::Builder::default()
    }
}

/// See [`UpdateAccountSettingsInput`](crate::input::UpdateAccountSettingsInput)
pub mod update_account_settings_input {

    /// A builder for [`UpdateAccountSettingsInput`](crate::input::UpdateAccountSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) account_settings: std::option::Option<crate::model::AccountSettings>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The Amazon Chime account settings to update.</p>
        pub fn account_settings(mut self, input: crate::model::AccountSettings) -> Self {
            self.account_settings = Some(input);
            self
        }
        /// <p>The Amazon Chime account settings to update.</p>
        pub fn set_account_settings(
            mut self,
            input: std::option::Option<crate::model::AccountSettings>,
        ) -> Self {
            self.account_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAccountSettingsInput`](crate::input::UpdateAccountSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateAccountSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateAccountSettingsInput {
                account_id: self.account_id,
                account_settings: self.account_settings,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAccountSettingsInputOperationOutputAlias = crate::operation::UpdateAccountSettings;
#[doc(hidden)]
pub type UpdateAccountSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateAccountSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAccountSettings`](crate::operation::UpdateAccountSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAccountSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAccountSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_257 = &_input.account_id;
                let input_257 = input_257.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_257, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/settings",
                    AccountId = account_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAccountSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_account_settings(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAccountSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAccountSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAccountSettingsInput`](crate::input::UpdateAccountSettingsInput)
    pub fn builder() -> crate::input::update_account_settings_input::Builder {
        crate::input::update_account_settings_input::Builder::default()
    }
}

/// See [`UpdateAppInstanceInput`](crate::input::UpdateAppInstanceInput)
pub mod update_app_instance_input {

    /// A builder for [`UpdateAppInstanceInput`](crate::input::UpdateAppInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// <p>The name that you want to change.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name that you want to change.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The metadata that you want to change.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        /// <p>The metadata that you want to change.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAppInstanceInput`](crate::input::UpdateAppInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateAppInstanceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateAppInstanceInput {
                app_instance_arn: self.app_instance_arn,
                name: self.name,
                metadata: self.metadata,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAppInstanceInputOperationOutputAlias = crate::operation::UpdateAppInstance;
#[doc(hidden)]
pub type UpdateAppInstanceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateAppInstanceInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAppInstance`](crate::operation::UpdateAppInstance)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAppInstance,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAppInstanceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_258 = &_input.app_instance_arn;
                let input_258 = input_258.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_arn = aws_smithy_http::label::fmt_string(input_258, false);
                if app_instance_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instances/{AppInstanceArn}",
                    AppInstanceArn = app_instance_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAppInstanceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_app_instance(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAppInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAppInstance",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAppInstanceInput`](crate::input::UpdateAppInstanceInput)
    pub fn builder() -> crate::input::update_app_instance_input::Builder {
        crate::input::update_app_instance_input::Builder::default()
    }
}

/// See [`UpdateAppInstanceUserInput`](crate::input::UpdateAppInstanceUserInput)
pub mod update_app_instance_user_input {

    /// A builder for [`UpdateAppInstanceUserInput`](crate::input::UpdateAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstanceUser</code>.</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the <code>AppInstanceUser</code>.</p>
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// <p>The name of the <code>AppInstanceUser</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the <code>AppInstanceUser</code>.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The metadata of the <code>AppInstanceUser</code>.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        /// <p>The metadata of the <code>AppInstanceUser</code>.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAppInstanceUserInput`](crate::input::UpdateAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateAppInstanceUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateAppInstanceUserInput {
                app_instance_user_arn: self.app_instance_user_arn,
                name: self.name,
                metadata: self.metadata,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateAppInstanceUserInputOperationOutputAlias = crate::operation::UpdateAppInstanceUser;
#[doc(hidden)]
pub type UpdateAppInstanceUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAppInstanceUser`](crate::operation::UpdateAppInstanceUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAppInstanceUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAppInstanceUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_259 = &_input.app_instance_user_arn;
                let input_259 = input_259.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_user_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let app_instance_user_arn = aws_smithy_http::label::fmt_string(input_259, false);
                if app_instance_user_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "app_instance_user_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/app-instance-users/{AppInstanceUserArn}",
                    AppInstanceUserArn = app_instance_user_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAppInstanceUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_app_instance_user(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("identity-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAppInstanceUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAppInstanceUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAppInstanceUserInput`](crate::input::UpdateAppInstanceUserInput)
    pub fn builder() -> crate::input::update_app_instance_user_input::Builder {
        crate::input::update_app_instance_user_input::Builder::default()
    }
}

/// See [`UpdateBotInput`](crate::input::UpdateBotInput)
pub mod update_bot_input {

    /// A builder for [`UpdateBotInput`](crate::input::UpdateBotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) bot_id: std::option::Option<std::string::String>,
        pub(crate) disabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The bot ID.</p>
        pub fn bot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bot_id = Some(input.into());
            self
        }
        /// <p>The bot ID.</p>
        pub fn set_bot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bot_id = input;
            self
        }
        /// <p>When true, stops the specified bot from running in your account.</p>
        pub fn disabled(mut self, input: bool) -> Self {
            self.disabled = Some(input);
            self
        }
        /// <p>When true, stops the specified bot from running in your account.</p>
        pub fn set_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.disabled = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateBotInput`](crate::input::UpdateBotInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UpdateBotInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateBotInput {
                account_id: self.account_id,
                bot_id: self.bot_id,
                disabled: self.disabled,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateBotInputOperationOutputAlias = crate::operation::UpdateBot;
#[doc(hidden)]
pub type UpdateBotInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateBotInput {
    /// Consumes the builder and constructs an Operation<[`UpdateBot`](crate::operation::UpdateBot)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateBot,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateBotInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_260 = &_input.account_id;
                let input_260 = input_260.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_260, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_261 = &_input.bot_id;
                let input_261 = input_261.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let bot_id = aws_smithy_http::label::fmt_string(input_261, false);
                if bot_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "bot_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/bots/{BotId}",
                    AccountId = account_id,
                    BotId = bot_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateBotInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_bot(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateBot::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "UpdateBot",
                    "chime",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateBotInput`](crate::input::UpdateBotInput)
    pub fn builder() -> crate::input::update_bot_input::Builder {
        crate::input::update_bot_input::Builder::default()
    }
}

/// See [`UpdateChannelInput`](crate::input::UpdateChannelInput)
pub mod update_channel_input {

    /// A builder for [`UpdateChannelInput`](crate::input::UpdateChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) mode: std::option::Option<crate::model::ChannelMode>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The name of the channel.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the channel.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The mode of the update request.</p>
        pub fn mode(mut self, input: crate::model::ChannelMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>The mode of the update request.</p>
        pub fn set_mode(mut self, input: std::option::Option<crate::model::ChannelMode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>The metadata for the update request.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        /// <p>The metadata for the update request.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateChannelInput`](crate::input::UpdateChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateChannelInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateChannelInput {
                channel_arn: self.channel_arn,
                name: self.name,
                mode: self.mode,
                metadata: self.metadata,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateChannelInputOperationOutputAlias = crate::operation::UpdateChannel;
#[doc(hidden)]
pub type UpdateChannelInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateChannelInput {
    /// Consumes the builder and constructs an Operation<[`UpdateChannel`](crate::operation::UpdateChannel)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateChannel,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateChannelInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_262 = &_input.channel_arn;
                let input_262 = input_262.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_262, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateChannelInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder = crate::http_serde::add_headers_update_channel(input, builder)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_channel(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateChannel::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateChannel",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateChannelInput`](crate::input::UpdateChannelInput)
    pub fn builder() -> crate::input::update_channel_input::Builder {
        crate::input::update_channel_input::Builder::default()
    }
}

/// See [`UpdateChannelMessageInput`](crate::input::UpdateChannelMessageInput)
pub mod update_channel_message_input {

    /// A builder for [`UpdateChannelMessageInput`](crate::input::UpdateChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ID string of the message being updated.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p>The ID string of the message being updated.</p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The content of the message being updated.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the message being updated.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The metadata of the message being updated.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        /// <p>The metadata of the message being updated.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateChannelMessageInput`](crate::input::UpdateChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateChannelMessageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateChannelMessageInput {
                channel_arn: self.channel_arn,
                message_id: self.message_id,
                content: self.content,
                metadata: self.metadata,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateChannelMessageInputOperationOutputAlias = crate::operation::UpdateChannelMessage;
#[doc(hidden)]
pub type UpdateChannelMessageInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`UpdateChannelMessage`](crate::operation::UpdateChannelMessage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateChannelMessage,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateChannelMessageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_263 = &_input.channel_arn;
                let input_263 = input_263.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_263, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                let input_264 = &_input.message_id;
                let input_264 = input_264.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let message_id = aws_smithy_http::label::fmt_string(input_264, false);
                if message_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/messages/{MessageId}",
                    ChannelArn = channel_arn,
                    MessageId = message_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateChannelMessageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_update_channel_message(input, builder)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_channel_message(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateChannelMessage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateChannelMessage",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateChannelMessageInput`](crate::input::UpdateChannelMessageInput)
    pub fn builder() -> crate::input::update_channel_message_input::Builder {
        crate::input::update_channel_message_input::Builder::default()
    }
}

/// See [`UpdateChannelReadMarkerInput`](crate::input::UpdateChannelReadMarkerInput)
pub mod update_channel_read_marker_input {

    /// A builder for [`UpdateChannelReadMarkerInput`](crate::input::UpdateChannelReadMarkerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the channel.</p>
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateChannelReadMarkerInput`](crate::input::UpdateChannelReadMarkerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateChannelReadMarkerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateChannelReadMarkerInput {
                channel_arn: self.channel_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateChannelReadMarkerInputOperationOutputAlias =
    crate::operation::UpdateChannelReadMarker;
#[doc(hidden)]
pub type UpdateChannelReadMarkerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateChannelReadMarkerInput {
    /// Consumes the builder and constructs an Operation<[`UpdateChannelReadMarker`](crate::operation::UpdateChannelReadMarker)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateChannelReadMarker,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateChannelReadMarkerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_265 = &_input.channel_arn;
                let input_265 = input_265.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    },
                )?;
                let channel_arn = aws_smithy_http::label::fmt_string(input_265, false);
                if channel_arn.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/channels/{ChannelArn}/readMarker",
                    ChannelArn = channel_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateChannelReadMarkerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                let builder =
                    crate::http_serde::add_headers_update_channel_read_marker(input, builder)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        let endpoint_prefix = aws_smithy_http::endpoint::EndpointPrefix::new("messaging-")?;
        request.properties_mut().insert(endpoint_prefix);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateChannelReadMarker::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateChannelReadMarker",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateChannelReadMarkerInput`](crate::input::UpdateChannelReadMarkerInput)
    pub fn builder() -> crate::input::update_channel_read_marker_input::Builder {
        crate::input::update_channel_read_marker_input::Builder::default()
    }
}

/// See [`UpdateGlobalSettingsInput`](crate::input::UpdateGlobalSettingsInput)
pub mod update_global_settings_input {

    /// A builder for [`UpdateGlobalSettingsInput`](crate::input::UpdateGlobalSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) business_calling: std::option::Option<crate::model::BusinessCallingSettings>,
        pub(crate) voice_connector: std::option::Option<crate::model::VoiceConnectorSettings>,
    }
    impl Builder {
        /// <p>The Amazon Chime Business Calling settings.</p>
        pub fn business_calling(mut self, input: crate::model::BusinessCallingSettings) -> Self {
            self.business_calling = Some(input);
            self
        }
        /// <p>The Amazon Chime Business Calling settings.</p>
        pub fn set_business_calling(
            mut self,
            input: std::option::Option<crate::model::BusinessCallingSettings>,
        ) -> Self {
            self.business_calling = input;
            self
        }
        /// <p>The Amazon Chime Voice Connector settings.</p>
        pub fn voice_connector(mut self, input: crate::model::VoiceConnectorSettings) -> Self {
            self.voice_connector = Some(input);
            self
        }
        /// <p>The Amazon Chime Voice Connector settings.</p>
        pub fn set_voice_connector(
            mut self,
            input: std::option::Option<crate::model::VoiceConnectorSettings>,
        ) -> Self {
            self.voice_connector = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateGlobalSettingsInput`](crate::input::UpdateGlobalSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateGlobalSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateGlobalSettingsInput {
                business_calling: self.business_calling,
                voice_connector: self.voice_connector,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateGlobalSettingsInputOperationOutputAlias = crate::operation::UpdateGlobalSettings;
#[doc(hidden)]
pub type UpdateGlobalSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateGlobalSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateGlobalSettings`](crate::operation::UpdateGlobalSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateGlobalSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateGlobalSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/settings").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateGlobalSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_global_settings(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateGlobalSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateGlobalSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateGlobalSettingsInput`](crate::input::UpdateGlobalSettingsInput)
    pub fn builder() -> crate::input::update_global_settings_input::Builder {
        crate::input::update_global_settings_input::Builder::default()
    }
}

/// See [`UpdatePhoneNumberInput`](crate::input::UpdatePhoneNumberInput)
pub mod update_phone_number_input {

    /// A builder for [`UpdatePhoneNumberInput`](crate::input::UpdatePhoneNumberInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) phone_number_id: std::option::Option<std::string::String>,
        pub(crate) product_type: std::option::Option<crate::model::PhoneNumberProductType>,
        pub(crate) calling_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The phone number ID.</p>
        pub fn phone_number_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number_id = Some(input.into());
            self
        }
        /// <p>The phone number ID.</p>
        pub fn set_phone_number_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.phone_number_id = input;
            self
        }
        /// <p>The product type.</p>
        pub fn product_type(mut self, input: crate::model::PhoneNumberProductType) -> Self {
            self.product_type = Some(input);
            self
        }
        /// <p>The product type.</p>
        pub fn set_product_type(
            mut self,
            input: std::option::Option<crate::model::PhoneNumberProductType>,
        ) -> Self {
            self.product_type = input;
            self
        }
        /// <p>The outbound calling name associated with the phone number.</p>
        pub fn calling_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.calling_name = Some(input.into());
            self
        }
        /// <p>The outbound calling name associated with the phone number.</p>
        pub fn set_calling_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.calling_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePhoneNumberInput`](crate::input::UpdatePhoneNumberInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdatePhoneNumberInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdatePhoneNumberInput {
                phone_number_id: self.phone_number_id,
                product_type: self.product_type,
                calling_name: self.calling_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdatePhoneNumberInputOperationOutputAlias = crate::operation::UpdatePhoneNumber;
#[doc(hidden)]
pub type UpdatePhoneNumberInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdatePhoneNumberInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePhoneNumber`](crate::operation::UpdatePhoneNumber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdatePhoneNumber,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdatePhoneNumberInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_266 = &_input.phone_number_id;
                let input_266 = input_266.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let phone_number_id = aws_smithy_http::label::fmt_string(input_266, false);
                if phone_number_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "phone_number_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/phone-numbers/{PhoneNumberId}",
                    PhoneNumberId = phone_number_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdatePhoneNumberInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_phone_number(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdatePhoneNumber::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdatePhoneNumber",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdatePhoneNumberInput`](crate::input::UpdatePhoneNumberInput)
    pub fn builder() -> crate::input::update_phone_number_input::Builder {
        crate::input::update_phone_number_input::Builder::default()
    }
}

/// See [`UpdatePhoneNumberSettingsInput`](crate::input::UpdatePhoneNumberSettingsInput)
pub mod update_phone_number_settings_input {

    /// A builder for [`UpdatePhoneNumberSettingsInput`](crate::input::UpdatePhoneNumberSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) calling_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The default outbound calling name for the account.</p>
        pub fn calling_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.calling_name = Some(input.into());
            self
        }
        /// <p>The default outbound calling name for the account.</p>
        pub fn set_calling_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.calling_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePhoneNumberSettingsInput`](crate::input::UpdatePhoneNumberSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdatePhoneNumberSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdatePhoneNumberSettingsInput {
                calling_name: self.calling_name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdatePhoneNumberSettingsInputOperationOutputAlias =
    crate::operation::UpdatePhoneNumberSettings;
#[doc(hidden)]
pub type UpdatePhoneNumberSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdatePhoneNumberSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePhoneNumberSettings`](crate::operation::UpdatePhoneNumberSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdatePhoneNumberSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdatePhoneNumberSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                write!(output, "/settings/phone-number").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdatePhoneNumberSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_phone_number_settings(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdatePhoneNumberSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdatePhoneNumberSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdatePhoneNumberSettingsInput`](crate::input::UpdatePhoneNumberSettingsInput)
    pub fn builder() -> crate::input::update_phone_number_settings_input::Builder {
        crate::input::update_phone_number_settings_input::Builder::default()
    }
}

/// See [`UpdateProxySessionInput`](crate::input::UpdateProxySessionInput)
pub mod update_proxy_session_input {

    /// A builder for [`UpdateProxySessionInput`](crate::input::UpdateProxySessionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) proxy_session_id: std::option::Option<std::string::String>,
        pub(crate) capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        pub(crate) expiry_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime voice connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The proxy session ID.</p>
        pub fn proxy_session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.proxy_session_id = Some(input.into());
            self
        }
        /// <p>The proxy session ID.</p>
        pub fn set_proxy_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.proxy_session_id = input;
            self
        }
        /// Appends an item to `capabilities`.
        ///
        /// To override the contents of this collection use [`set_capabilities`](Self::set_capabilities).
        ///
        /// <p>The proxy session capabilities.</p>
        pub fn capabilities(mut self, input: crate::model::Capability) -> Self {
            let mut v = self.capabilities.unwrap_or_default();
            v.push(input);
            self.capabilities = Some(v);
            self
        }
        /// <p>The proxy session capabilities.</p>
        pub fn set_capabilities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        ) -> Self {
            self.capabilities = input;
            self
        }
        /// <p>The number of minutes allowed for the proxy session.</p>
        pub fn expiry_minutes(mut self, input: i32) -> Self {
            self.expiry_minutes = Some(input);
            self
        }
        /// <p>The number of minutes allowed for the proxy session.</p>
        pub fn set_expiry_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.expiry_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateProxySessionInput`](crate::input::UpdateProxySessionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateProxySessionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateProxySessionInput {
                voice_connector_id: self.voice_connector_id,
                proxy_session_id: self.proxy_session_id,
                capabilities: self.capabilities,
                expiry_minutes: self.expiry_minutes,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateProxySessionInputOperationOutputAlias = crate::operation::UpdateProxySession;
#[doc(hidden)]
pub type UpdateProxySessionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateProxySessionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateProxySession`](crate::operation::UpdateProxySession)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateProxySession,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateProxySessionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_267 = &_input.voice_connector_id;
                let input_267 = input_267.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_267, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_268 = &_input.proxy_session_id;
                let input_268 = input_268.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "proxy_session_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let proxy_session_id = aws_smithy_http::label::fmt_string(input_268, false);
                if proxy_session_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "proxy_session_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}/proxy-sessions/{ProxySessionId}",
                    VoiceConnectorId = voice_connector_id,
                    ProxySessionId = proxy_session_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateProxySessionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_proxy_session(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateProxySession::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateProxySession",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateProxySessionInput`](crate::input::UpdateProxySessionInput)
    pub fn builder() -> crate::input::update_proxy_session_input::Builder {
        crate::input::update_proxy_session_input::Builder::default()
    }
}

/// See [`UpdateRoomInput`](crate::input::UpdateRoomInput)
pub mod update_room_input {

    /// A builder for [`UpdateRoomInput`](crate::input::UpdateRoomInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) room_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The room ID.</p>
        pub fn room_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.room_id = Some(input.into());
            self
        }
        /// <p>The room ID.</p>
        pub fn set_room_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.room_id = input;
            self
        }
        /// <p>The room name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The room name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRoomInput`](crate::input::UpdateRoomInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateRoomInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateRoomInput {
                account_id: self.account_id,
                room_id: self.room_id,
                name: self.name,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRoomInputOperationOutputAlias = crate::operation::UpdateRoom;
#[doc(hidden)]
pub type UpdateRoomInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateRoomInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRoom`](crate::operation::UpdateRoom)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRoom,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateRoomInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_269 = &_input.account_id;
                let input_269 = input_269.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_269, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_270 = &_input.room_id;
                let input_270 = input_270.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let room_id = aws_smithy_http::label::fmt_string(input_270, false);
                if room_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms/{RoomId}",
                    AccountId = account_id,
                    RoomId = room_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateRoomInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_room(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRoom::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRoom",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateRoomInput`](crate::input::UpdateRoomInput)
    pub fn builder() -> crate::input::update_room_input::Builder {
        crate::input::update_room_input::Builder::default()
    }
}

/// See [`UpdateRoomMembershipInput`](crate::input::UpdateRoomMembershipInput)
pub mod update_room_membership_input {

    /// A builder for [`UpdateRoomMembershipInput`](crate::input::UpdateRoomMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) room_id: std::option::Option<std::string::String>,
        pub(crate) member_id: std::option::Option<std::string::String>,
        pub(crate) role: std::option::Option<crate::model::RoomMembershipRole>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The room ID.</p>
        pub fn room_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.room_id = Some(input.into());
            self
        }
        /// <p>The room ID.</p>
        pub fn set_room_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.room_id = input;
            self
        }
        /// <p>The member ID.</p>
        pub fn member_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_id = Some(input.into());
            self
        }
        /// <p>The member ID.</p>
        pub fn set_member_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_id = input;
            self
        }
        /// <p>The role of the member.</p>
        pub fn role(mut self, input: crate::model::RoomMembershipRole) -> Self {
            self.role = Some(input);
            self
        }
        /// <p>The role of the member.</p>
        pub fn set_role(
            mut self,
            input: std::option::Option<crate::model::RoomMembershipRole>,
        ) -> Self {
            self.role = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRoomMembershipInput`](crate::input::UpdateRoomMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateRoomMembershipInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateRoomMembershipInput {
                account_id: self.account_id,
                room_id: self.room_id,
                member_id: self.member_id,
                role: self.role,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRoomMembershipInputOperationOutputAlias = crate::operation::UpdateRoomMembership;
#[doc(hidden)]
pub type UpdateRoomMembershipInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateRoomMembershipInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRoomMembership`](crate::operation::UpdateRoomMembership)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRoomMembership,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateRoomMembershipInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_271 = &_input.account_id;
                let input_271 = input_271.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_271, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_272 = &_input.room_id;
                let input_272 = input_272.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let room_id = aws_smithy_http::label::fmt_string(input_272, false);
                if room_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "room_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_273 = &_input.member_id;
                let input_273 = input_273.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let member_id = aws_smithy_http::label::fmt_string(input_273, false);
                if member_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "member_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/rooms/{RoomId}/memberships/{MemberId}",
                    AccountId = account_id,
                    RoomId = room_id,
                    MemberId = member_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateRoomMembershipInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_room_membership(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRoomMembership::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRoomMembership",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateRoomMembershipInput`](crate::input::UpdateRoomMembershipInput)
    pub fn builder() -> crate::input::update_room_membership_input::Builder {
        crate::input::update_room_membership_input::Builder::default()
    }
}

/// See [`UpdateSipMediaApplicationInput`](crate::input::UpdateSipMediaApplicationInput)
pub mod update_sip_media_application_input {

    /// A builder for [`UpdateSipMediaApplicationInput`](crate::input::UpdateSipMediaApplicationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) endpoints:
            std::option::Option<std::vec::Vec<crate::model::SipMediaApplicationEndpoint>>,
    }
    impl Builder {
        /// <p>The SIP media application ID.</p>
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        /// <p>The SIP media application ID.</p>
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        /// <p>The new name for the specified SIP media application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The new name for the specified SIP media application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>The new set of endpoints for the specified SIP media application.</p>
        pub fn endpoints(mut self, input: crate::model::SipMediaApplicationEndpoint) -> Self {
            let mut v = self.endpoints.unwrap_or_default();
            v.push(input);
            self.endpoints = Some(v);
            self
        }
        /// <p>The new set of endpoints for the specified SIP media application.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SipMediaApplicationEndpoint>>,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSipMediaApplicationInput`](crate::input::UpdateSipMediaApplicationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateSipMediaApplicationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateSipMediaApplicationInput {
                sip_media_application_id: self.sip_media_application_id,
                name: self.name,
                endpoints: self.endpoints,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSipMediaApplicationInputOperationOutputAlias =
    crate::operation::UpdateSipMediaApplication;
#[doc(hidden)]
pub type UpdateSipMediaApplicationInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateSipMediaApplicationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSipMediaApplication`](crate::operation::UpdateSipMediaApplication)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSipMediaApplication,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateSipMediaApplicationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_274 = &_input.sip_media_application_id;
                let input_274 = input_274.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_media_application_id = aws_smithy_http::label::fmt_string(input_274, false);
                if sip_media_application_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/sip-media-applications/{SipMediaApplicationId}",
                    SipMediaApplicationId = sip_media_application_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateSipMediaApplicationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_sip_media_application(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSipMediaApplication::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSipMediaApplication",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateSipMediaApplicationInput`](crate::input::UpdateSipMediaApplicationInput)
    pub fn builder() -> crate::input::update_sip_media_application_input::Builder {
        crate::input::update_sip_media_application_input::Builder::default()
    }
}

/// See [`UpdateSipMediaApplicationCallInput`](crate::input::UpdateSipMediaApplicationCallInput)
pub mod update_sip_media_application_call_input {

    /// A builder for [`UpdateSipMediaApplicationCallInput`](crate::input::UpdateSipMediaApplicationCallInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_media_application_id: std::option::Option<std::string::String>,
        pub(crate) transaction_id: std::option::Option<std::string::String>,
        pub(crate) arguments: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ID of the SIP media application handling the call.</p>
        pub fn sip_media_application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_media_application_id = Some(input.into());
            self
        }
        /// <p>The ID of the SIP media application handling the call.</p>
        pub fn set_sip_media_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sip_media_application_id = input;
            self
        }
        /// <p>The ID of the call transaction.</p>
        pub fn transaction_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transaction_id = Some(input.into());
            self
        }
        /// <p>The ID of the call transaction.</p>
        pub fn set_transaction_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transaction_id = input;
            self
        }
        /// Adds a key-value pair to `arguments`.
        ///
        /// To override the contents of this collection use [`set_arguments`](Self::set_arguments).
        ///
        /// <p>Arguments made available to the Lambda function as part of the <code>CALL_UPDATE_REQUESTED</code> event. Can contain 0-20 key-value pairs.</p>
        pub fn arguments(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.arguments.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.arguments = Some(hash_map);
            self
        }
        /// <p>Arguments made available to the Lambda function as part of the <code>CALL_UPDATE_REQUESTED</code> event. Can contain 0-20 key-value pairs.</p>
        pub fn set_arguments(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.arguments = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSipMediaApplicationCallInput`](crate::input::UpdateSipMediaApplicationCallInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateSipMediaApplicationCallInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateSipMediaApplicationCallInput {
                sip_media_application_id: self.sip_media_application_id,
                transaction_id: self.transaction_id,
                arguments: self.arguments,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSipMediaApplicationCallInputOperationOutputAlias =
    crate::operation::UpdateSipMediaApplicationCall;
#[doc(hidden)]
pub type UpdateSipMediaApplicationCallInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl UpdateSipMediaApplicationCallInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSipMediaApplicationCall`](crate::operation::UpdateSipMediaApplicationCall)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSipMediaApplicationCall,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateSipMediaApplicationCallInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_275 = &_input.sip_media_application_id;
                let input_275 = input_275.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_media_application_id = aws_smithy_http::label::fmt_string(input_275, false);
                if sip_media_application_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_media_application_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_276 = &_input.transaction_id;
                let input_276 = input_276.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "transaction_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let transaction_id = aws_smithy_http::label::fmt_string(input_276, false);
                if transaction_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "transaction_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/sip-media-applications/{SipMediaApplicationId}/calls/{TransactionId}",
                    SipMediaApplicationId = sip_media_application_id,
                    TransactionId = transaction_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateSipMediaApplicationCallInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_sip_media_application_call(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSipMediaApplicationCall::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSipMediaApplicationCall",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateSipMediaApplicationCallInput`](crate::input::UpdateSipMediaApplicationCallInput)
    pub fn builder() -> crate::input::update_sip_media_application_call_input::Builder {
        crate::input::update_sip_media_application_call_input::Builder::default()
    }
}

/// See [`UpdateSipRuleInput`](crate::input::UpdateSipRuleInput)
pub mod update_sip_rule_input {

    /// A builder for [`UpdateSipRuleInput`](crate::input::UpdateSipRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sip_rule_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) disabled: std::option::Option<bool>,
        pub(crate) target_applications:
            std::option::Option<std::vec::Vec<crate::model::SipRuleTargetApplication>>,
    }
    impl Builder {
        /// <p>The SIP rule ID.</p>
        pub fn sip_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sip_rule_id = Some(input.into());
            self
        }
        /// <p>The SIP rule ID.</p>
        pub fn set_sip_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sip_rule_id = input;
            self
        }
        /// <p>The new name for the specified SIP rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The new name for the specified SIP rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The new value specified to indicate whether the rule is disabled.</p>
        pub fn disabled(mut self, input: bool) -> Self {
            self.disabled = Some(input);
            self
        }
        /// <p>The new value specified to indicate whether the rule is disabled.</p>
        pub fn set_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.disabled = input;
            self
        }
        /// Appends an item to `target_applications`.
        ///
        /// To override the contents of this collection use [`set_target_applications`](Self::set_target_applications).
        ///
        /// <p>The new value of the list of target applications.</p>
        pub fn target_applications(
            mut self,
            input: crate::model::SipRuleTargetApplication,
        ) -> Self {
            let mut v = self.target_applications.unwrap_or_default();
            v.push(input);
            self.target_applications = Some(v);
            self
        }
        /// <p>The new value of the list of target applications.</p>
        pub fn set_target_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SipRuleTargetApplication>>,
        ) -> Self {
            self.target_applications = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSipRuleInput`](crate::input::UpdateSipRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateSipRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateSipRuleInput {
                sip_rule_id: self.sip_rule_id,
                name: self.name,
                disabled: self.disabled,
                target_applications: self.target_applications,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSipRuleInputOperationOutputAlias = crate::operation::UpdateSipRule;
#[doc(hidden)]
pub type UpdateSipRuleInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateSipRuleInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSipRule`](crate::operation::UpdateSipRule)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSipRule,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateSipRuleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_277 = &_input.sip_rule_id;
                let input_277 = input_277.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_rule_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let sip_rule_id = aws_smithy_http::label::fmt_string(input_277, false);
                if sip_rule_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "sip_rule_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(output, "/sip-rules/{SipRuleId}", SipRuleId = sip_rule_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateSipRuleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_sip_rule(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSipRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSipRule",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateSipRuleInput`](crate::input::UpdateSipRuleInput)
    pub fn builder() -> crate::input::update_sip_rule_input::Builder {
        crate::input::update_sip_rule_input::Builder::default()
    }
}

/// See [`UpdateUserInput`](crate::input::UpdateUserInput)
pub mod update_user_input {

    /// A builder for [`UpdateUserInput`](crate::input::UpdateUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) license_type: std::option::Option<crate::model::License>,
        pub(crate) user_type: std::option::Option<crate::model::UserType>,
        pub(crate) alexa_for_business_metadata:
            std::option::Option<crate::model::AlexaForBusinessMetadata>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The user ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The user ID.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The user license type to update. This must be a supported license type for the Amazon Chime account that the user belongs to.</p>
        pub fn license_type(mut self, input: crate::model::License) -> Self {
            self.license_type = Some(input);
            self
        }
        /// <p>The user license type to update. This must be a supported license type for the Amazon Chime account that the user belongs to.</p>
        pub fn set_license_type(
            mut self,
            input: std::option::Option<crate::model::License>,
        ) -> Self {
            self.license_type = input;
            self
        }
        /// <p>The user type.</p>
        pub fn user_type(mut self, input: crate::model::UserType) -> Self {
            self.user_type = Some(input);
            self
        }
        /// <p>The user type.</p>
        pub fn set_user_type(mut self, input: std::option::Option<crate::model::UserType>) -> Self {
            self.user_type = input;
            self
        }
        /// <p>The Alexa for Business metadata.</p>
        pub fn alexa_for_business_metadata(
            mut self,
            input: crate::model::AlexaForBusinessMetadata,
        ) -> Self {
            self.alexa_for_business_metadata = Some(input);
            self
        }
        /// <p>The Alexa for Business metadata.</p>
        pub fn set_alexa_for_business_metadata(
            mut self,
            input: std::option::Option<crate::model::AlexaForBusinessMetadata>,
        ) -> Self {
            self.alexa_for_business_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserInput`](crate::input::UpdateUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateUserInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateUserInput {
                account_id: self.account_id,
                user_id: self.user_id,
                license_type: self.license_type,
                user_type: self.user_type,
                alexa_for_business_metadata: self.alexa_for_business_metadata,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateUserInputOperationOutputAlias = crate::operation::UpdateUser;
#[doc(hidden)]
pub type UpdateUserInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateUserInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUser`](crate::operation::UpdateUser)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateUser,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateUserInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_278 = &_input.account_id;
                let input_278 = input_278.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_278, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_279 = &_input.user_id;
                let input_279 = input_279.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let user_id = aws_smithy_http::label::fmt_string(input_279, false);
                if user_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users/{UserId}",
                    AccountId = account_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateUserInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_user(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateUser::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateUser",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateUserInput`](crate::input::UpdateUserInput)
    pub fn builder() -> crate::input::update_user_input::Builder {
        crate::input::update_user_input::Builder::default()
    }
}

/// See [`UpdateUserSettingsInput`](crate::input::UpdateUserSettingsInput)
pub mod update_user_settings_input {

    /// A builder for [`UpdateUserSettingsInput`](crate::input::UpdateUserSettingsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) user_settings: std::option::Option<crate::model::UserSettings>,
    }
    impl Builder {
        /// <p>The Amazon Chime account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The user ID.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The user ID.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The user settings to update.</p>
        pub fn user_settings(mut self, input: crate::model::UserSettings) -> Self {
            self.user_settings = Some(input);
            self
        }
        /// <p>The user settings to update.</p>
        pub fn set_user_settings(
            mut self,
            input: std::option::Option<crate::model::UserSettings>,
        ) -> Self {
            self.user_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateUserSettingsInput`](crate::input::UpdateUserSettingsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateUserSettingsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateUserSettingsInput {
                account_id: self.account_id,
                user_id: self.user_id,
                user_settings: self.user_settings,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateUserSettingsInputOperationOutputAlias = crate::operation::UpdateUserSettings;
#[doc(hidden)]
pub type UpdateUserSettingsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateUserSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateUserSettings`](crate::operation::UpdateUserSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateUserSettings,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateUserSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_280 = &_input.account_id;
                let input_280 = input_280.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let account_id = aws_smithy_http::label::fmt_string(input_280, false);
                if account_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "account_id",
                        details: "cannot be empty or unset",
                    });
                }
                let input_281 = &_input.user_id;
                let input_281 = input_281.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let user_id = aws_smithy_http::label::fmt_string(input_281, false);
                if user_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "user_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/accounts/{AccountId}/users/{UserId}/settings",
                    AccountId = account_id,
                    UserId = user_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateUserSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_user_settings(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateUserSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateUserSettings",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateUserSettingsInput`](crate::input::UpdateUserSettingsInput)
    pub fn builder() -> crate::input::update_user_settings_input::Builder {
        crate::input::update_user_settings_input::Builder::default()
    }
}

/// See [`UpdateVoiceConnectorInput`](crate::input::UpdateVoiceConnectorInput)
pub mod update_voice_connector_input {

    /// A builder for [`UpdateVoiceConnectorInput`](crate::input::UpdateVoiceConnectorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) require_encryption: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn voice_connector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector ID.</p>
        pub fn set_voice_connector_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_id = input;
            self
        }
        /// <p>The name of the Amazon Chime Voice Connector.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Chime Voice Connector.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>When enabled, requires encryption for the Amazon Chime Voice Connector.</p>
        pub fn require_encryption(mut self, input: bool) -> Self {
            self.require_encryption = Some(input);
            self
        }
        /// <p>When enabled, requires encryption for the Amazon Chime Voice Connector.</p>
        pub fn set_require_encryption(mut self, input: std::option::Option<bool>) -> Self {
            self.require_encryption = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVoiceConnectorInput`](crate::input::UpdateVoiceConnectorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateVoiceConnectorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateVoiceConnectorInput {
                voice_connector_id: self.voice_connector_id,
                name: self.name,
                require_encryption: self.require_encryption,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateVoiceConnectorInputOperationOutputAlias = crate::operation::UpdateVoiceConnector;
#[doc(hidden)]
pub type UpdateVoiceConnectorInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateVoiceConnectorInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVoiceConnector`](crate::operation::UpdateVoiceConnector)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateVoiceConnector,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateVoiceConnectorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_282 = &_input.voice_connector_id;
                let input_282 = input_282.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_id = aws_smithy_http::label::fmt_string(input_282, false);
                if voice_connector_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connectors/{VoiceConnectorId}",
                    VoiceConnectorId = voice_connector_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateVoiceConnectorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_voice_connector(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateVoiceConnector::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateVoiceConnector",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateVoiceConnectorInput`](crate::input::UpdateVoiceConnectorInput)
    pub fn builder() -> crate::input::update_voice_connector_input::Builder {
        crate::input::update_voice_connector_input::Builder::default()
    }
}

/// See [`UpdateVoiceConnectorGroupInput`](crate::input::UpdateVoiceConnectorGroupInput)
pub mod update_voice_connector_group_input {

    /// A builder for [`UpdateVoiceConnectorGroupInput`](crate::input::UpdateVoiceConnectorGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) voice_connector_group_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) voice_connector_items:
            std::option::Option<std::vec::Vec<crate::model::VoiceConnectorItem>>,
    }
    impl Builder {
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn voice_connector_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_connector_group_id = Some(input.into());
            self
        }
        /// <p>The Amazon Chime Voice Connector group ID.</p>
        pub fn set_voice_connector_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.voice_connector_group_id = input;
            self
        }
        /// <p>The name of the Amazon Chime Voice Connector group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Chime Voice Connector group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `voice_connector_items`.
        ///
        /// To override the contents of this collection use [`set_voice_connector_items`](Self::set_voice_connector_items).
        ///
        /// <p>The <code>VoiceConnectorItems</code> to associate with the group.</p>
        pub fn voice_connector_items(mut self, input: crate::model::VoiceConnectorItem) -> Self {
            let mut v = self.voice_connector_items.unwrap_or_default();
            v.push(input);
            self.voice_connector_items = Some(v);
            self
        }
        /// <p>The <code>VoiceConnectorItems</code> to associate with the group.</p>
        pub fn set_voice_connector_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VoiceConnectorItem>>,
        ) -> Self {
            self.voice_connector_items = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVoiceConnectorGroupInput`](crate::input::UpdateVoiceConnectorGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateVoiceConnectorGroupInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateVoiceConnectorGroupInput {
                voice_connector_group_id: self.voice_connector_group_id,
                name: self.name,
                voice_connector_items: self.voice_connector_items,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateVoiceConnectorGroupInputOperationOutputAlias =
    crate::operation::UpdateVoiceConnectorGroup;
#[doc(hidden)]
pub type UpdateVoiceConnectorGroupInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateVoiceConnectorGroupInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVoiceConnectorGroup`](crate::operation::UpdateVoiceConnectorGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateVoiceConnectorGroup,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateVoiceConnectorGroupInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::BuildError> {
                let input_283 = &_input.voice_connector_group_id;
                let input_283 = input_283.as_ref().ok_or(
                    aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    },
                )?;
                let voice_connector_group_id = aws_smithy_http::label::fmt_string(input_283, false);
                if voice_connector_group_id.is_empty() {
                    return Err(aws_smithy_http::operation::BuildError::MissingField {
                        field: "voice_connector_group_id",
                        details: "cannot be empty or unset",
                    });
                }
                write!(
                    output,
                    "/voice-connector-groups/{VoiceConnectorGroupId}",
                    VoiceConnectorGroupId = voice_connector_group_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateVoiceConnectorGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
            {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_voice_connector_group(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateVoiceConnectorGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateVoiceConnectorGroup",
            "chime",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateVoiceConnectorGroupInput`](crate::input::UpdateVoiceConnectorGroupInput)
    pub fn builder() -> crate::input::update_voice_connector_group_input::Builder {
        crate::input::update_voice_connector_group_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub voice_connector_group_id: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon Chime Voice Connector group.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The <code>VoiceConnectorItems</code> to associate with the group.</p>
    pub voice_connector_items: std::option::Option<std::vec::Vec<crate::model::VoiceConnectorItem>>,
}
impl UpdateVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub fn voice_connector_group_id(&self) -> std::option::Option<&str> {
        self.voice_connector_group_id.as_deref()
    }
    /// <p>The name of the Amazon Chime Voice Connector group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The <code>VoiceConnectorItems</code> to associate with the group.</p>
    pub fn voice_connector_items(
        &self,
    ) -> std::option::Option<&[crate::model::VoiceConnectorItem]> {
        self.voice_connector_items.as_deref()
    }
}
impl std::fmt::Debug for UpdateVoiceConnectorGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVoiceConnectorGroupInput");
        formatter.field("voice_connector_group_id", &self.voice_connector_group_id);
        formatter.field("name", &self.name);
        formatter.field("voice_connector_items", &self.voice_connector_items);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon Chime Voice Connector.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>When enabled, requires encryption for the Amazon Chime Voice Connector.</p>
    pub require_encryption: std::option::Option<bool>,
}
impl UpdateVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The name of the Amazon Chime Voice Connector.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>When enabled, requires encryption for the Amazon Chime Voice Connector.</p>
    pub fn require_encryption(&self) -> std::option::Option<bool> {
        self.require_encryption
    }
}
impl std::fmt::Debug for UpdateVoiceConnectorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVoiceConnectorInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("name", &self.name);
        formatter.field("require_encryption", &self.require_encryption);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateUserSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user ID.</p>
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The user settings to update.</p>
    pub user_settings: std::option::Option<crate::model::UserSettings>,
}
impl UpdateUserSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user ID.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The user settings to update.</p>
    pub fn user_settings(&self) -> std::option::Option<&crate::model::UserSettings> {
        self.user_settings.as_ref()
    }
}
impl std::fmt::Debug for UpdateUserSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateUserSettingsInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id", &self.user_id);
        formatter.field("user_settings", &self.user_settings);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user ID.</p>
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The user license type to update. This must be a supported license type for the Amazon Chime account that the user belongs to.</p>
    pub license_type: std::option::Option<crate::model::License>,
    /// <p>The user type.</p>
    pub user_type: std::option::Option<crate::model::UserType>,
    /// <p>The Alexa for Business metadata.</p>
    pub alexa_for_business_metadata: std::option::Option<crate::model::AlexaForBusinessMetadata>,
}
impl UpdateUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user ID.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The user license type to update. This must be a supported license type for the Amazon Chime account that the user belongs to.</p>
    pub fn license_type(&self) -> std::option::Option<&crate::model::License> {
        self.license_type.as_ref()
    }
    /// <p>The user type.</p>
    pub fn user_type(&self) -> std::option::Option<&crate::model::UserType> {
        self.user_type.as_ref()
    }
    /// <p>The Alexa for Business metadata.</p>
    pub fn alexa_for_business_metadata(
        &self,
    ) -> std::option::Option<&crate::model::AlexaForBusinessMetadata> {
        self.alexa_for_business_metadata.as_ref()
    }
}
impl std::fmt::Debug for UpdateUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateUserInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id", &self.user_id);
        formatter.field("license_type", &self.license_type);
        formatter.field("user_type", &self.user_type);
        formatter.field(
            "alexa_for_business_metadata",
            &self.alexa_for_business_metadata,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSipRuleInput {
    /// <p>The SIP rule ID.</p>
    pub sip_rule_id: std::option::Option<std::string::String>,
    /// <p>The new name for the specified SIP rule.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The new value specified to indicate whether the rule is disabled.</p>
    pub disabled: std::option::Option<bool>,
    /// <p>The new value of the list of target applications.</p>
    pub target_applications:
        std::option::Option<std::vec::Vec<crate::model::SipRuleTargetApplication>>,
}
impl UpdateSipRuleInput {
    /// <p>The SIP rule ID.</p>
    pub fn sip_rule_id(&self) -> std::option::Option<&str> {
        self.sip_rule_id.as_deref()
    }
    /// <p>The new name for the specified SIP rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The new value specified to indicate whether the rule is disabled.</p>
    pub fn disabled(&self) -> std::option::Option<bool> {
        self.disabled
    }
    /// <p>The new value of the list of target applications.</p>
    pub fn target_applications(
        &self,
    ) -> std::option::Option<&[crate::model::SipRuleTargetApplication]> {
        self.target_applications.as_deref()
    }
}
impl std::fmt::Debug for UpdateSipRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSipRuleInput");
        formatter.field("sip_rule_id", &self.sip_rule_id);
        formatter.field("name", &self.name);
        formatter.field("disabled", &self.disabled);
        formatter.field("target_applications", &self.target_applications);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSipMediaApplicationCallInput {
    /// <p>The ID of the SIP media application handling the call.</p>
    pub sip_media_application_id: std::option::Option<std::string::String>,
    /// <p>The ID of the call transaction.</p>
    pub transaction_id: std::option::Option<std::string::String>,
    /// <p>Arguments made available to the Lambda function as part of the <code>CALL_UPDATE_REQUESTED</code> event. Can contain 0-20 key-value pairs.</p>
    pub arguments:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateSipMediaApplicationCallInput {
    /// <p>The ID of the SIP media application handling the call.</p>
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
    /// <p>The ID of the call transaction.</p>
    pub fn transaction_id(&self) -> std::option::Option<&str> {
        self.transaction_id.as_deref()
    }
    /// <p>Arguments made available to the Lambda function as part of the <code>CALL_UPDATE_REQUESTED</code> event. Can contain 0-20 key-value pairs.</p>
    pub fn arguments(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.arguments.as_ref()
    }
}
impl std::fmt::Debug for UpdateSipMediaApplicationCallInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSipMediaApplicationCallInput");
        formatter.field("sip_media_application_id", &self.sip_media_application_id);
        formatter.field("transaction_id", &self.transaction_id);
        formatter.field("arguments", &self.arguments);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSipMediaApplicationInput {
    /// <p>The SIP media application ID.</p>
    pub sip_media_application_id: std::option::Option<std::string::String>,
    /// <p>The new name for the specified SIP media application.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The new set of endpoints for the specified SIP media application.</p>
    pub endpoints: std::option::Option<std::vec::Vec<crate::model::SipMediaApplicationEndpoint>>,
}
impl UpdateSipMediaApplicationInput {
    /// <p>The SIP media application ID.</p>
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
    /// <p>The new name for the specified SIP media application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The new set of endpoints for the specified SIP media application.</p>
    pub fn endpoints(&self) -> std::option::Option<&[crate::model::SipMediaApplicationEndpoint]> {
        self.endpoints.as_deref()
    }
}
impl std::fmt::Debug for UpdateSipMediaApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSipMediaApplicationInput");
        formatter.field("sip_media_application_id", &self.sip_media_application_id);
        formatter.field("name", &self.name);
        formatter.field("endpoints", &self.endpoints);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRoomMembershipInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The room ID.</p>
    pub room_id: std::option::Option<std::string::String>,
    /// <p>The member ID.</p>
    pub member_id: std::option::Option<std::string::String>,
    /// <p>The role of the member.</p>
    pub role: std::option::Option<crate::model::RoomMembershipRole>,
}
impl UpdateRoomMembershipInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The room ID.</p>
    pub fn room_id(&self) -> std::option::Option<&str> {
        self.room_id.as_deref()
    }
    /// <p>The member ID.</p>
    pub fn member_id(&self) -> std::option::Option<&str> {
        self.member_id.as_deref()
    }
    /// <p>The role of the member.</p>
    pub fn role(&self) -> std::option::Option<&crate::model::RoomMembershipRole> {
        self.role.as_ref()
    }
}
impl std::fmt::Debug for UpdateRoomMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRoomMembershipInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("room_id", &self.room_id);
        formatter.field("member_id", &self.member_id);
        formatter.field("role", &self.role);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRoomInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The room ID.</p>
    pub room_id: std::option::Option<std::string::String>,
    /// <p>The room name.</p>
    pub name: std::option::Option<std::string::String>,
}
impl UpdateRoomInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The room ID.</p>
    pub fn room_id(&self) -> std::option::Option<&str> {
        self.room_id.as_deref()
    }
    /// <p>The room name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for UpdateRoomInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRoomInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("room_id", &self.room_id);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateProxySessionInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The proxy session ID.</p>
    pub proxy_session_id: std::option::Option<std::string::String>,
    /// <p>The proxy session capabilities.</p>
    pub capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
    /// <p>The number of minutes allowed for the proxy session.</p>
    pub expiry_minutes: std::option::Option<i32>,
}
impl UpdateProxySessionInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The proxy session ID.</p>
    pub fn proxy_session_id(&self) -> std::option::Option<&str> {
        self.proxy_session_id.as_deref()
    }
    /// <p>The proxy session capabilities.</p>
    pub fn capabilities(&self) -> std::option::Option<&[crate::model::Capability]> {
        self.capabilities.as_deref()
    }
    /// <p>The number of minutes allowed for the proxy session.</p>
    pub fn expiry_minutes(&self) -> std::option::Option<i32> {
        self.expiry_minutes
    }
}
impl std::fmt::Debug for UpdateProxySessionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateProxySessionInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("proxy_session_id", &self.proxy_session_id);
        formatter.field("capabilities", &self.capabilities);
        formatter.field("expiry_minutes", &self.expiry_minutes);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePhoneNumberSettingsInput {
    /// <p>The default outbound calling name for the account.</p>
    pub calling_name: std::option::Option<std::string::String>,
}
impl UpdatePhoneNumberSettingsInput {
    /// <p>The default outbound calling name for the account.</p>
    pub fn calling_name(&self) -> std::option::Option<&str> {
        self.calling_name.as_deref()
    }
}
impl std::fmt::Debug for UpdatePhoneNumberSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePhoneNumberSettingsInput");
        formatter.field("calling_name", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePhoneNumberInput {
    /// <p>The phone number ID.</p>
    pub phone_number_id: std::option::Option<std::string::String>,
    /// <p>The product type.</p>
    pub product_type: std::option::Option<crate::model::PhoneNumberProductType>,
    /// <p>The outbound calling name associated with the phone number.</p>
    pub calling_name: std::option::Option<std::string::String>,
}
impl UpdatePhoneNumberInput {
    /// <p>The phone number ID.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
    /// <p>The product type.</p>
    pub fn product_type(&self) -> std::option::Option<&crate::model::PhoneNumberProductType> {
        self.product_type.as_ref()
    }
    /// <p>The outbound calling name associated with the phone number.</p>
    pub fn calling_name(&self) -> std::option::Option<&str> {
        self.calling_name.as_deref()
    }
}
impl std::fmt::Debug for UpdatePhoneNumberInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePhoneNumberInput");
        formatter.field("phone_number_id", &self.phone_number_id);
        formatter.field("product_type", &self.product_type);
        formatter.field("calling_name", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGlobalSettingsInput {
    /// <p>The Amazon Chime Business Calling settings.</p>
    pub business_calling: std::option::Option<crate::model::BusinessCallingSettings>,
    /// <p>The Amazon Chime Voice Connector settings.</p>
    pub voice_connector: std::option::Option<crate::model::VoiceConnectorSettings>,
}
impl UpdateGlobalSettingsInput {
    /// <p>The Amazon Chime Business Calling settings.</p>
    pub fn business_calling(&self) -> std::option::Option<&crate::model::BusinessCallingSettings> {
        self.business_calling.as_ref()
    }
    /// <p>The Amazon Chime Voice Connector settings.</p>
    pub fn voice_connector(&self) -> std::option::Option<&crate::model::VoiceConnectorSettings> {
        self.voice_connector.as_ref()
    }
}
impl std::fmt::Debug for UpdateGlobalSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateGlobalSettingsInput");
        formatter.field("business_calling", &self.business_calling);
        formatter.field("voice_connector", &self.voice_connector);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelReadMarkerInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl UpdateChannelReadMarkerInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for UpdateChannelReadMarkerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelReadMarkerInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ID string of the message being updated.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The content of the message being updated.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>The metadata of the message being updated.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl UpdateChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ID string of the message being updated.</p>
    pub fn message_id(&self) -> std::option::Option<&str> {
        self.message_id.as_deref()
    }
    /// <p>The content of the message being updated.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The metadata of the message being updated.</p>
    pub fn metadata(&self) -> std::option::Option<&str> {
        self.metadata.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for UpdateChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("message_id", &self.message_id);
        formatter.field("content", &"*** Sensitive Data Redacted ***");
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The mode of the update request.</p>
    pub mode: std::option::Option<crate::model::ChannelMode>,
    /// <p>The metadata for the update request.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl UpdateChannelInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The name of the channel.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The mode of the update request.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::ChannelMode> {
        self.mode.as_ref()
    }
    /// <p>The metadata for the update request.</p>
    pub fn metadata(&self) -> std::option::Option<&str> {
        self.metadata.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for UpdateChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("mode", &self.mode);
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateBotInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The bot ID.</p>
    pub bot_id: std::option::Option<std::string::String>,
    /// <p>When true, stops the specified bot from running in your account.</p>
    pub disabled: std::option::Option<bool>,
}
impl UpdateBotInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The bot ID.</p>
    pub fn bot_id(&self) -> std::option::Option<&str> {
        self.bot_id.as_deref()
    }
    /// <p>When true, stops the specified bot from running in your account.</p>
    pub fn disabled(&self) -> std::option::Option<bool> {
        self.disabled
    }
}
impl std::fmt::Debug for UpdateBotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateBotInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("bot_id", &self.bot_id);
        formatter.field("disabled", &self.disabled);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAppInstanceUserInput {
    /// <p>The ARN of the <code>AppInstanceUser</code>.</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
    /// <p>The name of the <code>AppInstanceUser</code>.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The metadata of the <code>AppInstanceUser</code>.</p>
    pub metadata: std::option::Option<std::string::String>,
}
impl UpdateAppInstanceUserInput {
    /// <p>The ARN of the <code>AppInstanceUser</code>.</p>
    pub fn app_instance_user_arn(&self) -> std::option::Option<&str> {
        self.app_instance_user_arn.as_deref()
    }
    /// <p>The name of the <code>AppInstanceUser</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The metadata of the <code>AppInstanceUser</code>.</p>
    pub fn metadata(&self) -> std::option::Option<&str> {
        self.metadata.as_deref()
    }
}
impl std::fmt::Debug for UpdateAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAppInstanceUserInput");
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAppInstanceInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The name that you want to change.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The metadata that you want to change.</p>
    pub metadata: std::option::Option<std::string::String>,
}
impl UpdateAppInstanceInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
    /// <p>The name that you want to change.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The metadata that you want to change.</p>
    pub fn metadata(&self) -> std::option::Option<&str> {
        self.metadata.as_deref()
    }
}
impl std::fmt::Debug for UpdateAppInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAppInstanceInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAccountSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Chime account settings to update.</p>
    pub account_settings: std::option::Option<crate::model::AccountSettings>,
}
impl UpdateAccountSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The Amazon Chime account settings to update.</p>
    pub fn account_settings(&self) -> std::option::Option<&crate::model::AccountSettings> {
        self.account_settings.as_ref()
    }
}
impl std::fmt::Debug for UpdateAccountSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAccountSettingsInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("account_settings", &self.account_settings);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The new name for the specified Amazon Chime account.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The default license applied when you add users to an Amazon Chime account.</p>
    pub default_license: std::option::Option<crate::model::License>,
}
impl UpdateAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The new name for the specified Amazon Chime account.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The default license applied when you add users to an Amazon Chime account.</p>
    pub fn default_license(&self) -> std::option::Option<&crate::model::License> {
        self.default_license.as_ref()
    }
}
impl std::fmt::Debug for UpdateAccountInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAccountInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("name", &self.name);
        formatter.field("default_license", &self.default_license);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The resource ARN.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag keys.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The resource ARN.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tag keys.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagMeetingInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The tag keys.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagMeetingInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The tag keys.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl std::fmt::Debug for UntagMeetingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagMeetingInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub attendee_id: std::option::Option<std::string::String>,
    /// <p>The tag keys.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub fn attendee_id(&self) -> std::option::Option<&str> {
        self.attendee_id.as_deref()
    }
    /// <p>The tag keys.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl std::fmt::Debug for UntagAttendeeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagAttendeeInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("attendee_id", &self.attendee_id);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The resource ARN.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag key-value pairs.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagResourceInput {
    /// <p>The resource ARN.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tag key-value pairs.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagMeetingInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The tag key-value pairs.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagMeetingInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The tag key-value pairs.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for TagMeetingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagMeetingInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub attendee_id: std::option::Option<std::string::String>,
    /// <p>The tag key-value pairs.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub fn attendee_id(&self) -> std::option::Option<&str> {
        self.attendee_id.as_deref()
    }
    /// <p>The tag key-value pairs.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for TagAttendeeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagAttendeeInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("attendee_id", &self.attendee_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopMeetingTranscriptionInput {
    /// <p>The unique ID of the meeting for which you stop transcription.</p>
    pub meeting_id: std::option::Option<std::string::String>,
}
impl StopMeetingTranscriptionInput {
    /// <p>The unique ID of the meeting for which you stop transcription.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
}
impl std::fmt::Debug for StopMeetingTranscriptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopMeetingTranscriptionInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartMeetingTranscriptionInput {
    /// <p>The unique ID of the meeting being transcribed.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The configuration for the current transcription operation. Must contain <code>EngineTranscribeSettings</code> or <code>EngineTranscribeMedicalSettings</code>.</p>
    pub transcription_configuration: std::option::Option<crate::model::TranscriptionConfiguration>,
}
impl StartMeetingTranscriptionInput {
    /// <p>The unique ID of the meeting being transcribed.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The configuration for the current transcription operation. Must contain <code>EngineTranscribeSettings</code> or <code>EngineTranscribeMedicalSettings</code>.</p>
    pub fn transcription_configuration(
        &self,
    ) -> std::option::Option<&crate::model::TranscriptionConfiguration> {
        self.transcription_configuration.as_ref()
    }
}
impl std::fmt::Debug for StartMeetingTranscriptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartMeetingTranscriptionInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field(
            "transcription_configuration",
            &self.transcription_configuration,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The content of the message.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    pub r#type: std::option::Option<crate::model::ChannelMessageType>,
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub persistence: std::option::Option<crate::model::ChannelMessagePersistenceType>,
    /// <p>The optional metadata for each message.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl SendChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The content of the message.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ChannelMessageType> {
        self.r#type.as_ref()
    }
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub fn persistence(&self) -> std::option::Option<&crate::model::ChannelMessagePersistenceType> {
        self.persistence.as_ref()
    }
    /// <p>The optional metadata for each message.</p>
    pub fn metadata(&self) -> std::option::Option<&str> {
        self.metadata.as_deref()
    }
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for SendChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("content", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &self.r#type);
        formatter.field("persistence", &self.persistence);
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchAvailablePhoneNumbersInput {
    /// <p>The area code used to filter results. Only applies to the US.</p>
    pub area_code: std::option::Option<std::string::String>,
    /// <p>The city used to filter results. Only applies to the US.</p>
    pub city: std::option::Option<std::string::String>,
    /// <p>The country used to filter results. Defaults to the US Format: ISO 3166-1 alpha-2.</p>
    pub country: std::option::Option<std::string::String>,
    /// <p>The state used to filter results. Required only if you provide <code>City</code>. Only applies to the US.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The toll-free prefix that you use to filter results. Only applies to the US.</p>
    pub toll_free_prefix: std::option::Option<std::string::String>,
    /// <p>The phone number type used to filter results. Required for non-US numbers.</p>
    pub phone_number_type: std::option::Option<crate::model::PhoneNumberType>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token used to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl SearchAvailablePhoneNumbersInput {
    /// <p>The area code used to filter results. Only applies to the US.</p>
    pub fn area_code(&self) -> std::option::Option<&str> {
        self.area_code.as_deref()
    }
    /// <p>The city used to filter results. Only applies to the US.</p>
    pub fn city(&self) -> std::option::Option<&str> {
        self.city.as_deref()
    }
    /// <p>The country used to filter results. Defaults to the US Format: ISO 3166-1 alpha-2.</p>
    pub fn country(&self) -> std::option::Option<&str> {
        self.country.as_deref()
    }
    /// <p>The state used to filter results. Required only if you provide <code>City</code>. Only applies to the US.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The toll-free prefix that you use to filter results. Only applies to the US.</p>
    pub fn toll_free_prefix(&self) -> std::option::Option<&str> {
        self.toll_free_prefix.as_deref()
    }
    /// <p>The phone number type used to filter results. Required for non-US numbers.</p>
    pub fn phone_number_type(&self) -> std::option::Option<&crate::model::PhoneNumberType> {
        self.phone_number_type.as_ref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token used to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for SearchAvailablePhoneNumbersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchAvailablePhoneNumbersInput");
        formatter.field("area_code", &self.area_code);
        formatter.field("city", &self.city);
        formatter.field("country", &self.country);
        formatter.field("state", &self.state);
        formatter.field("toll_free_prefix", &self.toll_free_prefix);
        formatter.field("phone_number_type", &self.phone_number_type);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RestorePhoneNumberInput {
    /// <p>The phone number.</p>
    pub phone_number_id: std::option::Option<std::string::String>,
}
impl RestorePhoneNumberInput {
    /// <p>The phone number.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
}
impl std::fmt::Debug for RestorePhoneNumberInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestorePhoneNumberInput");
        formatter.field("phone_number_id", &self.phone_number_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResetPersonalPinInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user ID.</p>
    pub user_id: std::option::Option<std::string::String>,
}
impl ResetPersonalPinInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user ID.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
}
impl std::fmt::Debug for ResetPersonalPinInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResetPersonalPinInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id", &self.user_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegenerateSecurityTokenInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The bot ID.</p>
    pub bot_id: std::option::Option<std::string::String>,
}
impl RegenerateSecurityTokenInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The bot ID.</p>
    pub fn bot_id(&self) -> std::option::Option<&str> {
        self.bot_id.as_deref()
    }
}
impl std::fmt::Debug for RegenerateSecurityTokenInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegenerateSecurityTokenInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("bot_id", &self.bot_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RedactRoomMessageInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The room ID.</p>
    pub room_id: std::option::Option<std::string::String>,
    /// <p>The message ID.</p>
    pub message_id: std::option::Option<std::string::String>,
}
impl RedactRoomMessageInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The room ID.</p>
    pub fn room_id(&self) -> std::option::Option<&str> {
        self.room_id.as_deref()
    }
    /// <p>The message ID.</p>
    pub fn message_id(&self) -> std::option::Option<&str> {
        self.message_id.as_deref()
    }
}
impl std::fmt::Debug for RedactRoomMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RedactRoomMessageInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("room_id", &self.room_id);
        formatter.field("message_id", &self.message_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RedactConversationMessageInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The conversation ID.</p>
    pub conversation_id: std::option::Option<std::string::String>,
    /// <p>The message ID.</p>
    pub message_id: std::option::Option<std::string::String>,
}
impl RedactConversationMessageInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The conversation ID.</p>
    pub fn conversation_id(&self) -> std::option::Option<&str> {
        self.conversation_id.as_deref()
    }
    /// <p>The message ID.</p>
    pub fn message_id(&self) -> std::option::Option<&str> {
        self.message_id.as_deref()
    }
}
impl std::fmt::Debug for RedactConversationMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RedactConversationMessageInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("conversation_id", &self.conversation_id);
        formatter.field("message_id", &self.message_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RedactChannelMessageInput {
    /// <p>The ARN of the channel containing the messages that you want to redact.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the message being redacted.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl RedactChannelMessageInput {
    /// <p>The ARN of the channel containing the messages that you want to redact.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ID of the message being redacted.</p>
    pub fn message_id(&self) -> std::option::Option<&str> {
        self.message_id.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for RedactChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RedactChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("message_id", &self.message_id);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutVoiceConnectorTerminationCredentialsInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The termination SIP credentials.</p>
    pub credentials: std::option::Option<std::vec::Vec<crate::model::Credential>>,
}
impl PutVoiceConnectorTerminationCredentialsInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The termination SIP credentials.</p>
    pub fn credentials(&self) -> std::option::Option<&[crate::model::Credential]> {
        self.credentials.as_deref()
    }
}
impl std::fmt::Debug for PutVoiceConnectorTerminationCredentialsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutVoiceConnectorTerminationCredentialsInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("credentials", &self.credentials);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutVoiceConnectorTerminationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The termination setting details to add.</p>
    pub termination: std::option::Option<crate::model::Termination>,
}
impl PutVoiceConnectorTerminationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The termination setting details to add.</p>
    pub fn termination(&self) -> std::option::Option<&crate::model::Termination> {
        self.termination.as_ref()
    }
}
impl std::fmt::Debug for PutVoiceConnectorTerminationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutVoiceConnectorTerminationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("termination", &self.termination);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutVoiceConnectorStreamingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The streaming configuration details to add.</p>
    pub streaming_configuration: std::option::Option<crate::model::StreamingConfiguration>,
}
impl PutVoiceConnectorStreamingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The streaming configuration details to add.</p>
    pub fn streaming_configuration(
        &self,
    ) -> std::option::Option<&crate::model::StreamingConfiguration> {
        self.streaming_configuration.as_ref()
    }
}
impl std::fmt::Debug for PutVoiceConnectorStreamingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutVoiceConnectorStreamingConfigurationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("streaming_configuration", &self.streaming_configuration);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutVoiceConnectorProxyInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The default number of minutes allowed for proxy sessions.</p>
    pub default_session_expiry_minutes: std::option::Option<i32>,
    /// <p>The countries for proxy phone numbers to be selected from.</p>
    pub phone_number_pool_countries: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The phone number to route calls to after a proxy session expires.</p>
    pub fall_back_phone_number: std::option::Option<std::string::String>,
    /// <p>When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.</p>
    pub disabled: std::option::Option<bool>,
}
impl PutVoiceConnectorProxyInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The default number of minutes allowed for proxy sessions.</p>
    pub fn default_session_expiry_minutes(&self) -> std::option::Option<i32> {
        self.default_session_expiry_minutes
    }
    /// <p>The countries for proxy phone numbers to be selected from.</p>
    pub fn phone_number_pool_countries(&self) -> std::option::Option<&[std::string::String]> {
        self.phone_number_pool_countries.as_deref()
    }
    /// <p>The phone number to route calls to after a proxy session expires.</p>
    pub fn fall_back_phone_number(&self) -> std::option::Option<&str> {
        self.fall_back_phone_number.as_deref()
    }
    /// <p>When true, stops proxy sessions from being created on the specified Amazon Chime Voice Connector.</p>
    pub fn disabled(&self) -> std::option::Option<bool> {
        self.disabled
    }
}
impl std::fmt::Debug for PutVoiceConnectorProxyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutVoiceConnectorProxyInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field(
            "default_session_expiry_minutes",
            &self.default_session_expiry_minutes,
        );
        formatter.field(
            "phone_number_pool_countries",
            &self.phone_number_pool_countries,
        );
        formatter.field("fall_back_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("disabled", &self.disabled);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutVoiceConnectorOriginationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The origination setting details to add.</p>
    pub origination: std::option::Option<crate::model::Origination>,
}
impl PutVoiceConnectorOriginationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The origination setting details to add.</p>
    pub fn origination(&self) -> std::option::Option<&crate::model::Origination> {
        self.origination.as_ref()
    }
}
impl std::fmt::Debug for PutVoiceConnectorOriginationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutVoiceConnectorOriginationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("origination", &self.origination);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutVoiceConnectorLoggingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The logging configuration details to add.</p>
    pub logging_configuration: std::option::Option<crate::model::LoggingConfiguration>,
}
impl PutVoiceConnectorLoggingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The logging configuration details to add.</p>
    pub fn logging_configuration(
        &self,
    ) -> std::option::Option<&crate::model::LoggingConfiguration> {
        self.logging_configuration.as_ref()
    }
}
impl std::fmt::Debug for PutVoiceConnectorLoggingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutVoiceConnectorLoggingConfigurationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("logging_configuration", &self.logging_configuration);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutVoiceConnectorEmergencyCallingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The emergency calling configuration details.</p>
    pub emergency_calling_configuration:
        std::option::Option<crate::model::EmergencyCallingConfiguration>,
}
impl PutVoiceConnectorEmergencyCallingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The emergency calling configuration details.</p>
    pub fn emergency_calling_configuration(
        &self,
    ) -> std::option::Option<&crate::model::EmergencyCallingConfiguration> {
        self.emergency_calling_configuration.as_ref()
    }
}
impl std::fmt::Debug for PutVoiceConnectorEmergencyCallingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutVoiceConnectorEmergencyCallingConfigurationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field(
            "emergency_calling_configuration",
            &self.emergency_calling_configuration,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutSipMediaApplicationLoggingConfigurationInput {
    /// <p>The SIP media application ID.</p>
    pub sip_media_application_id: std::option::Option<std::string::String>,
    /// <p>The actual logging configuration.</p>
    pub sip_media_application_logging_configuration:
        std::option::Option<crate::model::SipMediaApplicationLoggingConfiguration>,
}
impl PutSipMediaApplicationLoggingConfigurationInput {
    /// <p>The SIP media application ID.</p>
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
    /// <p>The actual logging configuration.</p>
    pub fn sip_media_application_logging_configuration(
        &self,
    ) -> std::option::Option<&crate::model::SipMediaApplicationLoggingConfiguration> {
        self.sip_media_application_logging_configuration.as_ref()
    }
}
impl std::fmt::Debug for PutSipMediaApplicationLoggingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutSipMediaApplicationLoggingConfigurationInput");
        formatter.field("sip_media_application_id", &self.sip_media_application_id);
        formatter.field(
            "sip_media_application_logging_configuration",
            &self.sip_media_application_logging_configuration,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRetentionSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The retention settings.</p>
    pub retention_settings: std::option::Option<crate::model::RetentionSettings>,
}
impl PutRetentionSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The retention settings.</p>
    pub fn retention_settings(&self) -> std::option::Option<&crate::model::RetentionSettings> {
        self.retention_settings.as_ref()
    }
}
impl std::fmt::Debug for PutRetentionSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRetentionSettingsInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("retention_settings", &self.retention_settings);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutEventsConfigurationInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The bot ID.</p>
    pub bot_id: std::option::Option<std::string::String>,
    /// <p>HTTPS endpoint that allows the bot to receive outgoing events.</p>
    pub outbound_events_https_endpoint: std::option::Option<std::string::String>,
    /// <p>Lambda function ARN that allows the bot to receive outgoing events.</p>
    pub lambda_function_arn: std::option::Option<std::string::String>,
}
impl PutEventsConfigurationInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The bot ID.</p>
    pub fn bot_id(&self) -> std::option::Option<&str> {
        self.bot_id.as_deref()
    }
    /// <p>HTTPS endpoint that allows the bot to receive outgoing events.</p>
    pub fn outbound_events_https_endpoint(&self) -> std::option::Option<&str> {
        self.outbound_events_https_endpoint.as_deref()
    }
    /// <p>Lambda function ARN that allows the bot to receive outgoing events.</p>
    pub fn lambda_function_arn(&self) -> std::option::Option<&str> {
        self.lambda_function_arn.as_deref()
    }
}
impl std::fmt::Debug for PutEventsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutEventsConfigurationInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("bot_id", &self.bot_id);
        formatter.field(
            "outbound_events_https_endpoint",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("lambda_function_arn", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutAppInstanceStreamingConfigurationsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The streaming configurations set for an <code>AppInstance</code>.</p>
    pub app_instance_streaming_configurations:
        std::option::Option<std::vec::Vec<crate::model::AppInstanceStreamingConfiguration>>,
}
impl PutAppInstanceStreamingConfigurationsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
    /// <p>The streaming configurations set for an <code>AppInstance</code>.</p>
    pub fn app_instance_streaming_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::AppInstanceStreamingConfiguration]> {
        self.app_instance_streaming_configurations.as_deref()
    }
}
impl std::fmt::Debug for PutAppInstanceStreamingConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutAppInstanceStreamingConfigurationsInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field(
            "app_instance_streaming_configurations",
            &self.app_instance_streaming_configurations,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutAppInstanceRetentionSettingsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The time in days to retain data. Data type: number.</p>
    pub app_instance_retention_settings:
        std::option::Option<crate::model::AppInstanceRetentionSettings>,
}
impl PutAppInstanceRetentionSettingsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
    /// <p>The time in days to retain data. Data type: number.</p>
    pub fn app_instance_retention_settings(
        &self,
    ) -> std::option::Option<&crate::model::AppInstanceRetentionSettings> {
        self.app_instance_retention_settings.as_ref()
    }
}
impl std::fmt::Debug for PutAppInstanceRetentionSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutAppInstanceRetentionSettingsInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field(
            "app_instance_retention_settings",
            &self.app_instance_retention_settings,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LogoutUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user ID.</p>
    pub user_id: std::option::Option<std::string::String>,
}
impl LogoutUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user ID.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
}
impl std::fmt::Debug for LogoutUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LogoutUserInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id", &self.user_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVoiceConnectorTerminationCredentialsInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl ListVoiceConnectorTerminationCredentialsInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for ListVoiceConnectorTerminationCredentialsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVoiceConnectorTerminationCredentialsInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVoiceConnectorsInput {
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListVoiceConnectorsInput {
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListVoiceConnectorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVoiceConnectorsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVoiceConnectorGroupsInput {
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListVoiceConnectorGroupsInput {
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListVoiceConnectorGroupsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVoiceConnectorGroupsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListUsersInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>Optional. The user email address used to filter results. Maximum 1.</p>
    pub user_email: std::option::Option<std::string::String>,
    /// <p>The user type.</p>
    pub user_type: std::option::Option<crate::model::UserType>,
    /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListUsersInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>Optional. The user email address used to filter results. Maximum 1.</p>
    pub fn user_email(&self) -> std::option::Option<&str> {
        self.user_email.as_deref()
    }
    /// <p>The user type.</p>
    pub fn user_type(&self) -> std::option::Option<&crate::model::UserType> {
        self.user_type.as_ref()
    }
    /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListUsersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListUsersInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_email", &"*** Sensitive Data Redacted ***");
        formatter.field("user_type", &self.user_type);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The resource ARN.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The resource ARN.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSupportedPhoneNumberCountriesInput {
    /// <p>The phone number product type.</p>
    pub product_type: std::option::Option<crate::model::PhoneNumberProductType>,
}
impl ListSupportedPhoneNumberCountriesInput {
    /// <p>The phone number product type.</p>
    pub fn product_type(&self) -> std::option::Option<&crate::model::PhoneNumberProductType> {
        self.product_type.as_ref()
    }
}
impl std::fmt::Debug for ListSupportedPhoneNumberCountriesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSupportedPhoneNumberCountriesInput");
        formatter.field("product_type", &self.product_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSipRulesInput {
    /// <p>The SIP media application ID.</p>
    pub sip_media_application_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListSipRulesInput {
    /// <p>The SIP media application ID.</p>
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
    /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListSipRulesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSipRulesInput");
        formatter.field("sip_media_application_id", &self.sip_media_application_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSipMediaApplicationsInput {
    /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListSipMediaApplicationsInput {
    /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListSipMediaApplicationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSipMediaApplicationsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRoomsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The member ID (user ID or bot ID).</p>
    pub member_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListRoomsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The member ID (user ID or bot ID).</p>
    pub fn member_id(&self) -> std::option::Option<&str> {
        self.member_id.as_deref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListRoomsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRoomsInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("member_id", &self.member_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRoomMembershipsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The room ID.</p>
    pub room_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListRoomMembershipsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The room ID.</p>
    pub fn room_id(&self) -> std::option::Option<&str> {
        self.room_id.as_deref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListRoomMembershipsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRoomMembershipsInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("room_id", &self.room_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListProxySessionsInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The proxy session status.</p>
    pub status: std::option::Option<crate::model::ProxySessionStatus>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListProxySessionsInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The proxy session status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ProxySessionStatus> {
        self.status.as_ref()
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListProxySessionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListProxySessionsInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("status", &self.status);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPhoneNumbersInput {
    /// <p>The phone number status.</p>
    pub status: std::option::Option<crate::model::PhoneNumberStatus>,
    /// <p>The phone number product type.</p>
    pub product_type: std::option::Option<crate::model::PhoneNumberProductType>,
    /// <p>The filter to use to limit the number of results.</p>
    pub filter_name: std::option::Option<crate::model::PhoneNumberAssociationName>,
    /// <p>The value to use for the filter.</p>
    pub filter_value: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListPhoneNumbersInput {
    /// <p>The phone number status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::PhoneNumberStatus> {
        self.status.as_ref()
    }
    /// <p>The phone number product type.</p>
    pub fn product_type(&self) -> std::option::Option<&crate::model::PhoneNumberProductType> {
        self.product_type.as_ref()
    }
    /// <p>The filter to use to limit the number of results.</p>
    pub fn filter_name(&self) -> std::option::Option<&crate::model::PhoneNumberAssociationName> {
        self.filter_name.as_ref()
    }
    /// <p>The value to use for the filter.</p>
    pub fn filter_value(&self) -> std::option::Option<&str> {
        self.filter_value.as_deref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListPhoneNumbersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPhoneNumbersInput");
        formatter.field("status", &self.status);
        formatter.field("product_type", &self.product_type);
        formatter.field("filter_name", &self.filter_name);
        formatter.field("filter_value", &self.filter_value);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPhoneNumberOrdersInput {
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListPhoneNumberOrdersInput {
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListPhoneNumberOrdersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPhoneNumberOrdersInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMeetingTagsInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
}
impl ListMeetingTagsInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
}
impl std::fmt::Debug for ListMeetingTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMeetingTagsInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMeetingsInput {
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListMeetingsInput {
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListMeetingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMeetingsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMediaCapturePipelinesInput {
    /// <p>The token used to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call. Valid Range: 1 - 99.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListMediaCapturePipelinesInput {
    /// <p>The token used to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in a single call. Valid Range: 1 - 99.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListMediaCapturePipelinesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMediaCapturePipelinesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelsModeratedByAppInstanceUserInput {
    /// <p>The ARN of the user in the moderated channel.</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of channels in the request.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token returned from previous API requests until the number of channels moderated by the user is reached.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl ListChannelsModeratedByAppInstanceUserInput {
    /// <p>The ARN of the user in the moderated channel.</p>
    pub fn app_instance_user_arn(&self) -> std::option::Option<&str> {
        self.app_instance_user_arn.as_deref()
    }
    /// <p>The maximum number of channels in the request.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token returned from previous API requests until the number of channels moderated by the user is reached.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for ListChannelsModeratedByAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelsModeratedByAppInstanceUserInput");
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The privacy setting. <code>PUBLIC</code> retrieves all the public channels. <code>PRIVATE</code> retrieves private channels. Only an <code>AppInstanceAdmin</code> can retrieve private channels. </p>
    pub privacy: std::option::Option<crate::model::ChannelPrivacy>,
    /// <p>The maximum number of channels that you want to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested channels are returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl ListChannelsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
    /// <p>The privacy setting. <code>PUBLIC</code> retrieves all the public channels. <code>PRIVATE</code> retrieves private channels. Only an <code>AppInstanceAdmin</code> can retrieve private channels. </p>
    pub fn privacy(&self) -> std::option::Option<&crate::model::ChannelPrivacy> {
        self.privacy.as_ref()
    }
    /// <p>The maximum number of channels that you want to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token passed by previous API calls until all requested channels are returned.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for ListChannelsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelsInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field("privacy", &self.privacy);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelModeratorsInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of moderators that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested moderators are returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl ListChannelModeratorsInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The maximum number of moderators that you want returned.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token passed by previous API calls until all requested moderators are returned.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for ListChannelModeratorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelModeratorsInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelMessagesInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The order in which you want messages sorted. Default is Descending, based on time created.</p>
    pub sort_order: std::option::Option<crate::model::SortOrder>,
    /// <p>The initial or starting time stamp for your requested messages.</p>
    pub not_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The final or ending time stamp for your requested messages.</p>
    pub not_after: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The maximum number of messages that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested messages are returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl ListChannelMessagesInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The order in which you want messages sorted. Default is Descending, based on time created.</p>
    pub fn sort_order(&self) -> std::option::Option<&crate::model::SortOrder> {
        self.sort_order.as_ref()
    }
    /// <p>The initial or starting time stamp for your requested messages.</p>
    pub fn not_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.not_before.as_ref()
    }
    /// <p>The final or ending time stamp for your requested messages.</p>
    pub fn not_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.not_after.as_ref()
    }
    /// <p>The maximum number of messages that you want returned.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token passed by previous API calls until all requested messages are returned.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for ListChannelMessagesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelMessagesInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("not_before", &self.not_before);
        formatter.field("not_after", &self.not_after);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelMembershipsForAppInstanceUserInput {
    /// <p>The ARN of the <code>AppInstanceUser</code>s</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of users that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token returned from previous API requests until the number of channel memberships is reached.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl ListChannelMembershipsForAppInstanceUserInput {
    /// <p>The ARN of the <code>AppInstanceUser</code>s</p>
    pub fn app_instance_user_arn(&self) -> std::option::Option<&str> {
        self.app_instance_user_arn.as_deref()
    }
    /// <p>The maximum number of users that you want returned.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token returned from previous API requests until the number of channel memberships is reached.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for ListChannelMembershipsForAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelMembershipsForAppInstanceUserInput");
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelMembershipsInput {
    /// <p>The maximum number of channel memberships that you want returned.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned.</p>
    pub r#type: std::option::Option<crate::model::ChannelMembershipType>,
    /// <p>The maximum number of channel memberships that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested channel memberships are returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl ListChannelMembershipsInput {
    /// <p>The maximum number of channel memberships that you want returned.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ChannelMembershipType> {
        self.r#type.as_ref()
    }
    /// <p>The maximum number of channel memberships that you want returned.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token passed by previous API calls until all requested channel memberships are returned.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for ListChannelMembershipsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelMembershipsInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelBansInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of bans that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested bans are returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl ListChannelBansInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The maximum number of bans that you want returned.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token passed by previous API calls until all requested bans are returned.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for ListChannelBansInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelBansInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBotsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call. The default is 10.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListBotsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The maximum number of results to return in a single call. The default is 10.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListBotsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBotsInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAttendeeTagsInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub attendee_id: std::option::Option<std::string::String>,
}
impl ListAttendeeTagsInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub fn attendee_id(&self) -> std::option::Option<&str> {
        self.attendee_id.as_deref()
    }
}
impl std::fmt::Debug for ListAttendeeTagsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAttendeeTagsInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("attendee_id", &self.attendee_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAttendeesInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListAttendeesInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in a single call.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListAttendeesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAttendeesInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAppInstanceUsersInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of requests that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested users are returned.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListAppInstanceUsersInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
    /// <p>The maximum number of requests that you want returned.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token passed by previous API calls until all requested users are returned.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListAppInstanceUsersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAppInstanceUsersInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAppInstancesInput {
    /// <p>The maximum number of <code>AppInstance</code>s that you want to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API requests until you reach the maximum number of <code>AppInstance</code>s.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListAppInstancesInput {
    /// <p>The maximum number of <code>AppInstance</code>s that you want to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token passed by previous API requests until you reach the maximum number of <code>AppInstance</code>s.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListAppInstancesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAppInstancesInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAppInstanceAdminsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of administrators that you want to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token returned from previous API requests until the number of administrators is reached.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListAppInstanceAdminsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
    /// <p>The maximum number of administrators that you want to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token returned from previous API requests until the number of administrators is reached.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListAppInstanceAdminsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAppInstanceAdminsInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAccountsInput {
    /// <p>Amazon Chime account name prefix with which to filter results.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>User email address with which to filter results.</p>
    pub user_email: std::option::Option<std::string::String>,
    /// <p>The token to use to retrieve the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
    pub max_results: std::option::Option<i32>,
}
impl ListAccountsInput {
    /// <p>Amazon Chime account name prefix with which to filter results.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>User email address with which to filter results.</p>
    pub fn user_email(&self) -> std::option::Option<&str> {
        self.user_email.as_deref()
    }
    /// <p>The token to use to retrieve the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to return in a single call. Defaults to 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl std::fmt::Debug for ListAccountsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAccountsInput");
        formatter.field("name", &self.name);
        formatter.field("user_email", &"*** Sensitive Data Redacted ***");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InviteUsersInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user email addresses to which to send the email invitation.</p>
    pub user_email_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The user type.</p>
    pub user_type: std::option::Option<crate::model::UserType>,
}
impl InviteUsersInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user email addresses to which to send the email invitation.</p>
    pub fn user_email_list(&self) -> std::option::Option<&[std::string::String]> {
        self.user_email_list.as_deref()
    }
    /// <p>The user type.</p>
    pub fn user_type(&self) -> std::option::Option<&crate::model::UserType> {
        self.user_type.as_ref()
    }
}
impl std::fmt::Debug for InviteUsersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InviteUsersInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_email_list", &self.user_email_list);
        formatter.field("user_type", &self.user_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVoiceConnectorTerminationHealthInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl GetVoiceConnectorTerminationHealthInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for GetVoiceConnectorTerminationHealthInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVoiceConnectorTerminationHealthInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVoiceConnectorTerminationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl GetVoiceConnectorTerminationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for GetVoiceConnectorTerminationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVoiceConnectorTerminationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVoiceConnectorStreamingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl GetVoiceConnectorStreamingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for GetVoiceConnectorStreamingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVoiceConnectorStreamingConfigurationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVoiceConnectorProxyInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl GetVoiceConnectorProxyInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for GetVoiceConnectorProxyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVoiceConnectorProxyInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVoiceConnectorOriginationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl GetVoiceConnectorOriginationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for GetVoiceConnectorOriginationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVoiceConnectorOriginationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVoiceConnectorLoggingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl GetVoiceConnectorLoggingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for GetVoiceConnectorLoggingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVoiceConnectorLoggingConfigurationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub voice_connector_group_id: std::option::Option<std::string::String>,
}
impl GetVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub fn voice_connector_group_id(&self) -> std::option::Option<&str> {
        self.voice_connector_group_id.as_deref()
    }
}
impl std::fmt::Debug for GetVoiceConnectorGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVoiceConnectorGroupInput");
        formatter.field("voice_connector_group_id", &self.voice_connector_group_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVoiceConnectorEmergencyCallingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl GetVoiceConnectorEmergencyCallingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for GetVoiceConnectorEmergencyCallingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVoiceConnectorEmergencyCallingConfigurationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl GetVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for GetVoiceConnectorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVoiceConnectorInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetUserSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user ID.</p>
    pub user_id: std::option::Option<std::string::String>,
}
impl GetUserSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user ID.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
}
impl std::fmt::Debug for GetUserSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetUserSettingsInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id", &self.user_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user ID.</p>
    pub user_id: std::option::Option<std::string::String>,
}
impl GetUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user ID.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
}
impl std::fmt::Debug for GetUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetUserInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id", &self.user_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSipRuleInput {
    /// <p>The SIP rule ID.</p>
    pub sip_rule_id: std::option::Option<std::string::String>,
}
impl GetSipRuleInput {
    /// <p>The SIP rule ID.</p>
    pub fn sip_rule_id(&self) -> std::option::Option<&str> {
        self.sip_rule_id.as_deref()
    }
}
impl std::fmt::Debug for GetSipRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSipRuleInput");
        formatter.field("sip_rule_id", &self.sip_rule_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSipMediaApplicationLoggingConfigurationInput {
    /// <p>The SIP media application ID.</p>
    pub sip_media_application_id: std::option::Option<std::string::String>,
}
impl GetSipMediaApplicationLoggingConfigurationInput {
    /// <p>The SIP media application ID.</p>
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
}
impl std::fmt::Debug for GetSipMediaApplicationLoggingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSipMediaApplicationLoggingConfigurationInput");
        formatter.field("sip_media_application_id", &self.sip_media_application_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSipMediaApplicationInput {
    /// <p>The SIP media application ID.</p>
    pub sip_media_application_id: std::option::Option<std::string::String>,
}
impl GetSipMediaApplicationInput {
    /// <p>The SIP media application ID.</p>
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
}
impl std::fmt::Debug for GetSipMediaApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSipMediaApplicationInput");
        formatter.field("sip_media_application_id", &self.sip_media_application_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRoomInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The room ID.</p>
    pub room_id: std::option::Option<std::string::String>,
}
impl GetRoomInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The room ID.</p>
    pub fn room_id(&self) -> std::option::Option<&str> {
        self.room_id.as_deref()
    }
}
impl std::fmt::Debug for GetRoomInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRoomInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("room_id", &self.room_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRetentionSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
}
impl GetRetentionSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
}
impl std::fmt::Debug for GetRetentionSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRetentionSettingsInput");
        formatter.field("account_id", &self.account_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetProxySessionInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The proxy session ID.</p>
    pub proxy_session_id: std::option::Option<std::string::String>,
}
impl GetProxySessionInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The proxy session ID.</p>
    pub fn proxy_session_id(&self) -> std::option::Option<&str> {
        self.proxy_session_id.as_deref()
    }
}
impl std::fmt::Debug for GetProxySessionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetProxySessionInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("proxy_session_id", &self.proxy_session_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPhoneNumberSettingsInput {}
impl std::fmt::Debug for GetPhoneNumberSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPhoneNumberSettingsInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPhoneNumberOrderInput {
    /// <p>The ID for the phone number order.</p>
    pub phone_number_order_id: std::option::Option<std::string::String>,
}
impl GetPhoneNumberOrderInput {
    /// <p>The ID for the phone number order.</p>
    pub fn phone_number_order_id(&self) -> std::option::Option<&str> {
        self.phone_number_order_id.as_deref()
    }
}
impl std::fmt::Debug for GetPhoneNumberOrderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPhoneNumberOrderInput");
        formatter.field("phone_number_order_id", &self.phone_number_order_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPhoneNumberInput {
    /// <p>The phone number ID.</p>
    pub phone_number_id: std::option::Option<std::string::String>,
}
impl GetPhoneNumberInput {
    /// <p>The phone number ID.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
}
impl std::fmt::Debug for GetPhoneNumberInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetPhoneNumberInput");
        formatter.field("phone_number_id", &self.phone_number_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMessagingSessionEndpointInput {}
impl std::fmt::Debug for GetMessagingSessionEndpointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMessagingSessionEndpointInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMeetingInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
}
impl GetMeetingInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
}
impl std::fmt::Debug for GetMeetingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMeetingInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMediaCapturePipelineInput {
    /// <p>The ID of the pipeline that you want to get.</p>
    pub media_pipeline_id: std::option::Option<std::string::String>,
}
impl GetMediaCapturePipelineInput {
    /// <p>The ID of the pipeline that you want to get.</p>
    pub fn media_pipeline_id(&self) -> std::option::Option<&str> {
        self.media_pipeline_id.as_deref()
    }
}
impl std::fmt::Debug for GetMediaCapturePipelineInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMediaCapturePipelineInput");
        formatter.field("media_pipeline_id", &self.media_pipeline_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGlobalSettingsInput {}
impl std::fmt::Debug for GetGlobalSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetGlobalSettingsInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetEventsConfigurationInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The bot ID.</p>
    pub bot_id: std::option::Option<std::string::String>,
}
impl GetEventsConfigurationInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The bot ID.</p>
    pub fn bot_id(&self) -> std::option::Option<&str> {
        self.bot_id.as_deref()
    }
}
impl std::fmt::Debug for GetEventsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetEventsConfigurationInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("bot_id", &self.bot_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the message.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl GetChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ID of the message.</p>
    pub fn message_id(&self) -> std::option::Option<&str> {
        self.message_id.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for GetChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("message_id", &self.message_id);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBotInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The bot ID.</p>
    pub bot_id: std::option::Option<std::string::String>,
}
impl GetBotInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The bot ID.</p>
    pub fn bot_id(&self) -> std::option::Option<&str> {
        self.bot_id.as_deref()
    }
}
impl std::fmt::Debug for GetBotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBotInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("bot_id", &self.bot_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub attendee_id: std::option::Option<std::string::String>,
}
impl GetAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub fn attendee_id(&self) -> std::option::Option<&str> {
        self.attendee_id.as_deref()
    }
}
impl std::fmt::Debug for GetAttendeeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAttendeeInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("attendee_id", &self.attendee_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAppInstanceStreamingConfigurationsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
}
impl GetAppInstanceStreamingConfigurationsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
}
impl std::fmt::Debug for GetAppInstanceStreamingConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAppInstanceStreamingConfigurationsInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAppInstanceRetentionSettingsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
}
impl GetAppInstanceRetentionSettingsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
}
impl std::fmt::Debug for GetAppInstanceRetentionSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAppInstanceRetentionSettingsInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccountSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
}
impl GetAccountSettingsInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
}
impl std::fmt::Debug for GetAccountSettingsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccountSettingsInput");
        formatter.field("account_id", &self.account_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
}
impl GetAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
}
impl std::fmt::Debug for GetAccountInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccountInput");
        formatter.field("account_id", &self.account_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateSigninDelegateGroupsFromAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The sign-in delegate group names.</p>
    pub group_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DisassociateSigninDelegateGroupsFromAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The sign-in delegate group names.</p>
    pub fn group_names(&self) -> std::option::Option<&[std::string::String]> {
        self.group_names.as_deref()
    }
}
impl std::fmt::Debug for DisassociateSigninDelegateGroupsFromAccountInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateSigninDelegateGroupsFromAccountInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("group_names", &self.group_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociatePhoneNumbersFromVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub voice_connector_group_id: std::option::Option<std::string::String>,
    /// <p>List of phone numbers, in E.164 format.</p>
    pub e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DisassociatePhoneNumbersFromVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub fn voice_connector_group_id(&self) -> std::option::Option<&str> {
        self.voice_connector_group_id.as_deref()
    }
    /// <p>List of phone numbers, in E.164 format.</p>
    pub fn e164_phone_numbers(&self) -> std::option::Option<&[std::string::String]> {
        self.e164_phone_numbers.as_deref()
    }
}
impl std::fmt::Debug for DisassociatePhoneNumbersFromVoiceConnectorGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociatePhoneNumbersFromVoiceConnectorGroupInput");
        formatter.field("voice_connector_group_id", &self.voice_connector_group_id);
        formatter.field("e164_phone_numbers", &self.e164_phone_numbers);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociatePhoneNumbersFromVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>List of phone numbers, in E.164 format.</p>
    pub e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DisassociatePhoneNumbersFromVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>List of phone numbers, in E.164 format.</p>
    pub fn e164_phone_numbers(&self) -> std::option::Option<&[std::string::String]> {
        self.e164_phone_numbers.as_deref()
    }
}
impl std::fmt::Debug for DisassociatePhoneNumbersFromVoiceConnectorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociatePhoneNumbersFromVoiceConnectorInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("e164_phone_numbers", &self.e164_phone_numbers);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociatePhoneNumberFromUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user ID.</p>
    pub user_id: std::option::Option<std::string::String>,
}
impl DisassociatePhoneNumberFromUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user ID.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
}
impl std::fmt::Debug for DisassociatePhoneNumberFromUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociatePhoneNumberFromUserInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id", &self.user_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelModeratorInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the channel moderator.</p>
    pub channel_moderator_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DescribeChannelModeratorInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the channel moderator.</p>
    pub fn channel_moderator_arn(&self) -> std::option::Option<&str> {
        self.channel_moderator_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DescribeChannelModeratorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelModeratorInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("channel_moderator_arn", &self.channel_moderator_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelModeratedByAppInstanceUserInput {
    /// <p>The ARN of the moderated channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the <code>AppInstanceUser</code> in the moderated channel.</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DescribeChannelModeratedByAppInstanceUserInput {
    /// <p>The ARN of the moderated channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the <code>AppInstanceUser</code> in the moderated channel.</p>
    pub fn app_instance_user_arn(&self) -> std::option::Option<&str> {
        self.app_instance_user_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DescribeChannelModeratedByAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelModeratedByAppInstanceUserInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelMembershipForAppInstanceUserInput {
    /// <p>The ARN of the channel to which the user belongs.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the user in a channel.</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DescribeChannelMembershipForAppInstanceUserInput {
    /// <p>The ARN of the channel to which the user belongs.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the user in a channel.</p>
    pub fn app_instance_user_arn(&self) -> std::option::Option<&str> {
        self.app_instance_user_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DescribeChannelMembershipForAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelMembershipForAppInstanceUserInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelMembershipInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DescribeChannelMembershipInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the member.</p>
    pub fn member_arn(&self) -> std::option::Option<&str> {
        self.member_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DescribeChannelMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelMembershipInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelBanInput {
    /// <p>The ARN of the channel from which the user is banned.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member being banned.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DescribeChannelBanInput {
    /// <p>The ARN of the channel from which the user is banned.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the member being banned.</p>
    pub fn member_arn(&self) -> std::option::Option<&str> {
        self.member_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DescribeChannelBanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelBanInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DescribeChannelInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DescribeChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAppInstanceUserInput {
    /// <p>The ARN of the <code>AppInstanceUser</code>.</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
}
impl DescribeAppInstanceUserInput {
    /// <p>The ARN of the <code>AppInstanceUser</code>.</p>
    pub fn app_instance_user_arn(&self) -> std::option::Option<&str> {
        self.app_instance_user_arn.as_deref()
    }
}
impl std::fmt::Debug for DescribeAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAppInstanceUserInput");
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAppInstanceAdminInput {
    /// <p>The ARN of the <code>AppInstanceAdmin</code>.</p>
    pub app_instance_admin_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
}
impl DescribeAppInstanceAdminInput {
    /// <p>The ARN of the <code>AppInstanceAdmin</code>.</p>
    pub fn app_instance_admin_arn(&self) -> std::option::Option<&str> {
        self.app_instance_admin_arn.as_deref()
    }
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
}
impl std::fmt::Debug for DescribeAppInstanceAdminInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAppInstanceAdminInput");
        formatter.field("app_instance_admin_arn", &self.app_instance_admin_arn);
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAppInstanceInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
}
impl DescribeAppInstanceInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
}
impl std::fmt::Debug for DescribeAppInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAppInstanceInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVoiceConnectorTerminationCredentialsInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The RFC2617 compliant username associated with the SIP credentials, in US-ASCII format.</p>
    pub usernames: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DeleteVoiceConnectorTerminationCredentialsInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The RFC2617 compliant username associated with the SIP credentials, in US-ASCII format.</p>
    pub fn usernames(&self) -> std::option::Option<&[std::string::String]> {
        self.usernames.as_deref()
    }
}
impl std::fmt::Debug for DeleteVoiceConnectorTerminationCredentialsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVoiceConnectorTerminationCredentialsInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("usernames", &self.usernames);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVoiceConnectorTerminationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl DeleteVoiceConnectorTerminationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteVoiceConnectorTerminationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVoiceConnectorTerminationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVoiceConnectorStreamingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl DeleteVoiceConnectorStreamingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteVoiceConnectorStreamingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVoiceConnectorStreamingConfigurationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVoiceConnectorProxyInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl DeleteVoiceConnectorProxyInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteVoiceConnectorProxyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVoiceConnectorProxyInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVoiceConnectorOriginationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl DeleteVoiceConnectorOriginationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteVoiceConnectorOriginationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVoiceConnectorOriginationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub voice_connector_group_id: std::option::Option<std::string::String>,
}
impl DeleteVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub fn voice_connector_group_id(&self) -> std::option::Option<&str> {
        self.voice_connector_group_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteVoiceConnectorGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVoiceConnectorGroupInput");
        formatter.field("voice_connector_group_id", &self.voice_connector_group_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVoiceConnectorEmergencyCallingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl DeleteVoiceConnectorEmergencyCallingConfigurationInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteVoiceConnectorEmergencyCallingConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("DeleteVoiceConnectorEmergencyCallingConfigurationInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
}
impl DeleteVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteVoiceConnectorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVoiceConnectorInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSipRuleInput {
    /// <p>The SIP rule ID.</p>
    pub sip_rule_id: std::option::Option<std::string::String>,
}
impl DeleteSipRuleInput {
    /// <p>The SIP rule ID.</p>
    pub fn sip_rule_id(&self) -> std::option::Option<&str> {
        self.sip_rule_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteSipRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSipRuleInput");
        formatter.field("sip_rule_id", &self.sip_rule_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSipMediaApplicationInput {
    /// <p>The SIP media application ID.</p>
    pub sip_media_application_id: std::option::Option<std::string::String>,
}
impl DeleteSipMediaApplicationInput {
    /// <p>The SIP media application ID.</p>
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteSipMediaApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSipMediaApplicationInput");
        formatter.field("sip_media_application_id", &self.sip_media_application_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRoomMembershipInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The room ID.</p>
    pub room_id: std::option::Option<std::string::String>,
    /// <p>The member ID (user ID or bot ID).</p>
    pub member_id: std::option::Option<std::string::String>,
}
impl DeleteRoomMembershipInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The room ID.</p>
    pub fn room_id(&self) -> std::option::Option<&str> {
        self.room_id.as_deref()
    }
    /// <p>The member ID (user ID or bot ID).</p>
    pub fn member_id(&self) -> std::option::Option<&str> {
        self.member_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteRoomMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRoomMembershipInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("room_id", &self.room_id);
        formatter.field("member_id", &self.member_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRoomInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The chat room ID.</p>
    pub room_id: std::option::Option<std::string::String>,
}
impl DeleteRoomInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The chat room ID.</p>
    pub fn room_id(&self) -> std::option::Option<&str> {
        self.room_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteRoomInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRoomInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("room_id", &self.room_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteProxySessionInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The proxy session ID.</p>
    pub proxy_session_id: std::option::Option<std::string::String>,
}
impl DeleteProxySessionInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The proxy session ID.</p>
    pub fn proxy_session_id(&self) -> std::option::Option<&str> {
        self.proxy_session_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteProxySessionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteProxySessionInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("proxy_session_id", &self.proxy_session_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeletePhoneNumberInput {
    /// <p>The phone number ID.</p>
    pub phone_number_id: std::option::Option<std::string::String>,
}
impl DeletePhoneNumberInput {
    /// <p>The phone number ID.</p>
    pub fn phone_number_id(&self) -> std::option::Option<&str> {
        self.phone_number_id.as_deref()
    }
}
impl std::fmt::Debug for DeletePhoneNumberInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeletePhoneNumberInput");
        formatter.field("phone_number_id", &self.phone_number_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMeetingInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
}
impl DeleteMeetingInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteMeetingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMeetingInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMediaCapturePipelineInput {
    /// <p>The ID of the media capture pipeline being deleted. </p>
    pub media_pipeline_id: std::option::Option<std::string::String>,
}
impl DeleteMediaCapturePipelineInput {
    /// <p>The ID of the media capture pipeline being deleted. </p>
    pub fn media_pipeline_id(&self) -> std::option::Option<&str> {
        self.media_pipeline_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteMediaCapturePipelineInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMediaCapturePipelineInput");
        formatter.field("media_pipeline_id", &self.media_pipeline_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteEventsConfigurationInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The bot ID.</p>
    pub bot_id: std::option::Option<std::string::String>,
}
impl DeleteEventsConfigurationInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The bot ID.</p>
    pub fn bot_id(&self) -> std::option::Option<&str> {
        self.bot_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteEventsConfigurationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteEventsConfigurationInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("bot_id", &self.bot_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelModeratorInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the moderator being deleted.</p>
    pub channel_moderator_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DeleteChannelModeratorInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the moderator being deleted.</p>
    pub fn channel_moderator_arn(&self) -> std::option::Option<&str> {
        self.channel_moderator_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DeleteChannelModeratorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelModeratorInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("channel_moderator_arn", &self.channel_moderator_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the message being deleted.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DeleteChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ID of the message being deleted.</p>
    pub fn message_id(&self) -> std::option::Option<&str> {
        self.message_id.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DeleteChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("message_id", &self.message_id);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelMembershipInput {
    /// <p>The ARN of the channel from which you want to remove the user.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member that you're removing from the channel.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DeleteChannelMembershipInput {
    /// <p>The ARN of the channel from which you want to remove the user.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the member that you're removing from the channel.</p>
    pub fn member_arn(&self) -> std::option::Option<&str> {
        self.member_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DeleteChannelMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelMembershipInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelBanInput {
    /// <p>The ARN of the channel from which the <code>AppInstanceUser</code> was banned.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the <code>AppInstanceUser</code> that you want to reinstate.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DeleteChannelBanInput {
    /// <p>The ARN of the channel from which the <code>AppInstanceUser</code> was banned.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the <code>AppInstanceUser</code> that you want to reinstate.</p>
    pub fn member_arn(&self) -> std::option::Option<&str> {
        self.member_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DeleteChannelBanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelBanInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelInput {
    /// <p>The ARN of the channel being deleted.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl DeleteChannelInput {
    /// <p>The ARN of the channel being deleted.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for DeleteChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub attendee_id: std::option::Option<std::string::String>,
}
impl DeleteAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The Amazon Chime SDK attendee ID.</p>
    pub fn attendee_id(&self) -> std::option::Option<&str> {
        self.attendee_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteAttendeeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAttendeeInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("attendee_id", &self.attendee_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAppInstanceUserInput {
    /// <p>The ARN of the user request being deleted.</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
}
impl DeleteAppInstanceUserInput {
    /// <p>The ARN of the user request being deleted.</p>
    pub fn app_instance_user_arn(&self) -> std::option::Option<&str> {
        self.app_instance_user_arn.as_deref()
    }
}
impl std::fmt::Debug for DeleteAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAppInstanceUserInput");
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAppInstanceStreamingConfigurationsInput {
    /// <p>The ARN of the streaming configurations being deleted.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
}
impl DeleteAppInstanceStreamingConfigurationsInput {
    /// <p>The ARN of the streaming configurations being deleted.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
}
impl std::fmt::Debug for DeleteAppInstanceStreamingConfigurationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAppInstanceStreamingConfigurationsInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAppInstanceAdminInput {
    /// <p>The ARN of the <code>AppInstance</code>'s administrator.</p>
    pub app_instance_admin_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
}
impl DeleteAppInstanceAdminInput {
    /// <p>The ARN of the <code>AppInstance</code>'s administrator.</p>
    pub fn app_instance_admin_arn(&self) -> std::option::Option<&str> {
        self.app_instance_admin_arn.as_deref()
    }
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
}
impl std::fmt::Debug for DeleteAppInstanceAdminInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAppInstanceAdminInput");
        formatter.field("app_instance_admin_arn", &self.app_instance_admin_arn);
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAppInstanceInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
}
impl DeleteAppInstanceInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
}
impl std::fmt::Debug for DeleteAppInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAppInstanceInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
}
impl DeleteAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteAccountInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAccountInput");
        formatter.field("account_id", &self.account_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVoiceConnectorGroupInput {
    /// <p>The name of the Amazon Chime Voice Connector group.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Chime Voice Connectors to route inbound calls to.</p>
    pub voice_connector_items: std::option::Option<std::vec::Vec<crate::model::VoiceConnectorItem>>,
}
impl CreateVoiceConnectorGroupInput {
    /// <p>The name of the Amazon Chime Voice Connector group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Chime Voice Connectors to route inbound calls to.</p>
    pub fn voice_connector_items(
        &self,
    ) -> std::option::Option<&[crate::model::VoiceConnectorItem]> {
        self.voice_connector_items.as_deref()
    }
}
impl std::fmt::Debug for CreateVoiceConnectorGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVoiceConnectorGroupInput");
        formatter.field("name", &self.name);
        formatter.field("voice_connector_items", &self.voice_connector_items);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVoiceConnectorInput {
    /// <p>The name of the Amazon Chime Voice Connector.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p> The AWS Region in which the Amazon Chime Voice Connector is created. Default value: <code>us-east-1</code> . </p>
    pub aws_region: std::option::Option<crate::model::VoiceConnectorAwsRegion>,
    /// <p>When enabled, requires encryption for the Amazon Chime Voice Connector.</p>
    pub require_encryption: std::option::Option<bool>,
}
impl CreateVoiceConnectorInput {
    /// <p>The name of the Amazon Chime Voice Connector.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The AWS Region in which the Amazon Chime Voice Connector is created. Default value: <code>us-east-1</code> . </p>
    pub fn aws_region(&self) -> std::option::Option<&crate::model::VoiceConnectorAwsRegion> {
        self.aws_region.as_ref()
    }
    /// <p>When enabled, requires encryption for the Amazon Chime Voice Connector.</p>
    pub fn require_encryption(&self) -> std::option::Option<bool> {
        self.require_encryption
    }
}
impl std::fmt::Debug for CreateVoiceConnectorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVoiceConnectorInput");
        formatter.field("name", &self.name);
        formatter.field("aws_region", &self.aws_region);
        formatter.field("require_encryption", &self.require_encryption);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user name.</p>
    pub username: std::option::Option<std::string::String>,
    /// <p>The user's email address.</p>
    pub email: std::option::Option<std::string::String>,
    /// <p>The user type.</p>
    pub user_type: std::option::Option<crate::model::UserType>,
}
impl CreateUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user name.</p>
    pub fn username(&self) -> std::option::Option<&str> {
        self.username.as_deref()
    }
    /// <p>The user's email address.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
    /// <p>The user type.</p>
    pub fn user_type(&self) -> std::option::Option<&crate::model::UserType> {
        self.user_type.as_ref()
    }
}
impl std::fmt::Debug for CreateUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateUserInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("username", &self.username);
        formatter.field("email", &"*** Sensitive Data Redacted ***");
        formatter.field("user_type", &self.user_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSipRuleInput {
    /// <p>The name of the SIP rule.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of trigger assigned to the SIP rule in <code>TriggerValue</code>, currently <code>RequestUriHostname</code> or <code>ToPhoneNumber</code>.</p>
    pub trigger_type: std::option::Option<crate::model::SipRuleTriggerType>,
    /// <p>If <code>TriggerType</code> is <code>RequestUriHostname</code>, the value can be the outbound host name of an Amazon Chime Voice Connector. If <code>TriggerType</code> is <code>ToPhoneNumber</code>, the value can be a customer-owned phone number in the E164 format. The <code>SipMediaApplication</code> specified in the <code>SipRule</code> is triggered if the request URI in an incoming SIP request matches the <code>RequestUriHostname</code>, or if the <code>To</code> header in the incoming SIP request matches the <code>ToPhoneNumber</code> value.</p>
    pub trigger_value: std::option::Option<std::string::String>,
    /// <p>Enables or disables a rule. You must disable rules before you can delete them.</p>
    pub disabled: std::option::Option<bool>,
    /// <p>List of SIP media applications with priority and AWS Region. Only one SIP application per AWS Region can be used.</p>
    pub target_applications:
        std::option::Option<std::vec::Vec<crate::model::SipRuleTargetApplication>>,
}
impl CreateSipRuleInput {
    /// <p>The name of the SIP rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of trigger assigned to the SIP rule in <code>TriggerValue</code>, currently <code>RequestUriHostname</code> or <code>ToPhoneNumber</code>.</p>
    pub fn trigger_type(&self) -> std::option::Option<&crate::model::SipRuleTriggerType> {
        self.trigger_type.as_ref()
    }
    /// <p>If <code>TriggerType</code> is <code>RequestUriHostname</code>, the value can be the outbound host name of an Amazon Chime Voice Connector. If <code>TriggerType</code> is <code>ToPhoneNumber</code>, the value can be a customer-owned phone number in the E164 format. The <code>SipMediaApplication</code> specified in the <code>SipRule</code> is triggered if the request URI in an incoming SIP request matches the <code>RequestUriHostname</code>, or if the <code>To</code> header in the incoming SIP request matches the <code>ToPhoneNumber</code> value.</p>
    pub fn trigger_value(&self) -> std::option::Option<&str> {
        self.trigger_value.as_deref()
    }
    /// <p>Enables or disables a rule. You must disable rules before you can delete them.</p>
    pub fn disabled(&self) -> std::option::Option<bool> {
        self.disabled
    }
    /// <p>List of SIP media applications with priority and AWS Region. Only one SIP application per AWS Region can be used.</p>
    pub fn target_applications(
        &self,
    ) -> std::option::Option<&[crate::model::SipRuleTargetApplication]> {
        self.target_applications.as_deref()
    }
}
impl std::fmt::Debug for CreateSipRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSipRuleInput");
        formatter.field("name", &self.name);
        formatter.field("trigger_type", &self.trigger_type);
        formatter.field("trigger_value", &self.trigger_value);
        formatter.field("disabled", &self.disabled);
        formatter.field("target_applications", &self.target_applications);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSipMediaApplicationCallInput {
    /// <p>The phone number that a user calls from. This is a phone number in your Amazon Chime phone number inventory.</p>
    pub from_phone_number: std::option::Option<std::string::String>,
    /// <p>The phone number that the service should call.</p>
    pub to_phone_number: std::option::Option<std::string::String>,
    /// <p>The ID of the SIP media application.</p>
    pub sip_media_application_id: std::option::Option<std::string::String>,
    /// <p>The SIP headers added to an outbound call leg.</p>
    pub sip_headers:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateSipMediaApplicationCallInput {
    /// <p>The phone number that a user calls from. This is a phone number in your Amazon Chime phone number inventory.</p>
    pub fn from_phone_number(&self) -> std::option::Option<&str> {
        self.from_phone_number.as_deref()
    }
    /// <p>The phone number that the service should call.</p>
    pub fn to_phone_number(&self) -> std::option::Option<&str> {
        self.to_phone_number.as_deref()
    }
    /// <p>The ID of the SIP media application.</p>
    pub fn sip_media_application_id(&self) -> std::option::Option<&str> {
        self.sip_media_application_id.as_deref()
    }
    /// <p>The SIP headers added to an outbound call leg.</p>
    pub fn sip_headers(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.sip_headers.as_ref()
    }
}
impl std::fmt::Debug for CreateSipMediaApplicationCallInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSipMediaApplicationCallInput");
        formatter.field("from_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("to_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("sip_media_application_id", &self.sip_media_application_id);
        formatter.field("sip_headers", &self.sip_headers);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSipMediaApplicationInput {
    /// <p>The AWS Region assigned to the SIP media application.</p>
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The SIP media application name.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>List of endpoints (Lambda Amazon Resource Names) specified for the SIP media application. Currently, only one endpoint is supported.</p>
    pub endpoints: std::option::Option<std::vec::Vec<crate::model::SipMediaApplicationEndpoint>>,
}
impl CreateSipMediaApplicationInput {
    /// <p>The AWS Region assigned to the SIP media application.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The SIP media application name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>List of endpoints (Lambda Amazon Resource Names) specified for the SIP media application. Currently, only one endpoint is supported.</p>
    pub fn endpoints(&self) -> std::option::Option<&[crate::model::SipMediaApplicationEndpoint]> {
        self.endpoints.as_deref()
    }
}
impl std::fmt::Debug for CreateSipMediaApplicationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSipMediaApplicationInput");
        formatter.field("aws_region", &self.aws_region);
        formatter.field("name", &self.name);
        formatter.field("endpoints", &self.endpoints);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRoomMembershipInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The room ID.</p>
    pub room_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Chime member ID (user ID or bot ID).</p>
    pub member_id: std::option::Option<std::string::String>,
    /// <p>The role of the member.</p>
    pub role: std::option::Option<crate::model::RoomMembershipRole>,
}
impl CreateRoomMembershipInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The room ID.</p>
    pub fn room_id(&self) -> std::option::Option<&str> {
        self.room_id.as_deref()
    }
    /// <p>The Amazon Chime member ID (user ID or bot ID).</p>
    pub fn member_id(&self) -> std::option::Option<&str> {
        self.member_id.as_deref()
    }
    /// <p>The role of the member.</p>
    pub fn role(&self) -> std::option::Option<&crate::model::RoomMembershipRole> {
        self.role.as_ref()
    }
}
impl std::fmt::Debug for CreateRoomMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRoomMembershipInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("room_id", &self.room_id);
        formatter.field("member_id", &self.member_id);
        formatter.field("role", &self.role);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRoomInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The room name.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The idempotency token for the request.</p>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl CreateRoomInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The room name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The idempotency token for the request.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
}
impl std::fmt::Debug for CreateRoomInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRoomInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateProxySessionInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>The participant phone numbers.</p>
    pub participant_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the proxy session.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The number of minutes allowed for the proxy session.</p>
    pub expiry_minutes: std::option::Option<i32>,
    /// <p>The proxy session capabilities.</p>
    pub capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
    /// <p>The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.</p>
    pub number_selection_behavior: std::option::Option<crate::model::NumberSelectionBehavior>,
    /// <p>The preference for matching the country or area code of the proxy phone number with that of the first participant.</p>
    pub geo_match_level: std::option::Option<crate::model::GeoMatchLevel>,
    /// <p>The country and area code for the proxy phone number.</p>
    pub geo_match_params: std::option::Option<crate::model::GeoMatchParams>,
}
impl CreateProxySessionInput {
    /// <p>The Amazon Chime voice connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>The participant phone numbers.</p>
    pub fn participant_phone_numbers(&self) -> std::option::Option<&[std::string::String]> {
        self.participant_phone_numbers.as_deref()
    }
    /// <p>The name of the proxy session.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The number of minutes allowed for the proxy session.</p>
    pub fn expiry_minutes(&self) -> std::option::Option<i32> {
        self.expiry_minutes
    }
    /// <p>The proxy session capabilities.</p>
    pub fn capabilities(&self) -> std::option::Option<&[crate::model::Capability]> {
        self.capabilities.as_deref()
    }
    /// <p>The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.</p>
    pub fn number_selection_behavior(
        &self,
    ) -> std::option::Option<&crate::model::NumberSelectionBehavior> {
        self.number_selection_behavior.as_ref()
    }
    /// <p>The preference for matching the country or area code of the proxy phone number with that of the first participant.</p>
    pub fn geo_match_level(&self) -> std::option::Option<&crate::model::GeoMatchLevel> {
        self.geo_match_level.as_ref()
    }
    /// <p>The country and area code for the proxy phone number.</p>
    pub fn geo_match_params(&self) -> std::option::Option<&crate::model::GeoMatchParams> {
        self.geo_match_params.as_ref()
    }
}
impl std::fmt::Debug for CreateProxySessionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateProxySessionInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("participant_phone_numbers", &self.participant_phone_numbers);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("expiry_minutes", &self.expiry_minutes);
        formatter.field("capabilities", &self.capabilities);
        formatter.field("number_selection_behavior", &self.number_selection_behavior);
        formatter.field("geo_match_level", &self.geo_match_level);
        formatter.field("geo_match_params", &self.geo_match_params);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePhoneNumberOrderInput {
    /// <p>The phone number product type.</p>
    pub product_type: std::option::Option<crate::model::PhoneNumberProductType>,
    /// <p>List of phone numbers, in E.164 format.</p>
    pub e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CreatePhoneNumberOrderInput {
    /// <p>The phone number product type.</p>
    pub fn product_type(&self) -> std::option::Option<&crate::model::PhoneNumberProductType> {
        self.product_type.as_ref()
    }
    /// <p>List of phone numbers, in E.164 format.</p>
    pub fn e164_phone_numbers(&self) -> std::option::Option<&[std::string::String]> {
        self.e164_phone_numbers.as_deref()
    }
}
impl std::fmt::Debug for CreatePhoneNumberOrderInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePhoneNumberOrderInput");
        formatter.field("product_type", &self.product_type);
        formatter.field("e164_phone_numbers", &self.e164_phone_numbers);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMeetingWithAttendeesInput {
    /// <p>The unique identifier for the client request. Use a different token for different meetings.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The external meeting ID.</p>
    pub external_meeting_id: std::option::Option<std::string::String>,
    /// <p>Reserved.</p>
    pub meeting_host_id: std::option::Option<std::string::String>,
    /// <p> The Region in which to create the meeting. Default: <code>us-east-1</code> . </p>
    /// <p> Available values: <code>af-south-1</code> , <code>ap-northeast-1</code> , <code>ap-northeast-2</code> , <code>ap-south-1</code> , <code>ap-southeast-1</code> , <code>ap-southeast-2</code> , <code>ca-central-1</code> , <code>eu-central-1</code> , <code>eu-north-1</code> , <code>eu-south-1</code> , <code>eu-west-1</code> , <code>eu-west-2</code> , <code>eu-west-3</code> , <code>sa-east-1</code> , <code>us-east-1</code> , <code>us-east-2</code> , <code>us-west-1</code> , <code>us-west-2</code> . </p>
    pub media_region: std::option::Option<std::string::String>,
    /// <p>The tag key-value pairs.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p> The resource target configurations for receiving Amazon Chime SDK meeting and attendee event notifications. The Amazon Chime SDK supports resource targets located in the US East (N. Virginia) AWS Region (<code>us-east-1</code>). </p>
    pub notifications_configuration:
        std::option::Option<crate::model::MeetingNotificationConfiguration>,
    /// <p>The request containing the attendees to create.</p>
    pub attendees: std::option::Option<std::vec::Vec<crate::model::CreateAttendeeRequestItem>>,
}
impl CreateMeetingWithAttendeesInput {
    /// <p>The unique identifier for the client request. Use a different token for different meetings.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>The external meeting ID.</p>
    pub fn external_meeting_id(&self) -> std::option::Option<&str> {
        self.external_meeting_id.as_deref()
    }
    /// <p>Reserved.</p>
    pub fn meeting_host_id(&self) -> std::option::Option<&str> {
        self.meeting_host_id.as_deref()
    }
    /// <p> The Region in which to create the meeting. Default: <code>us-east-1</code> . </p>
    /// <p> Available values: <code>af-south-1</code> , <code>ap-northeast-1</code> , <code>ap-northeast-2</code> , <code>ap-south-1</code> , <code>ap-southeast-1</code> , <code>ap-southeast-2</code> , <code>ca-central-1</code> , <code>eu-central-1</code> , <code>eu-north-1</code> , <code>eu-south-1</code> , <code>eu-west-1</code> , <code>eu-west-2</code> , <code>eu-west-3</code> , <code>sa-east-1</code> , <code>us-east-1</code> , <code>us-east-2</code> , <code>us-west-1</code> , <code>us-west-2</code> . </p>
    pub fn media_region(&self) -> std::option::Option<&str> {
        self.media_region.as_deref()
    }
    /// <p>The tag key-value pairs.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p> The resource target configurations for receiving Amazon Chime SDK meeting and attendee event notifications. The Amazon Chime SDK supports resource targets located in the US East (N. Virginia) AWS Region (<code>us-east-1</code>). </p>
    pub fn notifications_configuration(
        &self,
    ) -> std::option::Option<&crate::model::MeetingNotificationConfiguration> {
        self.notifications_configuration.as_ref()
    }
    /// <p>The request containing the attendees to create.</p>
    pub fn attendees(&self) -> std::option::Option<&[crate::model::CreateAttendeeRequestItem]> {
        self.attendees.as_deref()
    }
}
impl std::fmt::Debug for CreateMeetingWithAttendeesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMeetingWithAttendeesInput");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("external_meeting_id", &"*** Sensitive Data Redacted ***");
        formatter.field("meeting_host_id", &"*** Sensitive Data Redacted ***");
        formatter.field("media_region", &self.media_region);
        formatter.field("tags", &self.tags);
        formatter.field(
            "notifications_configuration",
            &self.notifications_configuration,
        );
        formatter.field("attendees", &self.attendees);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMeetingDialOutInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>Phone number used as the caller ID when the remote party receives a call.</p>
    pub from_phone_number: std::option::Option<std::string::String>,
    /// <p>Phone number called when inviting someone to a meeting.</p>
    pub to_phone_number: std::option::Option<std::string::String>,
    /// <p>Token used by the Amazon Chime SDK attendee. Call the <a href="https://docs.aws.amazon.com/chime/latest/APIReference/API_CreateAttendee.html">CreateAttendee</a> action to get a join token.</p>
    pub join_token: std::option::Option<std::string::String>,
}
impl CreateMeetingDialOutInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>Phone number used as the caller ID when the remote party receives a call.</p>
    pub fn from_phone_number(&self) -> std::option::Option<&str> {
        self.from_phone_number.as_deref()
    }
    /// <p>Phone number called when inviting someone to a meeting.</p>
    pub fn to_phone_number(&self) -> std::option::Option<&str> {
        self.to_phone_number.as_deref()
    }
    /// <p>Token used by the Amazon Chime SDK attendee. Call the <a href="https://docs.aws.amazon.com/chime/latest/APIReference/API_CreateAttendee.html">CreateAttendee</a> action to get a join token.</p>
    pub fn join_token(&self) -> std::option::Option<&str> {
        self.join_token.as_deref()
    }
}
impl std::fmt::Debug for CreateMeetingDialOutInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMeetingDialOutInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("from_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("to_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.field("join_token", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMeetingInput {
    /// <p>The unique identifier for the client request. Use a different token for different meetings.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The external meeting ID.</p>
    pub external_meeting_id: std::option::Option<std::string::String>,
    /// <p>Reserved.</p>
    pub meeting_host_id: std::option::Option<std::string::String>,
    /// <p> The Region in which to create the meeting. Default: <code>us-east-1</code>. </p>
    /// <p> Available values: <code>af-south-1</code> , <code>ap-northeast-1</code> , <code>ap-northeast-2</code> , <code>ap-south-1</code> , <code>ap-southeast-1</code> , <code>ap-southeast-2</code> , <code>ca-central-1</code> , <code>eu-central-1</code> , <code>eu-north-1</code> , <code>eu-south-1</code> , <code>eu-west-1</code> , <code>eu-west-2</code> , <code>eu-west-3</code> , <code>sa-east-1</code> , <code>us-east-1</code> , <code>us-east-2</code> , <code>us-west-1</code> , <code>us-west-2</code> . </p>
    pub media_region: std::option::Option<std::string::String>,
    /// <p>The tag key-value pairs.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The configuration for resource targets to receive notifications when meeting and attendee events occur.</p>
    pub notifications_configuration:
        std::option::Option<crate::model::MeetingNotificationConfiguration>,
}
impl CreateMeetingInput {
    /// <p>The unique identifier for the client request. Use a different token for different meetings.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>The external meeting ID.</p>
    pub fn external_meeting_id(&self) -> std::option::Option<&str> {
        self.external_meeting_id.as_deref()
    }
    /// <p>Reserved.</p>
    pub fn meeting_host_id(&self) -> std::option::Option<&str> {
        self.meeting_host_id.as_deref()
    }
    /// <p> The Region in which to create the meeting. Default: <code>us-east-1</code>. </p>
    /// <p> Available values: <code>af-south-1</code> , <code>ap-northeast-1</code> , <code>ap-northeast-2</code> , <code>ap-south-1</code> , <code>ap-southeast-1</code> , <code>ap-southeast-2</code> , <code>ca-central-1</code> , <code>eu-central-1</code> , <code>eu-north-1</code> , <code>eu-south-1</code> , <code>eu-west-1</code> , <code>eu-west-2</code> , <code>eu-west-3</code> , <code>sa-east-1</code> , <code>us-east-1</code> , <code>us-east-2</code> , <code>us-west-1</code> , <code>us-west-2</code> . </p>
    pub fn media_region(&self) -> std::option::Option<&str> {
        self.media_region.as_deref()
    }
    /// <p>The tag key-value pairs.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The configuration for resource targets to receive notifications when meeting and attendee events occur.</p>
    pub fn notifications_configuration(
        &self,
    ) -> std::option::Option<&crate::model::MeetingNotificationConfiguration> {
        self.notifications_configuration.as_ref()
    }
}
impl std::fmt::Debug for CreateMeetingInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMeetingInput");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("external_meeting_id", &"*** Sensitive Data Redacted ***");
        formatter.field("meeting_host_id", &"*** Sensitive Data Redacted ***");
        formatter.field("media_region", &self.media_region);
        formatter.field("tags", &self.tags);
        formatter.field(
            "notifications_configuration",
            &self.notifications_configuration,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMediaCapturePipelineInput {
    /// <p>Source type from which the media artifacts will be captured. A Chime SDK Meeting is the only supported source.</p>
    pub source_type: std::option::Option<crate::model::MediaPipelineSourceType>,
    /// <p>ARN of the source from which the media artifacts are captured.</p>
    pub source_arn: std::option::Option<std::string::String>,
    /// <p>Destination type to which the media artifacts are saved. You must use an S3 bucket. </p>
    pub sink_type: std::option::Option<crate::model::MediaPipelineSinkType>,
    /// <p>The ARN of the sink type.</p>
    pub sink_arn: std::option::Option<std::string::String>,
    /// <p>The token assigned to the client making the pipeline request.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The configuration for a specified media capture pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
    pub chime_sdk_meeting_configuration:
        std::option::Option<crate::model::ChimeSdkMeetingConfiguration>,
}
impl CreateMediaCapturePipelineInput {
    /// <p>Source type from which the media artifacts will be captured. A Chime SDK Meeting is the only supported source.</p>
    pub fn source_type(&self) -> std::option::Option<&crate::model::MediaPipelineSourceType> {
        self.source_type.as_ref()
    }
    /// <p>ARN of the source from which the media artifacts are captured.</p>
    pub fn source_arn(&self) -> std::option::Option<&str> {
        self.source_arn.as_deref()
    }
    /// <p>Destination type to which the media artifacts are saved. You must use an S3 bucket. </p>
    pub fn sink_type(&self) -> std::option::Option<&crate::model::MediaPipelineSinkType> {
        self.sink_type.as_ref()
    }
    /// <p>The ARN of the sink type.</p>
    pub fn sink_arn(&self) -> std::option::Option<&str> {
        self.sink_arn.as_deref()
    }
    /// <p>The token assigned to the client making the pipeline request.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>The configuration for a specified media capture pipeline. <code>SourceType</code> must be <code>ChimeSdkMeeting</code>.</p>
    pub fn chime_sdk_meeting_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ChimeSdkMeetingConfiguration> {
        self.chime_sdk_meeting_configuration.as_ref()
    }
}
impl std::fmt::Debug for CreateMediaCapturePipelineInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMediaCapturePipelineInput");
        formatter.field("source_type", &self.source_type);
        formatter.field("source_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("sink_type", &self.sink_type);
        formatter.field("sink_arn", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "chime_sdk_meeting_configuration",
            &self.chime_sdk_meeting_configuration,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelModeratorInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the moderator.</p>
    pub channel_moderator_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl CreateChannelModeratorInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the moderator.</p>
    pub fn channel_moderator_arn(&self) -> std::option::Option<&str> {
        self.channel_moderator_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for CreateChannelModeratorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelModeratorInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("channel_moderator_arn", &self.channel_moderator_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelMembershipInput {
    /// <p>The ARN of the channel to which you're adding users.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member you want to add to the channel.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.</p>
    pub r#type: std::option::Option<crate::model::ChannelMembershipType>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl CreateChannelMembershipInput {
    /// <p>The ARN of the channel to which you're adding users.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the member you want to add to the channel.</p>
    pub fn member_arn(&self) -> std::option::Option<&str> {
        self.member_arn.as_deref()
    }
    /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ChannelMembershipType> {
        self.r#type.as_ref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for CreateChannelMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelMembershipInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelBanInput {
    /// <p>The ARN of the ban request.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member being banned.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl CreateChannelBanInput {
    /// <p>The ARN of the ban request.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The ARN of the member being banned.</p>
    pub fn member_arn(&self) -> std::option::Option<&str> {
        self.member_arn.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for CreateChannelBanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelBanInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelInput {
    /// <p>The ARN of the channel request.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The channel mode: <code>UNRESTRICTED</code> or <code>RESTRICTED</code>. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.</p>
    pub mode: std::option::Option<crate::model::ChannelMode>,
    /// <p>The channel's privacy level: <code>PUBLIC</code> or <code>PRIVATE</code>. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the <code>AppInstance</code>.</p>
    pub privacy: std::option::Option<crate::model::ChannelPrivacy>,
    /// <p>The metadata of the creation request. Limited to 1KB and UTF-8.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The client token for the request. An <code>Idempotency</code> token.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The tags for the creation request.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl CreateChannelInput {
    /// <p>The ARN of the channel request.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
    /// <p>The name of the channel.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The channel mode: <code>UNRESTRICTED</code> or <code>RESTRICTED</code>. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::ChannelMode> {
        self.mode.as_ref()
    }
    /// <p>The channel's privacy level: <code>PUBLIC</code> or <code>PRIVATE</code>. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the <code>AppInstance</code>.</p>
    pub fn privacy(&self) -> std::option::Option<&crate::model::ChannelPrivacy> {
        self.privacy.as_ref()
    }
    /// <p>The metadata of the creation request. Limited to 1KB and UTF-8.</p>
    pub fn metadata(&self) -> std::option::Option<&str> {
        self.metadata.as_deref()
    }
    /// <p>The client token for the request. An <code>Idempotency</code> token.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>The tags for the creation request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for CreateChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("mode", &self.mode);
        formatter.field("privacy", &self.privacy);
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBotInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The bot display name.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The domain of the Amazon Chime Enterprise account.</p>
    pub domain: std::option::Option<std::string::String>,
}
impl CreateBotInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The bot display name.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The domain of the Amazon Chime Enterprise account.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
}
impl std::fmt::Debug for CreateBotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBotInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("display_name", &"*** Sensitive Data Redacted ***");
        formatter.field("domain", &self.domain);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.</p>
    pub external_user_id: std::option::Option<std::string::String>,
    /// <p>The tag key-value pairs.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application.</p>
    pub fn external_user_id(&self) -> std::option::Option<&str> {
        self.external_user_id.as_deref()
    }
    /// <p>The tag key-value pairs.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateAttendeeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAttendeeInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("external_user_id", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAppInstanceUserInput {
    /// <p>The ARN of the <code>AppInstance</code> request.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The user ID of the <code>AppInstance</code>.</p>
    pub app_instance_user_id: std::option::Option<std::string::String>,
    /// <p>The user's name.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The request's metadata. Limited to a 1KB string in UTF-8.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The token assigned to the user requesting an <code>AppInstance</code>.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>Tags assigned to the <code>AppInstanceUser</code>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateAppInstanceUserInput {
    /// <p>The ARN of the <code>AppInstance</code> request.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
    /// <p>The user ID of the <code>AppInstance</code>.</p>
    pub fn app_instance_user_id(&self) -> std::option::Option<&str> {
        self.app_instance_user_id.as_deref()
    }
    /// <p>The user's name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The request's metadata. Limited to a 1KB string in UTF-8.</p>
    pub fn metadata(&self) -> std::option::Option<&str> {
        self.metadata.as_deref()
    }
    /// <p>The token assigned to the user requesting an <code>AppInstance</code>.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>Tags assigned to the <code>AppInstanceUser</code>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAppInstanceUserInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field("app_instance_user_id", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAppInstanceAdminInput {
    /// <p>The ARN of the administrator of the current <code>AppInstance</code>.</p>
    pub app_instance_admin_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
}
impl CreateAppInstanceAdminInput {
    /// <p>The ARN of the administrator of the current <code>AppInstance</code>.</p>
    pub fn app_instance_admin_arn(&self) -> std::option::Option<&str> {
        self.app_instance_admin_arn.as_deref()
    }
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub fn app_instance_arn(&self) -> std::option::Option<&str> {
        self.app_instance_arn.as_deref()
    }
}
impl std::fmt::Debug for CreateAppInstanceAdminInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAppInstanceAdminInput");
        formatter.field("app_instance_admin_arn", &self.app_instance_admin_arn);
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAppInstanceInput {
    /// <p>The name of the <code>AppInstance</code>.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The metadata of the <code>AppInstance</code>. Limited to a 1KB string in UTF-8.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The <code>ClientRequestToken</code> of the <code>AppInstance</code>.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>Tags assigned to the <code>AppInstance</code>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateAppInstanceInput {
    /// <p>The name of the <code>AppInstance</code>.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The metadata of the <code>AppInstance</code>. Limited to a 1KB string in UTF-8.</p>
    pub fn metadata(&self) -> std::option::Option<&str> {
        self.metadata.as_deref()
    }
    /// <p>The <code>ClientRequestToken</code> of the <code>AppInstance</code>.</p>
    pub fn client_request_token(&self) -> std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>Tags assigned to the <code>AppInstance</code>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateAppInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAppInstanceInput");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAccountInput {
    /// <p>The name of the Amazon Chime account.</p>
    pub name: std::option::Option<std::string::String>,
}
impl CreateAccountInput {
    /// <p>The name of the Amazon Chime account.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl std::fmt::Debug for CreateAccountInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAccountInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchUpdateUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The request containing the user IDs and details to update.</p>
    pub update_user_request_items:
        std::option::Option<std::vec::Vec<crate::model::UpdateUserRequestItem>>,
}
impl BatchUpdateUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The request containing the user IDs and details to update.</p>
    pub fn update_user_request_items(
        &self,
    ) -> std::option::Option<&[crate::model::UpdateUserRequestItem]> {
        self.update_user_request_items.as_deref()
    }
}
impl std::fmt::Debug for BatchUpdateUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchUpdateUserInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("update_user_request_items", &self.update_user_request_items);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchUpdatePhoneNumberInput {
    /// <p>The request containing the phone number IDs and product types or calling names to update.</p>
    pub update_phone_number_request_items:
        std::option::Option<std::vec::Vec<crate::model::UpdatePhoneNumberRequestItem>>,
}
impl BatchUpdatePhoneNumberInput {
    /// <p>The request containing the phone number IDs and product types or calling names to update.</p>
    pub fn update_phone_number_request_items(
        &self,
    ) -> std::option::Option<&[crate::model::UpdatePhoneNumberRequestItem]> {
        self.update_phone_number_request_items.as_deref()
    }
}
impl std::fmt::Debug for BatchUpdatePhoneNumberInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchUpdatePhoneNumberInput");
        formatter.field(
            "update_phone_number_request_items",
            &self.update_phone_number_request_items,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchUnsuspendUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The request containing the user IDs to unsuspend.</p>
    pub user_id_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl BatchUnsuspendUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The request containing the user IDs to unsuspend.</p>
    pub fn user_id_list(&self) -> std::option::Option<&[std::string::String]> {
        self.user_id_list.as_deref()
    }
}
impl std::fmt::Debug for BatchUnsuspendUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchUnsuspendUserInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id_list", &self.user_id_list);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchSuspendUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The request containing the user IDs to suspend.</p>
    pub user_id_list: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl BatchSuspendUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The request containing the user IDs to suspend.</p>
    pub fn user_id_list(&self) -> std::option::Option<&[std::string::String]> {
        self.user_id_list.as_deref()
    }
}
impl std::fmt::Debug for BatchSuspendUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchSuspendUserInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id_list", &self.user_id_list);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDeletePhoneNumberInput {
    /// <p>List of phone number IDs.</p>
    pub phone_number_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl BatchDeletePhoneNumberInput {
    /// <p>List of phone number IDs.</p>
    pub fn phone_number_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.phone_number_ids.as_deref()
    }
}
impl std::fmt::Debug for BatchDeletePhoneNumberInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDeletePhoneNumberInput");
        formatter.field("phone_number_ids", &self.phone_number_ids);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchCreateRoomMembershipInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The room ID.</p>
    pub room_id: std::option::Option<std::string::String>,
    /// <p>The list of membership items.</p>
    pub membership_item_list: std::option::Option<std::vec::Vec<crate::model::MembershipItem>>,
}
impl BatchCreateRoomMembershipInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The room ID.</p>
    pub fn room_id(&self) -> std::option::Option<&str> {
        self.room_id.as_deref()
    }
    /// <p>The list of membership items.</p>
    pub fn membership_item_list(&self) -> std::option::Option<&[crate::model::MembershipItem]> {
        self.membership_item_list.as_deref()
    }
}
impl std::fmt::Debug for BatchCreateRoomMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchCreateRoomMembershipInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("room_id", &self.room_id);
        formatter.field("membership_item_list", &self.membership_item_list);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchCreateChannelMembershipInput {
    /// <p>The ARN of the channel to which you're adding users.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.</p>
    pub r#type: std::option::Option<crate::model::ChannelMembershipType>,
    /// <p>The ARNs of the members you want to add to the channel.</p>
    pub member_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl BatchCreateChannelMembershipInput {
    /// <p>The ARN of the channel to which you're adding users.</p>
    pub fn channel_arn(&self) -> std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default members are always returned as part of <code>ListChannelMemberships</code>. Hidden members are only returned if the type filter in <code>ListChannelMemberships</code> equals <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported by moderators.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ChannelMembershipType> {
        self.r#type.as_ref()
    }
    /// <p>The ARNs of the members you want to add to the channel.</p>
    pub fn member_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.member_arns.as_deref()
    }
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub fn chime_bearer(&self) -> std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
}
impl std::fmt::Debug for BatchCreateChannelMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchCreateChannelMembershipInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("member_arns", &self.member_arns);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchCreateAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub meeting_id: std::option::Option<std::string::String>,
    /// <p>The request containing the attendees to create.</p>
    pub attendees: std::option::Option<std::vec::Vec<crate::model::CreateAttendeeRequestItem>>,
}
impl BatchCreateAttendeeInput {
    /// <p>The Amazon Chime SDK meeting ID.</p>
    pub fn meeting_id(&self) -> std::option::Option<&str> {
        self.meeting_id.as_deref()
    }
    /// <p>The request containing the attendees to create.</p>
    pub fn attendees(&self) -> std::option::Option<&[crate::model::CreateAttendeeRequestItem]> {
        self.attendees.as_deref()
    }
}
impl std::fmt::Debug for BatchCreateAttendeeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchCreateAttendeeInput");
        formatter.field("meeting_id", &self.meeting_id);
        formatter.field("attendees", &self.attendees);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateSigninDelegateGroupsWithAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The sign-in delegate groups.</p>
    pub signin_delegate_groups:
        std::option::Option<std::vec::Vec<crate::model::SigninDelegateGroup>>,
}
impl AssociateSigninDelegateGroupsWithAccountInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The sign-in delegate groups.</p>
    pub fn signin_delegate_groups(
        &self,
    ) -> std::option::Option<&[crate::model::SigninDelegateGroup]> {
        self.signin_delegate_groups.as_deref()
    }
}
impl std::fmt::Debug for AssociateSigninDelegateGroupsWithAccountInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateSigninDelegateGroupsWithAccountInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("signin_delegate_groups", &self.signin_delegate_groups);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociatePhoneNumberWithUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The user ID.</p>
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The phone number, in E.164 format.</p>
    pub e164_phone_number: std::option::Option<std::string::String>,
}
impl AssociatePhoneNumberWithUserInput {
    /// <p>The Amazon Chime account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The user ID.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The phone number, in E.164 format.</p>
    pub fn e164_phone_number(&self) -> std::option::Option<&str> {
        self.e164_phone_number.as_deref()
    }
}
impl std::fmt::Debug for AssociatePhoneNumberWithUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociatePhoneNumberWithUserInput");
        formatter.field("account_id", &self.account_id);
        formatter.field("user_id", &self.user_id);
        formatter.field("e164_phone_number", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociatePhoneNumbersWithVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub voice_connector_group_id: std::option::Option<std::string::String>,
    /// <p>List of phone numbers, in E.164 format.</p>
    pub e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector Group and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.</p>
    pub force_associate: std::option::Option<bool>,
}
impl AssociatePhoneNumbersWithVoiceConnectorGroupInput {
    /// <p>The Amazon Chime Voice Connector group ID.</p>
    pub fn voice_connector_group_id(&self) -> std::option::Option<&str> {
        self.voice_connector_group_id.as_deref()
    }
    /// <p>List of phone numbers, in E.164 format.</p>
    pub fn e164_phone_numbers(&self) -> std::option::Option<&[std::string::String]> {
        self.e164_phone_numbers.as_deref()
    }
    /// <p>If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector Group and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.</p>
    pub fn force_associate(&self) -> std::option::Option<bool> {
        self.force_associate
    }
}
impl std::fmt::Debug for AssociatePhoneNumbersWithVoiceConnectorGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociatePhoneNumbersWithVoiceConnectorGroupInput");
        formatter.field("voice_connector_group_id", &self.voice_connector_group_id);
        formatter.field("e164_phone_numbers", &self.e164_phone_numbers);
        formatter.field("force_associate", &self.force_associate);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociatePhoneNumbersWithVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub voice_connector_id: std::option::Option<std::string::String>,
    /// <p>List of phone numbers, in E.164 format.</p>
    pub e164_phone_numbers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.</p>
    pub force_associate: std::option::Option<bool>,
}
impl AssociatePhoneNumbersWithVoiceConnectorInput {
    /// <p>The Amazon Chime Voice Connector ID.</p>
    pub fn voice_connector_id(&self) -> std::option::Option<&str> {
        self.voice_connector_id.as_deref()
    }
    /// <p>List of phone numbers, in E.164 format.</p>
    pub fn e164_phone_numbers(&self) -> std::option::Option<&[std::string::String]> {
        self.e164_phone_numbers.as_deref()
    }
    /// <p>If true, associates the provided phone numbers with the provided Amazon Chime Voice Connector and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.</p>
    pub fn force_associate(&self) -> std::option::Option<bool> {
        self.force_associate
    }
}
impl std::fmt::Debug for AssociatePhoneNumbersWithVoiceConnectorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociatePhoneNumbersWithVoiceConnectorInput");
        formatter.field("voice_connector_id", &self.voice_connector_id);
        formatter.field("e164_phone_numbers", &self.e164_phone_numbers);
        formatter.field("force_associate", &self.force_associate);
        formatter.finish()
    }
}
