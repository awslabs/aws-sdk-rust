// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociatePhoneNumbersWithVoiceConnectorError {
    pub kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociatePhoneNumbersWithVoiceConnectorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociatePhoneNumbersWithVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociatePhoneNumbersWithVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        AssociatePhoneNumbersWithVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociatePhoneNumbersWithVoiceConnectorError {
    pub fn new(
        kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for AssociatePhoneNumbersWithVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociatePhoneNumbersWithVoiceConnectorGroupError {
    pub kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociatePhoneNumbersWithVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociatePhoneNumbersWithVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        AssociatePhoneNumbersWithVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociatePhoneNumbersWithVoiceConnectorGroupError {
    pub fn new(
        kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for AssociatePhoneNumbersWithVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::AccessDeniedException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            AssociatePhoneNumbersWithVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociatePhoneNumberWithUserError {
    pub kind: AssociatePhoneNumberWithUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociatePhoneNumberWithUserErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociatePhoneNumberWithUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociatePhoneNumberWithUserErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AssociatePhoneNumberWithUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            AssociatePhoneNumberWithUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            AssociatePhoneNumberWithUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            AssociatePhoneNumberWithUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            AssociatePhoneNumberWithUserErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumberWithUserErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumberWithUserErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            AssociatePhoneNumberWithUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociatePhoneNumberWithUserError {
    fn code(&self) -> Option<&str> {
        AssociatePhoneNumberWithUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociatePhoneNumberWithUserError {
    pub fn new(kind: AssociatePhoneNumberWithUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociatePhoneNumberWithUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociatePhoneNumberWithUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumberWithUserErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumberWithUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumberWithUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumberWithUserErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumberWithUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumberWithUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumberWithUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociatePhoneNumberWithUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for AssociatePhoneNumberWithUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociatePhoneNumberWithUserErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AssociatePhoneNumberWithUserErrorKind::BadRequestException(_inner) => Some(_inner),
            AssociatePhoneNumberWithUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            AssociatePhoneNumberWithUserErrorKind::NotFoundException(_inner) => Some(_inner),
            AssociatePhoneNumberWithUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            AssociatePhoneNumberWithUserErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumberWithUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            AssociatePhoneNumberWithUserErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            AssociatePhoneNumberWithUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateSigninDelegateGroupsWithAccountError {
    pub kind: AssociateSigninDelegateGroupsWithAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateSigninDelegateGroupsWithAccountErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateSigninDelegateGroupsWithAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateSigninDelegateGroupsWithAccountErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            AssociateSigninDelegateGroupsWithAccountErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            AssociateSigninDelegateGroupsWithAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateSigninDelegateGroupsWithAccountError {
    fn code(&self) -> Option<&str> {
        AssociateSigninDelegateGroupsWithAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateSigninDelegateGroupsWithAccountError {
    pub fn new(
        kind: AssociateSigninDelegateGroupsWithAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateSigninDelegateGroupsWithAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateSigninDelegateGroupsWithAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSigninDelegateGroupsWithAccountErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSigninDelegateGroupsWithAccountErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSigninDelegateGroupsWithAccountErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSigninDelegateGroupsWithAccountErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSigninDelegateGroupsWithAccountErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSigninDelegateGroupsWithAccountErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSigninDelegateGroupsWithAccountErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for AssociateSigninDelegateGroupsWithAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateSigninDelegateGroupsWithAccountErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            AssociateSigninDelegateGroupsWithAccountErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            AssociateSigninDelegateGroupsWithAccountErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            AssociateSigninDelegateGroupsWithAccountErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchCreateAttendeeError {
    pub kind: BatchCreateAttendeeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchCreateAttendeeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchCreateAttendeeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchCreateAttendeeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchCreateAttendeeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchCreateAttendeeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchCreateAttendeeErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            BatchCreateAttendeeErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchCreateAttendeeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            BatchCreateAttendeeErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            BatchCreateAttendeeErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            BatchCreateAttendeeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchCreateAttendeeError {
    fn code(&self) -> Option<&str> {
        BatchCreateAttendeeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchCreateAttendeeError {
    pub fn new(kind: BatchCreateAttendeeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchCreateAttendeeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchCreateAttendeeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateAttendeeErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateAttendeeErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateAttendeeErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateAttendeeErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateAttendeeErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateAttendeeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateAttendeeErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateAttendeeErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchCreateAttendeeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchCreateAttendeeErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchCreateAttendeeErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchCreateAttendeeErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchCreateAttendeeErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            BatchCreateAttendeeErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchCreateAttendeeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchCreateAttendeeErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchCreateAttendeeErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            BatchCreateAttendeeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchCreateChannelMembershipError {
    pub kind: BatchCreateChannelMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchCreateChannelMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchCreateChannelMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchCreateChannelMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchCreateChannelMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchCreateChannelMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchCreateChannelMembershipErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateChannelMembershipErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateChannelMembershipErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateChannelMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchCreateChannelMembershipError {
    fn code(&self) -> Option<&str> {
        BatchCreateChannelMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchCreateChannelMembershipError {
    pub fn new(kind: BatchCreateChannelMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchCreateChannelMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchCreateChannelMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateChannelMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchCreateChannelMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchCreateChannelMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchCreateChannelMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchCreateChannelMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchCreateChannelMembershipErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            BatchCreateChannelMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchCreateChannelMembershipErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            BatchCreateChannelMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchCreateRoomMembershipError {
    pub kind: BatchCreateRoomMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchCreateRoomMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchCreateRoomMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchCreateRoomMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchCreateRoomMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchCreateRoomMembershipErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchCreateRoomMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchCreateRoomMembershipErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateRoomMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            BatchCreateRoomMembershipErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateRoomMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchCreateRoomMembershipError {
    fn code(&self) -> Option<&str> {
        BatchCreateRoomMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchCreateRoomMembershipError {
    pub fn new(kind: BatchCreateRoomMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchCreateRoomMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchCreateRoomMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateRoomMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateRoomMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateRoomMembershipErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateRoomMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateRoomMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateRoomMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateRoomMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchCreateRoomMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchCreateRoomMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchCreateRoomMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchCreateRoomMembershipErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchCreateRoomMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchCreateRoomMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchCreateRoomMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchCreateRoomMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            BatchCreateRoomMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeletePhoneNumberError {
    pub kind: BatchDeletePhoneNumberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeletePhoneNumberErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeletePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeletePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            BatchDeletePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeletePhoneNumberError {
    fn code(&self) -> Option<&str> {
        BatchDeletePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeletePhoneNumberError {
    pub fn new(kind: BatchDeletePhoneNumberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeletePhoneNumberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeletePhoneNumberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeletePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchDeletePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeletePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            BatchDeletePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchSuspendUserError {
    pub kind: BatchSuspendUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchSuspendUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchSuspendUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchSuspendUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchSuspendUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchSuspendUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchSuspendUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchSuspendUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            BatchSuspendUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            BatchSuspendUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            BatchSuspendUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchSuspendUserError {
    fn code(&self) -> Option<&str> {
        BatchSuspendUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchSuspendUserError {
    pub fn new(kind: BatchSuspendUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchSuspendUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchSuspendUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchSuspendUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, BatchSuspendUserErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchSuspendUserErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchSuspendUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchSuspendUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchSuspendUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchSuspendUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchSuspendUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchSuspendUserErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchSuspendUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchSuspendUserErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchSuspendUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchSuspendUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchSuspendUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchSuspendUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            BatchSuspendUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchUnsuspendUserError {
    pub kind: BatchUnsuspendUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUnsuspendUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchUnsuspendUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchUnsuspendUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchUnsuspendUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchUnsuspendUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchUnsuspendUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchUnsuspendUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            BatchUnsuspendUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            BatchUnsuspendUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            BatchUnsuspendUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchUnsuspendUserError {
    fn code(&self) -> Option<&str> {
        BatchUnsuspendUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUnsuspendUserError {
    pub fn new(kind: BatchUnsuspendUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchUnsuspendUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchUnsuspendUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUnsuspendUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUnsuspendUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUnsuspendUserErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUnsuspendUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUnsuspendUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUnsuspendUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUnsuspendUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchUnsuspendUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchUnsuspendUserErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchUnsuspendUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchUnsuspendUserErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchUnsuspendUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchUnsuspendUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchUnsuspendUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchUnsuspendUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            BatchUnsuspendUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchUpdatePhoneNumberError {
    pub kind: BatchUpdatePhoneNumberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUpdatePhoneNumberErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchUpdatePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchUpdatePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            BatchUpdatePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchUpdatePhoneNumberError {
    fn code(&self) -> Option<&str> {
        BatchUpdatePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUpdatePhoneNumberError {
    pub fn new(kind: BatchUpdatePhoneNumberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchUpdatePhoneNumberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchUpdatePhoneNumberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchUpdatePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchUpdatePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            BatchUpdatePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchUpdateUserError {
    pub kind: BatchUpdateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchUpdateUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchUpdateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchUpdateUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchUpdateUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchUpdateUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchUpdateUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            BatchUpdateUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            BatchUpdateUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            BatchUpdateUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            BatchUpdateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchUpdateUserError {
    fn code(&self) -> Option<&str> {
        BatchUpdateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchUpdateUserError {
    pub fn new(kind: BatchUpdateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchUpdateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchUpdateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdateUserErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdateUserErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchUpdateUserErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchUpdateUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for BatchUpdateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchUpdateUserErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchUpdateUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchUpdateUserErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchUpdateUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            BatchUpdateUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchUpdateUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            BatchUpdateUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            BatchUpdateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAccountError {
    pub kind: CreateAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAccountErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAccountErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAccountErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateAccountErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateAccountErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAccountErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAccountErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateAccountErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAccountError {
    fn code(&self) -> Option<&str> {
        CreateAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAccountError {
    pub fn new(kind: CreateAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateAccountErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAccountErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAccountErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAccountErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateAccountErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateAccountErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAccountErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAccountErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateAccountErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAppInstanceError {
    pub kind: CreateAppInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAppInstanceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAppInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAppInstanceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAppInstanceError {
    fn code(&self) -> Option<&str> {
        CreateAppInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAppInstanceError {
    pub fn new(kind: CreateAppInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAppInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAppInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateAppInstanceErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateAppInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAppInstanceErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ConflictException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAppInstanceAdminError {
    pub kind: CreateAppInstanceAdminErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAppInstanceAdminErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAppInstanceAdminError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAppInstanceAdminErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateAppInstanceAdminErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAppInstanceAdminError {
    fn code(&self) -> Option<&str> {
        CreateAppInstanceAdminError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAppInstanceAdminError {
    pub fn new(kind: CreateAppInstanceAdminErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAppInstanceAdminErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAppInstanceAdminErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateAppInstanceAdminError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAppInstanceAdminErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ConflictException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAppInstanceUserError {
    pub kind: CreateAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAppInstanceUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        CreateAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAppInstanceUserError {
    pub fn new(kind: CreateAppInstanceUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAppInstanceUserErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ConflictException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAttendeeError {
    pub kind: CreateAttendeeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAttendeeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAttendeeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAttendeeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAttendeeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateAttendeeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateAttendeeErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateAttendeeErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAttendeeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAttendeeErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateAttendeeErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateAttendeeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAttendeeError {
    fn code(&self) -> Option<&str> {
        CreateAttendeeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAttendeeError {
    pub fn new(kind: CreateAttendeeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAttendeeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAttendeeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateAttendeeErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateAttendeeErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateAttendeeErrorKind::NotFoundException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAttendeeErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAttendeeErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAttendeeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAttendeeErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAttendeeErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateAttendeeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAttendeeErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAttendeeErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateAttendeeErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateAttendeeErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateAttendeeErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAttendeeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAttendeeErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateAttendeeErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateAttendeeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBotError {
    pub kind: CreateBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBotErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBotErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBotError {
    fn code(&self) -> Option<&str> {
        CreateBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBotError {
    pub fn new(kind: CreateBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateBotErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateBotErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateBotErrorKind::NotFoundException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateBotErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreateBotErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBotErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBotErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateBotErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateBotErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateBotErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateBotErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateBotErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateBotErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateBotErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelError {
    pub kind: CreateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelError {
    fn code(&self) -> Option<&str> {
        CreateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelError {
    pub fn new(kind: CreateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateChannelErrorKind::ConflictException(_inner) => Some(_inner),
            CreateChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateChannelErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateChannelErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateChannelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateChannelErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateChannelErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelBanError {
    pub kind: CreateChannelBanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelBanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelBanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelBanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateChannelBanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelBanError {
    fn code(&self) -> Option<&str> {
        CreateChannelBanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelBanError {
    pub fn new(kind: CreateChannelBanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelBanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelBanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelBanErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateChannelBanErrorKind::ForbiddenException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelBanErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateChannelBanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelBanErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ConflictException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateChannelBanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelMembershipError {
    pub kind: CreateChannelMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateChannelMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateChannelMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelMembershipError {
    fn code(&self) -> Option<&str> {
        CreateChannelMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelMembershipError {
    pub fn new(kind: CreateChannelMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateChannelMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ConflictException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateChannelMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateChannelMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChannelModeratorError {
    pub kind: CreateChannelModeratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChannelModeratorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChannelModeratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChannelModeratorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateChannelModeratorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateChannelModeratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChannelModeratorError {
    fn code(&self) -> Option<&str> {
        CreateChannelModeratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChannelModeratorError {
    pub fn new(kind: CreateChannelModeratorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChannelModeratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChannelModeratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateChannelModeratorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateChannelModeratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChannelModeratorErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ConflictException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateChannelModeratorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMediaCapturePipelineError {
    pub kind: CreateMediaCapturePipelineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMediaCapturePipelineErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMediaCapturePipelineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMediaCapturePipelineErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateMediaCapturePipelineErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateMediaCapturePipelineErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateMediaCapturePipelineErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateMediaCapturePipelineErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateMediaCapturePipelineErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateMediaCapturePipelineErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateMediaCapturePipelineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMediaCapturePipelineError {
    fn code(&self) -> Option<&str> {
        CreateMediaCapturePipelineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMediaCapturePipelineError {
    pub fn new(kind: CreateMediaCapturePipelineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMediaCapturePipelineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMediaCapturePipelineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMediaCapturePipelineErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMediaCapturePipelineErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMediaCapturePipelineErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMediaCapturePipelineErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMediaCapturePipelineErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMediaCapturePipelineErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMediaCapturePipelineErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateMediaCapturePipelineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMediaCapturePipelineErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateMediaCapturePipelineErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateMediaCapturePipelineErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateMediaCapturePipelineErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateMediaCapturePipelineErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateMediaCapturePipelineErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateMediaCapturePipelineErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            CreateMediaCapturePipelineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMeetingError {
    pub kind: CreateMeetingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMeetingErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMeetingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMeetingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateMeetingErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateMeetingErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateMeetingErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateMeetingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateMeetingErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateMeetingErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateMeetingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMeetingError {
    fn code(&self) -> Option<&str> {
        CreateMeetingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMeetingError {
    pub fn new(kind: CreateMeetingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMeetingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMeetingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateMeetingErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateMeetingErrorKind::ForbiddenException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateMeetingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMeetingErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateMeetingErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateMeetingErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateMeetingErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateMeetingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateMeetingErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateMeetingErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateMeetingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMeetingDialOutError {
    pub kind: CreateMeetingDialOutErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMeetingDialOutErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMeetingDialOutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMeetingDialOutErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateMeetingDialOutErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateMeetingDialOutErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateMeetingDialOutErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateMeetingDialOutErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateMeetingDialOutErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateMeetingDialOutErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateMeetingDialOutErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMeetingDialOutError {
    fn code(&self) -> Option<&str> {
        CreateMeetingDialOutError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMeetingDialOutError {
    pub fn new(kind: CreateMeetingDialOutErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMeetingDialOutErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMeetingDialOutErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingDialOutErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingDialOutErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingDialOutErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingDialOutErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingDialOutErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingDialOutErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingDialOutErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateMeetingDialOutError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMeetingDialOutErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateMeetingDialOutErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateMeetingDialOutErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateMeetingDialOutErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateMeetingDialOutErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateMeetingDialOutErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateMeetingDialOutErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateMeetingDialOutErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMeetingWithAttendeesError {
    pub kind: CreateMeetingWithAttendeesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMeetingWithAttendeesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMeetingWithAttendeesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMeetingWithAttendeesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateMeetingWithAttendeesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateMeetingWithAttendeesErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateMeetingWithAttendeesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateMeetingWithAttendeesErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateMeetingWithAttendeesErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateMeetingWithAttendeesErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateMeetingWithAttendeesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMeetingWithAttendeesError {
    fn code(&self) -> Option<&str> {
        CreateMeetingWithAttendeesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMeetingWithAttendeesError {
    pub fn new(kind: CreateMeetingWithAttendeesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMeetingWithAttendeesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMeetingWithAttendeesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingWithAttendeesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingWithAttendeesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingWithAttendeesErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingWithAttendeesErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingWithAttendeesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingWithAttendeesErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMeetingWithAttendeesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateMeetingWithAttendeesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMeetingWithAttendeesErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateMeetingWithAttendeesErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateMeetingWithAttendeesErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateMeetingWithAttendeesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateMeetingWithAttendeesErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateMeetingWithAttendeesErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateMeetingWithAttendeesErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            CreateMeetingWithAttendeesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePhoneNumberOrderError {
    pub kind: CreatePhoneNumberOrderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePhoneNumberOrderErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePhoneNumberOrderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePhoneNumberOrderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreatePhoneNumberOrderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreatePhoneNumberOrderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePhoneNumberOrderError {
    fn code(&self) -> Option<&str> {
        CreatePhoneNumberOrderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePhoneNumberOrderError {
    pub fn new(kind: CreatePhoneNumberOrderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePhoneNumberOrderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePhoneNumberOrderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePhoneNumberOrderErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreatePhoneNumberOrderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePhoneNumberOrderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::BadRequestException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreatePhoneNumberOrderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProxySessionError {
    pub kind: CreateProxySessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProxySessionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProxySessionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateProxySessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateProxySessionError {
    fn code(&self) -> Option<&str> {
        CreateProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProxySessionError {
    pub fn new(kind: CreateProxySessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProxySessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProxySessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProxySessionErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProxySessionErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateProxySessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRoomError {
    pub kind: CreateRoomErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRoomErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRoomError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRoomErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateRoomErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateRoomErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateRoomErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateRoomErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateRoomErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateRoomErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateRoomErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateRoomErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRoomError {
    fn code(&self) -> Option<&str> {
        CreateRoomError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRoomError {
    pub fn new(kind: CreateRoomErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRoomErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRoomErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateRoomErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateRoomErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateRoomErrorKind::NotFoundException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateRoomErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreateRoomErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateRoomError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRoomErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateRoomErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateRoomErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateRoomErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateRoomErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateRoomErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateRoomErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateRoomErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateRoomErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRoomMembershipError {
    pub kind: CreateRoomMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRoomMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRoomMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRoomMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateRoomMembershipErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateRoomMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateRoomMembershipErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateRoomMembershipErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateRoomMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateRoomMembershipErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateRoomMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateRoomMembershipErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateRoomMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRoomMembershipError {
    fn code(&self) -> Option<&str> {
        CreateRoomMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRoomMembershipError {
    pub fn new(kind: CreateRoomMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRoomMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRoomMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomMembershipErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomMembershipErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomMembershipErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRoomMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateRoomMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRoomMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateRoomMembershipErrorKind::ConflictException(_inner) => Some(_inner),
            CreateRoomMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateRoomMembershipErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateRoomMembershipErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateRoomMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateRoomMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateRoomMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateRoomMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateRoomMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSipMediaApplicationError {
    pub kind: CreateSipMediaApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSipMediaApplicationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSipMediaApplicationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        CreateSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSipMediaApplicationError {
    pub fn new(kind: CreateSipMediaApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSipMediaApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSipMediaApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSipMediaApplicationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ConflictException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateSipMediaApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSipMediaApplicationCallError {
    pub kind: CreateSipMediaApplicationCallErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSipMediaApplicationCallErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSipMediaApplicationCallError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSipMediaApplicationCallErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationCallErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateSipMediaApplicationCallErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSipMediaApplicationCallError {
    fn code(&self) -> Option<&str> {
        CreateSipMediaApplicationCallError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSipMediaApplicationCallError {
    pub fn new(kind: CreateSipMediaApplicationCallErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSipMediaApplicationCallErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSipMediaApplicationCallErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateSipMediaApplicationCallError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSipMediaApplicationCallErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateSipMediaApplicationCallErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            CreateSipMediaApplicationCallErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSipRuleError {
    pub kind: CreateSipRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSipRuleErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSipRuleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateSipRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSipRuleError {
    fn code(&self) -> Option<&str> {
        CreateSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSipRuleError {
    pub fn new(kind: CreateSipRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSipRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSipRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::AccessDeniedException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateSipRuleErrorKind::ForbiddenException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSipRuleErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSipRuleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ConflictException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateSipRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserError {
    pub kind: CreateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserError {
    fn code(&self) -> Option<&str> {
        CreateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserError {
    pub fn new(kind: CreateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateUserErrorKind::ConflictException(_inner) => Some(_inner),
            CreateUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateUserErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVoiceConnectorError {
    pub kind: CreateVoiceConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVoiceConnectorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVoiceConnectorErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        CreateVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVoiceConnectorError {
    pub fn new(kind: CreateVoiceConnectorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVoiceConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVoiceConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVoiceConnectorErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVoiceConnectorGroupError {
    pub kind: CreateVoiceConnectorGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVoiceConnectorGroupErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVoiceConnectorGroupErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateVoiceConnectorGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        CreateVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVoiceConnectorGroupError {
    pub fn new(kind: CreateVoiceConnectorGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVoiceConnectorGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVoiceConnectorGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVoiceConnectorGroupErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateVoiceConnectorGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAccountError {
    pub kind: DeleteAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAccountErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAccountErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAccountErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAccountErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteAccountErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAccountErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAccountErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteAccountErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteAccountErrorKind::UnprocessableEntityException(_inner) => _inner.fmt(f),
            DeleteAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAccountError {
    fn code(&self) -> Option<&str> {
        DeleteAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAccountError {
    pub fn new(kind: DeleteAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteAccountErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteAccountErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteAccountErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountErrorKind::UnauthorizedClientException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAccountErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for DeleteAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAccountErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAccountErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAccountErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteAccountErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAccountErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAccountErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteAccountErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteAccountErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            DeleteAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppInstanceError {
    pub kind: DeleteAppInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppInstanceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppInstanceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAppInstanceError {
    fn code(&self) -> Option<&str> {
        DeleteAppInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppInstanceError {
    pub fn new(kind: DeleteAppInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteAppInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppInstanceErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppInstanceAdminError {
    pub kind: DeleteAppInstanceAdminErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppInstanceAdminErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppInstanceAdminError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppInstanceAdminErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAppInstanceAdminError {
    fn code(&self) -> Option<&str> {
        DeleteAppInstanceAdminError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppInstanceAdminError {
    pub fn new(kind: DeleteAppInstanceAdminErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppInstanceAdminErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppInstanceAdminErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteAppInstanceAdminError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppInstanceAdminErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppInstanceStreamingConfigurationsError {
    pub kind: DeleteAppInstanceStreamingConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppInstanceStreamingConfigurationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppInstanceStreamingConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppInstanceStreamingConfigurationsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DeleteAppInstanceStreamingConfigurationsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteAppInstanceStreamingConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAppInstanceStreamingConfigurationsError {
    fn code(&self) -> Option<&str> {
        DeleteAppInstanceStreamingConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppInstanceStreamingConfigurationsError {
    pub fn new(
        kind: DeleteAppInstanceStreamingConfigurationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppInstanceStreamingConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppInstanceStreamingConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceStreamingConfigurationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceStreamingConfigurationsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceStreamingConfigurationsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceStreamingConfigurationsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceStreamingConfigurationsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceStreamingConfigurationsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceStreamingConfigurationsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteAppInstanceStreamingConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppInstanceStreamingConfigurationsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DeleteAppInstanceStreamingConfigurationsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            DeleteAppInstanceStreamingConfigurationsErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DeleteAppInstanceStreamingConfigurationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppInstanceUserError {
    pub kind: DeleteAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppInstanceUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        DeleteAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppInstanceUserError {
    pub fn new(kind: DeleteAppInstanceUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppInstanceUserErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAttendeeError {
    pub kind: DeleteAttendeeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAttendeeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAttendeeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAttendeeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAttendeeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAttendeeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteAttendeeErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAttendeeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAttendeeErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteAttendeeErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteAttendeeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAttendeeError {
    fn code(&self) -> Option<&str> {
        DeleteAttendeeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAttendeeError {
    pub fn new(kind: DeleteAttendeeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAttendeeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAttendeeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteAttendeeErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteAttendeeErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteAttendeeErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttendeeErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttendeeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttendeeErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAttendeeErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteAttendeeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAttendeeErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAttendeeErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAttendeeErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteAttendeeErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAttendeeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAttendeeErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteAttendeeErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteAttendeeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelError {
    pub kind: DeleteChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelError {
    fn code(&self) -> Option<&str> {
        DeleteChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelError {
    pub fn new(kind: DeleteChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelBanError {
    pub kind: DeleteChannelBanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelBanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelBanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelBanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelBanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelBanError {
    fn code(&self) -> Option<&str> {
        DeleteChannelBanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelBanError {
    pub fn new(kind: DeleteChannelBanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelBanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelBanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteChannelBanErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelBanErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelBanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelBanErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelBanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelMembershipError {
    pub kind: DeleteChannelMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelMembershipError {
    fn code(&self) -> Option<&str> {
        DeleteChannelMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelMembershipError {
    pub fn new(kind: DeleteChannelMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelMessageError {
    pub kind: DeleteChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelMessageError {
    fn code(&self) -> Option<&str> {
        DeleteChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelMessageError {
    pub fn new(kind: DeleteChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChannelModeratorError {
    pub kind: DeleteChannelModeratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChannelModeratorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChannelModeratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChannelModeratorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteChannelModeratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChannelModeratorError {
    fn code(&self) -> Option<&str> {
        DeleteChannelModeratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChannelModeratorError {
    pub fn new(kind: DeleteChannelModeratorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChannelModeratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChannelModeratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChannelModeratorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteChannelModeratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChannelModeratorErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteChannelModeratorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEventsConfigurationError {
    pub kind: DeleteEventsConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEventsConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEventsConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEventsConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteEventsConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteEventsConfigurationErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEventsConfigurationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteEventsConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEventsConfigurationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEventsConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEventsConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteEventsConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEventsConfigurationError {
    pub fn new(kind: DeleteEventsConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEventsConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEventsConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventsConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventsConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventsConfigurationErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventsConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventsConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventsConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteEventsConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEventsConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteEventsConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteEventsConfigurationErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            DeleteEventsConfigurationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteEventsConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteEventsConfigurationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteEventsConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMediaCapturePipelineError {
    pub kind: DeleteMediaCapturePipelineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMediaCapturePipelineErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMediaCapturePipelineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMediaCapturePipelineErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMediaCapturePipelineErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteMediaCapturePipelineErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteMediaCapturePipelineErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteMediaCapturePipelineErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteMediaCapturePipelineErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteMediaCapturePipelineErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteMediaCapturePipelineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMediaCapturePipelineError {
    fn code(&self) -> Option<&str> {
        DeleteMediaCapturePipelineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMediaCapturePipelineError {
    pub fn new(kind: DeleteMediaCapturePipelineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMediaCapturePipelineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMediaCapturePipelineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMediaCapturePipelineErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMediaCapturePipelineErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMediaCapturePipelineErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMediaCapturePipelineErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMediaCapturePipelineErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMediaCapturePipelineErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMediaCapturePipelineErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteMediaCapturePipelineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMediaCapturePipelineErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMediaCapturePipelineErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteMediaCapturePipelineErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteMediaCapturePipelineErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteMediaCapturePipelineErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteMediaCapturePipelineErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteMediaCapturePipelineErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            DeleteMediaCapturePipelineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMeetingError {
    pub kind: DeleteMeetingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMeetingErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMeetingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMeetingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMeetingErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteMeetingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteMeetingErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteMeetingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteMeetingErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteMeetingErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteMeetingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMeetingError {
    fn code(&self) -> Option<&str> {
        DeleteMeetingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMeetingError {
    pub fn new(kind: DeleteMeetingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMeetingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMeetingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteMeetingErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteMeetingErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteMeetingErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMeetingErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMeetingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMeetingErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMeetingErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteMeetingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMeetingErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMeetingErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteMeetingErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteMeetingErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteMeetingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteMeetingErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteMeetingErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteMeetingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePhoneNumberError {
    pub kind: DeletePhoneNumberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePhoneNumberErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeletePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePhoneNumberError {
    fn code(&self) -> Option<&str> {
        DeletePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePhoneNumberError {
    pub fn new(kind: DeletePhoneNumberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePhoneNumberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePhoneNumberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeletePhoneNumberErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeletePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeletePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProxySessionError {
    pub kind: DeleteProxySessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProxySessionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProxySessionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteProxySessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteProxySessionError {
    fn code(&self) -> Option<&str> {
        DeleteProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProxySessionError {
    pub fn new(kind: DeleteProxySessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProxySessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProxySessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProxySessionErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProxySessionErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteProxySessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRoomError {
    pub kind: DeleteRoomErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRoomErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRoomError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRoomErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteRoomErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteRoomErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRoomErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteRoomErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteRoomErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteRoomErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteRoomErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRoomError {
    fn code(&self) -> Option<&str> {
        DeleteRoomError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRoomError {
    pub fn new(kind: DeleteRoomErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRoomErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRoomErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoomErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoomErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoomErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoomErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoomErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, DeleteRoomErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoomErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteRoomError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRoomErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteRoomErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteRoomErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRoomErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteRoomErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteRoomErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteRoomErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteRoomErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRoomMembershipError {
    pub kind: DeleteRoomMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRoomMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRoomMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRoomMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteRoomMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteRoomMembershipErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRoomMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteRoomMembershipErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteRoomMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteRoomMembershipErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteRoomMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRoomMembershipError {
    fn code(&self) -> Option<&str> {
        DeleteRoomMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRoomMembershipError {
    pub fn new(kind: DeleteRoomMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRoomMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRoomMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoomMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoomMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoomMembershipErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoomMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoomMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoomMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRoomMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteRoomMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRoomMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteRoomMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteRoomMembershipErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRoomMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteRoomMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteRoomMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteRoomMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteRoomMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSipMediaApplicationError {
    pub kind: DeleteSipMediaApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSipMediaApplicationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSipMediaApplicationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteSipMediaApplicationErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteSipMediaApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        DeleteSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSipMediaApplicationError {
    pub fn new(kind: DeleteSipMediaApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSipMediaApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSipMediaApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipMediaApplicationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSipMediaApplicationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteSipMediaApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSipRuleError {
    pub kind: DeleteSipRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSipRuleErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSipRuleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteSipRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSipRuleError {
    fn code(&self) -> Option<&str> {
        DeleteSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSipRuleError {
    pub fn new(kind: DeleteSipRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSipRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSipRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteSipRuleErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipRuleErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipRuleErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSipRuleErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSipRuleErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteSipRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorError {
    pub kind: DeleteVoiceConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorError {
    pub fn new(kind: DeleteVoiceConnectorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorEmergencyCallingConfigurationError {
    pub kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceConnectorEmergencyCallingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind
    for DeleteVoiceConnectorEmergencyCallingConfigurationError
{
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorEmergencyCallingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorEmergencyCallingConfigurationError {
    pub fn new(
        kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(
                _
            )
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(
                _
            )
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorEmergencyCallingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DeleteVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorGroupError {
    pub kind: DeleteVoiceConnectorGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorGroupErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorGroupError {
    pub fn new(kind: DeleteVoiceConnectorGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorOriginationError {
    pub kind: DeleteVoiceConnectorOriginationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorOriginationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceConnectorOriginationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorOriginationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorOriginationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorOriginationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorOriginationError {
    pub fn new(kind: DeleteVoiceConnectorOriginationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorOriginationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorOriginationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorOriginationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorOriginationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorProxyError {
    pub kind: DeleteVoiceConnectorProxyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorProxyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceConnectorProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorProxyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorProxyError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorProxyError {
    pub fn new(kind: DeleteVoiceConnectorProxyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorProxyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorProxyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorProxyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteVoiceConnectorProxyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorStreamingConfigurationError {
    pub kind: DeleteVoiceConnectorStreamingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorStreamingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceConnectorStreamingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorStreamingConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorStreamingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorStreamingConfigurationError {
    pub fn new(
        kind: DeleteVoiceConnectorStreamingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorStreamingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorTerminationError {
    pub kind: DeleteVoiceConnectorTerminationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorTerminationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceConnectorTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorTerminationError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorTerminationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorTerminationError {
    pub fn new(kind: DeleteVoiceConnectorTerminationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorTerminationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorTerminationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceConnectorTerminationCredentialsError {
    pub kind: DeleteVoiceConnectorTerminationCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceConnectorTerminationCredentialsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceConnectorTerminationCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVoiceConnectorTerminationCredentialsError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceConnectorTerminationCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceConnectorTerminationCredentialsError {
    pub fn new(
        kind: DeleteVoiceConnectorTerminationCredentialsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceConnectorTerminationCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DeleteVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppInstanceError {
    pub kind: DescribeAppInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppInstanceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppInstanceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAppInstanceError {
    fn code(&self) -> Option<&str> {
        DescribeAppInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppInstanceError {
    pub fn new(kind: DescribeAppInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeAppInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppInstanceErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppInstanceAdminError {
    pub kind: DescribeAppInstanceAdminErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppInstanceAdminErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppInstanceAdminError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppInstanceAdminErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAppInstanceAdminError {
    fn code(&self) -> Option<&str> {
        DescribeAppInstanceAdminError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppInstanceAdminError {
    pub fn new(kind: DescribeAppInstanceAdminErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppInstanceAdminErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppInstanceAdminErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeAppInstanceAdminError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppInstanceAdminErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppInstanceUserError {
    pub kind: DescribeAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppInstanceUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        DescribeAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppInstanceUserError {
    pub fn new(kind: DescribeAppInstanceUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppInstanceUserErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelError {
    pub kind: DescribeChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelError {
    fn code(&self) -> Option<&str> {
        DescribeChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelError {
    pub fn new(kind: DescribeChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeChannelErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeChannelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeChannelErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeChannelErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelBanError {
    pub kind: DescribeChannelBanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelBanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelBanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelBanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeChannelBanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelBanError {
    fn code(&self) -> Option<&str> {
        DescribeChannelBanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelBanError {
    pub fn new(kind: DescribeChannelBanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelBanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelBanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelBanErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelBanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelBanErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeChannelBanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelMembershipError {
    pub kind: DescribeChannelMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeChannelMembershipErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelMembershipError {
    fn code(&self) -> Option<&str> {
        DescribeChannelMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelMembershipError {
    pub fn new(kind: DescribeChannelMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeChannelMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelMembershipForAppInstanceUserError {
    pub kind: DescribeChannelMembershipForAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelMembershipForAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelMembershipForAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelMembershipForAppInstanceUserErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelMembershipForAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelMembershipForAppInstanceUserErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelMembershipForAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelMembershipForAppInstanceUserErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelMembershipForAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        DescribeChannelMembershipForAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelMembershipForAppInstanceUserError {
    pub fn new(
        kind: DescribeChannelMembershipForAppInstanceUserErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelMembershipForAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelMembershipForAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelMembershipForAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelMembershipForAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelMembershipForAppInstanceUserErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DescribeChannelMembershipForAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            DescribeChannelMembershipForAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DescribeChannelMembershipForAppInstanceUserErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DescribeChannelMembershipForAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DescribeChannelMembershipForAppInstanceUserErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelModeratedByAppInstanceUserError {
    pub kind: DescribeChannelModeratedByAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelModeratedByAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelModeratedByAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelModeratedByAppInstanceUserErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelModeratedByAppInstanceUserErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeChannelModeratedByAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelModeratedByAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        DescribeChannelModeratedByAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelModeratedByAppInstanceUserError {
    pub fn new(
        kind: DescribeChannelModeratedByAppInstanceUserErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelModeratedByAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelModeratedByAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelModeratedByAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelModeratedByAppInstanceUserErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            DescribeChannelModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DescribeChannelModeratedByAppInstanceUserErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DescribeChannelModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DescribeChannelModeratedByAppInstanceUserErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChannelModeratorError {
    pub kind: DescribeChannelModeratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChannelModeratorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChannelModeratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChannelModeratorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeChannelModeratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChannelModeratorError {
    fn code(&self) -> Option<&str> {
        DescribeChannelModeratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChannelModeratorError {
    pub fn new(kind: DescribeChannelModeratorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChannelModeratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChannelModeratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChannelModeratorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeChannelModeratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChannelModeratorErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeChannelModeratorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociatePhoneNumberFromUserError {
    pub kind: DisassociatePhoneNumberFromUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociatePhoneNumberFromUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociatePhoneNumberFromUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociatePhoneNumberFromUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DisassociatePhoneNumberFromUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DisassociatePhoneNumberFromUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DisassociatePhoneNumberFromUserErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumberFromUserErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumberFromUserErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumberFromUserErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumberFromUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociatePhoneNumberFromUserError {
    fn code(&self) -> Option<&str> {
        DisassociatePhoneNumberFromUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociatePhoneNumberFromUserError {
    pub fn new(kind: DisassociatePhoneNumberFromUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociatePhoneNumberFromUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociatePhoneNumberFromUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumberFromUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumberFromUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumberFromUserErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumberFromUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumberFromUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumberFromUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumberFromUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DisassociatePhoneNumberFromUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociatePhoneNumberFromUserErrorKind::BadRequestException(_inner) => Some(_inner),
            DisassociatePhoneNumberFromUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            DisassociatePhoneNumberFromUserErrorKind::NotFoundException(_inner) => Some(_inner),
            DisassociatePhoneNumberFromUserErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumberFromUserErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumberFromUserErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumberFromUserErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumberFromUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociatePhoneNumbersFromVoiceConnectorError {
    pub kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociatePhoneNumbersFromVoiceConnectorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        DisassociatePhoneNumbersFromVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociatePhoneNumbersFromVoiceConnectorError {
    pub fn new(
        kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DisassociatePhoneNumbersFromVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DisassociatePhoneNumbersFromVoiceConnectorErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    pub kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind
    for DisassociatePhoneNumbersFromVoiceConnectorGroupError
{
    fn code(&self) -> Option<&str> {
        DisassociatePhoneNumbersFromVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    pub fn new(
        kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException(
                _
            )
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException(
                _
            )
        )
    }
}
impl std::error::Error for DisassociatePhoneNumbersFromVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            DisassociatePhoneNumbersFromVoiceConnectorGroupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateSigninDelegateGroupsFromAccountError {
    pub kind: DisassociateSigninDelegateGroupsFromAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateSigninDelegateGroupsFromAccountErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateSigninDelegateGroupsFromAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateSigninDelegateGroupsFromAccountErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateSigninDelegateGroupsFromAccountErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateSigninDelegateGroupsFromAccountErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateSigninDelegateGroupsFromAccountErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateSigninDelegateGroupsFromAccountError {
    fn code(&self) -> Option<&str> {
        DisassociateSigninDelegateGroupsFromAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateSigninDelegateGroupsFromAccountError {
    pub fn new(
        kind: DisassociateSigninDelegateGroupsFromAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateSigninDelegateGroupsFromAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateSigninDelegateGroupsFromAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSigninDelegateGroupsFromAccountErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSigninDelegateGroupsFromAccountErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateSigninDelegateGroupsFromAccountErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DisassociateSigninDelegateGroupsFromAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateSigninDelegateGroupsFromAccountErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            DisassociateSigninDelegateGroupsFromAccountErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            DisassociateSigninDelegateGroupsFromAccountErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            DisassociateSigninDelegateGroupsFromAccountErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            DisassociateSigninDelegateGroupsFromAccountErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountError {
    pub kind: GetAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountError {
    fn code(&self) -> Option<&str> {
        GetAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountError {
    pub fn new(kind: GetAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAccountErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetAccountErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAccountErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetAccountErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetAccountErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetAccountErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountSettingsError {
    pub kind: GetAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountSettingsError {
    fn code(&self) -> Option<&str> {
        GetAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountSettingsError {
    pub fn new(kind: GetAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAppInstanceRetentionSettingsError {
    pub kind: GetAppInstanceRetentionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAppInstanceRetentionSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAppInstanceRetentionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAppInstanceRetentionSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAppInstanceRetentionSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetAppInstanceRetentionSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceRetentionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAppInstanceRetentionSettingsError {
    fn code(&self) -> Option<&str> {
        GetAppInstanceRetentionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAppInstanceRetentionSettingsError {
    pub fn new(kind: GetAppInstanceRetentionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAppInstanceRetentionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAppInstanceRetentionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetAppInstanceRetentionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAppInstanceRetentionSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAppInstanceRetentionSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetAppInstanceRetentionSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceRetentionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAppInstanceStreamingConfigurationsError {
    pub kind: GetAppInstanceStreamingConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAppInstanceStreamingConfigurationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAppInstanceStreamingConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAppInstanceStreamingConfigurationsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAppInstanceStreamingConfigurationsError {
    fn code(&self) -> Option<&str> {
        GetAppInstanceStreamingConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAppInstanceStreamingConfigurationsError {
    pub fn new(
        kind: GetAppInstanceStreamingConfigurationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAppInstanceStreamingConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAppInstanceStreamingConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceStreamingConfigurationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceStreamingConfigurationsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceStreamingConfigurationsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceStreamingConfigurationsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceStreamingConfigurationsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceStreamingConfigurationsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceStreamingConfigurationsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetAppInstanceStreamingConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAppInstanceStreamingConfigurationsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceStreamingConfigurationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAttendeeError {
    pub kind: GetAttendeeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAttendeeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAttendeeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAttendeeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAttendeeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetAttendeeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAttendeeErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetAttendeeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetAttendeeErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetAttendeeErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetAttendeeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAttendeeError {
    fn code(&self) -> Option<&str> {
        GetAttendeeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAttendeeError {
    pub fn new(kind: GetAttendeeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAttendeeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAttendeeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetAttendeeErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetAttendeeErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAttendeeErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetAttendeeErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAttendeeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAttendeeErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAttendeeErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetAttendeeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAttendeeErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAttendeeErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetAttendeeErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAttendeeErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetAttendeeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetAttendeeErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetAttendeeErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetAttendeeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBotError {
    pub kind: GetBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBotErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBotErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBotErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetBotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBotErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetBotErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetBotErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetBotErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBotError {
    fn code(&self) -> Option<&str> {
        GetBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBotError {
    pub fn new(kind: GetBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::ServiceUnavailableException(_))
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetBotErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBotErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBotErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetBotErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBotErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetBotErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetBotErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetBotErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetChannelMessageError {
    pub kind: GetChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetChannelMessageError {
    fn code(&self) -> Option<&str> {
        GetChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetChannelMessageError {
    pub fn new(kind: GetChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetChannelMessageErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::NotFoundException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEventsConfigurationError {
    pub kind: GetEventsConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEventsConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEventsConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEventsConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetEventsConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetEventsConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetEventsConfigurationErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetEventsConfigurationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetEventsConfigurationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetEventsConfigurationErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetEventsConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEventsConfigurationError {
    fn code(&self) -> Option<&str> {
        GetEventsConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEventsConfigurationError {
    pub fn new(kind: GetEventsConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEventsConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEventsConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventsConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventsConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventsConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventsConfigurationErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventsConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventsConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventsConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetEventsConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEventsConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetEventsConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetEventsConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetEventsConfigurationErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            GetEventsConfigurationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetEventsConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetEventsConfigurationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetEventsConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGlobalSettingsError {
    pub kind: GetGlobalSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGlobalSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGlobalSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGlobalSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetGlobalSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGlobalSettingsError {
    fn code(&self) -> Option<&str> {
        GetGlobalSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGlobalSettingsError {
    pub fn new(kind: GetGlobalSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGlobalSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGlobalSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGlobalSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetGlobalSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGlobalSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetGlobalSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMediaCapturePipelineError {
    pub kind: GetMediaCapturePipelineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMediaCapturePipelineErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMediaCapturePipelineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMediaCapturePipelineErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetMediaCapturePipelineErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetMediaCapturePipelineErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetMediaCapturePipelineErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetMediaCapturePipelineErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetMediaCapturePipelineErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetMediaCapturePipelineErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetMediaCapturePipelineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMediaCapturePipelineError {
    fn code(&self) -> Option<&str> {
        GetMediaCapturePipelineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMediaCapturePipelineError {
    pub fn new(kind: GetMediaCapturePipelineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMediaCapturePipelineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMediaCapturePipelineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMediaCapturePipelineErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMediaCapturePipelineErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMediaCapturePipelineErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMediaCapturePipelineErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMediaCapturePipelineErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMediaCapturePipelineErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMediaCapturePipelineErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetMediaCapturePipelineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMediaCapturePipelineErrorKind::BadRequestException(_inner) => Some(_inner),
            GetMediaCapturePipelineErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetMediaCapturePipelineErrorKind::NotFoundException(_inner) => Some(_inner),
            GetMediaCapturePipelineErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetMediaCapturePipelineErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetMediaCapturePipelineErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetMediaCapturePipelineErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetMediaCapturePipelineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMeetingError {
    pub kind: GetMeetingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMeetingErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMeetingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMeetingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetMeetingErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetMeetingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetMeetingErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetMeetingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetMeetingErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetMeetingErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetMeetingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMeetingError {
    fn code(&self) -> Option<&str> {
        GetMeetingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMeetingError {
    pub fn new(kind: GetMeetingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMeetingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMeetingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetMeetingErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetMeetingErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetMeetingErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetMeetingErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMeetingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetMeetingErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMeetingErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetMeetingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMeetingErrorKind::BadRequestException(_inner) => Some(_inner),
            GetMeetingErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetMeetingErrorKind::NotFoundException(_inner) => Some(_inner),
            GetMeetingErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetMeetingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetMeetingErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetMeetingErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetMeetingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMessagingSessionEndpointError {
    pub kind: GetMessagingSessionEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMessagingSessionEndpointErrorKind {
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMessagingSessionEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMessagingSessionEndpointErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetMessagingSessionEndpointErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetMessagingSessionEndpointErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetMessagingSessionEndpointErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetMessagingSessionEndpointErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetMessagingSessionEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMessagingSessionEndpointError {
    fn code(&self) -> Option<&str> {
        GetMessagingSessionEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMessagingSessionEndpointError {
    pub fn new(kind: GetMessagingSessionEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMessagingSessionEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMessagingSessionEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMessagingSessionEndpointErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetMessagingSessionEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMessagingSessionEndpointErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetMessagingSessionEndpointErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetMessagingSessionEndpointErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetMessagingSessionEndpointErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetMessagingSessionEndpointErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetMessagingSessionEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPhoneNumberError {
    pub kind: GetPhoneNumberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPhoneNumberErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPhoneNumberError {
    fn code(&self) -> Option<&str> {
        GetPhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPhoneNumberError {
    pub fn new(kind: GetPhoneNumberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPhoneNumberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPhoneNumberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPhoneNumberErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetPhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetPhoneNumberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPhoneNumberOrderError {
    pub kind: GetPhoneNumberOrderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPhoneNumberOrderErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPhoneNumberOrderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPhoneNumberOrderErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberOrderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPhoneNumberOrderError {
    fn code(&self) -> Option<&str> {
        GetPhoneNumberOrderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPhoneNumberOrderError {
    pub fn new(kind: GetPhoneNumberOrderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPhoneNumberOrderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPhoneNumberOrderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberOrderErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetPhoneNumberOrderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPhoneNumberOrderErrorKind::BadRequestException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::NotFoundException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetPhoneNumberOrderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPhoneNumberSettingsError {
    pub kind: GetPhoneNumberSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPhoneNumberSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPhoneNumberSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPhoneNumberSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetPhoneNumberSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPhoneNumberSettingsError {
    fn code(&self) -> Option<&str> {
        GetPhoneNumberSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPhoneNumberSettingsError {
    pub fn new(kind: GetPhoneNumberSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPhoneNumberSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPhoneNumberSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPhoneNumberSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetPhoneNumberSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPhoneNumberSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetPhoneNumberSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetProxySessionError {
    pub kind: GetProxySessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetProxySessionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetProxySessionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetProxySessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetProxySessionError {
    fn code(&self) -> Option<&str> {
        GetProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetProxySessionError {
    pub fn new(kind: GetProxySessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetProxySessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetProxySessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetProxySessionErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProxySessionErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProxySessionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProxySessionErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetProxySessionErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetProxySessionErrorKind::BadRequestException(_inner) => Some(_inner),
            GetProxySessionErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetProxySessionErrorKind::NotFoundException(_inner) => Some(_inner),
            GetProxySessionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetProxySessionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetProxySessionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetProxySessionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetProxySessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRetentionSettingsError {
    pub kind: GetRetentionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRetentionSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRetentionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRetentionSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetRetentionSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetRetentionSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRetentionSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetRetentionSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetRetentionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRetentionSettingsError {
    fn code(&self) -> Option<&str> {
        GetRetentionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRetentionSettingsError {
    pub fn new(kind: GetRetentionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRetentionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRetentionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRetentionSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRetentionSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRetentionSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRetentionSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRetentionSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRetentionSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRetentionSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetRetentionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRetentionSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetRetentionSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetRetentionSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRetentionSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetRetentionSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetRetentionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRoomError {
    pub kind: GetRoomErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRoomErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRoomError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRoomErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetRoomErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetRoomErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRoomErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetRoomErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetRoomErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetRoomErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetRoomErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRoomError {
    fn code(&self) -> Option<&str> {
        GetRoomError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRoomError {
    pub fn new(kind: GetRoomErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRoomErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRoomErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetRoomErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetRoomErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetRoomErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetRoomErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetRoomErrorKind::ServiceUnavailableException(_))
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetRoomErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetRoomErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetRoomError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRoomErrorKind::BadRequestException(_inner) => Some(_inner),
            GetRoomErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetRoomErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRoomErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetRoomErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetRoomErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetRoomErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetRoomErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipMediaApplicationError {
    pub kind: GetSipMediaApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipMediaApplicationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipMediaApplicationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetSipMediaApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        GetSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipMediaApplicationError {
    pub fn new(kind: GetSipMediaApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSipMediaApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSipMediaApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipMediaApplicationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetSipMediaApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipMediaApplicationLoggingConfigurationError {
    pub kind: GetSipMediaApplicationLoggingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipMediaApplicationLoggingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSipMediaApplicationLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSipMediaApplicationLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetSipMediaApplicationLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipMediaApplicationLoggingConfigurationError {
    pub fn new(
        kind: GetSipMediaApplicationLoggingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetSipMediaApplicationLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            GetSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSipRuleError {
    pub kind: GetSipRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSipRuleErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSipRuleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetSipRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSipRuleError {
    fn code(&self) -> Option<&str> {
        GetSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSipRuleError {
    pub fn new(kind: GetSipRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSipRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSipRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetSipRuleErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSipRuleErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSipRuleErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSipRuleErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSipRuleErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSipRuleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetSipRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetSipRuleErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetSipRuleErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetSipRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserError {
    pub kind: GetUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserError {
    fn code(&self) -> Option<&str> {
        GetUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserError {
    pub fn new(kind: GetUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::ServiceUnavailableException(_))
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::UnauthorizedClientException(_))
    }
}
impl std::error::Error for GetUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserErrorKind::BadRequestException(_inner) => Some(_inner),
            GetUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetUserErrorKind::NotFoundException(_inner) => Some(_inner),
            GetUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserSettingsError {
    pub kind: GetUserSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetUserSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetUserSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetUserSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetUserSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetUserSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetUserSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetUserSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserSettingsError {
    fn code(&self) -> Option<&str> {
        GetUserSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserSettingsError {
    pub fn new(kind: GetUserSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetUserSettingsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetUserSettingsErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUserSettingsErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetUserSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetUserSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetUserSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetUserSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetUserSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetUserSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetUserSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetUserSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorError {
    pub kind: GetVoiceConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorError {
    pub fn new(kind: GetVoiceConnectorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceConnectorErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorEmergencyCallingConfigurationError {
    pub kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorEmergencyCallingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceConnectorEmergencyCallingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceConnectorEmergencyCallingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorEmergencyCallingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorEmergencyCallingConfigurationError {
    pub fn new(
        kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorEmergencyCallingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            GetVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorGroupError {
    pub kind: GetVoiceConnectorGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorGroupErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorGroupError {
    pub fn new(kind: GetVoiceConnectorGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetVoiceConnectorGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorLoggingConfigurationError {
    pub kind: GetVoiceConnectorLoggingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorLoggingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceConnectorLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceConnectorLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorLoggingConfigurationError {
    pub fn new(
        kind: GetVoiceConnectorLoggingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorOriginationError {
    pub kind: GetVoiceConnectorOriginationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorOriginationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceConnectorOriginationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorOriginationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceConnectorOriginationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorOriginationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorOriginationError {
    pub fn new(kind: GetVoiceConnectorOriginationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorOriginationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorOriginationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorOriginationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorOriginationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorProxyError {
    pub kind: GetVoiceConnectorProxyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorProxyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceConnectorProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorProxyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            GetVoiceConnectorProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceConnectorProxyError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorProxyError {
    pub fn new(kind: GetVoiceConnectorProxyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorProxyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorProxyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorProxyErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorProxyErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            GetVoiceConnectorProxyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorStreamingConfigurationError {
    pub kind: GetVoiceConnectorStreamingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorStreamingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceConnectorStreamingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceConnectorStreamingConfigurationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorStreamingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorStreamingConfigurationError {
    pub fn new(
        kind: GetVoiceConnectorStreamingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorStreamingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            GetVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            GetVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorTerminationError {
    pub kind: GetVoiceConnectorTerminationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorTerminationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceConnectorTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceConnectorTerminationError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorTerminationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorTerminationError {
    pub fn new(kind: GetVoiceConnectorTerminationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorTerminationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorTerminationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceConnectorTerminationHealthError {
    pub kind: GetVoiceConnectorTerminationHealthErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceConnectorTerminationHealthErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceConnectorTerminationHealthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceConnectorTerminationHealthErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetVoiceConnectorTerminationHealthErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceConnectorTerminationHealthError {
    fn code(&self) -> Option<&str> {
        GetVoiceConnectorTerminationHealthError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceConnectorTerminationHealthError {
    pub fn new(
        kind: GetVoiceConnectorTerminationHealthErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceConnectorTerminationHealthErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceConnectorTerminationHealthErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetVoiceConnectorTerminationHealthError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceConnectorTerminationHealthErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationHealthErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceConnectorTerminationHealthErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetVoiceConnectorTerminationHealthErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InviteUsersError {
    pub kind: InviteUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InviteUsersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InviteUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            InviteUsersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            InviteUsersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            InviteUsersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            InviteUsersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            InviteUsersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            InviteUsersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            InviteUsersErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            InviteUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for InviteUsersError {
    fn code(&self) -> Option<&str> {
        InviteUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl InviteUsersError {
    pub fn new(kind: InviteUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: InviteUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: InviteUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, InviteUsersErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, InviteUsersErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, InviteUsersErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, InviteUsersErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            InviteUsersErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            InviteUsersErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            InviteUsersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for InviteUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            InviteUsersErrorKind::BadRequestException(_inner) => Some(_inner),
            InviteUsersErrorKind::ForbiddenException(_inner) => Some(_inner),
            InviteUsersErrorKind::NotFoundException(_inner) => Some(_inner),
            InviteUsersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            InviteUsersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            InviteUsersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            InviteUsersErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            InviteUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAccountsError {
    pub kind: ListAccountsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAccountsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAccountsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAccountsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListAccountsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListAccountsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListAccountsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAccountsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAccountsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListAccountsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListAccountsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAccountsError {
    fn code(&self) -> Option<&str> {
        ListAccountsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAccountsError {
    pub fn new(kind: ListAccountsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAccountsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAccountsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListAccountsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListAccountsErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAccountsErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAccountsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAccountsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAccountsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAccountsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAccountsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAccountsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListAccountsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAccountsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListAccountsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAccountsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAccountsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListAccountsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListAccountsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppInstanceAdminsError {
    pub kind: ListAppInstanceAdminsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppInstanceAdminsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppInstanceAdminsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppInstanceAdminsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAppInstanceAdminsError {
    fn code(&self) -> Option<&str> {
        ListAppInstanceAdminsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppInstanceAdminsError {
    pub fn new(kind: ListAppInstanceAdminsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppInstanceAdminsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppInstanceAdminsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAppInstanceAdminsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppInstanceAdminsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppInstancesError {
    pub kind: ListAppInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppInstancesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppInstancesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAppInstancesError {
    fn code(&self) -> Option<&str> {
        ListAppInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppInstancesError {
    pub fn new(kind: ListAppInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListAppInstancesErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAppInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppInstancesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppInstanceUsersError {
    pub kind: ListAppInstanceUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppInstanceUsersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppInstanceUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppInstanceUsersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAppInstanceUsersError {
    fn code(&self) -> Option<&str> {
        ListAppInstanceUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppInstanceUsersError {
    pub fn new(kind: ListAppInstanceUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppInstanceUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppInstanceUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAppInstanceUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppInstanceUsersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttendeesError {
    pub kind: ListAttendeesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttendeesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttendeesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttendeesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListAttendeesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListAttendeesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListAttendeesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAttendeesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAttendeesErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListAttendeesErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListAttendeesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttendeesError {
    fn code(&self) -> Option<&str> {
        ListAttendeesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttendeesError {
    pub fn new(kind: ListAttendeesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttendeesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttendeesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListAttendeesErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListAttendeesErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAttendeesErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttendeesErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttendeesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttendeesErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttendeesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAttendeesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttendeesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListAttendeesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAttendeesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListAttendeesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAttendeesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAttendeesErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListAttendeesErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListAttendeesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAttendeeTagsError {
    pub kind: ListAttendeeTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAttendeeTagsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAttendeeTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAttendeeTagsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListAttendeeTagsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListAttendeeTagsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListAttendeeTagsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAttendeeTagsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAttendeeTagsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListAttendeeTagsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListAttendeeTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAttendeeTagsError {
    fn code(&self) -> Option<&str> {
        ListAttendeeTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAttendeeTagsError {
    pub fn new(kind: ListAttendeeTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAttendeeTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAttendeeTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttendeeTagsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListAttendeeTagsErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAttendeeTagsErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttendeeTagsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttendeeTagsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttendeeTagsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAttendeeTagsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAttendeeTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAttendeeTagsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListAttendeeTagsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAttendeeTagsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListAttendeeTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAttendeeTagsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAttendeeTagsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListAttendeeTagsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListAttendeeTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBotsError {
    pub kind: ListBotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBotsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBotsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListBotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBotsError {
    fn code(&self) -> Option<&str> {
        ListBotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBotsError {
    pub fn new(kind: ListBotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBotsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListBotsErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBotsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListBotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBotsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListBotsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListBotsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListBotsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListBotsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListBotsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListBotsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListBotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelBansError {
    pub kind: ListChannelBansErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelBansErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelBansError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelBansErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelBansErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelBansError {
    fn code(&self) -> Option<&str> {
        ListChannelBansError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelBansError {
    pub fn new(kind: ListChannelBansErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelBansErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelBansErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListChannelBansErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListChannelBansErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelBansErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelBansErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelBansErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelBansErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelBansError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelBansErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelBansErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelBansErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelBansErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelBansErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelBansErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelBansErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelMembershipsError {
    pub kind: ListChannelMembershipsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelMembershipsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelMembershipsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelMembershipsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelMembershipsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelMembershipsError {
    fn code(&self) -> Option<&str> {
        ListChannelMembershipsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelMembershipsError {
    pub fn new(kind: ListChannelMembershipsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelMembershipsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelMembershipsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelMembershipsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelMembershipsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelMembershipsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelMembershipsForAppInstanceUserError {
    pub kind: ListChannelMembershipsForAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelMembershipsForAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelMembershipsForAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelMembershipsForAppInstanceUserErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            ListChannelMembershipsForAppInstanceUserErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            ListChannelMembershipsForAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelMembershipsForAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        ListChannelMembershipsForAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelMembershipsForAppInstanceUserError {
    pub fn new(
        kind: ListChannelMembershipsForAppInstanceUserErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelMembershipsForAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelMembershipsForAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMembershipsForAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelMembershipsForAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelMembershipsForAppInstanceUserErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            ListChannelMembershipsForAppInstanceUserErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            ListChannelMembershipsForAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            ListChannelMembershipsForAppInstanceUserErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelMessagesError {
    pub kind: ListChannelMessagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelMessagesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelMessagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelMessagesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelMessagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelMessagesError {
    fn code(&self) -> Option<&str> {
        ListChannelMessagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelMessagesError {
    pub fn new(kind: ListChannelMessagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelMessagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelMessagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelMessagesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelMessagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelMessagesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelMessagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelModeratorsError {
    pub kind: ListChannelModeratorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelModeratorsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelModeratorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelModeratorsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelModeratorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelModeratorsError {
    fn code(&self) -> Option<&str> {
        ListChannelModeratorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelModeratorsError {
    pub fn new(kind: ListChannelModeratorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelModeratorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelModeratorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelModeratorsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelModeratorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelModeratorsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelModeratorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelsError {
    pub kind: ListChannelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListChannelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelsError {
    fn code(&self) -> Option<&str> {
        ListChannelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelsError {
    pub fn new(kind: ListChannelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListChannelsErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListChannelsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListChannelsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListChannelsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListChannelsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListChannelsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListChannelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChannelsModeratedByAppInstanceUserError {
    pub kind: ListChannelsModeratedByAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChannelsModeratedByAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChannelsModeratedByAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChannelsModeratedByAppInstanceUserErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            ListChannelsModeratedByAppInstanceUserErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            ListChannelsModeratedByAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChannelsModeratedByAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        ListChannelsModeratedByAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChannelsModeratedByAppInstanceUserError {
    pub fn new(
        kind: ListChannelsModeratedByAppInstanceUserErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChannelsModeratedByAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChannelsModeratedByAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListChannelsModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListChannelsModeratedByAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChannelsModeratedByAppInstanceUserErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            ListChannelsModeratedByAppInstanceUserErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            ListChannelsModeratedByAppInstanceUserErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            ListChannelsModeratedByAppInstanceUserErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMediaCapturePipelinesError {
    pub kind: ListMediaCapturePipelinesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMediaCapturePipelinesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMediaCapturePipelinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMediaCapturePipelinesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMediaCapturePipelinesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListMediaCapturePipelinesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListMediaCapturePipelinesErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListMediaCapturePipelinesErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListMediaCapturePipelinesErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            ListMediaCapturePipelinesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMediaCapturePipelinesError {
    fn code(&self) -> Option<&str> {
        ListMediaCapturePipelinesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMediaCapturePipelinesError {
    pub fn new(kind: ListMediaCapturePipelinesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMediaCapturePipelinesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMediaCapturePipelinesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMediaCapturePipelinesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMediaCapturePipelinesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMediaCapturePipelinesErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMediaCapturePipelinesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMediaCapturePipelinesErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMediaCapturePipelinesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListMediaCapturePipelinesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMediaCapturePipelinesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMediaCapturePipelinesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListMediaCapturePipelinesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListMediaCapturePipelinesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListMediaCapturePipelinesErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListMediaCapturePipelinesErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListMediaCapturePipelinesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMeetingsError {
    pub kind: ListMeetingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMeetingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMeetingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMeetingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMeetingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListMeetingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListMeetingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListMeetingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListMeetingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListMeetingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMeetingsError {
    fn code(&self) -> Option<&str> {
        ListMeetingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMeetingsError {
    pub fn new(kind: ListMeetingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMeetingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMeetingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListMeetingsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListMeetingsErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeetingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeetingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeetingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeetingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListMeetingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMeetingsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMeetingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListMeetingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListMeetingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListMeetingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListMeetingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListMeetingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMeetingTagsError {
    pub kind: ListMeetingTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMeetingTagsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMeetingTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMeetingTagsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMeetingTagsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListMeetingTagsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListMeetingTagsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListMeetingTagsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListMeetingTagsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListMeetingTagsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListMeetingTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMeetingTagsError {
    fn code(&self) -> Option<&str> {
        ListMeetingTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMeetingTagsError {
    pub fn new(kind: ListMeetingTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMeetingTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMeetingTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListMeetingTagsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListMeetingTagsErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListMeetingTagsErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeetingTagsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeetingTagsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeetingTagsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMeetingTagsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListMeetingTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMeetingTagsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMeetingTagsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListMeetingTagsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListMeetingTagsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListMeetingTagsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListMeetingTagsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListMeetingTagsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListMeetingTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPhoneNumberOrdersError {
    pub kind: ListPhoneNumberOrdersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPhoneNumberOrdersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPhoneNumberOrdersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPhoneNumberOrdersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListPhoneNumberOrdersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPhoneNumberOrdersError {
    fn code(&self) -> Option<&str> {
        ListPhoneNumberOrdersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPhoneNumberOrdersError {
    pub fn new(kind: ListPhoneNumberOrdersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPhoneNumberOrdersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPhoneNumberOrdersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumberOrdersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListPhoneNumberOrdersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPhoneNumberOrdersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListPhoneNumberOrdersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPhoneNumbersError {
    pub kind: ListPhoneNumbersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPhoneNumbersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPhoneNumbersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPhoneNumbersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListPhoneNumbersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPhoneNumbersError {
    fn code(&self) -> Option<&str> {
        ListPhoneNumbersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPhoneNumbersError {
    pub fn new(kind: ListPhoneNumbersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPhoneNumbersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPhoneNumbersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListPhoneNumbersErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPhoneNumbersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListPhoneNumbersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPhoneNumbersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::NotFoundException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListPhoneNumbersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProxySessionsError {
    pub kind: ListProxySessionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProxySessionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProxySessionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProxySessionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListProxySessionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListProxySessionsError {
    fn code(&self) -> Option<&str> {
        ListProxySessionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProxySessionsError {
    pub fn new(kind: ListProxySessionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProxySessionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProxySessionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListProxySessionsErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProxySessionsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListProxySessionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProxySessionsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListProxySessionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRoomMembershipsError {
    pub kind: ListRoomMembershipsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRoomMembershipsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRoomMembershipsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRoomMembershipsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListRoomMembershipsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListRoomMembershipsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListRoomMembershipsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListRoomMembershipsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListRoomMembershipsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListRoomMembershipsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListRoomMembershipsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRoomMembershipsError {
    fn code(&self) -> Option<&str> {
        ListRoomMembershipsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRoomMembershipsError {
    pub fn new(kind: ListRoomMembershipsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRoomMembershipsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRoomMembershipsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoomMembershipsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoomMembershipsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoomMembershipsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoomMembershipsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoomMembershipsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoomMembershipsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoomMembershipsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListRoomMembershipsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRoomMembershipsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListRoomMembershipsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListRoomMembershipsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListRoomMembershipsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListRoomMembershipsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListRoomMembershipsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListRoomMembershipsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListRoomMembershipsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRoomsError {
    pub kind: ListRoomsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRoomsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRoomsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRoomsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListRoomsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListRoomsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListRoomsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListRoomsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListRoomsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListRoomsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListRoomsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRoomsError {
    fn code(&self) -> Option<&str> {
        ListRoomsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRoomsError {
    pub fn new(kind: ListRoomsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRoomsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRoomsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListRoomsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListRoomsErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListRoomsErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListRoomsErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoomsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListRoomsErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRoomsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListRoomsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRoomsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListRoomsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListRoomsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListRoomsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListRoomsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListRoomsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListRoomsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListRoomsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSipMediaApplicationsError {
    pub kind: ListSipMediaApplicationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSipMediaApplicationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSipMediaApplicationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSipMediaApplicationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListSipMediaApplicationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSipMediaApplicationsError {
    fn code(&self) -> Option<&str> {
        ListSipMediaApplicationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSipMediaApplicationsError {
    pub fn new(kind: ListSipMediaApplicationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSipMediaApplicationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSipMediaApplicationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipMediaApplicationsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListSipMediaApplicationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSipMediaApplicationsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListSipMediaApplicationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSipRulesError {
    pub kind: ListSipRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSipRulesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSipRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSipRulesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListSipRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSipRulesError {
    fn code(&self) -> Option<&str> {
        ListSipRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSipRulesError {
    pub fn new(kind: ListSipRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSipRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSipRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListSipRulesErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipRulesErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipRulesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipRulesErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSipRulesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListSipRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSipRulesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListSipRulesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListSipRulesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListSipRulesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListSipRulesErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListSipRulesErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListSipRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSupportedPhoneNumberCountriesError {
    pub kind: ListSupportedPhoneNumberCountriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSupportedPhoneNumberCountriesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSupportedPhoneNumberCountriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            ListSupportedPhoneNumberCountriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSupportedPhoneNumberCountriesError {
    fn code(&self) -> Option<&str> {
        ListSupportedPhoneNumberCountriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSupportedPhoneNumberCountriesError {
    pub fn new(
        kind: ListSupportedPhoneNumberCountriesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSupportedPhoneNumberCountriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSupportedPhoneNumberCountriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListSupportedPhoneNumberCountriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSupportedPhoneNumberCountriesErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListSupportedPhoneNumberCountriesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListSupportedPhoneNumberCountriesErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            ListSupportedPhoneNumberCountriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUsersError {
    pub kind: ListUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUsersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUsersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUsersError {
    fn code(&self) -> Option<&str> {
        ListUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUsersError {
    pub fn new(kind: ListUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUsersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListUsersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListUsersErrorKind::NotFoundException(_inner) => Some(_inner),
            ListUsersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListUsersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListUsersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListUsersErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVoiceConnectorGroupsError {
    pub kind: ListVoiceConnectorGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVoiceConnectorGroupsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVoiceConnectorGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVoiceConnectorGroupsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListVoiceConnectorGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVoiceConnectorGroupsError {
    fn code(&self) -> Option<&str> {
        ListVoiceConnectorGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVoiceConnectorGroupsError {
    pub fn new(kind: ListVoiceConnectorGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVoiceConnectorGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVoiceConnectorGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListVoiceConnectorGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVoiceConnectorGroupsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListVoiceConnectorGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVoiceConnectorsError {
    pub kind: ListVoiceConnectorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVoiceConnectorsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVoiceConnectorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVoiceConnectorsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListVoiceConnectorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVoiceConnectorsError {
    fn code(&self) -> Option<&str> {
        ListVoiceConnectorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVoiceConnectorsError {
    pub fn new(kind: ListVoiceConnectorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVoiceConnectorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVoiceConnectorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListVoiceConnectorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVoiceConnectorsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListVoiceConnectorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVoiceConnectorTerminationCredentialsError {
    pub kind: ListVoiceConnectorTerminationCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVoiceConnectorTerminationCredentialsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVoiceConnectorTerminationCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVoiceConnectorTerminationCredentialsError {
    fn code(&self) -> Option<&str> {
        ListVoiceConnectorTerminationCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVoiceConnectorTerminationCredentialsError {
    pub fn new(
        kind: ListVoiceConnectorTerminationCredentialsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListVoiceConnectorTerminationCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            ListVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            ListVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            ListVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct LogoutUserError {
    pub kind: LogoutUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum LogoutUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for LogoutUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            LogoutUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            LogoutUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            LogoutUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            LogoutUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            LogoutUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            LogoutUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            LogoutUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            LogoutUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for LogoutUserError {
    fn code(&self) -> Option<&str> {
        LogoutUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl LogoutUserError {
    pub fn new(kind: LogoutUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: LogoutUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: LogoutUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, LogoutUserErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, LogoutUserErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, LogoutUserErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, LogoutUserErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            LogoutUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, LogoutUserErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            LogoutUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for LogoutUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            LogoutUserErrorKind::BadRequestException(_inner) => Some(_inner),
            LogoutUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            LogoutUserErrorKind::NotFoundException(_inner) => Some(_inner),
            LogoutUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            LogoutUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            LogoutUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            LogoutUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            LogoutUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAppInstanceRetentionSettingsError {
    pub kind: PutAppInstanceRetentionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAppInstanceRetentionSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAppInstanceRetentionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAppInstanceRetentionSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutAppInstanceRetentionSettingsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutAppInstanceRetentionSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutAppInstanceRetentionSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceRetentionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAppInstanceRetentionSettingsError {
    fn code(&self) -> Option<&str> {
        PutAppInstanceRetentionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAppInstanceRetentionSettingsError {
    pub fn new(kind: PutAppInstanceRetentionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAppInstanceRetentionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAppInstanceRetentionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutAppInstanceRetentionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAppInstanceRetentionSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            PutAppInstanceRetentionSettingsErrorKind::ConflictException(_inner) => Some(_inner),
            PutAppInstanceRetentionSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutAppInstanceRetentionSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            PutAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceRetentionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAppInstanceStreamingConfigurationsError {
    pub kind: PutAppInstanceStreamingConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAppInstanceStreamingConfigurationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAppInstanceStreamingConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAppInstanceStreamingConfigurationsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAppInstanceStreamingConfigurationsError {
    fn code(&self) -> Option<&str> {
        PutAppInstanceStreamingConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAppInstanceStreamingConfigurationsError {
    pub fn new(
        kind: PutAppInstanceStreamingConfigurationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAppInstanceStreamingConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAppInstanceStreamingConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceStreamingConfigurationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceStreamingConfigurationsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceStreamingConfigurationsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceStreamingConfigurationsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceStreamingConfigurationsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceStreamingConfigurationsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceStreamingConfigurationsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutAppInstanceStreamingConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAppInstanceStreamingConfigurationsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceStreamingConfigurationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEventsConfigurationError {
    pub kind: PutEventsConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEventsConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEventsConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEventsConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutEventsConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutEventsConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutEventsConfigurationErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutEventsConfigurationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutEventsConfigurationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutEventsConfigurationErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            PutEventsConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEventsConfigurationError {
    fn code(&self) -> Option<&str> {
        PutEventsConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEventsConfigurationError {
    pub fn new(kind: PutEventsConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEventsConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEventsConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventsConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventsConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventsConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventsConfigurationErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventsConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventsConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventsConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutEventsConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEventsConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            PutEventsConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutEventsConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            PutEventsConfigurationErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            PutEventsConfigurationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutEventsConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutEventsConfigurationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            PutEventsConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRetentionSettingsError {
    pub kind: PutRetentionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRetentionSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRetentionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRetentionSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutRetentionSettingsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutRetentionSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutRetentionSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutRetentionSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutRetentionSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            PutRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            PutRetentionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRetentionSettingsError {
    fn code(&self) -> Option<&str> {
        PutRetentionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRetentionSettingsError {
    pub fn new(kind: PutRetentionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRetentionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRetentionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionSettingsErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutRetentionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRetentionSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            PutRetentionSettingsErrorKind::ConflictException(_inner) => Some(_inner),
            PutRetentionSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutRetentionSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            PutRetentionSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutRetentionSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            PutRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            PutRetentionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSipMediaApplicationLoggingConfigurationError {
    pub kind: PutSipMediaApplicationLoggingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSipMediaApplicationLoggingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutSipMediaApplicationLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutSipMediaApplicationLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutSipMediaApplicationLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSipMediaApplicationLoggingConfigurationError {
    pub fn new(
        kind: PutSipMediaApplicationLoggingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutSipMediaApplicationLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSipMediaApplicationLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceFailureException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationLoggingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationLoggingConfigurationErrorKind::ThrottledClientException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationLoggingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            PutSipMediaApplicationLoggingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorEmergencyCallingConfigurationError {
    pub kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorEmergencyCallingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutVoiceConnectorEmergencyCallingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            _inner.fmt(f)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutVoiceConnectorEmergencyCallingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorEmergencyCallingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorEmergencyCallingConfigurationError {
    pub fn new(
        kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorEmergencyCallingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::BadRequestException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ForbiddenException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::NotFoundException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceFailureException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ServiceUnavailableException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::ThrottledClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::UnauthorizedClientException(_inner) =>
            Some(_inner)
            ,
            PutVoiceConnectorEmergencyCallingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorLoggingConfigurationError {
    pub kind: PutVoiceConnectorLoggingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorLoggingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutVoiceConnectorLoggingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutVoiceConnectorLoggingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorLoggingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorLoggingConfigurationError {
    pub fn new(
        kind: PutVoiceConnectorLoggingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorLoggingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorLoggingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorLoggingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorOriginationError {
    pub kind: PutVoiceConnectorOriginationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorOriginationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutVoiceConnectorOriginationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorOriginationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutVoiceConnectorOriginationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorOriginationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorOriginationError {
    pub fn new(kind: PutVoiceConnectorOriginationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorOriginationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorOriginationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorOriginationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorOriginationErrorKind::BadRequestException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::NotFoundException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorOriginationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            PutVoiceConnectorOriginationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorOriginationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorProxyError {
    pub kind: PutVoiceConnectorProxyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorProxyErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutVoiceConnectorProxyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorProxyErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            PutVoiceConnectorProxyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutVoiceConnectorProxyError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorProxyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorProxyError {
    pub fn new(kind: PutVoiceConnectorProxyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorProxyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorProxyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorProxyErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorProxyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorProxyErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::BadRequestException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::NotFoundException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::ThrottledClientException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            PutVoiceConnectorProxyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorStreamingConfigurationError {
    pub kind: PutVoiceConnectorStreamingConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorStreamingConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutVoiceConnectorStreamingConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutVoiceConnectorStreamingConfigurationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorStreamingConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorStreamingConfigurationError {
    pub fn new(
        kind: PutVoiceConnectorStreamingConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorStreamingConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorStreamingConfigurationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            PutVoiceConnectorStreamingConfigurationErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorStreamingConfigurationErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            PutVoiceConnectorStreamingConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorTerminationError {
    pub kind: PutVoiceConnectorTerminationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorTerminationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutVoiceConnectorTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorTerminationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutVoiceConnectorTerminationError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorTerminationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorTerminationError {
    pub fn new(kind: PutVoiceConnectorTerminationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorTerminationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorTerminationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorTerminationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::BadRequestException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::NotFoundException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            PutVoiceConnectorTerminationErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutVoiceConnectorTerminationCredentialsError {
    pub kind: PutVoiceConnectorTerminationCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutVoiceConnectorTerminationCredentialsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutVoiceConnectorTerminationCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => _inner.fmt(f),
            PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutVoiceConnectorTerminationCredentialsError {
    fn code(&self) -> Option<&str> {
        PutVoiceConnectorTerminationCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutVoiceConnectorTerminationCredentialsError {
    pub fn new(
        kind: PutVoiceConnectorTerminationCredentialsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutVoiceConnectorTerminationCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutVoiceConnectorTerminationCredentialsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ForbiddenException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::ServiceUnavailableException(
                _inner,
            ) => Some(_inner),
            PutVoiceConnectorTerminationCredentialsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            PutVoiceConnectorTerminationCredentialsErrorKind::UnauthorizedClientException(
                _inner,
            ) => Some(_inner),
            PutVoiceConnectorTerminationCredentialsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RedactChannelMessageError {
    pub kind: RedactChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RedactChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RedactChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RedactChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            RedactChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RedactChannelMessageError {
    fn code(&self) -> Option<&str> {
        RedactChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RedactChannelMessageError {
    pub fn new(kind: RedactChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RedactChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RedactChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for RedactChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RedactChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            RedactChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RedactConversationMessageError {
    pub kind: RedactConversationMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RedactConversationMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RedactConversationMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RedactConversationMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RedactConversationMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RedactConversationMessageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RedactConversationMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            RedactConversationMessageErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            RedactConversationMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            RedactConversationMessageErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            RedactConversationMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RedactConversationMessageError {
    fn code(&self) -> Option<&str> {
        RedactConversationMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RedactConversationMessageError {
    pub fn new(kind: RedactConversationMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RedactConversationMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RedactConversationMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactConversationMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactConversationMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactConversationMessageErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactConversationMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactConversationMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactConversationMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactConversationMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for RedactConversationMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RedactConversationMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            RedactConversationMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            RedactConversationMessageErrorKind::NotFoundException(_inner) => Some(_inner),
            RedactConversationMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            RedactConversationMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RedactConversationMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            RedactConversationMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            RedactConversationMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RedactRoomMessageError {
    pub kind: RedactRoomMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RedactRoomMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RedactRoomMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RedactRoomMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RedactRoomMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RedactRoomMessageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RedactRoomMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            RedactRoomMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RedactRoomMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            RedactRoomMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            RedactRoomMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RedactRoomMessageError {
    fn code(&self) -> Option<&str> {
        RedactRoomMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RedactRoomMessageError {
    pub fn new(kind: RedactRoomMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RedactRoomMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RedactRoomMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactRoomMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactRoomMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, RedactRoomMessageErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactRoomMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactRoomMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactRoomMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RedactRoomMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for RedactRoomMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RedactRoomMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            RedactRoomMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            RedactRoomMessageErrorKind::NotFoundException(_inner) => Some(_inner),
            RedactRoomMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            RedactRoomMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RedactRoomMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            RedactRoomMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            RedactRoomMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegenerateSecurityTokenError {
    pub kind: RegenerateSecurityTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegenerateSecurityTokenErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegenerateSecurityTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegenerateSecurityTokenErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RegenerateSecurityTokenErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RegenerateSecurityTokenErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RegenerateSecurityTokenErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            RegenerateSecurityTokenErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RegenerateSecurityTokenErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            RegenerateSecurityTokenErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            RegenerateSecurityTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegenerateSecurityTokenError {
    fn code(&self) -> Option<&str> {
        RegenerateSecurityTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegenerateSecurityTokenError {
    pub fn new(kind: RegenerateSecurityTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegenerateSecurityTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegenerateSecurityTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegenerateSecurityTokenErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegenerateSecurityTokenErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegenerateSecurityTokenErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegenerateSecurityTokenErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegenerateSecurityTokenErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegenerateSecurityTokenErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegenerateSecurityTokenErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for RegenerateSecurityTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegenerateSecurityTokenErrorKind::BadRequestException(_inner) => Some(_inner),
            RegenerateSecurityTokenErrorKind::ForbiddenException(_inner) => Some(_inner),
            RegenerateSecurityTokenErrorKind::NotFoundException(_inner) => Some(_inner),
            RegenerateSecurityTokenErrorKind::ServiceFailureException(_inner) => Some(_inner),
            RegenerateSecurityTokenErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RegenerateSecurityTokenErrorKind::ThrottledClientException(_inner) => Some(_inner),
            RegenerateSecurityTokenErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            RegenerateSecurityTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetPersonalPINError {
    pub kind: ResetPersonalPINErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetPersonalPINErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetPersonalPINError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetPersonalPINErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ResetPersonalPINErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ResetPersonalPINErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ResetPersonalPINErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ResetPersonalPINErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ResetPersonalPINErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ResetPersonalPINErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ResetPersonalPINErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetPersonalPINError {
    fn code(&self) -> Option<&str> {
        ResetPersonalPINError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetPersonalPINError {
    pub fn new(kind: ResetPersonalPINErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetPersonalPINErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetPersonalPINErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetPersonalPINErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ResetPersonalPINErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ResetPersonalPINErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetPersonalPINErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetPersonalPINErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetPersonalPINErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetPersonalPINErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ResetPersonalPINError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetPersonalPINErrorKind::BadRequestException(_inner) => Some(_inner),
            ResetPersonalPINErrorKind::ForbiddenException(_inner) => Some(_inner),
            ResetPersonalPINErrorKind::NotFoundException(_inner) => Some(_inner),
            ResetPersonalPINErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ResetPersonalPINErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ResetPersonalPINErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ResetPersonalPINErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ResetPersonalPINErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestorePhoneNumberError {
    pub kind: RestorePhoneNumberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestorePhoneNumberErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestorePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestorePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            RestorePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestorePhoneNumberError {
    fn code(&self) -> Option<&str> {
        RestorePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestorePhoneNumberError {
    pub fn new(kind: RestorePhoneNumberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestorePhoneNumberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestorePhoneNumberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestorePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for RestorePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestorePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            RestorePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchAvailablePhoneNumbersError {
    pub kind: SearchAvailablePhoneNumbersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchAvailablePhoneNumbersErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SearchAvailablePhoneNumbersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchAvailablePhoneNumbersErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            SearchAvailablePhoneNumbersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            SearchAvailablePhoneNumbersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SearchAvailablePhoneNumbersError {
    fn code(&self) -> Option<&str> {
        SearchAvailablePhoneNumbersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SearchAvailablePhoneNumbersError {
    pub fn new(kind: SearchAvailablePhoneNumbersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SearchAvailablePhoneNumbersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SearchAvailablePhoneNumbersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for SearchAvailablePhoneNumbersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchAvailablePhoneNumbersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::BadRequestException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::ForbiddenException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            SearchAvailablePhoneNumbersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            SearchAvailablePhoneNumbersErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            SearchAvailablePhoneNumbersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendChannelMessageError {
    pub kind: SendChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ConflictException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            SendChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendChannelMessageError {
    fn code(&self) -> Option<&str> {
        SendChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendChannelMessageError {
    pub fn new(kind: SendChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for SendChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ConflictException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            SendChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartMeetingTranscriptionError {
    pub kind: StartMeetingTranscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartMeetingTranscriptionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartMeetingTranscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartMeetingTranscriptionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartMeetingTranscriptionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            StartMeetingTranscriptionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StartMeetingTranscriptionErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            StartMeetingTranscriptionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            StartMeetingTranscriptionErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            StartMeetingTranscriptionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            StartMeetingTranscriptionErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            StartMeetingTranscriptionErrorKind::UnprocessableEntityException(_inner) => {
                _inner.fmt(f)
            }
            StartMeetingTranscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartMeetingTranscriptionError {
    fn code(&self) -> Option<&str> {
        StartMeetingTranscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartMeetingTranscriptionError {
    pub fn new(kind: StartMeetingTranscriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartMeetingTranscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartMeetingTranscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMeetingTranscriptionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMeetingTranscriptionErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMeetingTranscriptionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMeetingTranscriptionErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMeetingTranscriptionErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMeetingTranscriptionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMeetingTranscriptionErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMeetingTranscriptionErrorKind::UnauthorizedClientException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMeetingTranscriptionErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for StartMeetingTranscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartMeetingTranscriptionErrorKind::BadRequestException(_inner) => Some(_inner),
            StartMeetingTranscriptionErrorKind::ForbiddenException(_inner) => Some(_inner),
            StartMeetingTranscriptionErrorKind::NotFoundException(_inner) => Some(_inner),
            StartMeetingTranscriptionErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            StartMeetingTranscriptionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            StartMeetingTranscriptionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            StartMeetingTranscriptionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            StartMeetingTranscriptionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            StartMeetingTranscriptionErrorKind::UnprocessableEntityException(_inner) => {
                Some(_inner)
            }
            StartMeetingTranscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopMeetingTranscriptionError {
    pub kind: StopMeetingTranscriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopMeetingTranscriptionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    UnprocessableEntityException(crate::error::UnprocessableEntityException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopMeetingTranscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopMeetingTranscriptionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StopMeetingTranscriptionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            StopMeetingTranscriptionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StopMeetingTranscriptionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            StopMeetingTranscriptionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            StopMeetingTranscriptionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            StopMeetingTranscriptionErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            StopMeetingTranscriptionErrorKind::UnprocessableEntityException(_inner) => {
                _inner.fmt(f)
            }
            StopMeetingTranscriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopMeetingTranscriptionError {
    fn code(&self) -> Option<&str> {
        StopMeetingTranscriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopMeetingTranscriptionError {
    pub fn new(kind: StopMeetingTranscriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopMeetingTranscriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopMeetingTranscriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMeetingTranscriptionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMeetingTranscriptionErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMeetingTranscriptionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMeetingTranscriptionErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMeetingTranscriptionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMeetingTranscriptionErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMeetingTranscriptionErrorKind::UnauthorizedClientException(_)
        )
    }
    pub fn is_unprocessable_entity_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopMeetingTranscriptionErrorKind::UnprocessableEntityException(_)
        )
    }
}
impl std::error::Error for StopMeetingTranscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopMeetingTranscriptionErrorKind::BadRequestException(_inner) => Some(_inner),
            StopMeetingTranscriptionErrorKind::ForbiddenException(_inner) => Some(_inner),
            StopMeetingTranscriptionErrorKind::NotFoundException(_inner) => Some(_inner),
            StopMeetingTranscriptionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            StopMeetingTranscriptionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            StopMeetingTranscriptionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            StopMeetingTranscriptionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            StopMeetingTranscriptionErrorKind::UnprocessableEntityException(_inner) => Some(_inner),
            StopMeetingTranscriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagAttendeeError {
    pub kind: TagAttendeeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagAttendeeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagAttendeeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagAttendeeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagAttendeeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            TagAttendeeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagAttendeeErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            TagAttendeeErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagAttendeeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TagAttendeeErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            TagAttendeeErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            TagAttendeeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagAttendeeError {
    fn code(&self) -> Option<&str> {
        TagAttendeeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagAttendeeError {
    pub fn new(kind: TagAttendeeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagAttendeeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagAttendeeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagAttendeeErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, TagAttendeeErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagAttendeeErrorKind::NotFoundException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagAttendeeErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, TagAttendeeErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagAttendeeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagAttendeeErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagAttendeeErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for TagAttendeeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagAttendeeErrorKind::BadRequestException(_inner) => Some(_inner),
            TagAttendeeErrorKind::ForbiddenException(_inner) => Some(_inner),
            TagAttendeeErrorKind::NotFoundException(_inner) => Some(_inner),
            TagAttendeeErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            TagAttendeeErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagAttendeeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TagAttendeeErrorKind::ThrottledClientException(_inner) => Some(_inner),
            TagAttendeeErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            TagAttendeeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagMeetingError {
    pub kind: TagMeetingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagMeetingErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagMeetingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagMeetingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagMeetingErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            TagMeetingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagMeetingErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            TagMeetingErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagMeetingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TagMeetingErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            TagMeetingErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            TagMeetingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagMeetingError {
    fn code(&self) -> Option<&str> {
        TagMeetingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagMeetingError {
    pub fn new(kind: TagMeetingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagMeetingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagMeetingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagMeetingErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, TagMeetingErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagMeetingErrorKind::NotFoundException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagMeetingErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, TagMeetingErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagMeetingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, TagMeetingErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagMeetingErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for TagMeetingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagMeetingErrorKind::BadRequestException(_inner) => Some(_inner),
            TagMeetingErrorKind::ForbiddenException(_inner) => Some(_inner),
            TagMeetingErrorKind::NotFoundException(_inner) => Some(_inner),
            TagMeetingErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            TagMeetingErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagMeetingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TagMeetingErrorKind::ThrottledClientException(_inner) => Some(_inner),
            TagMeetingErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            TagMeetingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::ForbiddenException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            TagResourceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TagResourceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagAttendeeError {
    pub kind: UntagAttendeeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagAttendeeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagAttendeeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagAttendeeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagAttendeeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UntagAttendeeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagAttendeeErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagAttendeeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UntagAttendeeErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UntagAttendeeErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UntagAttendeeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagAttendeeError {
    fn code(&self) -> Option<&str> {
        UntagAttendeeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagAttendeeError {
    pub fn new(kind: UntagAttendeeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagAttendeeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagAttendeeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagAttendeeErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UntagAttendeeErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagAttendeeErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagAttendeeErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagAttendeeErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagAttendeeErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagAttendeeErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UntagAttendeeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagAttendeeErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagAttendeeErrorKind::ForbiddenException(_inner) => Some(_inner),
            UntagAttendeeErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagAttendeeErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagAttendeeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UntagAttendeeErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UntagAttendeeErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UntagAttendeeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagMeetingError {
    pub kind: UntagMeetingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagMeetingErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagMeetingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagMeetingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagMeetingErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UntagMeetingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagMeetingErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagMeetingErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UntagMeetingErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UntagMeetingErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UntagMeetingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagMeetingError {
    fn code(&self) -> Option<&str> {
        UntagMeetingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagMeetingError {
    pub fn new(kind: UntagMeetingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagMeetingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagMeetingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagMeetingErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UntagMeetingErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagMeetingErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagMeetingErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagMeetingErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagMeetingErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagMeetingErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UntagMeetingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagMeetingErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagMeetingErrorKind::ForbiddenException(_inner) => Some(_inner),
            UntagMeetingErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagMeetingErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagMeetingErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UntagMeetingErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UntagMeetingErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UntagMeetingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ForbiddenException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UntagResourceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UntagResourceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountError {
    pub kind: UpdateAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountError {
    fn code(&self) -> Option<&str> {
        UpdateAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccountError {
    pub fn new(kind: UpdateAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateAccountErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateAccountErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateAccountErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateAccountErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateAccountErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateAccountErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateAccountErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateAccountErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateAccountErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountSettingsError {
    pub kind: UpdateAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccountSettingsError {
    pub fn new(kind: UpdateAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAppInstanceError {
    pub kind: UpdateAppInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAppInstanceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAppInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAppInstanceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAppInstanceError {
    fn code(&self) -> Option<&str> {
        UpdateAppInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAppInstanceError {
    pub fn new(kind: UpdateAppInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAppInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAppInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateAppInstanceErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateAppInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAppInstanceErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAppInstanceUserError {
    pub kind: UpdateAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAppInstanceUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        UpdateAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAppInstanceUserError {
    pub fn new(kind: UpdateAppInstanceUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAppInstanceUserErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBotError {
    pub kind: UpdateBotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBotErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBotErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateBotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBotError {
    fn code(&self) -> Option<&str> {
        UpdateBotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBotError {
    pub fn new(kind: UpdateBotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateBotErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBotErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateBotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBotErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateBotErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateBotErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateBotErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateBotErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateBotErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateBotErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateBotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelError {
    pub kind: UpdateChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelError {
    fn code(&self) -> Option<&str> {
        UpdateChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelError {
    pub fn new(kind: UpdateChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateChannelErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateChannelErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelMessageError {
    pub kind: UpdateChannelMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelMessageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelMessageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateChannelMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelMessageError {
    fn code(&self) -> Option<&str> {
        UpdateChannelMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelMessageError {
    pub fn new(kind: UpdateChannelMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelMessageErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateChannelMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelMessageErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateChannelMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChannelReadMarkerError {
    pub kind: UpdateChannelReadMarkerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChannelReadMarkerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChannelReadMarkerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChannelReadMarkerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateChannelReadMarkerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChannelReadMarkerError {
    fn code(&self) -> Option<&str> {
        UpdateChannelReadMarkerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChannelReadMarkerError {
    pub fn new(kind: UpdateChannelReadMarkerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChannelReadMarkerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChannelReadMarkerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChannelReadMarkerErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateChannelReadMarkerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChannelReadMarkerErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateChannelReadMarkerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGlobalSettingsError {
    pub kind: UpdateGlobalSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGlobalSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGlobalSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGlobalSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateGlobalSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGlobalSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateGlobalSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGlobalSettingsError {
    pub fn new(kind: UpdateGlobalSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGlobalSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGlobalSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGlobalSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateGlobalSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGlobalSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateGlobalSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePhoneNumberError {
    pub kind: UpdatePhoneNumberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePhoneNumberErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePhoneNumberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePhoneNumberErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePhoneNumberError {
    fn code(&self) -> Option<&str> {
        UpdatePhoneNumberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePhoneNumberError {
    pub fn new(kind: UpdatePhoneNumberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePhoneNumberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePhoneNumberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdatePhoneNumberErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdatePhoneNumberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePhoneNumberErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdatePhoneNumberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePhoneNumberSettingsError {
    pub kind: UpdatePhoneNumberSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePhoneNumberSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePhoneNumberSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePhoneNumberSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePhoneNumberSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePhoneNumberSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePhoneNumberSettingsError {
    fn code(&self) -> Option<&str> {
        UpdatePhoneNumberSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePhoneNumberSettingsError {
    pub fn new(kind: UpdatePhoneNumberSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePhoneNumberSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePhoneNumberSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdatePhoneNumberSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePhoneNumberSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdatePhoneNumberSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateProxySessionError {
    pub kind: UpdateProxySessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateProxySessionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateProxySessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateProxySessionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateProxySessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateProxySessionError {
    fn code(&self) -> Option<&str> {
        UpdateProxySessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateProxySessionError {
    pub fn new(kind: UpdateProxySessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateProxySessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateProxySessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProxySessionErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateProxySessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateProxySessionErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateProxySessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoomError {
    pub kind: UpdateRoomErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoomErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoomError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoomErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateRoomErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateRoomErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateRoomErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateRoomErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateRoomErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateRoomErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateRoomErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoomError {
    fn code(&self) -> Option<&str> {
        UpdateRoomError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoomError {
    pub fn new(kind: UpdateRoomErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoomErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoomErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateRoomErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateRoomErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateRoomErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateRoomErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoomErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateRoomErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoomErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateRoomError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoomErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateRoomErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateRoomErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateRoomErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateRoomErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateRoomErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateRoomErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateRoomErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRoomMembershipError {
    pub kind: UpdateRoomMembershipErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRoomMembershipErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRoomMembershipError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRoomMembershipErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateRoomMembershipErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateRoomMembershipErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateRoomMembershipErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateRoomMembershipErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateRoomMembershipErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateRoomMembershipErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateRoomMembershipErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRoomMembershipError {
    fn code(&self) -> Option<&str> {
        UpdateRoomMembershipError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRoomMembershipError {
    pub fn new(kind: UpdateRoomMembershipErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRoomMembershipErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRoomMembershipErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoomMembershipErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoomMembershipErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoomMembershipErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoomMembershipErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoomMembershipErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoomMembershipErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRoomMembershipErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateRoomMembershipError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRoomMembershipErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateRoomMembershipErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateRoomMembershipErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateRoomMembershipErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateRoomMembershipErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateRoomMembershipErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateRoomMembershipErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateRoomMembershipErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSipMediaApplicationError {
    pub kind: UpdateSipMediaApplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSipMediaApplicationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSipMediaApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSipMediaApplicationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSipMediaApplicationError {
    fn code(&self) -> Option<&str> {
        UpdateSipMediaApplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSipMediaApplicationError {
    pub fn new(kind: UpdateSipMediaApplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSipMediaApplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSipMediaApplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateSipMediaApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSipMediaApplicationErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateSipMediaApplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSipMediaApplicationCallError {
    pub kind: UpdateSipMediaApplicationCallErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSipMediaApplicationCallErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSipMediaApplicationCallError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSipMediaApplicationCallErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationCallErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSipMediaApplicationCallErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSipMediaApplicationCallError {
    fn code(&self) -> Option<&str> {
        UpdateSipMediaApplicationCallError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSipMediaApplicationCallError {
    pub fn new(kind: UpdateSipMediaApplicationCallErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSipMediaApplicationCallErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSipMediaApplicationCallErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::NotFoundException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateSipMediaApplicationCallError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSipMediaApplicationCallErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSipMediaApplicationCallErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSipMediaApplicationCallErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSipMediaApplicationCallErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            UpdateSipMediaApplicationCallErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateSipMediaApplicationCallErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateSipMediaApplicationCallErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            UpdateSipMediaApplicationCallErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            UpdateSipMediaApplicationCallErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSipRuleError {
    pub kind: UpdateSipRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSipRuleErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSipRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSipRuleErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateSipRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSipRuleError {
    fn code(&self) -> Option<&str> {
        UpdateSipRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSipRuleError {
    pub fn new(kind: UpdateSipRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSipRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSipRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateSipRuleErrorKind::NotFoundException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSipRuleErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateSipRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSipRuleErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateSipRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserError {
    pub kind: UpdateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserError {
    fn code(&self) -> Option<&str> {
        UpdateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserError {
    pub fn new(kind: UpdateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::ForbiddenException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::NotFoundException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::ServiceFailureException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(&self.kind, UpdateUserErrorKind::ThrottledClientException(_))
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateUserErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserSettingsError {
    pub kind: UpdateUserSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateUserSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateUserSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateUserSettingsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateUserSettingsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateUserSettingsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateUserSettingsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateUserSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateUserSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserSettingsError {
    pub fn new(kind: UpdateUserSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateUserSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateUserSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateUserSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateUserSettingsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateUserSettingsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateUserSettingsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateUserSettingsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateUserSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVoiceConnectorError {
    pub kind: UpdateVoiceConnectorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVoiceConnectorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVoiceConnectorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVoiceConnectorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVoiceConnectorError {
    fn code(&self) -> Option<&str> {
        UpdateVoiceConnectorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVoiceConnectorError {
    pub fn new(kind: UpdateVoiceConnectorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVoiceConnectorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVoiceConnectorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateVoiceConnectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVoiceConnectorErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateVoiceConnectorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVoiceConnectorGroupError {
    pub kind: UpdateVoiceConnectorGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVoiceConnectorGroupErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    NotFoundException(crate::error::NotFoundException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVoiceConnectorGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVoiceConnectorGroupErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdateVoiceConnectorGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVoiceConnectorGroupError {
    fn code(&self) -> Option<&str> {
        UpdateVoiceConnectorGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVoiceConnectorGroupError {
    pub fn new(kind: UpdateVoiceConnectorGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVoiceConnectorGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVoiceConnectorGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateVoiceConnectorGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVoiceConnectorGroupErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateVoiceConnectorGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The client is not currently authorized to make the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedClientException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedClientException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedClientException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedClientException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedClientException {}
/// See [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
pub mod unauthorized_client_exception {
    /// A builder for [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
        pub fn build(self) -> crate::error::UnauthorizedClientException {
            crate::error::UnauthorizedClientException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl UnauthorizedClientException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
    pub fn builder() -> crate::error::unauthorized_client_exception::Builder {
        crate::error::unauthorized_client_exception::Builder::default()
    }
}

/// <p>The client exceeded its request rate limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottledClientException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottledClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottledClientException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottledClientException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottledClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottledClientException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottledClientException {}
/// See [`ThrottledClientException`](crate::error::ThrottledClientException)
pub mod throttled_client_exception {
    /// A builder for [`ThrottledClientException`](crate::error::ThrottledClientException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottledClientException`](crate::error::ThrottledClientException)
        pub fn build(self) -> crate::error::ThrottledClientException {
            crate::error::ThrottledClientException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ThrottledClientException {
    /// Creates a new builder-style object to manufacture [`ThrottledClientException`](crate::error::ThrottledClientException)
    pub fn builder() -> crate::error::throttled_client_exception::Builder {
        crate::error::throttled_client_exception::Builder::default()
    }
}

/// <p>The service is currently unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>The service encountered an unexpected error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceFailureException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceFailureException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceFailureException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceFailureException {}
/// See [`ServiceFailureException`](crate::error::ServiceFailureException)
pub mod service_failure_exception {
    /// A builder for [`ServiceFailureException`](crate::error::ServiceFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceFailureException`](crate::error::ServiceFailureException)
        pub fn build(self) -> crate::error::ServiceFailureException {
            crate::error::ServiceFailureException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ServiceFailureException {
    /// Creates a new builder-style object to manufacture [`ServiceFailureException`](crate::error::ServiceFailureException)
    pub fn builder() -> crate::error::service_failure_exception::Builder {
        crate::error::service_failure_exception::Builder::default()
    }
}

/// <p>One or more of the resources in the request does not exist in the system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>The client is permanently forbidden from making the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException)
pub mod forbidden_exception {
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException)
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException)
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

/// <p>The request could not be processed because of conflict in the current state of the
/// resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The input parameters don't match the service's restrictions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>The request exceeds the resource limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceLimitExceededException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceLimitExceededException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceLimitExceededException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceLimitExceededException {}
/// See [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
pub mod resource_limit_exceeded_exception {
    /// A builder for [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
        pub fn build(self) -> crate::error::ResourceLimitExceededException {
            crate::error::ResourceLimitExceededException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ResourceLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    pub fn builder() -> crate::error::resource_limit_exceeded_exception::Builder {
        crate::error::resource_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request was well-formed but was unable to be followed due to semantic errors.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnprocessableEntityException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnprocessableEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnprocessableEntityException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnprocessableEntityException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnprocessableEntityException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnprocessableEntityException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnprocessableEntityException {}
/// See [`UnprocessableEntityException`](crate::error::UnprocessableEntityException)
pub mod unprocessable_entity_exception {
    /// A builder for [`UnprocessableEntityException`](crate::error::UnprocessableEntityException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessableEntityException`](crate::error::UnprocessableEntityException)
        pub fn build(self) -> crate::error::UnprocessableEntityException {
            crate::error::UnprocessableEntityException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl UnprocessableEntityException {
    /// Creates a new builder-style object to manufacture [`UnprocessableEntityException`](crate::error::UnprocessableEntityException)
    pub fn builder() -> crate::error::unprocessable_entity_exception::Builder {
        crate::error::unprocessable_entity_exception::Builder::default()
    }
}

/// <p>You don't have permissions to perform the requested operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}
