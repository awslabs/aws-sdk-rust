// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Parameter information for key material export using the asymmetric ECDH key exchange method.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct ExportDiffieHellmanTr31KeyBlock {
    /// <p>The <code>keyARN</code> of the asymmetric ECC key.</p>
    pub private_key_identifier: ::std::string::String,
    /// <p>The <code>keyARN</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub certificate_authority_public_key_identifier: ::std::string::String,
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub public_key_certificate: ::std::string::String,
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub derive_key_algorithm: crate::types::SymmetricKeyAlgorithm,
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub key_derivation_function: crate::types::KeyDerivationFunction,
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub key_derivation_hash_algorithm: crate::types::KeyDerivationHashAlgorithm,
    /// <p>Derivation data used to derive an ECDH key.</p>
    pub derivation_data: ::std::option::Option<crate::types::DiffieHellmanDerivationData>,
    /// <p>Optional metadata for export associated with the key material. This data is signed but transmitted in clear text.</p>
    pub key_block_headers: ::std::option::Option<crate::types::KeyBlockHeaders>,
}
impl ExportDiffieHellmanTr31KeyBlock {
    /// <p>The <code>keyARN</code> of the asymmetric ECC key.</p>
    pub fn private_key_identifier(&self) -> &str {
        use std::ops::Deref;
        self.private_key_identifier.deref()
    }
    /// <p>The <code>keyARN</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub fn certificate_authority_public_key_identifier(&self) -> &str {
        use std::ops::Deref;
        self.certificate_authority_public_key_identifier.deref()
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub fn public_key_certificate(&self) -> &str {
        use std::ops::Deref;
        self.public_key_certificate.deref()
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub fn derive_key_algorithm(&self) -> &crate::types::SymmetricKeyAlgorithm {
        &self.derive_key_algorithm
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub fn key_derivation_function(&self) -> &crate::types::KeyDerivationFunction {
        &self.key_derivation_function
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub fn key_derivation_hash_algorithm(&self) -> &crate::types::KeyDerivationHashAlgorithm {
        &self.key_derivation_hash_algorithm
    }
    /// <p>Derivation data used to derive an ECDH key.</p>
    pub fn derivation_data(&self) -> ::std::option::Option<&crate::types::DiffieHellmanDerivationData> {
        self.derivation_data.as_ref()
    }
    /// <p>Optional metadata for export associated with the key material. This data is signed but transmitted in clear text.</p>
    pub fn key_block_headers(&self) -> ::std::option::Option<&crate::types::KeyBlockHeaders> {
        self.key_block_headers.as_ref()
    }
}
impl ::std::fmt::Debug for ExportDiffieHellmanTr31KeyBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ExportDiffieHellmanTr31KeyBlock");
        formatter.field("private_key_identifier", &self.private_key_identifier);
        formatter.field(
            "certificate_authority_public_key_identifier",
            &self.certificate_authority_public_key_identifier,
        );
        formatter.field("public_key_certificate", &"*** Sensitive Data Redacted ***");
        formatter.field("derive_key_algorithm", &self.derive_key_algorithm);
        formatter.field("key_derivation_function", &self.key_derivation_function);
        formatter.field("key_derivation_hash_algorithm", &self.key_derivation_hash_algorithm);
        formatter.field("derivation_data", &self.derivation_data);
        formatter.field("key_block_headers", &self.key_block_headers);
        formatter.finish()
    }
}
impl ExportDiffieHellmanTr31KeyBlock {
    /// Creates a new builder-style object to manufacture [`ExportDiffieHellmanTr31KeyBlock`](crate::types::ExportDiffieHellmanTr31KeyBlock).
    pub fn builder() -> crate::types::builders::ExportDiffieHellmanTr31KeyBlockBuilder {
        crate::types::builders::ExportDiffieHellmanTr31KeyBlockBuilder::default()
    }
}

/// A builder for [`ExportDiffieHellmanTr31KeyBlock`](crate::types::ExportDiffieHellmanTr31KeyBlock).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct ExportDiffieHellmanTr31KeyBlockBuilder {
    pub(crate) private_key_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) certificate_authority_public_key_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) public_key_certificate: ::std::option::Option<::std::string::String>,
    pub(crate) derive_key_algorithm: ::std::option::Option<crate::types::SymmetricKeyAlgorithm>,
    pub(crate) key_derivation_function: ::std::option::Option<crate::types::KeyDerivationFunction>,
    pub(crate) key_derivation_hash_algorithm: ::std::option::Option<crate::types::KeyDerivationHashAlgorithm>,
    pub(crate) derivation_data: ::std::option::Option<crate::types::DiffieHellmanDerivationData>,
    pub(crate) key_block_headers: ::std::option::Option<crate::types::KeyBlockHeaders>,
}
impl ExportDiffieHellmanTr31KeyBlockBuilder {
    /// <p>The <code>keyARN</code> of the asymmetric ECC key.</p>
    /// This field is required.
    pub fn private_key_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.private_key_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>keyARN</code> of the asymmetric ECC key.</p>
    pub fn set_private_key_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.private_key_identifier = input;
        self
    }
    /// <p>The <code>keyARN</code> of the asymmetric ECC key.</p>
    pub fn get_private_key_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.private_key_identifier
    }
    /// <p>The <code>keyARN</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    /// This field is required.
    pub fn certificate_authority_public_key_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.certificate_authority_public_key_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>keyARN</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub fn set_certificate_authority_public_key_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.certificate_authority_public_key_identifier = input;
        self
    }
    /// <p>The <code>keyARN</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub fn get_certificate_authority_public_key_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.certificate_authority_public_key_identifier
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    /// This field is required.
    pub fn public_key_certificate(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.public_key_certificate = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub fn set_public_key_certificate(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.public_key_certificate = input;
        self
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub fn get_public_key_certificate(&self) -> &::std::option::Option<::std::string::String> {
        &self.public_key_certificate
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    /// This field is required.
    pub fn derive_key_algorithm(mut self, input: crate::types::SymmetricKeyAlgorithm) -> Self {
        self.derive_key_algorithm = ::std::option::Option::Some(input);
        self
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub fn set_derive_key_algorithm(mut self, input: ::std::option::Option<crate::types::SymmetricKeyAlgorithm>) -> Self {
        self.derive_key_algorithm = input;
        self
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub fn get_derive_key_algorithm(&self) -> &::std::option::Option<crate::types::SymmetricKeyAlgorithm> {
        &self.derive_key_algorithm
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    /// This field is required.
    pub fn key_derivation_function(mut self, input: crate::types::KeyDerivationFunction) -> Self {
        self.key_derivation_function = ::std::option::Option::Some(input);
        self
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub fn set_key_derivation_function(mut self, input: ::std::option::Option<crate::types::KeyDerivationFunction>) -> Self {
        self.key_derivation_function = input;
        self
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub fn get_key_derivation_function(&self) -> &::std::option::Option<crate::types::KeyDerivationFunction> {
        &self.key_derivation_function
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    /// This field is required.
    pub fn key_derivation_hash_algorithm(mut self, input: crate::types::KeyDerivationHashAlgorithm) -> Self {
        self.key_derivation_hash_algorithm = ::std::option::Option::Some(input);
        self
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub fn set_key_derivation_hash_algorithm(mut self, input: ::std::option::Option<crate::types::KeyDerivationHashAlgorithm>) -> Self {
        self.key_derivation_hash_algorithm = input;
        self
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub fn get_key_derivation_hash_algorithm(&self) -> &::std::option::Option<crate::types::KeyDerivationHashAlgorithm> {
        &self.key_derivation_hash_algorithm
    }
    /// <p>Derivation data used to derive an ECDH key.</p>
    /// This field is required.
    pub fn derivation_data(mut self, input: crate::types::DiffieHellmanDerivationData) -> Self {
        self.derivation_data = ::std::option::Option::Some(input);
        self
    }
    /// <p>Derivation data used to derive an ECDH key.</p>
    pub fn set_derivation_data(mut self, input: ::std::option::Option<crate::types::DiffieHellmanDerivationData>) -> Self {
        self.derivation_data = input;
        self
    }
    /// <p>Derivation data used to derive an ECDH key.</p>
    pub fn get_derivation_data(&self) -> &::std::option::Option<crate::types::DiffieHellmanDerivationData> {
        &self.derivation_data
    }
    /// <p>Optional metadata for export associated with the key material. This data is signed but transmitted in clear text.</p>
    pub fn key_block_headers(mut self, input: crate::types::KeyBlockHeaders) -> Self {
        self.key_block_headers = ::std::option::Option::Some(input);
        self
    }
    /// <p>Optional metadata for export associated with the key material. This data is signed but transmitted in clear text.</p>
    pub fn set_key_block_headers(mut self, input: ::std::option::Option<crate::types::KeyBlockHeaders>) -> Self {
        self.key_block_headers = input;
        self
    }
    /// <p>Optional metadata for export associated with the key material. This data is signed but transmitted in clear text.</p>
    pub fn get_key_block_headers(&self) -> &::std::option::Option<crate::types::KeyBlockHeaders> {
        &self.key_block_headers
    }
    /// Consumes the builder and constructs a [`ExportDiffieHellmanTr31KeyBlock`](crate::types::ExportDiffieHellmanTr31KeyBlock).
    /// This method will fail if any of the following fields are not set:
    /// - [`private_key_identifier`](crate::types::builders::ExportDiffieHellmanTr31KeyBlockBuilder::private_key_identifier)
    /// - [`certificate_authority_public_key_identifier`](crate::types::builders::ExportDiffieHellmanTr31KeyBlockBuilder::certificate_authority_public_key_identifier)
    /// - [`public_key_certificate`](crate::types::builders::ExportDiffieHellmanTr31KeyBlockBuilder::public_key_certificate)
    /// - [`derive_key_algorithm`](crate::types::builders::ExportDiffieHellmanTr31KeyBlockBuilder::derive_key_algorithm)
    /// - [`key_derivation_function`](crate::types::builders::ExportDiffieHellmanTr31KeyBlockBuilder::key_derivation_function)
    /// - [`key_derivation_hash_algorithm`](crate::types::builders::ExportDiffieHellmanTr31KeyBlockBuilder::key_derivation_hash_algorithm)
    pub fn build(self) -> ::std::result::Result<crate::types::ExportDiffieHellmanTr31KeyBlock, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::ExportDiffieHellmanTr31KeyBlock {
            private_key_identifier: self.private_key_identifier.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "private_key_identifier",
                    "private_key_identifier was not specified but it is required when building ExportDiffieHellmanTr31KeyBlock",
                )
            })?,
            certificate_authority_public_key_identifier: self.certificate_authority_public_key_identifier.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "certificate_authority_public_key_identifier",
                    "certificate_authority_public_key_identifier was not specified but it is required when building ExportDiffieHellmanTr31KeyBlock",
                )
            })?,
            public_key_certificate: self.public_key_certificate.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "public_key_certificate",
                    "public_key_certificate was not specified but it is required when building ExportDiffieHellmanTr31KeyBlock",
                )
            })?,
            derive_key_algorithm: self.derive_key_algorithm.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "derive_key_algorithm",
                    "derive_key_algorithm was not specified but it is required when building ExportDiffieHellmanTr31KeyBlock",
                )
            })?,
            key_derivation_function: self.key_derivation_function.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "key_derivation_function",
                    "key_derivation_function was not specified but it is required when building ExportDiffieHellmanTr31KeyBlock",
                )
            })?,
            key_derivation_hash_algorithm: self.key_derivation_hash_algorithm.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "key_derivation_hash_algorithm",
                    "key_derivation_hash_algorithm was not specified but it is required when building ExportDiffieHellmanTr31KeyBlock",
                )
            })?,
            derivation_data: self.derivation_data,
            key_block_headers: self.key_block_headers,
        })
    }
}
impl ::std::fmt::Debug for ExportDiffieHellmanTr31KeyBlockBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ExportDiffieHellmanTr31KeyBlockBuilder");
        formatter.field("private_key_identifier", &self.private_key_identifier);
        formatter.field(
            "certificate_authority_public_key_identifier",
            &self.certificate_authority_public_key_identifier,
        );
        formatter.field("public_key_certificate", &"*** Sensitive Data Redacted ***");
        formatter.field("derive_key_algorithm", &self.derive_key_algorithm);
        formatter.field("key_derivation_function", &self.key_derivation_function);
        formatter.field("key_derivation_hash_algorithm", &self.key_derivation_hash_algorithm);
        formatter.field("derivation_data", &self.derivation_data);
        formatter.field("key_block_headers", &self.key_block_headers);
        formatter.finish()
    }
}
