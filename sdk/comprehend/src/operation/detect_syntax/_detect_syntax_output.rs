// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectSyntaxOutput  {
    /// <p>A collection of syntax tokens describing the text. For each token, the response provides the text, the token type, where the text begins and ends, and the level of confidence that Amazon Comprehend has that the token is correct. For a list of token types, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide. </p>
    #[doc(hidden)]
    pub syntax_tokens: std::option::Option<std::vec::Vec<crate::types::SyntaxToken>>,
    _request_id: Option<String>,
}
impl DetectSyntaxOutput {
    /// <p>A collection of syntax tokens describing the text. For each token, the response provides the text, the token type, where the text begins and ends, and the level of confidence that Amazon Comprehend has that the token is correct. For a list of token types, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide. </p>
    pub fn syntax_tokens(&self) -> std::option::Option<& [crate::types::SyntaxToken]> {
        self.syntax_tokens.as_deref()
    }
}
impl  std::fmt::Debug for DetectSyntaxOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectSyntaxOutput");
        formatter.field("syntax_tokens", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
impl aws_http::request_id::RequestId for DetectSyntaxOutput {
                                fn request_id(&self) -> Option<&str> {
                                    self._request_id.as_deref()
                                }
                            }
impl DetectSyntaxOutput {
    /// Creates a new builder-style object to manufacture [`DetectSyntaxOutput`](crate::operation::detect_syntax::DetectSyntaxOutput).
    pub fn builder() -> crate::operation::detect_syntax::builders::DetectSyntaxOutputBuilder {
        crate::operation::detect_syntax::builders::DetectSyntaxOutputBuilder::default()
    }
}

/// A builder for [`DetectSyntaxOutput`](crate::operation::detect_syntax::DetectSyntaxOutput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct DetectSyntaxOutputBuilder {
    pub(crate) syntax_tokens: std::option::Option<std::vec::Vec<crate::types::SyntaxToken>>,
    _request_id: Option<String>,
}
impl DetectSyntaxOutputBuilder {
    /// Appends an item to `syntax_tokens`.
    ///
    /// To override the contents of this collection use [`set_syntax_tokens`](Self::set_syntax_tokens).
    ///
    /// <p>A collection of syntax tokens describing the text. For each token, the response provides the text, the token type, where the text begins and ends, and the level of confidence that Amazon Comprehend has that the token is correct. For a list of token types, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide. </p>
    pub fn syntax_tokens(mut self, input: crate::types::SyntaxToken) -> Self {
        let mut v = self.syntax_tokens.unwrap_or_default();
                        v.push(input);
                        self.syntax_tokens = Some(v);
                        self
    }
    /// <p>A collection of syntax tokens describing the text. For each token, the response provides the text, the token type, where the text begins and ends, and the level of confidence that Amazon Comprehend has that the token is correct. For a list of token types, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide. </p>
    pub fn set_syntax_tokens(mut self, input: std::option::Option<std::vec::Vec<crate::types::SyntaxToken>>) -> Self {
        self.syntax_tokens = input; self
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
                                    self._request_id = Some(request_id.into());
                                    self
                                }
    
                                pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
                                    self._request_id = request_id;
                                    self
                                }
    /// Consumes the builder and constructs a [`DetectSyntaxOutput`](crate::operation::detect_syntax::DetectSyntaxOutput).
    pub fn build(self) -> crate::operation::detect_syntax::DetectSyntaxOutput {
        crate::operation::detect_syntax::DetectSyntaxOutput {
            syntax_tokens: self.syntax_tokens
            ,
            _request_id: self._request_id,
        }
    }
}
impl std::fmt::Debug for DetectSyntaxOutputBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectSyntaxOutputBuilder");
        formatter.field("syntax_tokens", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}

