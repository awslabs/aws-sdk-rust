// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectEntitiesOutput {
    /// <p>A collection of entities identified in the input text. For each entity, the response provides the entity text, entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection. </p>
    /// <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the entities that the model is trained to recognize. Otherwise, it detects the default entity types. For a list of default entity types, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-entities.html">Entities</a> in the Comprehend Developer Guide. </p>
    #[doc(hidden)]
    pub entities: std::option::Option<std::vec::Vec<crate::types::Entity>>,
    /// <p>Information about the document, discovered during text extraction. This field is present in the response only if your request used the <code>Byte</code> parameter. </p>
    #[doc(hidden)]
    pub document_metadata: std::option::Option<crate::types::DocumentMetadata>,
    /// <p>The document type for each page in the input document. This field is present in the response only if your request used the <code>Byte</code> parameter. </p>
    #[doc(hidden)]
    pub document_type: std::option::Option<std::vec::Vec<crate::types::DocumentTypeListItem>>,
    /// <p>Information about each block of text in the input document. Blocks are nested. A page block contains a block for each line of text, which contains a block for each word. </p>
    /// <p>The <code>Block</code> content for a Word input document does not include a <code>Geometry</code> field.</p>
    /// <p>The <code>Block</code> field is not present in the response for plain-text inputs.</p>
    #[doc(hidden)]
    pub blocks: std::option::Option<std::vec::Vec<crate::types::Block>>,
    /// <p>Page-level errors that the system detected while processing the input document. The field is empty if the system encountered no errors.</p>
    #[doc(hidden)]
    pub errors: std::option::Option<std::vec::Vec<crate::types::ErrorsListItem>>,
    _request_id: Option<String>,
}
impl DetectEntitiesOutput {
    /// <p>A collection of entities identified in the input text. For each entity, the response provides the entity text, entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection. </p>
    /// <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the entities that the model is trained to recognize. Otherwise, it detects the default entity types. For a list of default entity types, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-entities.html">Entities</a> in the Comprehend Developer Guide. </p>
    pub fn entities(&self) -> std::option::Option<&[crate::types::Entity]> {
        self.entities.as_deref()
    }
    /// <p>Information about the document, discovered during text extraction. This field is present in the response only if your request used the <code>Byte</code> parameter. </p>
    pub fn document_metadata(&self) -> std::option::Option<&crate::types::DocumentMetadata> {
        self.document_metadata.as_ref()
    }
    /// <p>The document type for each page in the input document. This field is present in the response only if your request used the <code>Byte</code> parameter. </p>
    pub fn document_type(&self) -> std::option::Option<&[crate::types::DocumentTypeListItem]> {
        self.document_type.as_deref()
    }
    /// <p>Information about each block of text in the input document. Blocks are nested. A page block contains a block for each line of text, which contains a block for each word. </p>
    /// <p>The <code>Block</code> content for a Word input document does not include a <code>Geometry</code> field.</p>
    /// <p>The <code>Block</code> field is not present in the response for plain-text inputs.</p>
    pub fn blocks(&self) -> std::option::Option<&[crate::types::Block]> {
        self.blocks.as_deref()
    }
    /// <p>Page-level errors that the system detected while processing the input document. The field is empty if the system encountered no errors.</p>
    pub fn errors(&self) -> std::option::Option<&[crate::types::ErrorsListItem]> {
        self.errors.as_deref()
    }
}
impl std::fmt::Debug for DetectEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectEntitiesOutput");
        formatter.field("entities", &"*** Sensitive Data Redacted ***");
        formatter.field("document_metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("document_type", &"*** Sensitive Data Redacted ***");
        formatter.field("blocks", &"*** Sensitive Data Redacted ***");
        formatter.field("errors", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
impl aws_http::request_id::RequestId for DetectEntitiesOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DetectEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`DetectEntitiesOutput`](crate::operation::detect_entities::DetectEntitiesOutput).
    pub fn builder() -> crate::operation::detect_entities::builders::DetectEntitiesOutputBuilder {
        crate::operation::detect_entities::builders::DetectEntitiesOutputBuilder::default()
    }
}

/// A builder for [`DetectEntitiesOutput`](crate::operation::detect_entities::DetectEntitiesOutput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct DetectEntitiesOutputBuilder {
    pub(crate) entities: std::option::Option<std::vec::Vec<crate::types::Entity>>,
    pub(crate) document_metadata: std::option::Option<crate::types::DocumentMetadata>,
    pub(crate) document_type:
        std::option::Option<std::vec::Vec<crate::types::DocumentTypeListItem>>,
    pub(crate) blocks: std::option::Option<std::vec::Vec<crate::types::Block>>,
    pub(crate) errors: std::option::Option<std::vec::Vec<crate::types::ErrorsListItem>>,
    _request_id: Option<String>,
}
impl DetectEntitiesOutputBuilder {
    /// Appends an item to `entities`.
    ///
    /// To override the contents of this collection use [`set_entities`](Self::set_entities).
    ///
    /// <p>A collection of entities identified in the input text. For each entity, the response provides the entity text, entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection. </p>
    /// <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the entities that the model is trained to recognize. Otherwise, it detects the default entity types. For a list of default entity types, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-entities.html">Entities</a> in the Comprehend Developer Guide. </p>
    pub fn entities(mut self, input: crate::types::Entity) -> Self {
        let mut v = self.entities.unwrap_or_default();
        v.push(input);
        self.entities = Some(v);
        self
    }
    /// <p>A collection of entities identified in the input text. For each entity, the response provides the entity text, entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection. </p>
    /// <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the entities that the model is trained to recognize. Otherwise, it detects the default entity types. For a list of default entity types, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-entities.html">Entities</a> in the Comprehend Developer Guide. </p>
    pub fn set_entities(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Entity>>,
    ) -> Self {
        self.entities = input;
        self
    }
    /// <p>Information about the document, discovered during text extraction. This field is present in the response only if your request used the <code>Byte</code> parameter. </p>
    pub fn document_metadata(mut self, input: crate::types::DocumentMetadata) -> Self {
        self.document_metadata = Some(input);
        self
    }
    /// <p>Information about the document, discovered during text extraction. This field is present in the response only if your request used the <code>Byte</code> parameter. </p>
    pub fn set_document_metadata(
        mut self,
        input: std::option::Option<crate::types::DocumentMetadata>,
    ) -> Self {
        self.document_metadata = input;
        self
    }
    /// Appends an item to `document_type`.
    ///
    /// To override the contents of this collection use [`set_document_type`](Self::set_document_type).
    ///
    /// <p>The document type for each page in the input document. This field is present in the response only if your request used the <code>Byte</code> parameter. </p>
    pub fn document_type(mut self, input: crate::types::DocumentTypeListItem) -> Self {
        let mut v = self.document_type.unwrap_or_default();
        v.push(input);
        self.document_type = Some(v);
        self
    }
    /// <p>The document type for each page in the input document. This field is present in the response only if your request used the <code>Byte</code> parameter. </p>
    pub fn set_document_type(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::DocumentTypeListItem>>,
    ) -> Self {
        self.document_type = input;
        self
    }
    /// Appends an item to `blocks`.
    ///
    /// To override the contents of this collection use [`set_blocks`](Self::set_blocks).
    ///
    /// <p>Information about each block of text in the input document. Blocks are nested. A page block contains a block for each line of text, which contains a block for each word. </p>
    /// <p>The <code>Block</code> content for a Word input document does not include a <code>Geometry</code> field.</p>
    /// <p>The <code>Block</code> field is not present in the response for plain-text inputs.</p>
    pub fn blocks(mut self, input: crate::types::Block) -> Self {
        let mut v = self.blocks.unwrap_or_default();
        v.push(input);
        self.blocks = Some(v);
        self
    }
    /// <p>Information about each block of text in the input document. Blocks are nested. A page block contains a block for each line of text, which contains a block for each word. </p>
    /// <p>The <code>Block</code> content for a Word input document does not include a <code>Geometry</code> field.</p>
    /// <p>The <code>Block</code> field is not present in the response for plain-text inputs.</p>
    pub fn set_blocks(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Block>>,
    ) -> Self {
        self.blocks = input;
        self
    }
    /// Appends an item to `errors`.
    ///
    /// To override the contents of this collection use [`set_errors`](Self::set_errors).
    ///
    /// <p>Page-level errors that the system detected while processing the input document. The field is empty if the system encountered no errors.</p>
    pub fn errors(mut self, input: crate::types::ErrorsListItem) -> Self {
        let mut v = self.errors.unwrap_or_default();
        v.push(input);
        self.errors = Some(v);
        self
    }
    /// <p>Page-level errors that the system detected while processing the input document. The field is empty if the system encountered no errors.</p>
    pub fn set_errors(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::ErrorsListItem>>,
    ) -> Self {
        self.errors = input;
        self
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`DetectEntitiesOutput`](crate::operation::detect_entities::DetectEntitiesOutput).
    pub fn build(self) -> crate::operation::detect_entities::DetectEntitiesOutput {
        crate::operation::detect_entities::DetectEntitiesOutput {
            entities: self.entities,
            document_metadata: self.document_metadata,
            document_type: self.document_type,
            blocks: self.blocks,
            errors: self.errors,
            _request_id: self._request_id,
        }
    }
}
impl std::fmt::Debug for DetectEntitiesOutputBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectEntitiesOutputBuilder");
        formatter.field("entities", &"*** Sensitive Data Redacted ***");
        formatter.field("document_metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("document_type", &"*** Sensitive Data Redacted ***");
        formatter.field("blocks", &"*** Sensitive Data Redacted ***");
        formatter.field("errors", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
