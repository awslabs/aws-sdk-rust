// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Determines the dominant language of the input text for a batch of documents. For a list
/// of languages that Amazon Comprehend can detect, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-languages.html">Amazon Comprehend Supported Languages</a>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDetectDominantLanguage {
    _private: (),
}
impl BatchDetectDominantLanguage {
    /// Creates a new builder-style object to manufacture [`BatchDetectDominantLanguageInput`](crate::input::BatchDetectDominantLanguageInput)
    pub fn builder() -> crate::input::batch_detect_dominant_language_input::Builder {
        crate::input::batch_detect_dominant_language_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDetectDominantLanguage {
    type Output = std::result::Result<
        crate::output::BatchDetectDominantLanguageOutput,
        crate::error::BatchDetectDominantLanguageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_detect_dominant_language_error(response)
        } else {
            crate::operation_deser::parse_batch_detect_dominant_language_response(response)
        }
    }
}

/// <p>Inspects the text of a batch of documents for named entities and returns information
/// about them. For more information about named entities, see <a>how-entities</a>
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDetectEntities {
    _private: (),
}
impl BatchDetectEntities {
    /// Creates a new builder-style object to manufacture [`BatchDetectEntitiesInput`](crate::input::BatchDetectEntitiesInput)
    pub fn builder() -> crate::input::batch_detect_entities_input::Builder {
        crate::input::batch_detect_entities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDetectEntities {
    type Output = std::result::Result<
        crate::output::BatchDetectEntitiesOutput,
        crate::error::BatchDetectEntitiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_detect_entities_error(response)
        } else {
            crate::operation_deser::parse_batch_detect_entities_response(response)
        }
    }
}

/// <p>Detects the key noun phrases found in a batch of documents.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDetectKeyPhrases {
    _private: (),
}
impl BatchDetectKeyPhrases {
    /// Creates a new builder-style object to manufacture [`BatchDetectKeyPhrasesInput`](crate::input::BatchDetectKeyPhrasesInput)
    pub fn builder() -> crate::input::batch_detect_key_phrases_input::Builder {
        crate::input::batch_detect_key_phrases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDetectKeyPhrases {
    type Output = std::result::Result<
        crate::output::BatchDetectKeyPhrasesOutput,
        crate::error::BatchDetectKeyPhrasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_detect_key_phrases_error(response)
        } else {
            crate::operation_deser::parse_batch_detect_key_phrases_response(response)
        }
    }
}

/// <p>Inspects a batch of documents and returns an inference of the prevailing sentiment,
/// <code>POSITIVE</code>, <code>NEUTRAL</code>, <code>MIXED</code>, or <code>NEGATIVE</code>,
/// in each one.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDetectSentiment {
    _private: (),
}
impl BatchDetectSentiment {
    /// Creates a new builder-style object to manufacture [`BatchDetectSentimentInput`](crate::input::BatchDetectSentimentInput)
    pub fn builder() -> crate::input::batch_detect_sentiment_input::Builder {
        crate::input::batch_detect_sentiment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDetectSentiment {
    type Output = std::result::Result<
        crate::output::BatchDetectSentimentOutput,
        crate::error::BatchDetectSentimentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_detect_sentiment_error(response)
        } else {
            crate::operation_deser::parse_batch_detect_sentiment_response(response)
        }
    }
}

/// <p>Inspects the text of a batch of documents for the syntax and part of speech of the words
/// in the document and returns information about them. For more information, see <a>how-syntax</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDetectSyntax {
    _private: (),
}
impl BatchDetectSyntax {
    /// Creates a new builder-style object to manufacture [`BatchDetectSyntaxInput`](crate::input::BatchDetectSyntaxInput)
    pub fn builder() -> crate::input::batch_detect_syntax_input::Builder {
        crate::input::batch_detect_syntax_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDetectSyntax {
    type Output = std::result::Result<
        crate::output::BatchDetectSyntaxOutput,
        crate::error::BatchDetectSyntaxError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_detect_syntax_error(response)
        } else {
            crate::operation_deser::parse_batch_detect_syntax_response(response)
        }
    }
}

/// <p>Creates a new document classification request to analyze a single document in real-time,
/// using a previously created and trained custom model and an endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ClassifyDocument {
    _private: (),
}
impl ClassifyDocument {
    /// Creates a new builder-style object to manufacture [`ClassifyDocumentInput`](crate::input::ClassifyDocumentInput)
    pub fn builder() -> crate::input::classify_document_input::Builder {
        crate::input::classify_document_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ClassifyDocument {
    type Output = std::result::Result<
        crate::output::ClassifyDocumentOutput,
        crate::error::ClassifyDocumentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_classify_document_error(response)
        } else {
            crate::operation_deser::parse_classify_document_response(response)
        }
    }
}

/// <p>Analyzes input text for the presence of personally identifiable information (PII) and
/// returns the labels of identified PII entity types such as name, address, bank account number,
/// or phone number.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ContainsPiiEntities {
    _private: (),
}
impl ContainsPiiEntities {
    /// Creates a new builder-style object to manufacture [`ContainsPiiEntitiesInput`](crate::input::ContainsPiiEntitiesInput)
    pub fn builder() -> crate::input::contains_pii_entities_input::Builder {
        crate::input::contains_pii_entities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ContainsPiiEntities {
    type Output = std::result::Result<
        crate::output::ContainsPiiEntitiesOutput,
        crate::error::ContainsPiiEntitiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_contains_pii_entities_error(response)
        } else {
            crate::operation_deser::parse_contains_pii_entities_response(response)
        }
    }
}

/// <p>Creates a new document classifier that you can use to categorize documents. To create a
/// classifier, you provide a set of training documents that labeled with the categories that you
/// want to use. After the classifier is trained you can use it to categorize a set of labeled
/// documents into the categories. For more information, see <a>how-document-classification</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDocumentClassifier {
    _private: (),
}
impl CreateDocumentClassifier {
    /// Creates a new builder-style object to manufacture [`CreateDocumentClassifierInput`](crate::input::CreateDocumentClassifierInput)
    pub fn builder() -> crate::input::create_document_classifier_input::Builder {
        crate::input::create_document_classifier_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDocumentClassifier {
    type Output = std::result::Result<
        crate::output::CreateDocumentClassifierOutput,
        crate::error::CreateDocumentClassifierError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_document_classifier_error(response)
        } else {
            crate::operation_deser::parse_create_document_classifier_response(response)
        }
    }
}

/// <p>Creates a model-specific endpoint for synchronous inference for a previously trained
/// custom model
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEndpoint {
    _private: (),
}
impl CreateEndpoint {
    /// Creates a new builder-style object to manufacture [`CreateEndpointInput`](crate::input::CreateEndpointInput)
    pub fn builder() -> crate::input::create_endpoint_input::Builder {
        crate::input::create_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEndpoint {
    type Output =
        std::result::Result<crate::output::CreateEndpointOutput, crate::error::CreateEndpointError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_endpoint_error(response)
        } else {
            crate::operation_deser::parse_create_endpoint_response(response)
        }
    }
}

/// <p>Creates an entity recognizer using submitted files. After your
/// <code>CreateEntityRecognizer</code> request is submitted, you can check job status using the
/// API. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEntityRecognizer {
    _private: (),
}
impl CreateEntityRecognizer {
    /// Creates a new builder-style object to manufacture [`CreateEntityRecognizerInput`](crate::input::CreateEntityRecognizerInput)
    pub fn builder() -> crate::input::create_entity_recognizer_input::Builder {
        crate::input::create_entity_recognizer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEntityRecognizer {
    type Output = std::result::Result<
        crate::output::CreateEntityRecognizerOutput,
        crate::error::CreateEntityRecognizerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_entity_recognizer_error(response)
        } else {
            crate::operation_deser::parse_create_entity_recognizer_response(response)
        }
    }
}

/// <p>Deletes a previously created document classifier</p>
/// <p>Only those classifiers that are in terminated states (IN_ERROR, TRAINED) will be deleted.
/// If an active inference job is using the model, a <code>ResourceInUseException</code> will be
/// returned.</p>
/// <p>This is an asynchronous action that puts the classifier into a DELETING state, and it is
/// then removed by a background job. Once removed, the classifier disappears from your account
/// and is no longer available for use. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDocumentClassifier {
    _private: (),
}
impl DeleteDocumentClassifier {
    /// Creates a new builder-style object to manufacture [`DeleteDocumentClassifierInput`](crate::input::DeleteDocumentClassifierInput)
    pub fn builder() -> crate::input::delete_document_classifier_input::Builder {
        crate::input::delete_document_classifier_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDocumentClassifier {
    type Output = std::result::Result<
        crate::output::DeleteDocumentClassifierOutput,
        crate::error::DeleteDocumentClassifierError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_document_classifier_error(response)
        } else {
            crate::operation_deser::parse_delete_document_classifier_response(response)
        }
    }
}

/// <p>Deletes a model-specific endpoint for a previously-trained custom model. All endpoints
/// must be deleted in order for the model to be deleted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEndpoint {
    _private: (),
}
impl DeleteEndpoint {
    /// Creates a new builder-style object to manufacture [`DeleteEndpointInput`](crate::input::DeleteEndpointInput)
    pub fn builder() -> crate::input::delete_endpoint_input::Builder {
        crate::input::delete_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEndpoint {
    type Output =
        std::result::Result<crate::output::DeleteEndpointOutput, crate::error::DeleteEndpointError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_endpoint_error(response)
        } else {
            crate::operation_deser::parse_delete_endpoint_response(response)
        }
    }
}

/// <p>Deletes an entity recognizer.</p>
/// <p>Only those recognizers that are in terminated states (IN_ERROR, TRAINED) will be deleted.
/// If an active inference job is using the model, a <code>ResourceInUseException</code> will be
/// returned.</p>
/// <p>This is an asynchronous action that puts the recognizer into a DELETING state, and it is
/// then removed by a background job. Once removed, the recognizer disappears from your account
/// and is no longer available for use. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEntityRecognizer {
    _private: (),
}
impl DeleteEntityRecognizer {
    /// Creates a new builder-style object to manufacture [`DeleteEntityRecognizerInput`](crate::input::DeleteEntityRecognizerInput)
    pub fn builder() -> crate::input::delete_entity_recognizer_input::Builder {
        crate::input::delete_entity_recognizer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEntityRecognizer {
    type Output = std::result::Result<
        crate::output::DeleteEntityRecognizerOutput,
        crate::error::DeleteEntityRecognizerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_entity_recognizer_error(response)
        } else {
            crate::operation_deser::parse_delete_entity_recognizer_response(response)
        }
    }
}

/// <p>Gets the properties associated with a document classification job. Use this operation to
/// get the status of a classification job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDocumentClassificationJob {
    _private: (),
}
impl DescribeDocumentClassificationJob {
    /// Creates a new builder-style object to manufacture [`DescribeDocumentClassificationJobInput`](crate::input::DescribeDocumentClassificationJobInput)
    pub fn builder() -> crate::input::describe_document_classification_job_input::Builder {
        crate::input::describe_document_classification_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDocumentClassificationJob {
    type Output = std::result::Result<
        crate::output::DescribeDocumentClassificationJobOutput,
        crate::error::DescribeDocumentClassificationJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_document_classification_job_error(response)
        } else {
            crate::operation_deser::parse_describe_document_classification_job_response(response)
        }
    }
}

/// <p>Gets the properties associated with a document classifier.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDocumentClassifier {
    _private: (),
}
impl DescribeDocumentClassifier {
    /// Creates a new builder-style object to manufacture [`DescribeDocumentClassifierInput`](crate::input::DescribeDocumentClassifierInput)
    pub fn builder() -> crate::input::describe_document_classifier_input::Builder {
        crate::input::describe_document_classifier_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDocumentClassifier {
    type Output = std::result::Result<
        crate::output::DescribeDocumentClassifierOutput,
        crate::error::DescribeDocumentClassifierError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_document_classifier_error(response)
        } else {
            crate::operation_deser::parse_describe_document_classifier_response(response)
        }
    }
}

/// <p>Gets the properties associated with a dominant language detection job. Use this operation
/// to get the status of a detection job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDominantLanguageDetectionJob {
    _private: (),
}
impl DescribeDominantLanguageDetectionJob {
    /// Creates a new builder-style object to manufacture [`DescribeDominantLanguageDetectionJobInput`](crate::input::DescribeDominantLanguageDetectionJobInput)
    pub fn builder() -> crate::input::describe_dominant_language_detection_job_input::Builder {
        crate::input::describe_dominant_language_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDominantLanguageDetectionJob {
    type Output = std::result::Result<
        crate::output::DescribeDominantLanguageDetectionJobOutput,
        crate::error::DescribeDominantLanguageDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_dominant_language_detection_job_error(response)
        } else {
            crate::operation_deser::parse_describe_dominant_language_detection_job_response(
                response,
            )
        }
    }
}

/// <p>Gets the properties associated with a specific endpoint. Use this operation to get the
/// status of an endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEndpoint {
    _private: (),
}
impl DescribeEndpoint {
    /// Creates a new builder-style object to manufacture [`DescribeEndpointInput`](crate::input::DescribeEndpointInput)
    pub fn builder() -> crate::input::describe_endpoint_input::Builder {
        crate::input::describe_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEndpoint {
    type Output = std::result::Result<
        crate::output::DescribeEndpointOutput,
        crate::error::DescribeEndpointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_endpoint_error(response)
        } else {
            crate::operation_deser::parse_describe_endpoint_response(response)
        }
    }
}

/// <p>Gets the properties associated with an entities detection job. Use this operation to get
/// the status of a detection job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEntitiesDetectionJob {
    _private: (),
}
impl DescribeEntitiesDetectionJob {
    /// Creates a new builder-style object to manufacture [`DescribeEntitiesDetectionJobInput`](crate::input::DescribeEntitiesDetectionJobInput)
    pub fn builder() -> crate::input::describe_entities_detection_job_input::Builder {
        crate::input::describe_entities_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEntitiesDetectionJob {
    type Output = std::result::Result<
        crate::output::DescribeEntitiesDetectionJobOutput,
        crate::error::DescribeEntitiesDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_entities_detection_job_error(response)
        } else {
            crate::operation_deser::parse_describe_entities_detection_job_response(response)
        }
    }
}

/// <p>Provides details about an entity recognizer including status, S3 buckets containing
/// training data, recognizer metadata, metrics, and so on.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEntityRecognizer {
    _private: (),
}
impl DescribeEntityRecognizer {
    /// Creates a new builder-style object to manufacture [`DescribeEntityRecognizerInput`](crate::input::DescribeEntityRecognizerInput)
    pub fn builder() -> crate::input::describe_entity_recognizer_input::Builder {
        crate::input::describe_entity_recognizer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEntityRecognizer {
    type Output = std::result::Result<
        crate::output::DescribeEntityRecognizerOutput,
        crate::error::DescribeEntityRecognizerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_entity_recognizer_error(response)
        } else {
            crate::operation_deser::parse_describe_entity_recognizer_response(response)
        }
    }
}

/// <p>Gets the status and details of an events detection job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEventsDetectionJob {
    _private: (),
}
impl DescribeEventsDetectionJob {
    /// Creates a new builder-style object to manufacture [`DescribeEventsDetectionJobInput`](crate::input::DescribeEventsDetectionJobInput)
    pub fn builder() -> crate::input::describe_events_detection_job_input::Builder {
        crate::input::describe_events_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEventsDetectionJob {
    type Output = std::result::Result<
        crate::output::DescribeEventsDetectionJobOutput,
        crate::error::DescribeEventsDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_events_detection_job_error(response)
        } else {
            crate::operation_deser::parse_describe_events_detection_job_response(response)
        }
    }
}

/// <p>Gets the properties associated with a key phrases detection job. Use this operation to get
/// the status of a detection job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeKeyPhrasesDetectionJob {
    _private: (),
}
impl DescribeKeyPhrasesDetectionJob {
    /// Creates a new builder-style object to manufacture [`DescribeKeyPhrasesDetectionJobInput`](crate::input::DescribeKeyPhrasesDetectionJobInput)
    pub fn builder() -> crate::input::describe_key_phrases_detection_job_input::Builder {
        crate::input::describe_key_phrases_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeKeyPhrasesDetectionJob {
    type Output = std::result::Result<
        crate::output::DescribeKeyPhrasesDetectionJobOutput,
        crate::error::DescribeKeyPhrasesDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_key_phrases_detection_job_error(response)
        } else {
            crate::operation_deser::parse_describe_key_phrases_detection_job_response(response)
        }
    }
}

/// <p>Gets the properties associated with a PII entities detection job. For example, you can use
/// this operation to get the job status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePiiEntitiesDetectionJob {
    _private: (),
}
impl DescribePiiEntitiesDetectionJob {
    /// Creates a new builder-style object to manufacture [`DescribePiiEntitiesDetectionJobInput`](crate::input::DescribePiiEntitiesDetectionJobInput)
    pub fn builder() -> crate::input::describe_pii_entities_detection_job_input::Builder {
        crate::input::describe_pii_entities_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePiiEntitiesDetectionJob {
    type Output = std::result::Result<
        crate::output::DescribePiiEntitiesDetectionJobOutput,
        crate::error::DescribePiiEntitiesDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_pii_entities_detection_job_error(response)
        } else {
            crate::operation_deser::parse_describe_pii_entities_detection_job_response(response)
        }
    }
}

/// <p>Gets the properties associated with a sentiment detection job. Use this operation to get
/// the status of a detection job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSentimentDetectionJob {
    _private: (),
}
impl DescribeSentimentDetectionJob {
    /// Creates a new builder-style object to manufacture [`DescribeSentimentDetectionJobInput`](crate::input::DescribeSentimentDetectionJobInput)
    pub fn builder() -> crate::input::describe_sentiment_detection_job_input::Builder {
        crate::input::describe_sentiment_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSentimentDetectionJob {
    type Output = std::result::Result<
        crate::output::DescribeSentimentDetectionJobOutput,
        crate::error::DescribeSentimentDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_sentiment_detection_job_error(response)
        } else {
            crate::operation_deser::parse_describe_sentiment_detection_job_response(response)
        }
    }
}

/// <p>Gets the properties associated with a topic detection job. Use this operation to get
/// the status of a detection job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTopicsDetectionJob {
    _private: (),
}
impl DescribeTopicsDetectionJob {
    /// Creates a new builder-style object to manufacture [`DescribeTopicsDetectionJobInput`](crate::input::DescribeTopicsDetectionJobInput)
    pub fn builder() -> crate::input::describe_topics_detection_job_input::Builder {
        crate::input::describe_topics_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTopicsDetectionJob {
    type Output = std::result::Result<
        crate::output::DescribeTopicsDetectionJobOutput,
        crate::error::DescribeTopicsDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_topics_detection_job_error(response)
        } else {
            crate::operation_deser::parse_describe_topics_detection_job_response(response)
        }
    }
}

/// <p>Determines the dominant language of the input text. For a list of languages that Amazon
/// Comprehend can detect, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-languages.html">Amazon Comprehend Supported Languages</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectDominantLanguage {
    _private: (),
}
impl DetectDominantLanguage {
    /// Creates a new builder-style object to manufacture [`DetectDominantLanguageInput`](crate::input::DetectDominantLanguageInput)
    pub fn builder() -> crate::input::detect_dominant_language_input::Builder {
        crate::input::detect_dominant_language_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectDominantLanguage {
    type Output = std::result::Result<
        crate::output::DetectDominantLanguageOutput,
        crate::error::DetectDominantLanguageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detect_dominant_language_error(response)
        } else {
            crate::operation_deser::parse_detect_dominant_language_response(response)
        }
    }
}

/// <p>Inspects text for named entities, and returns information about them. For more
/// information, about named entities, see <a>how-entities</a>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectEntities {
    _private: (),
}
impl DetectEntities {
    /// Creates a new builder-style object to manufacture [`DetectEntitiesInput`](crate::input::DetectEntitiesInput)
    pub fn builder() -> crate::input::detect_entities_input::Builder {
        crate::input::detect_entities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectEntities {
    type Output =
        std::result::Result<crate::output::DetectEntitiesOutput, crate::error::DetectEntitiesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detect_entities_error(response)
        } else {
            crate::operation_deser::parse_detect_entities_response(response)
        }
    }
}

/// <p>Detects the key noun phrases found in the text. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectKeyPhrases {
    _private: (),
}
impl DetectKeyPhrases {
    /// Creates a new builder-style object to manufacture [`DetectKeyPhrasesInput`](crate::input::DetectKeyPhrasesInput)
    pub fn builder() -> crate::input::detect_key_phrases_input::Builder {
        crate::input::detect_key_phrases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectKeyPhrases {
    type Output = std::result::Result<
        crate::output::DetectKeyPhrasesOutput,
        crate::error::DetectKeyPhrasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detect_key_phrases_error(response)
        } else {
            crate::operation_deser::parse_detect_key_phrases_response(response)
        }
    }
}

/// <p>Inspects the input text for entities that contain personally identifiable information
/// (PII) and returns information about them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectPiiEntities {
    _private: (),
}
impl DetectPiiEntities {
    /// Creates a new builder-style object to manufacture [`DetectPiiEntitiesInput`](crate::input::DetectPiiEntitiesInput)
    pub fn builder() -> crate::input::detect_pii_entities_input::Builder {
        crate::input::detect_pii_entities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectPiiEntities {
    type Output = std::result::Result<
        crate::output::DetectPiiEntitiesOutput,
        crate::error::DetectPiiEntitiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detect_pii_entities_error(response)
        } else {
            crate::operation_deser::parse_detect_pii_entities_response(response)
        }
    }
}

/// <p>Inspects text and returns an inference of the prevailing sentiment
/// (<code>POSITIVE</code>, <code>NEUTRAL</code>, <code>MIXED</code>, or <code>NEGATIVE</code>). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectSentiment {
    _private: (),
}
impl DetectSentiment {
    /// Creates a new builder-style object to manufacture [`DetectSentimentInput`](crate::input::DetectSentimentInput)
    pub fn builder() -> crate::input::detect_sentiment_input::Builder {
        crate::input::detect_sentiment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectSentiment {
    type Output = std::result::Result<
        crate::output::DetectSentimentOutput,
        crate::error::DetectSentimentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detect_sentiment_error(response)
        } else {
            crate::operation_deser::parse_detect_sentiment_response(response)
        }
    }
}

/// <p>Inspects text for syntax and the part of speech of words in the document. For more
/// information, <a>how-syntax</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectSyntax {
    _private: (),
}
impl DetectSyntax {
    /// Creates a new builder-style object to manufacture [`DetectSyntaxInput`](crate::input::DetectSyntaxInput)
    pub fn builder() -> crate::input::detect_syntax_input::Builder {
        crate::input::detect_syntax_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectSyntax {
    type Output =
        std::result::Result<crate::output::DetectSyntaxOutput, crate::error::DetectSyntaxError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detect_syntax_error(response)
        } else {
            crate::operation_deser::parse_detect_syntax_response(response)
        }
    }
}

/// <p>Gets a list of the documentation classification jobs that you have submitted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDocumentClassificationJobs {
    _private: (),
}
impl ListDocumentClassificationJobs {
    /// Creates a new builder-style object to manufacture [`ListDocumentClassificationJobsInput`](crate::input::ListDocumentClassificationJobsInput)
    pub fn builder() -> crate::input::list_document_classification_jobs_input::Builder {
        crate::input::list_document_classification_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDocumentClassificationJobs {
    type Output = std::result::Result<
        crate::output::ListDocumentClassificationJobsOutput,
        crate::error::ListDocumentClassificationJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_document_classification_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_document_classification_jobs_response(response)
        }
    }
}

/// <p>Gets a list of the document classifiers that you have created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDocumentClassifiers {
    _private: (),
}
impl ListDocumentClassifiers {
    /// Creates a new builder-style object to manufacture [`ListDocumentClassifiersInput`](crate::input::ListDocumentClassifiersInput)
    pub fn builder() -> crate::input::list_document_classifiers_input::Builder {
        crate::input::list_document_classifiers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDocumentClassifiers {
    type Output = std::result::Result<
        crate::output::ListDocumentClassifiersOutput,
        crate::error::ListDocumentClassifiersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_document_classifiers_error(response)
        } else {
            crate::operation_deser::parse_list_document_classifiers_response(response)
        }
    }
}

/// <p>Gets a list of summaries of the document classifiers that you have created</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDocumentClassifierSummaries {
    _private: (),
}
impl ListDocumentClassifierSummaries {
    /// Creates a new builder-style object to manufacture [`ListDocumentClassifierSummariesInput`](crate::input::ListDocumentClassifierSummariesInput)
    pub fn builder() -> crate::input::list_document_classifier_summaries_input::Builder {
        crate::input::list_document_classifier_summaries_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDocumentClassifierSummaries {
    type Output = std::result::Result<
        crate::output::ListDocumentClassifierSummariesOutput,
        crate::error::ListDocumentClassifierSummariesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_document_classifier_summaries_error(response)
        } else {
            crate::operation_deser::parse_list_document_classifier_summaries_response(response)
        }
    }
}

/// <p>Gets a list of the dominant language detection jobs that you have submitted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDominantLanguageDetectionJobs {
    _private: (),
}
impl ListDominantLanguageDetectionJobs {
    /// Creates a new builder-style object to manufacture [`ListDominantLanguageDetectionJobsInput`](crate::input::ListDominantLanguageDetectionJobsInput)
    pub fn builder() -> crate::input::list_dominant_language_detection_jobs_input::Builder {
        crate::input::list_dominant_language_detection_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDominantLanguageDetectionJobs {
    type Output = std::result::Result<
        crate::output::ListDominantLanguageDetectionJobsOutput,
        crate::error::ListDominantLanguageDetectionJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dominant_language_detection_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_dominant_language_detection_jobs_response(response)
        }
    }
}

/// <p>Gets a list of all existing endpoints that you've created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEndpoints {
    _private: (),
}
impl ListEndpoints {
    /// Creates a new builder-style object to manufacture [`ListEndpointsInput`](crate::input::ListEndpointsInput)
    pub fn builder() -> crate::input::list_endpoints_input::Builder {
        crate::input::list_endpoints_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEndpoints {
    type Output =
        std::result::Result<crate::output::ListEndpointsOutput, crate::error::ListEndpointsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_endpoints_error(response)
        } else {
            crate::operation_deser::parse_list_endpoints_response(response)
        }
    }
}

/// <p>Gets a list of the entity detection jobs that you have submitted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEntitiesDetectionJobs {
    _private: (),
}
impl ListEntitiesDetectionJobs {
    /// Creates a new builder-style object to manufacture [`ListEntitiesDetectionJobsInput`](crate::input::ListEntitiesDetectionJobsInput)
    pub fn builder() -> crate::input::list_entities_detection_jobs_input::Builder {
        crate::input::list_entities_detection_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEntitiesDetectionJobs {
    type Output = std::result::Result<
        crate::output::ListEntitiesDetectionJobsOutput,
        crate::error::ListEntitiesDetectionJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_entities_detection_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_entities_detection_jobs_response(response)
        }
    }
}

/// <p>Gets a list of the properties of all entity recognizers that you created, including
/// recognizers currently in training. Allows you to filter the list of recognizers based on
/// criteria such as status and submission time. This call returns up to 500 entity recognizers in
/// the list, with a default number of 100 recognizers in the list.</p>
/// <p>The results of this list are not in any particular order. Please get the list and sort
/// locally if needed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEntityRecognizers {
    _private: (),
}
impl ListEntityRecognizers {
    /// Creates a new builder-style object to manufacture [`ListEntityRecognizersInput`](crate::input::ListEntityRecognizersInput)
    pub fn builder() -> crate::input::list_entity_recognizers_input::Builder {
        crate::input::list_entity_recognizers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEntityRecognizers {
    type Output = std::result::Result<
        crate::output::ListEntityRecognizersOutput,
        crate::error::ListEntityRecognizersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_entity_recognizers_error(response)
        } else {
            crate::operation_deser::parse_list_entity_recognizers_response(response)
        }
    }
}

/// <p>Gets a list of summaries for the entity recognizers that you have created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEntityRecognizerSummaries {
    _private: (),
}
impl ListEntityRecognizerSummaries {
    /// Creates a new builder-style object to manufacture [`ListEntityRecognizerSummariesInput`](crate::input::ListEntityRecognizerSummariesInput)
    pub fn builder() -> crate::input::list_entity_recognizer_summaries_input::Builder {
        crate::input::list_entity_recognizer_summaries_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEntityRecognizerSummaries {
    type Output = std::result::Result<
        crate::output::ListEntityRecognizerSummariesOutput,
        crate::error::ListEntityRecognizerSummariesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_entity_recognizer_summaries_error(response)
        } else {
            crate::operation_deser::parse_list_entity_recognizer_summaries_response(response)
        }
    }
}

/// <p>Gets a list of the events detection jobs that you have submitted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEventsDetectionJobs {
    _private: (),
}
impl ListEventsDetectionJobs {
    /// Creates a new builder-style object to manufacture [`ListEventsDetectionJobsInput`](crate::input::ListEventsDetectionJobsInput)
    pub fn builder() -> crate::input::list_events_detection_jobs_input::Builder {
        crate::input::list_events_detection_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEventsDetectionJobs {
    type Output = std::result::Result<
        crate::output::ListEventsDetectionJobsOutput,
        crate::error::ListEventsDetectionJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_events_detection_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_events_detection_jobs_response(response)
        }
    }
}

/// <p>Get a list of key phrase detection jobs that you have submitted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListKeyPhrasesDetectionJobs {
    _private: (),
}
impl ListKeyPhrasesDetectionJobs {
    /// Creates a new builder-style object to manufacture [`ListKeyPhrasesDetectionJobsInput`](crate::input::ListKeyPhrasesDetectionJobsInput)
    pub fn builder() -> crate::input::list_key_phrases_detection_jobs_input::Builder {
        crate::input::list_key_phrases_detection_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListKeyPhrasesDetectionJobs {
    type Output = std::result::Result<
        crate::output::ListKeyPhrasesDetectionJobsOutput,
        crate::error::ListKeyPhrasesDetectionJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_key_phrases_detection_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_key_phrases_detection_jobs_response(response)
        }
    }
}

/// <p>Gets a list of the PII entity detection jobs that you have submitted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPiiEntitiesDetectionJobs {
    _private: (),
}
impl ListPiiEntitiesDetectionJobs {
    /// Creates a new builder-style object to manufacture [`ListPiiEntitiesDetectionJobsInput`](crate::input::ListPiiEntitiesDetectionJobsInput)
    pub fn builder() -> crate::input::list_pii_entities_detection_jobs_input::Builder {
        crate::input::list_pii_entities_detection_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPiiEntitiesDetectionJobs {
    type Output = std::result::Result<
        crate::output::ListPiiEntitiesDetectionJobsOutput,
        crate::error::ListPiiEntitiesDetectionJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_pii_entities_detection_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_pii_entities_detection_jobs_response(response)
        }
    }
}

/// <p>Gets a list of sentiment detection jobs that you have submitted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSentimentDetectionJobs {
    _private: (),
}
impl ListSentimentDetectionJobs {
    /// Creates a new builder-style object to manufacture [`ListSentimentDetectionJobsInput`](crate::input::ListSentimentDetectionJobsInput)
    pub fn builder() -> crate::input::list_sentiment_detection_jobs_input::Builder {
        crate::input::list_sentiment_detection_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSentimentDetectionJobs {
    type Output = std::result::Result<
        crate::output::ListSentimentDetectionJobsOutput,
        crate::error::ListSentimentDetectionJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_sentiment_detection_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_sentiment_detection_jobs_response(response)
        }
    }
}

/// <p>Lists all tags associated with a given Amazon Comprehend resource. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Gets a list of the topic detection jobs that you have submitted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTopicsDetectionJobs {
    _private: (),
}
impl ListTopicsDetectionJobs {
    /// Creates a new builder-style object to manufacture [`ListTopicsDetectionJobsInput`](crate::input::ListTopicsDetectionJobsInput)
    pub fn builder() -> crate::input::list_topics_detection_jobs_input::Builder {
        crate::input::list_topics_detection_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTopicsDetectionJobs {
    type Output = std::result::Result<
        crate::output::ListTopicsDetectionJobsOutput,
        crate::error::ListTopicsDetectionJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_topics_detection_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_topics_detection_jobs_response(response)
        }
    }
}

/// <p>Starts an asynchronous document classification job. Use the  operation to track the progress of the
/// job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartDocumentClassificationJob {
    _private: (),
}
impl StartDocumentClassificationJob {
    /// Creates a new builder-style object to manufacture [`StartDocumentClassificationJobInput`](crate::input::StartDocumentClassificationJobInput)
    pub fn builder() -> crate::input::start_document_classification_job_input::Builder {
        crate::input::start_document_classification_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartDocumentClassificationJob {
    type Output = std::result::Result<
        crate::output::StartDocumentClassificationJobOutput,
        crate::error::StartDocumentClassificationJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_document_classification_job_error(response)
        } else {
            crate::operation_deser::parse_start_document_classification_job_response(response)
        }
    }
}

/// <p>Starts an asynchronous dominant language detection job for a collection of documents. Use
/// the  operation to track the status
/// of a job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartDominantLanguageDetectionJob {
    _private: (),
}
impl StartDominantLanguageDetectionJob {
    /// Creates a new builder-style object to manufacture [`StartDominantLanguageDetectionJobInput`](crate::input::StartDominantLanguageDetectionJobInput)
    pub fn builder() -> crate::input::start_dominant_language_detection_job_input::Builder {
        crate::input::start_dominant_language_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartDominantLanguageDetectionJob {
    type Output = std::result::Result<
        crate::output::StartDominantLanguageDetectionJobOutput,
        crate::error::StartDominantLanguageDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_dominant_language_detection_job_error(response)
        } else {
            crate::operation_deser::parse_start_dominant_language_detection_job_response(response)
        }
    }
}

/// <p>Starts an asynchronous entity detection job for a collection of documents. Use the  operation to track the status of a job.</p>
/// <p>This API can be used for either standard entity detection or custom entity recognition. In
/// order to be used for custom entity recognition, the optional <code>EntityRecognizerArn</code>
/// must be used in order to provide access to the recognizer being used to detect the custom
/// entity.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartEntitiesDetectionJob {
    _private: (),
}
impl StartEntitiesDetectionJob {
    /// Creates a new builder-style object to manufacture [`StartEntitiesDetectionJobInput`](crate::input::StartEntitiesDetectionJobInput)
    pub fn builder() -> crate::input::start_entities_detection_job_input::Builder {
        crate::input::start_entities_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartEntitiesDetectionJob {
    type Output = std::result::Result<
        crate::output::StartEntitiesDetectionJobOutput,
        crate::error::StartEntitiesDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_entities_detection_job_error(response)
        } else {
            crate::operation_deser::parse_start_entities_detection_job_response(response)
        }
    }
}

/// <p>Starts an asynchronous event detection job for a collection of documents.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartEventsDetectionJob {
    _private: (),
}
impl StartEventsDetectionJob {
    /// Creates a new builder-style object to manufacture [`StartEventsDetectionJobInput`](crate::input::StartEventsDetectionJobInput)
    pub fn builder() -> crate::input::start_events_detection_job_input::Builder {
        crate::input::start_events_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartEventsDetectionJob {
    type Output = std::result::Result<
        crate::output::StartEventsDetectionJobOutput,
        crate::error::StartEventsDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_events_detection_job_error(response)
        } else {
            crate::operation_deser::parse_start_events_detection_job_response(response)
        }
    }
}

/// <p>Starts an asynchronous key phrase detection job for a collection of documents. Use the
/// operation to track the status of a
/// job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartKeyPhrasesDetectionJob {
    _private: (),
}
impl StartKeyPhrasesDetectionJob {
    /// Creates a new builder-style object to manufacture [`StartKeyPhrasesDetectionJobInput`](crate::input::StartKeyPhrasesDetectionJobInput)
    pub fn builder() -> crate::input::start_key_phrases_detection_job_input::Builder {
        crate::input::start_key_phrases_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartKeyPhrasesDetectionJob {
    type Output = std::result::Result<
        crate::output::StartKeyPhrasesDetectionJobOutput,
        crate::error::StartKeyPhrasesDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_key_phrases_detection_job_error(response)
        } else {
            crate::operation_deser::parse_start_key_phrases_detection_job_response(response)
        }
    }
}

/// <p>Starts an asynchronous PII entity detection job for a collection of documents.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartPiiEntitiesDetectionJob {
    _private: (),
}
impl StartPiiEntitiesDetectionJob {
    /// Creates a new builder-style object to manufacture [`StartPiiEntitiesDetectionJobInput`](crate::input::StartPiiEntitiesDetectionJobInput)
    pub fn builder() -> crate::input::start_pii_entities_detection_job_input::Builder {
        crate::input::start_pii_entities_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartPiiEntitiesDetectionJob {
    type Output = std::result::Result<
        crate::output::StartPiiEntitiesDetectionJobOutput,
        crate::error::StartPiiEntitiesDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_pii_entities_detection_job_error(response)
        } else {
            crate::operation_deser::parse_start_pii_entities_detection_job_response(response)
        }
    }
}

/// <p>Starts an asynchronous sentiment detection job for a collection of documents. use the
/// operation to track the status of a
/// job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartSentimentDetectionJob {
    _private: (),
}
impl StartSentimentDetectionJob {
    /// Creates a new builder-style object to manufacture [`StartSentimentDetectionJobInput`](crate::input::StartSentimentDetectionJobInput)
    pub fn builder() -> crate::input::start_sentiment_detection_job_input::Builder {
        crate::input::start_sentiment_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartSentimentDetectionJob {
    type Output = std::result::Result<
        crate::output::StartSentimentDetectionJobOutput,
        crate::error::StartSentimentDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_sentiment_detection_job_error(response)
        } else {
            crate::operation_deser::parse_start_sentiment_detection_job_response(response)
        }
    }
}

/// <p>Starts an asynchronous topic detection job. Use the
/// <code>DescribeTopicDetectionJob</code> operation to track the status of a job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartTopicsDetectionJob {
    _private: (),
}
impl StartTopicsDetectionJob {
    /// Creates a new builder-style object to manufacture [`StartTopicsDetectionJobInput`](crate::input::StartTopicsDetectionJobInput)
    pub fn builder() -> crate::input::start_topics_detection_job_input::Builder {
        crate::input::start_topics_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartTopicsDetectionJob {
    type Output = std::result::Result<
        crate::output::StartTopicsDetectionJobOutput,
        crate::error::StartTopicsDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_topics_detection_job_error(response)
        } else {
            crate::operation_deser::parse_start_topics_detection_job_response(response)
        }
    }
}

/// <p>Stops a dominant language detection job in progress.</p>
/// <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put
/// into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it
/// is put into the <code>COMPLETED</code> state; otherwise the job is stopped and put into the
/// <code>STOPPED</code> state.</p>
/// <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the
/// <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400
/// Internal Request Exception. </p>
/// <p>When a job is stopped, any documents already processed are written to the output
/// location.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopDominantLanguageDetectionJob {
    _private: (),
}
impl StopDominantLanguageDetectionJob {
    /// Creates a new builder-style object to manufacture [`StopDominantLanguageDetectionJobInput`](crate::input::StopDominantLanguageDetectionJobInput)
    pub fn builder() -> crate::input::stop_dominant_language_detection_job_input::Builder {
        crate::input::stop_dominant_language_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopDominantLanguageDetectionJob {
    type Output = std::result::Result<
        crate::output::StopDominantLanguageDetectionJobOutput,
        crate::error::StopDominantLanguageDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_dominant_language_detection_job_error(response)
        } else {
            crate::operation_deser::parse_stop_dominant_language_detection_job_response(response)
        }
    }
}

/// <p>Stops an entities detection job in progress.</p>
/// <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put
/// into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it
/// is put into the <code>COMPLETED</code> state; otherwise the job is stopped and put into the
/// <code>STOPPED</code> state.</p>
/// <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the
/// <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400
/// Internal Request Exception. </p>
/// <p>When a job is stopped, any documents already processed are written to the output
/// location.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopEntitiesDetectionJob {
    _private: (),
}
impl StopEntitiesDetectionJob {
    /// Creates a new builder-style object to manufacture [`StopEntitiesDetectionJobInput`](crate::input::StopEntitiesDetectionJobInput)
    pub fn builder() -> crate::input::stop_entities_detection_job_input::Builder {
        crate::input::stop_entities_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopEntitiesDetectionJob {
    type Output = std::result::Result<
        crate::output::StopEntitiesDetectionJobOutput,
        crate::error::StopEntitiesDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_entities_detection_job_error(response)
        } else {
            crate::operation_deser::parse_stop_entities_detection_job_response(response)
        }
    }
}

/// <p>Stops an events detection job in progress.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopEventsDetectionJob {
    _private: (),
}
impl StopEventsDetectionJob {
    /// Creates a new builder-style object to manufacture [`StopEventsDetectionJobInput`](crate::input::StopEventsDetectionJobInput)
    pub fn builder() -> crate::input::stop_events_detection_job_input::Builder {
        crate::input::stop_events_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopEventsDetectionJob {
    type Output = std::result::Result<
        crate::output::StopEventsDetectionJobOutput,
        crate::error::StopEventsDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_events_detection_job_error(response)
        } else {
            crate::operation_deser::parse_stop_events_detection_job_response(response)
        }
    }
}

/// <p>Stops a key phrases detection job in progress.</p>
/// <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put
/// into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it
/// is put into the <code>COMPLETED</code> state; otherwise the job is stopped and put into the
/// <code>STOPPED</code> state.</p>
/// <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the
/// <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400
/// Internal Request Exception. </p>
/// <p>When a job is stopped, any documents already processed are written to the output
/// location.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopKeyPhrasesDetectionJob {
    _private: (),
}
impl StopKeyPhrasesDetectionJob {
    /// Creates a new builder-style object to manufacture [`StopKeyPhrasesDetectionJobInput`](crate::input::StopKeyPhrasesDetectionJobInput)
    pub fn builder() -> crate::input::stop_key_phrases_detection_job_input::Builder {
        crate::input::stop_key_phrases_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopKeyPhrasesDetectionJob {
    type Output = std::result::Result<
        crate::output::StopKeyPhrasesDetectionJobOutput,
        crate::error::StopKeyPhrasesDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_key_phrases_detection_job_error(response)
        } else {
            crate::operation_deser::parse_stop_key_phrases_detection_job_response(response)
        }
    }
}

/// <p>Stops a PII entities detection job in progress.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopPiiEntitiesDetectionJob {
    _private: (),
}
impl StopPiiEntitiesDetectionJob {
    /// Creates a new builder-style object to manufacture [`StopPiiEntitiesDetectionJobInput`](crate::input::StopPiiEntitiesDetectionJobInput)
    pub fn builder() -> crate::input::stop_pii_entities_detection_job_input::Builder {
        crate::input::stop_pii_entities_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopPiiEntitiesDetectionJob {
    type Output = std::result::Result<
        crate::output::StopPiiEntitiesDetectionJobOutput,
        crate::error::StopPiiEntitiesDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_pii_entities_detection_job_error(response)
        } else {
            crate::operation_deser::parse_stop_pii_entities_detection_job_response(response)
        }
    }
}

/// <p>Stops a sentiment detection job in progress.</p>
/// <p>If the job state is <code>IN_PROGRESS</code> the job is marked for termination and put
/// into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped, it
/// is put into the <code>COMPLETED</code> state; otherwise the job is be stopped and put into the
/// <code>STOPPED</code> state.</p>
/// <p>If the job is in the <code>COMPLETED</code> or <code>FAILED</code> state when you call the
/// <code>StopDominantLanguageDetectionJob</code> operation, the operation returns a 400
/// Internal Request Exception. </p>
/// <p>When a job is stopped, any documents already processed are written to the output
/// location.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopSentimentDetectionJob {
    _private: (),
}
impl StopSentimentDetectionJob {
    /// Creates a new builder-style object to manufacture [`StopSentimentDetectionJobInput`](crate::input::StopSentimentDetectionJobInput)
    pub fn builder() -> crate::input::stop_sentiment_detection_job_input::Builder {
        crate::input::stop_sentiment_detection_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopSentimentDetectionJob {
    type Output = std::result::Result<
        crate::output::StopSentimentDetectionJobOutput,
        crate::error::StopSentimentDetectionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_sentiment_detection_job_error(response)
        } else {
            crate::operation_deser::parse_stop_sentiment_detection_job_response(response)
        }
    }
}

/// <p>Stops a document classifier training job while in progress.</p>
/// <p>If the training job state is <code>TRAINING</code>, the job is marked for termination and
/// put into the <code>STOP_REQUESTED</code> state. If the training job completes before it can be
/// stopped, it is put into the <code>TRAINED</code>; otherwise the training job is stopped and
/// put into the <code>STOPPED</code> state and the service sends back an HTTP 200 response with
/// an empty HTTP body. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopTrainingDocumentClassifier {
    _private: (),
}
impl StopTrainingDocumentClassifier {
    /// Creates a new builder-style object to manufacture [`StopTrainingDocumentClassifierInput`](crate::input::StopTrainingDocumentClassifierInput)
    pub fn builder() -> crate::input::stop_training_document_classifier_input::Builder {
        crate::input::stop_training_document_classifier_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopTrainingDocumentClassifier {
    type Output = std::result::Result<
        crate::output::StopTrainingDocumentClassifierOutput,
        crate::error::StopTrainingDocumentClassifierError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_training_document_classifier_error(response)
        } else {
            crate::operation_deser::parse_stop_training_document_classifier_response(response)
        }
    }
}

/// <p>Stops an entity recognizer training job while in progress.</p>
/// <p>If the training job state is <code>TRAINING</code>, the job is marked for termination and
/// put into the <code>STOP_REQUESTED</code> state. If the training job completes before it can be
/// stopped, it is put into the <code>TRAINED</code>; otherwise the training job is stopped and
/// putted into the <code>STOPPED</code> state and the service sends back an HTTP 200 response
/// with an empty HTTP body.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopTrainingEntityRecognizer {
    _private: (),
}
impl StopTrainingEntityRecognizer {
    /// Creates a new builder-style object to manufacture [`StopTrainingEntityRecognizerInput`](crate::input::StopTrainingEntityRecognizerInput)
    pub fn builder() -> crate::input::stop_training_entity_recognizer_input::Builder {
        crate::input::stop_training_entity_recognizer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopTrainingEntityRecognizer {
    type Output = std::result::Result<
        crate::output::StopTrainingEntityRecognizerOutput,
        crate::error::StopTrainingEntityRecognizerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_training_entity_recognizer_error(response)
        } else {
            crate::operation_deser::parse_stop_training_entity_recognizer_response(response)
        }
    }
}

/// <p>Associates a specific tag with an Amazon Comprehend resource. A tag is a key-value pair
/// that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with
/// "Sales" as the key might be added to a resource to indicate its use by the sales department.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes a specific tag associated with an Amazon Comprehend resource. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates information about the specified endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateEndpoint {
    _private: (),
}
impl UpdateEndpoint {
    /// Creates a new builder-style object to manufacture [`UpdateEndpointInput`](crate::input::UpdateEndpointInput)
    pub fn builder() -> crate::input::update_endpoint_input::Builder {
        crate::input::update_endpoint_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateEndpoint {
    type Output =
        std::result::Result<crate::output::UpdateEndpointOutput, crate::error::UpdateEndpointError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_endpoint_error(response)
        } else {
            crate::operation_deser::parse_update_endpoint_response(response)
        }
    }
}
