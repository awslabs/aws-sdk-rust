// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An augmented manifest file that provides training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AugmentedManifestsListItem {
    /// <p>The Amazon S3 location of the augmented manifest file.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The purpose of the data you've provided in the augmented manifest. You can either train or test this data. If you don't specify, the default is train.</p>
    /// <p>TRAIN - all of the documents in the manifest will be used for training. If no test documents are provided, Amazon Comprehend will automatically reserve a portion of the training documents for testing.</p>
    /// <p> TEST - all of the documents in the manifest will be used for testing.</p>
    #[doc(hidden)]
    pub split: std::option::Option<crate::types::Split>,
    /// <p>The JSON attribute that contains the annotations for your training documents. The number of attribute names that you specify depends on whether your augmented manifest file is the output of a single labeling job or a chained labeling job.</p>
    /// <p>If your file is the output of a single labeling job, specify the LabelAttributeName key that was used when the job was created in Ground Truth.</p>
    /// <p>If your file is the output of a chained labeling job, specify the LabelAttributeName key for one or more jobs in the chain. Each LabelAttributeName key provides the annotations from an individual job.</p>
    #[doc(hidden)]
    pub attribute_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The S3 prefix to the annotation files that are referred in the augmented manifest file.</p>
    #[doc(hidden)]
    pub annotation_data_s3_uri: std::option::Option<std::string::String>,
    /// <p>The S3 prefix to the source files (PDFs) that are referred to in the augmented manifest file.</p>
    #[doc(hidden)]
    pub source_documents_s3_uri: std::option::Option<std::string::String>,
    /// <p>The type of augmented manifest. PlainTextDocument or SemiStructuredDocument. If you don't specify, the default is PlainTextDocument. </p>
    /// <ul>
    /// <li> <p> <code>PLAIN_TEXT_DOCUMENT</code> A document type that represents any unicode text that is encoded in UTF-8.</p> </li>
    /// <li> <p> <code>SEMI_STRUCTURED_DOCUMENT</code> A document type with positional and structural context, like a PDF. For training with Amazon Comprehend, only PDFs are supported. For inference, Amazon Comprehend support PDFs, DOCX and TXT.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub document_type: std::option::Option<crate::types::AugmentedManifestsDocumentTypeFormat>,
}
impl AugmentedManifestsListItem {
    /// <p>The Amazon S3 location of the augmented manifest file.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>The purpose of the data you've provided in the augmented manifest. You can either train or test this data. If you don't specify, the default is train.</p>
    /// <p>TRAIN - all of the documents in the manifest will be used for training. If no test documents are provided, Amazon Comprehend will automatically reserve a portion of the training documents for testing.</p>
    /// <p> TEST - all of the documents in the manifest will be used for testing.</p>
    pub fn split(&self) -> std::option::Option<&crate::types::Split> {
        self.split.as_ref()
    }
    /// <p>The JSON attribute that contains the annotations for your training documents. The number of attribute names that you specify depends on whether your augmented manifest file is the output of a single labeling job or a chained labeling job.</p>
    /// <p>If your file is the output of a single labeling job, specify the LabelAttributeName key that was used when the job was created in Ground Truth.</p>
    /// <p>If your file is the output of a chained labeling job, specify the LabelAttributeName key for one or more jobs in the chain. Each LabelAttributeName key provides the annotations from an individual job.</p>
    pub fn attribute_names(&self) -> std::option::Option<&[std::string::String]> {
        self.attribute_names.as_deref()
    }
    /// <p>The S3 prefix to the annotation files that are referred in the augmented manifest file.</p>
    pub fn annotation_data_s3_uri(&self) -> std::option::Option<&str> {
        self.annotation_data_s3_uri.as_deref()
    }
    /// <p>The S3 prefix to the source files (PDFs) that are referred to in the augmented manifest file.</p>
    pub fn source_documents_s3_uri(&self) -> std::option::Option<&str> {
        self.source_documents_s3_uri.as_deref()
    }
    /// <p>The type of augmented manifest. PlainTextDocument or SemiStructuredDocument. If you don't specify, the default is PlainTextDocument. </p>
    /// <ul>
    /// <li> <p> <code>PLAIN_TEXT_DOCUMENT</code> A document type that represents any unicode text that is encoded in UTF-8.</p> </li>
    /// <li> <p> <code>SEMI_STRUCTURED_DOCUMENT</code> A document type with positional and structural context, like a PDF. For training with Amazon Comprehend, only PDFs are supported. For inference, Amazon Comprehend support PDFs, DOCX and TXT.</p> </li>
    /// </ul>
    pub fn document_type(
        &self,
    ) -> std::option::Option<&crate::types::AugmentedManifestsDocumentTypeFormat> {
        self.document_type.as_ref()
    }
}
impl AugmentedManifestsListItem {
    /// Creates a new builder-style object to manufacture [`AugmentedManifestsListItem`](crate::types::AugmentedManifestsListItem).
    pub fn builder() -> crate::types::builders::AugmentedManifestsListItemBuilder {
        crate::types::builders::AugmentedManifestsListItemBuilder::default()
    }
}

/// A builder for [`AugmentedManifestsListItem`](crate::types::AugmentedManifestsListItem).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct AugmentedManifestsListItemBuilder {
    pub(crate) s3_uri: std::option::Option<std::string::String>,
    pub(crate) split: std::option::Option<crate::types::Split>,
    pub(crate) attribute_names: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) annotation_data_s3_uri: std::option::Option<std::string::String>,
    pub(crate) source_documents_s3_uri: std::option::Option<std::string::String>,
    pub(crate) document_type:
        std::option::Option<crate::types::AugmentedManifestsDocumentTypeFormat>,
}
impl AugmentedManifestsListItemBuilder {
    /// <p>The Amazon S3 location of the augmented manifest file.</p>
    pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
        self.s3_uri = Some(input.into());
        self
    }
    /// <p>The Amazon S3 location of the augmented manifest file.</p>
    pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.s3_uri = input;
        self
    }
    /// <p>The purpose of the data you've provided in the augmented manifest. You can either train or test this data. If you don't specify, the default is train.</p>
    /// <p>TRAIN - all of the documents in the manifest will be used for training. If no test documents are provided, Amazon Comprehend will automatically reserve a portion of the training documents for testing.</p>
    /// <p> TEST - all of the documents in the manifest will be used for testing.</p>
    pub fn split(mut self, input: crate::types::Split) -> Self {
        self.split = Some(input);
        self
    }
    /// <p>The purpose of the data you've provided in the augmented manifest. You can either train or test this data. If you don't specify, the default is train.</p>
    /// <p>TRAIN - all of the documents in the manifest will be used for training. If no test documents are provided, Amazon Comprehend will automatically reserve a portion of the training documents for testing.</p>
    /// <p> TEST - all of the documents in the manifest will be used for testing.</p>
    pub fn set_split(mut self, input: std::option::Option<crate::types::Split>) -> Self {
        self.split = input;
        self
    }
    /// Appends an item to `attribute_names`.
    ///
    /// To override the contents of this collection use [`set_attribute_names`](Self::set_attribute_names).
    ///
    /// <p>The JSON attribute that contains the annotations for your training documents. The number of attribute names that you specify depends on whether your augmented manifest file is the output of a single labeling job or a chained labeling job.</p>
    /// <p>If your file is the output of a single labeling job, specify the LabelAttributeName key that was used when the job was created in Ground Truth.</p>
    /// <p>If your file is the output of a chained labeling job, specify the LabelAttributeName key for one or more jobs in the chain. Each LabelAttributeName key provides the annotations from an individual job.</p>
    pub fn attribute_names(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.attribute_names.unwrap_or_default();
        v.push(input.into());
        self.attribute_names = Some(v);
        self
    }
    /// <p>The JSON attribute that contains the annotations for your training documents. The number of attribute names that you specify depends on whether your augmented manifest file is the output of a single labeling job or a chained labeling job.</p>
    /// <p>If your file is the output of a single labeling job, specify the LabelAttributeName key that was used when the job was created in Ground Truth.</p>
    /// <p>If your file is the output of a chained labeling job, specify the LabelAttributeName key for one or more jobs in the chain. Each LabelAttributeName key provides the annotations from an individual job.</p>
    pub fn set_attribute_names(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.attribute_names = input;
        self
    }
    /// <p>The S3 prefix to the annotation files that are referred in the augmented manifest file.</p>
    pub fn annotation_data_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
        self.annotation_data_s3_uri = Some(input.into());
        self
    }
    /// <p>The S3 prefix to the annotation files that are referred in the augmented manifest file.</p>
    pub fn set_annotation_data_s3_uri(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.annotation_data_s3_uri = input;
        self
    }
    /// <p>The S3 prefix to the source files (PDFs) that are referred to in the augmented manifest file.</p>
    pub fn source_documents_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
        self.source_documents_s3_uri = Some(input.into());
        self
    }
    /// <p>The S3 prefix to the source files (PDFs) that are referred to in the augmented manifest file.</p>
    pub fn set_source_documents_s3_uri(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.source_documents_s3_uri = input;
        self
    }
    /// <p>The type of augmented manifest. PlainTextDocument or SemiStructuredDocument. If you don't specify, the default is PlainTextDocument. </p>
    /// <ul>
    /// <li> <p> <code>PLAIN_TEXT_DOCUMENT</code> A document type that represents any unicode text that is encoded in UTF-8.</p> </li>
    /// <li> <p> <code>SEMI_STRUCTURED_DOCUMENT</code> A document type with positional and structural context, like a PDF. For training with Amazon Comprehend, only PDFs are supported. For inference, Amazon Comprehend support PDFs, DOCX and TXT.</p> </li>
    /// </ul>
    pub fn document_type(
        mut self,
        input: crate::types::AugmentedManifestsDocumentTypeFormat,
    ) -> Self {
        self.document_type = Some(input);
        self
    }
    /// <p>The type of augmented manifest. PlainTextDocument or SemiStructuredDocument. If you don't specify, the default is PlainTextDocument. </p>
    /// <ul>
    /// <li> <p> <code>PLAIN_TEXT_DOCUMENT</code> A document type that represents any unicode text that is encoded in UTF-8.</p> </li>
    /// <li> <p> <code>SEMI_STRUCTURED_DOCUMENT</code> A document type with positional and structural context, like a PDF. For training with Amazon Comprehend, only PDFs are supported. For inference, Amazon Comprehend support PDFs, DOCX and TXT.</p> </li>
    /// </ul>
    pub fn set_document_type(
        mut self,
        input: std::option::Option<crate::types::AugmentedManifestsDocumentTypeFormat>,
    ) -> Self {
        self.document_type = input;
        self
    }
    /// Consumes the builder and constructs a [`AugmentedManifestsListItem`](crate::types::AugmentedManifestsListItem).
    pub fn build(self) -> crate::types::AugmentedManifestsListItem {
        crate::types::AugmentedManifestsListItem {
            s3_uri: self.s3_uri,
            split: self.split,
            attribute_names: self.attribute_names,
            annotation_data_s3_uri: self.annotation_data_s3_uri,
            source_documents_s3_uri: self.source_documents_s3_uri,
            document_type: self.document_type,
        }
    }
}
