// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEndpointOutput {}
impl std::fmt::Debug for UpdateEndpointOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEndpointOutput");
        formatter.finish()
    }
}
/// See [`UpdateEndpointOutput`](crate::output::UpdateEndpointOutput)
pub mod update_endpoint_output {

    /// A builder for [`UpdateEndpointOutput`](crate::output::UpdateEndpointOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateEndpointOutput`](crate::output::UpdateEndpointOutput)
        pub fn build(self) -> crate::output::UpdateEndpointOutput {
            crate::output::UpdateEndpointOutput {}
        }
    }
}
impl UpdateEndpointOutput {
    /// Creates a new builder-style object to manufacture [`UpdateEndpointOutput`](crate::output::UpdateEndpointOutput)
    pub fn builder() -> crate::output::update_endpoint_output::Builder {
        crate::output::update_endpoint_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceOutput {}
impl std::fmt::Debug for UntagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceOutput");
        formatter.finish()
    }
}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput)
pub mod untag_resource_output {

    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput)
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {}
        }
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceOutput {}
impl std::fmt::Debug for TagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceOutput");
        formatter.finish()
    }
}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput)
pub mod tag_resource_output {

    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput)
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {}
        }
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput)
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopTrainingEntityRecognizerOutput {}
impl std::fmt::Debug for StopTrainingEntityRecognizerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopTrainingEntityRecognizerOutput");
        formatter.finish()
    }
}
/// See [`StopTrainingEntityRecognizerOutput`](crate::output::StopTrainingEntityRecognizerOutput)
pub mod stop_training_entity_recognizer_output {

    /// A builder for [`StopTrainingEntityRecognizerOutput`](crate::output::StopTrainingEntityRecognizerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StopTrainingEntityRecognizerOutput`](crate::output::StopTrainingEntityRecognizerOutput)
        pub fn build(self) -> crate::output::StopTrainingEntityRecognizerOutput {
            crate::output::StopTrainingEntityRecognizerOutput {}
        }
    }
}
impl StopTrainingEntityRecognizerOutput {
    /// Creates a new builder-style object to manufacture [`StopTrainingEntityRecognizerOutput`](crate::output::StopTrainingEntityRecognizerOutput)
    pub fn builder() -> crate::output::stop_training_entity_recognizer_output::Builder {
        crate::output::stop_training_entity_recognizer_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopTrainingDocumentClassifierOutput {}
impl std::fmt::Debug for StopTrainingDocumentClassifierOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopTrainingDocumentClassifierOutput");
        formatter.finish()
    }
}
/// See [`StopTrainingDocumentClassifierOutput`](crate::output::StopTrainingDocumentClassifierOutput)
pub mod stop_training_document_classifier_output {

    /// A builder for [`StopTrainingDocumentClassifierOutput`](crate::output::StopTrainingDocumentClassifierOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StopTrainingDocumentClassifierOutput`](crate::output::StopTrainingDocumentClassifierOutput)
        pub fn build(self) -> crate::output::StopTrainingDocumentClassifierOutput {
            crate::output::StopTrainingDocumentClassifierOutput {}
        }
    }
}
impl StopTrainingDocumentClassifierOutput {
    /// Creates a new builder-style object to manufacture [`StopTrainingDocumentClassifierOutput`](crate::output::StopTrainingDocumentClassifierOutput)
    pub fn builder() -> crate::output::stop_training_document_classifier_output::Builder {
        crate::output::stop_training_document_classifier_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopTargetedSentimentDetectionJobOutput {
    /// <p>The identifier of the targeted sentiment detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopSentimentDetectionJob</code> operation.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StopTargetedSentimentDetectionJobOutput {
    /// <p>The identifier of the targeted sentiment detection job to stop.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopSentimentDetectionJob</code> operation.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StopTargetedSentimentDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopTargetedSentimentDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopTargetedSentimentDetectionJobOutput`](crate::output::StopTargetedSentimentDetectionJobOutput)
pub mod stop_targeted_sentiment_detection_job_output {

    /// A builder for [`StopTargetedSentimentDetectionJobOutput`](crate::output::StopTargetedSentimentDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the targeted sentiment detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the targeted sentiment detection job to stop.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopSentimentDetectionJob</code> operation.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopSentimentDetectionJob</code> operation.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopTargetedSentimentDetectionJobOutput`](crate::output::StopTargetedSentimentDetectionJobOutput)
        pub fn build(self) -> crate::output::StopTargetedSentimentDetectionJobOutput {
            crate::output::StopTargetedSentimentDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopTargetedSentimentDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopTargetedSentimentDetectionJobOutput`](crate::output::StopTargetedSentimentDetectionJobOutput)
    pub fn builder() -> crate::output::stop_targeted_sentiment_detection_job_output::Builder {
        crate::output::stop_targeted_sentiment_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopSentimentDetectionJobOutput {
    /// <p>The identifier of the sentiment detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopSentimentDetectionJob</code> operation.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StopSentimentDetectionJobOutput {
    /// <p>The identifier of the sentiment detection job to stop.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopSentimentDetectionJob</code> operation.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StopSentimentDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopSentimentDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopSentimentDetectionJobOutput`](crate::output::StopSentimentDetectionJobOutput)
pub mod stop_sentiment_detection_job_output {

    /// A builder for [`StopSentimentDetectionJobOutput`](crate::output::StopSentimentDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the sentiment detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the sentiment detection job to stop.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopSentimentDetectionJob</code> operation.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopSentimentDetectionJob</code> operation.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopSentimentDetectionJobOutput`](crate::output::StopSentimentDetectionJobOutput)
        pub fn build(self) -> crate::output::StopSentimentDetectionJobOutput {
            crate::output::StopSentimentDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopSentimentDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopSentimentDetectionJobOutput`](crate::output::StopSentimentDetectionJobOutput)
    pub fn builder() -> crate::output::stop_sentiment_detection_job_output::Builder {
        crate::output::stop_sentiment_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopPiiEntitiesDetectionJobOutput {
    /// <p>The identifier of the PII entities detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The status of the PII entities detection job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StopPiiEntitiesDetectionJobOutput {
    /// <p>The identifier of the PII entities detection job to stop.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The status of the PII entities detection job.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StopPiiEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopPiiEntitiesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopPiiEntitiesDetectionJobOutput`](crate::output::StopPiiEntitiesDetectionJobOutput)
pub mod stop_pii_entities_detection_job_output {

    /// A builder for [`StopPiiEntitiesDetectionJobOutput`](crate::output::StopPiiEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the PII entities detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the PII entities detection job to stop.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The status of the PII entities detection job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the PII entities detection job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopPiiEntitiesDetectionJobOutput`](crate::output::StopPiiEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::StopPiiEntitiesDetectionJobOutput {
            crate::output::StopPiiEntitiesDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopPiiEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopPiiEntitiesDetectionJobOutput`](crate::output::StopPiiEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::stop_pii_entities_detection_job_output::Builder {
        crate::output::stop_pii_entities_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopKeyPhrasesDetectionJobOutput {
    /// <p>The identifier of the key phrases detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopKeyPhrasesDetectionJob</code> operation.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StopKeyPhrasesDetectionJobOutput {
    /// <p>The identifier of the key phrases detection job to stop.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopKeyPhrasesDetectionJob</code> operation.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StopKeyPhrasesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopKeyPhrasesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopKeyPhrasesDetectionJobOutput`](crate::output::StopKeyPhrasesDetectionJobOutput)
pub mod stop_key_phrases_detection_job_output {

    /// A builder for [`StopKeyPhrasesDetectionJobOutput`](crate::output::StopKeyPhrasesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the key phrases detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the key phrases detection job to stop.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopKeyPhrasesDetectionJob</code> operation.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopKeyPhrasesDetectionJob</code> operation.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopKeyPhrasesDetectionJobOutput`](crate::output::StopKeyPhrasesDetectionJobOutput)
        pub fn build(self) -> crate::output::StopKeyPhrasesDetectionJobOutput {
            crate::output::StopKeyPhrasesDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopKeyPhrasesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopKeyPhrasesDetectionJobOutput`](crate::output::StopKeyPhrasesDetectionJobOutput)
    pub fn builder() -> crate::output::stop_key_phrases_detection_job_output::Builder {
        crate::output::stop_key_phrases_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopEventsDetectionJobOutput {
    /// <p>The identifier of the events detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The status of the events detection job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StopEventsDetectionJobOutput {
    /// <p>The identifier of the events detection job to stop.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The status of the events detection job.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StopEventsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopEventsDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopEventsDetectionJobOutput`](crate::output::StopEventsDetectionJobOutput)
pub mod stop_events_detection_job_output {

    /// A builder for [`StopEventsDetectionJobOutput`](crate::output::StopEventsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the events detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the events detection job to stop.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The status of the events detection job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the events detection job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopEventsDetectionJobOutput`](crate::output::StopEventsDetectionJobOutput)
        pub fn build(self) -> crate::output::StopEventsDetectionJobOutput {
            crate::output::StopEventsDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopEventsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopEventsDetectionJobOutput`](crate::output::StopEventsDetectionJobOutput)
    pub fn builder() -> crate::output::stop_events_detection_job_output::Builder {
        crate::output::stop_events_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopEntitiesDetectionJobOutput {
    /// <p>The identifier of the entities detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopEntitiesDetectionJob</code> operation.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StopEntitiesDetectionJobOutput {
    /// <p>The identifier of the entities detection job to stop.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopEntitiesDetectionJob</code> operation.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StopEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopEntitiesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopEntitiesDetectionJobOutput`](crate::output::StopEntitiesDetectionJobOutput)
pub mod stop_entities_detection_job_output {

    /// A builder for [`StopEntitiesDetectionJobOutput`](crate::output::StopEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the entities detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the entities detection job to stop.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopEntitiesDetectionJob</code> operation.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopEntitiesDetectionJob</code> operation.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopEntitiesDetectionJobOutput`](crate::output::StopEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::StopEntitiesDetectionJobOutput {
            crate::output::StopEntitiesDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopEntitiesDetectionJobOutput`](crate::output::StopEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::stop_entities_detection_job_output::Builder {
        crate::output::stop_entities_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopDominantLanguageDetectionJobOutput {
    /// <p>The identifier of the dominant language detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopDominantLanguageDetectionJob</code> operation.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StopDominantLanguageDetectionJobOutput {
    /// <p>The identifier of the dominant language detection job to stop.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopDominantLanguageDetectionJob</code> operation.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StopDominantLanguageDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopDominantLanguageDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopDominantLanguageDetectionJobOutput`](crate::output::StopDominantLanguageDetectionJobOutput)
pub mod stop_dominant_language_detection_job_output {

    /// A builder for [`StopDominantLanguageDetectionJobOutput`](crate::output::StopDominantLanguageDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the dominant language detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the dominant language detection job to stop.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopDominantLanguageDetectionJob</code> operation.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or <code>STOPPED</code> if the job was previously stopped with the <code>StopDominantLanguageDetectionJob</code> operation.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopDominantLanguageDetectionJobOutput`](crate::output::StopDominantLanguageDetectionJobOutput)
        pub fn build(self) -> crate::output::StopDominantLanguageDetectionJobOutput {
            crate::output::StopDominantLanguageDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopDominantLanguageDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopDominantLanguageDetectionJobOutput`](crate::output::StopDominantLanguageDetectionJobOutput)
    pub fn builder() -> crate::output::stop_dominant_language_detection_job_output::Builder {
        crate::output::stop_dominant_language_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartTopicsDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of the job, use this identifier with the <code>DescribeTopicDetectionJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :topics-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job: </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the <code>DescribeTopicDetectionJob</code> operation.</p> </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StartTopicsDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of the job, use this identifier with the <code>DescribeTopicDetectionJob</code> operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :topics-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the job: </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the <code>DescribeTopicDetectionJob</code> operation.</p> </li>
    /// </ul>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StartTopicsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartTopicsDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartTopicsDetectionJobOutput`](crate::output::StartTopicsDetectionJobOutput)
pub mod start_topics_detection_job_output {

    /// A builder for [`StartTopicsDetectionJobOutput`](crate::output::StartTopicsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of the job, use this identifier with the <code>DescribeTopicDetectionJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of the job, use this identifier with the <code>DescribeTopicDetectionJob</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :topics-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :topics-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job: </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the <code>DescribeTopicDetectionJob</code> operation.</p> </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the job: </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the <code>DescribeTopicDetectionJob</code> operation.</p> </li>
        /// </ul>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartTopicsDetectionJobOutput`](crate::output::StartTopicsDetectionJobOutput)
        pub fn build(self) -> crate::output::StartTopicsDetectionJobOutput {
            crate::output::StartTopicsDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartTopicsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartTopicsDetectionJobOutput`](crate::output::StartTopicsDetectionJobOutput)
    pub fn builder() -> crate::output::start_topics_detection_job_output::Builder {
        crate::output::start_topics_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartTargetedSentimentDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the targeted sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :targeted-sentiment-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:targeted-sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StartTargetedSentimentDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the targeted sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :targeted-sentiment-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:targeted-sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// </ul>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StartTargetedSentimentDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartTargetedSentimentDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartTargetedSentimentDetectionJobOutput`](crate::output::StartTargetedSentimentDetectionJobOutput)
pub mod start_targeted_sentiment_detection_job_output {

    /// A builder for [`StartTargetedSentimentDetectionJobOutput`](crate::output::StartTargetedSentimentDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the targeted sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :targeted-sentiment-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:targeted-sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the targeted sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :targeted-sentiment-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:targeted-sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// </ul>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartTargetedSentimentDetectionJobOutput`](crate::output::StartTargetedSentimentDetectionJobOutput)
        pub fn build(self) -> crate::output::StartTargetedSentimentDetectionJobOutput {
            crate::output::StartTargetedSentimentDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartTargetedSentimentDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartTargetedSentimentDetectionJobOutput`](crate::output::StartTargetedSentimentDetectionJobOutput)
    pub fn builder() -> crate::output::start_targeted_sentiment_detection_job_output::Builder {
        crate::output::start_targeted_sentiment_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartSentimentDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :sentiment-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StartSentimentDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :sentiment-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// </ul>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StartSentimentDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartSentimentDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartSentimentDetectionJobOutput`](crate::output::StartSentimentDetectionJobOutput)
pub mod start_sentiment_detection_job_output {

    /// A builder for [`StartSentimentDetectionJobOutput`](crate::output::StartSentimentDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :sentiment-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :sentiment-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// </ul>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartSentimentDetectionJobOutput`](crate::output::StartSentimentDetectionJobOutput)
        pub fn build(self) -> crate::output::StartSentimentDetectionJobOutput {
            crate::output::StartSentimentDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartSentimentDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartSentimentDetectionJobOutput`](crate::output::StartSentimentDetectionJobOutput)
    pub fn builder() -> crate::output::start_sentiment_detection_job_output::Builder {
        crate::output::start_sentiment_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartPiiEntitiesDetectionJobOutput {
    /// <p>The identifier generated for the job.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the PII entity detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :pii-entities-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StartPiiEntitiesDetectionJobOutput {
    /// <p>The identifier generated for the job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the PII entity detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :pii-entities-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the job.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StartPiiEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartPiiEntitiesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartPiiEntitiesDetectionJobOutput`](crate::output::StartPiiEntitiesDetectionJobOutput)
pub mod start_pii_entities_detection_job_output {

    /// A builder for [`StartPiiEntitiesDetectionJobOutput`](crate::output::StartPiiEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the PII entity detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :pii-entities-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the PII entity detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :pii-entities-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartPiiEntitiesDetectionJobOutput`](crate::output::StartPiiEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::StartPiiEntitiesDetectionJobOutput {
            crate::output::StartPiiEntitiesDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartPiiEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartPiiEntitiesDetectionJobOutput`](crate::output::StartPiiEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::start_pii_entities_detection_job_output::Builder {
        crate::output::start_pii_entities_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartKeyPhrasesDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the key phrase detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :key-phrases-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StartKeyPhrasesDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the key phrase detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :key-phrases-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// </ul>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StartKeyPhrasesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartKeyPhrasesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartKeyPhrasesDetectionJobOutput`](crate::output::StartKeyPhrasesDetectionJobOutput)
pub mod start_key_phrases_detection_job_output {

    /// A builder for [`StartKeyPhrasesDetectionJobOutput`](crate::output::StartKeyPhrasesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the key phrase detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :key-phrases-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the key phrase detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :key-phrases-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// </ul>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartKeyPhrasesDetectionJobOutput`](crate::output::StartKeyPhrasesDetectionJobOutput)
        pub fn build(self) -> crate::output::StartKeyPhrasesDetectionJobOutput {
            crate::output::StartKeyPhrasesDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartKeyPhrasesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartKeyPhrasesDetectionJobOutput`](crate::output::StartKeyPhrasesDetectionJobOutput)
    pub fn builder() -> crate::output::start_key_phrases_detection_job_output::Builder {
        crate::output::start_key_phrases_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartEventsDetectionJobOutput {
    /// <p>An unique identifier for the request. If you don't set the client request token, Amazon Comprehend generates one.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :events-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the events detection job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StartEventsDetectionJobOutput {
    /// <p>An unique identifier for the request. If you don't set the client request token, Amazon Comprehend generates one.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :events-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the events detection job.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StartEventsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartEventsDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartEventsDetectionJobOutput`](crate::output::StartEventsDetectionJobOutput)
pub mod start_events_detection_job_output {

    /// A builder for [`StartEventsDetectionJobOutput`](crate::output::StartEventsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>An unique identifier for the request. If you don't set the client request token, Amazon Comprehend generates one.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>An unique identifier for the request. If you don't set the client request token, Amazon Comprehend generates one.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :events-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :events-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the events detection job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the events detection job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartEventsDetectionJobOutput`](crate::output::StartEventsDetectionJobOutput)
        pub fn build(self) -> crate::output::StartEventsDetectionJobOutput {
            crate::output::StartEventsDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartEventsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartEventsDetectionJobOutput`](crate::output::StartEventsDetectionJobOutput)
    pub fn builder() -> crate::output::start_events_detection_job_output::Builder {
        crate::output::start_events_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartEntitiesDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with the operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :entities-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// <li> <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is processing the request.</p> </li>
    /// <li> <p>STOPPED - The job was successfully stopped without completing.</p> </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StartEntitiesDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with the operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :entities-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// <li> <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is processing the request.</p> </li>
    /// <li> <p>STOPPED - The job was successfully stopped without completing.</p> </li>
    /// </ul>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StartEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartEntitiesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartEntitiesDetectionJobOutput`](crate::output::StartEntitiesDetectionJobOutput)
pub mod start_entities_detection_job_output {

    /// A builder for [`StartEntitiesDetectionJobOutput`](crate::output::StartEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with the operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with the operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :entities-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :entities-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// <li> <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is processing the request.</p> </li>
        /// <li> <p>STOPPED - The job was successfully stopped without completing.</p> </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// <li> <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is processing the request.</p> </li>
        /// <li> <p>STOPPED - The job was successfully stopped without completing.</p> </li>
        /// </ul>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartEntitiesDetectionJobOutput`](crate::output::StartEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::StartEntitiesDetectionJobOutput {
            crate::output::StartEntitiesDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartEntitiesDetectionJobOutput`](crate::output::StartEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::start_entities_detection_job_output::Builder {
        crate::output::start_entities_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartDominantLanguageDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :dominant-language-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StartDominantLanguageDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :dominant-language-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
    /// </ul>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StartDominantLanguageDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartDominantLanguageDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartDominantLanguageDetectionJobOutput`](crate::output::StartDominantLanguageDetectionJobOutput)
pub mod start_dominant_language_detection_job_output {

    /// A builder for [`StartDominantLanguageDetectionJobOutput`](crate::output::StartDominantLanguageDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :dominant-language-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :dominant-language-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and is queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. To get details, use the operation.</p> </li>
        /// </ul>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartDominantLanguageDetectionJobOutput`](crate::output::StartDominantLanguageDetectionJobOutput)
        pub fn build(self) -> crate::output::StartDominantLanguageDetectionJobOutput {
            crate::output::StartDominantLanguageDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartDominantLanguageDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartDominantLanguageDetectionJobOutput`](crate::output::StartDominantLanguageDetectionJobOutput)
    pub fn builder() -> crate::output::start_dominant_language_detection_job_output::Builder {
        crate::output::start_dominant_language_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartDocumentClassificationJobOutput {
    /// <p>The identifier generated for the job. To get the status of the job, use this identifier with the operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :document-classification-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job:</p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. For details, use the operation.</p> </li>
    /// <li> <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is processing the request.</p> </li>
    /// <li> <p>STOPPED - The job was successfully stopped without completing.</p> </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl StartDocumentClassificationJobOutput {
    /// <p>The identifier generated for the job. To get the status of the job, use this identifier with the operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :document-classification-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The status of the job:</p>
    /// <ul>
    /// <li> <p>SUBMITTED - The job has been received and queued for processing.</p> </li>
    /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
    /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
    /// <li> <p>FAILED - The job did not complete. For details, use the operation.</p> </li>
    /// <li> <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is processing the request.</p> </li>
    /// <li> <p>STOPPED - The job was successfully stopped without completing.</p> </li>
    /// </ul>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
}
impl std::fmt::Debug for StartDocumentClassificationJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartDocumentClassificationJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartDocumentClassificationJobOutput`](crate::output::StartDocumentClassificationJobOutput)
pub mod start_document_classification_job_output {

    /// A builder for [`StartDocumentClassificationJobOutput`](crate::output::StartDocumentClassificationJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of the job, use this identifier with the operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of the job, use this identifier with the operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :document-classification-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :document-classification-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job:</p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. For details, use the operation.</p> </li>
        /// <li> <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is processing the request.</p> </li>
        /// <li> <p>STOPPED - The job was successfully stopped without completing.</p> </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the job:</p>
        /// <ul>
        /// <li> <p>SUBMITTED - The job has been received and queued for processing.</p> </li>
        /// <li> <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p> </li>
        /// <li> <p>COMPLETED - The job was successfully completed and the output is available.</p> </li>
        /// <li> <p>FAILED - The job did not complete. For details, use the operation.</p> </li>
        /// <li> <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is processing the request.</p> </li>
        /// <li> <p>STOPPED - The job was successfully stopped without completing.</p> </li>
        /// </ul>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartDocumentClassificationJobOutput`](crate::output::StartDocumentClassificationJobOutput)
        pub fn build(self) -> crate::output::StartDocumentClassificationJobOutput {
            crate::output::StartDocumentClassificationJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartDocumentClassificationJobOutput {
    /// Creates a new builder-style object to manufacture [`StartDocumentClassificationJobOutput`](crate::output::StartDocumentClassificationJobOutput)
    pub fn builder() -> crate::output::start_document_classification_job_output::Builder {
        crate::output::start_document_classification_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutResourcePolicyOutput {
    /// <p>The revision ID of the policy. Each time you modify a policy, Amazon Comprehend assigns a new revision ID, and it deletes the prior version of the policy.</p>
    pub policy_revision_id: std::option::Option<std::string::String>,
}
impl PutResourcePolicyOutput {
    /// <p>The revision ID of the policy. Each time you modify a policy, Amazon Comprehend assigns a new revision ID, and it deletes the prior version of the policy.</p>
    pub fn policy_revision_id(&self) -> std::option::Option<&str> {
        self.policy_revision_id.as_deref()
    }
}
impl std::fmt::Debug for PutResourcePolicyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutResourcePolicyOutput");
        formatter.field("policy_revision_id", &self.policy_revision_id);
        formatter.finish()
    }
}
/// See [`PutResourcePolicyOutput`](crate::output::PutResourcePolicyOutput)
pub mod put_resource_policy_output {

    /// A builder for [`PutResourcePolicyOutput`](crate::output::PutResourcePolicyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_revision_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The revision ID of the policy. Each time you modify a policy, Amazon Comprehend assigns a new revision ID, and it deletes the prior version of the policy.</p>
        pub fn policy_revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_revision_id = Some(input.into());
            self
        }
        /// <p>The revision ID of the policy. Each time you modify a policy, Amazon Comprehend assigns a new revision ID, and it deletes the prior version of the policy.</p>
        pub fn set_policy_revision_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_revision_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PutResourcePolicyOutput`](crate::output::PutResourcePolicyOutput)
        pub fn build(self) -> crate::output::PutResourcePolicyOutput {
            crate::output::PutResourcePolicyOutput {
                policy_revision_id: self.policy_revision_id,
            }
        }
    }
}
impl PutResourcePolicyOutput {
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyOutput`](crate::output::PutResourcePolicyOutput)
    pub fn builder() -> crate::output::put_resource_policy_output::Builder {
        crate::output::put_resource_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTopicsDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub topics_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::TopicsDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListTopicsDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub fn topics_detection_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::TopicsDetectionJobProperties]> {
        self.topics_detection_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListTopicsDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTopicsDetectionJobsOutput");
        formatter.field(
            "topics_detection_job_properties_list",
            &self.topics_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListTopicsDetectionJobsOutput`](crate::output::ListTopicsDetectionJobsOutput)
pub mod list_topics_detection_jobs_output {

    /// A builder for [`ListTopicsDetectionJobsOutput`](crate::output::ListTopicsDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) topics_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::TopicsDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `topics_detection_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_topics_detection_job_properties_list`](Self::set_topics_detection_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn topics_detection_job_properties_list(
            mut self,
            input: crate::model::TopicsDetectionJobProperties,
        ) -> Self {
            let mut v = self
                .topics_detection_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.topics_detection_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_topics_detection_job_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TopicsDetectionJobProperties>>,
        ) -> Self {
            self.topics_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTopicsDetectionJobsOutput`](crate::output::ListTopicsDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListTopicsDetectionJobsOutput {
            crate::output::ListTopicsDetectionJobsOutput {
                topics_detection_job_properties_list: self.topics_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListTopicsDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListTopicsDetectionJobsOutput`](crate::output::ListTopicsDetectionJobsOutput)
    pub fn builder() -> crate::output::list_topics_detection_jobs_output::Builder {
        crate::output::list_topics_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTargetedSentimentDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub targeted_sentiment_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::TargetedSentimentDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListTargetedSentimentDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub fn targeted_sentiment_detection_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::TargetedSentimentDetectionJobProperties]> {
        self.targeted_sentiment_detection_job_properties_list
            .as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListTargetedSentimentDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTargetedSentimentDetectionJobsOutput");
        formatter.field(
            "targeted_sentiment_detection_job_properties_list",
            &self.targeted_sentiment_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListTargetedSentimentDetectionJobsOutput`](crate::output::ListTargetedSentimentDetectionJobsOutput)
pub mod list_targeted_sentiment_detection_jobs_output {

    /// A builder for [`ListTargetedSentimentDetectionJobsOutput`](crate::output::ListTargetedSentimentDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) targeted_sentiment_detection_job_properties_list: std::option::Option<
            std::vec::Vec<crate::model::TargetedSentimentDetectionJobProperties>,
        >,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `targeted_sentiment_detection_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_targeted_sentiment_detection_job_properties_list`](Self::set_targeted_sentiment_detection_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn targeted_sentiment_detection_job_properties_list(
            mut self,
            input: crate::model::TargetedSentimentDetectionJobProperties,
        ) -> Self {
            let mut v = self
                .targeted_sentiment_detection_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.targeted_sentiment_detection_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_targeted_sentiment_detection_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::TargetedSentimentDetectionJobProperties>,
            >,
        ) -> Self {
            self.targeted_sentiment_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTargetedSentimentDetectionJobsOutput`](crate::output::ListTargetedSentimentDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListTargetedSentimentDetectionJobsOutput {
            crate::output::ListTargetedSentimentDetectionJobsOutput {
                targeted_sentiment_detection_job_properties_list: self
                    .targeted_sentiment_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListTargetedSentimentDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListTargetedSentimentDetectionJobsOutput`](crate::output::ListTargetedSentimentDetectionJobsOutput)
    pub fn builder() -> crate::output::list_targeted_sentiment_detection_jobs_output::Builder {
        crate::output::list_targeted_sentiment_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutput {
    /// <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource you are querying.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>Tags associated with the Amazon Comprehend resource being queried. A tag is a key-value pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the key might be added to a resource to indicate its use by the sales department. </p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl ListTagsForResourceOutput {
    /// <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource you are querying.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>Tags associated with the Amazon Comprehend resource being queried. A tag is a key-value pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the key might be added to a resource to indicate its use by the sales department. </p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for ListTagsForResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
pub mod list_tags_for_resource_output {

    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource you are querying.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource you are querying.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags associated with the Amazon Comprehend resource being queried. A tag is a key-value pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the key might be added to a resource to indicate its use by the sales department. </p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Tags associated with the Amazon Comprehend resource being queried. A tag is a key-value pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with "Sales" as the key might be added to a resource to indicate its use by the sales department. </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            }
        }
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSentimentDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub sentiment_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::SentimentDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListSentimentDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub fn sentiment_detection_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::SentimentDetectionJobProperties]> {
        self.sentiment_detection_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListSentimentDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSentimentDetectionJobsOutput");
        formatter.field(
            "sentiment_detection_job_properties_list",
            &self.sentiment_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListSentimentDetectionJobsOutput`](crate::output::ListSentimentDetectionJobsOutput)
pub mod list_sentiment_detection_jobs_output {

    /// A builder for [`ListSentimentDetectionJobsOutput`](crate::output::ListSentimentDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sentiment_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::SentimentDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `sentiment_detection_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_sentiment_detection_job_properties_list`](Self::set_sentiment_detection_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn sentiment_detection_job_properties_list(
            mut self,
            input: crate::model::SentimentDetectionJobProperties,
        ) -> Self {
            let mut v = self
                .sentiment_detection_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.sentiment_detection_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_sentiment_detection_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::SentimentDetectionJobProperties>,
            >,
        ) -> Self {
            self.sentiment_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSentimentDetectionJobsOutput`](crate::output::ListSentimentDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListSentimentDetectionJobsOutput {
            crate::output::ListSentimentDetectionJobsOutput {
                sentiment_detection_job_properties_list: self
                    .sentiment_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListSentimentDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListSentimentDetectionJobsOutput`](crate::output::ListSentimentDetectionJobsOutput)
    pub fn builder() -> crate::output::list_sentiment_detection_jobs_output::Builder {
        crate::output::list_sentiment_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPiiEntitiesDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub pii_entities_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::PiiEntitiesDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListPiiEntitiesDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub fn pii_entities_detection_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::PiiEntitiesDetectionJobProperties]> {
        self.pii_entities_detection_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListPiiEntitiesDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPiiEntitiesDetectionJobsOutput");
        formatter.field(
            "pii_entities_detection_job_properties_list",
            &self.pii_entities_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListPiiEntitiesDetectionJobsOutput`](crate::output::ListPiiEntitiesDetectionJobsOutput)
pub mod list_pii_entities_detection_jobs_output {

    /// A builder for [`ListPiiEntitiesDetectionJobsOutput`](crate::output::ListPiiEntitiesDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pii_entities_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::PiiEntitiesDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `pii_entities_detection_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_pii_entities_detection_job_properties_list`](Self::set_pii_entities_detection_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn pii_entities_detection_job_properties_list(
            mut self,
            input: crate::model::PiiEntitiesDetectionJobProperties,
        ) -> Self {
            let mut v = self
                .pii_entities_detection_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.pii_entities_detection_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_pii_entities_detection_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::PiiEntitiesDetectionJobProperties>,
            >,
        ) -> Self {
            self.pii_entities_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPiiEntitiesDetectionJobsOutput`](crate::output::ListPiiEntitiesDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListPiiEntitiesDetectionJobsOutput {
            crate::output::ListPiiEntitiesDetectionJobsOutput {
                pii_entities_detection_job_properties_list: self
                    .pii_entities_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListPiiEntitiesDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListPiiEntitiesDetectionJobsOutput`](crate::output::ListPiiEntitiesDetectionJobsOutput)
    pub fn builder() -> crate::output::list_pii_entities_detection_jobs_output::Builder {
        crate::output::list_pii_entities_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListKeyPhrasesDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub key_phrases_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::KeyPhrasesDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListKeyPhrasesDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub fn key_phrases_detection_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::KeyPhrasesDetectionJobProperties]> {
        self.key_phrases_detection_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListKeyPhrasesDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListKeyPhrasesDetectionJobsOutput");
        formatter.field(
            "key_phrases_detection_job_properties_list",
            &self.key_phrases_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListKeyPhrasesDetectionJobsOutput`](crate::output::ListKeyPhrasesDetectionJobsOutput)
pub mod list_key_phrases_detection_jobs_output {

    /// A builder for [`ListKeyPhrasesDetectionJobsOutput`](crate::output::ListKeyPhrasesDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_phrases_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::KeyPhrasesDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `key_phrases_detection_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_key_phrases_detection_job_properties_list`](Self::set_key_phrases_detection_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn key_phrases_detection_job_properties_list(
            mut self,
            input: crate::model::KeyPhrasesDetectionJobProperties,
        ) -> Self {
            let mut v = self
                .key_phrases_detection_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.key_phrases_detection_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_key_phrases_detection_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::KeyPhrasesDetectionJobProperties>,
            >,
        ) -> Self {
            self.key_phrases_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListKeyPhrasesDetectionJobsOutput`](crate::output::ListKeyPhrasesDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListKeyPhrasesDetectionJobsOutput {
            crate::output::ListKeyPhrasesDetectionJobsOutput {
                key_phrases_detection_job_properties_list: self
                    .key_phrases_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListKeyPhrasesDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListKeyPhrasesDetectionJobsOutput`](crate::output::ListKeyPhrasesDetectionJobsOutput)
    pub fn builder() -> crate::output::list_key_phrases_detection_jobs_output::Builder {
        crate::output::list_key_phrases_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEventsDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub events_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::EventsDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListEventsDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub fn events_detection_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::EventsDetectionJobProperties]> {
        self.events_detection_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListEventsDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEventsDetectionJobsOutput");
        formatter.field(
            "events_detection_job_properties_list",
            &self.events_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEventsDetectionJobsOutput`](crate::output::ListEventsDetectionJobsOutput)
pub mod list_events_detection_jobs_output {

    /// A builder for [`ListEventsDetectionJobsOutput`](crate::output::ListEventsDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) events_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::EventsDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `events_detection_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_events_detection_job_properties_list`](Self::set_events_detection_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn events_detection_job_properties_list(
            mut self,
            input: crate::model::EventsDetectionJobProperties,
        ) -> Self {
            let mut v = self
                .events_detection_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.events_detection_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_events_detection_job_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EventsDetectionJobProperties>>,
        ) -> Self {
            self.events_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEventsDetectionJobsOutput`](crate::output::ListEventsDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListEventsDetectionJobsOutput {
            crate::output::ListEventsDetectionJobsOutput {
                events_detection_job_properties_list: self.events_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEventsDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListEventsDetectionJobsOutput`](crate::output::ListEventsDetectionJobsOutput)
    pub fn builder() -> crate::output::list_events_detection_jobs_output::Builder {
        crate::output::list_events_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEntityRecognizerSummariesOutput {
    /// <p>The list entity recognizer summaries.</p>
    pub entity_recognizer_summaries_list:
        std::option::Option<std::vec::Vec<crate::model::EntityRecognizerSummary>>,
    /// <p>The list entity recognizer summaries.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListEntityRecognizerSummariesOutput {
    /// <p>The list entity recognizer summaries.</p>
    pub fn entity_recognizer_summaries_list(
        &self,
    ) -> std::option::Option<&[crate::model::EntityRecognizerSummary]> {
        self.entity_recognizer_summaries_list.as_deref()
    }
    /// <p>The list entity recognizer summaries.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListEntityRecognizerSummariesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEntityRecognizerSummariesOutput");
        formatter.field(
            "entity_recognizer_summaries_list",
            &self.entity_recognizer_summaries_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEntityRecognizerSummariesOutput`](crate::output::ListEntityRecognizerSummariesOutput)
pub mod list_entity_recognizer_summaries_output {

    /// A builder for [`ListEntityRecognizerSummariesOutput`](crate::output::ListEntityRecognizerSummariesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_recognizer_summaries_list:
            std::option::Option<std::vec::Vec<crate::model::EntityRecognizerSummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entity_recognizer_summaries_list`.
        ///
        /// To override the contents of this collection use [`set_entity_recognizer_summaries_list`](Self::set_entity_recognizer_summaries_list).
        ///
        /// <p>The list entity recognizer summaries.</p>
        pub fn entity_recognizer_summaries_list(
            mut self,
            input: crate::model::EntityRecognizerSummary,
        ) -> Self {
            let mut v = self.entity_recognizer_summaries_list.unwrap_or_default();
            v.push(input);
            self.entity_recognizer_summaries_list = Some(v);
            self
        }
        /// <p>The list entity recognizer summaries.</p>
        pub fn set_entity_recognizer_summaries_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntityRecognizerSummary>>,
        ) -> Self {
            self.entity_recognizer_summaries_list = input;
            self
        }
        /// <p>The list entity recognizer summaries.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The list entity recognizer summaries.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEntityRecognizerSummariesOutput`](crate::output::ListEntityRecognizerSummariesOutput)
        pub fn build(self) -> crate::output::ListEntityRecognizerSummariesOutput {
            crate::output::ListEntityRecognizerSummariesOutput {
                entity_recognizer_summaries_list: self.entity_recognizer_summaries_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEntityRecognizerSummariesOutput {
    /// Creates a new builder-style object to manufacture [`ListEntityRecognizerSummariesOutput`](crate::output::ListEntityRecognizerSummariesOutput)
    pub fn builder() -> crate::output::list_entity_recognizer_summaries_output::Builder {
        crate::output::list_entity_recognizer_summaries_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEntityRecognizersOutput {
    /// <p>The list of properties of an entity recognizer.</p>
    pub entity_recognizer_properties_list:
        std::option::Option<std::vec::Vec<crate::model::EntityRecognizerProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListEntityRecognizersOutput {
    /// <p>The list of properties of an entity recognizer.</p>
    pub fn entity_recognizer_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::EntityRecognizerProperties]> {
        self.entity_recognizer_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListEntityRecognizersOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEntityRecognizersOutput");
        formatter.field(
            "entity_recognizer_properties_list",
            &self.entity_recognizer_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEntityRecognizersOutput`](crate::output::ListEntityRecognizersOutput)
pub mod list_entity_recognizers_output {

    /// A builder for [`ListEntityRecognizersOutput`](crate::output::ListEntityRecognizersOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_recognizer_properties_list:
            std::option::Option<std::vec::Vec<crate::model::EntityRecognizerProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entity_recognizer_properties_list`.
        ///
        /// To override the contents of this collection use [`set_entity_recognizer_properties_list`](Self::set_entity_recognizer_properties_list).
        ///
        /// <p>The list of properties of an entity recognizer.</p>
        pub fn entity_recognizer_properties_list(
            mut self,
            input: crate::model::EntityRecognizerProperties,
        ) -> Self {
            let mut v = self.entity_recognizer_properties_list.unwrap_or_default();
            v.push(input);
            self.entity_recognizer_properties_list = Some(v);
            self
        }
        /// <p>The list of properties of an entity recognizer.</p>
        pub fn set_entity_recognizer_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntityRecognizerProperties>>,
        ) -> Self {
            self.entity_recognizer_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEntityRecognizersOutput`](crate::output::ListEntityRecognizersOutput)
        pub fn build(self) -> crate::output::ListEntityRecognizersOutput {
            crate::output::ListEntityRecognizersOutput {
                entity_recognizer_properties_list: self.entity_recognizer_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEntityRecognizersOutput {
    /// Creates a new builder-style object to manufacture [`ListEntityRecognizersOutput`](crate::output::ListEntityRecognizersOutput)
    pub fn builder() -> crate::output::list_entity_recognizers_output::Builder {
        crate::output::list_entity_recognizers_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEntitiesDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub entities_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::EntitiesDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListEntitiesDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub fn entities_detection_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::EntitiesDetectionJobProperties]> {
        self.entities_detection_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListEntitiesDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEntitiesDetectionJobsOutput");
        formatter.field(
            "entities_detection_job_properties_list",
            &self.entities_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEntitiesDetectionJobsOutput`](crate::output::ListEntitiesDetectionJobsOutput)
pub mod list_entities_detection_jobs_output {

    /// A builder for [`ListEntitiesDetectionJobsOutput`](crate::output::ListEntitiesDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::EntitiesDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities_detection_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_entities_detection_job_properties_list`](Self::set_entities_detection_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn entities_detection_job_properties_list(
            mut self,
            input: crate::model::EntitiesDetectionJobProperties,
        ) -> Self {
            let mut v = self
                .entities_detection_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.entities_detection_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_entities_detection_job_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntitiesDetectionJobProperties>>,
        ) -> Self {
            self.entities_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEntitiesDetectionJobsOutput`](crate::output::ListEntitiesDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListEntitiesDetectionJobsOutput {
            crate::output::ListEntitiesDetectionJobsOutput {
                entities_detection_job_properties_list: self.entities_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEntitiesDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListEntitiesDetectionJobsOutput`](crate::output::ListEntitiesDetectionJobsOutput)
    pub fn builder() -> crate::output::list_entities_detection_jobs_output::Builder {
        crate::output::list_entities_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEndpointsOutput {
    /// <p>Displays a list of endpoint properties being retrieved by the service in response to the request.</p>
    pub endpoint_properties_list:
        std::option::Option<std::vec::Vec<crate::model::EndpointProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListEndpointsOutput {
    /// <p>Displays a list of endpoint properties being retrieved by the service in response to the request.</p>
    pub fn endpoint_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::EndpointProperties]> {
        self.endpoint_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListEndpointsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEndpointsOutput");
        formatter.field("endpoint_properties_list", &self.endpoint_properties_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEndpointsOutput`](crate::output::ListEndpointsOutput)
pub mod list_endpoints_output {

    /// A builder for [`ListEndpointsOutput`](crate::output::ListEndpointsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_properties_list:
            std::option::Option<std::vec::Vec<crate::model::EndpointProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `endpoint_properties_list`.
        ///
        /// To override the contents of this collection use [`set_endpoint_properties_list`](Self::set_endpoint_properties_list).
        ///
        /// <p>Displays a list of endpoint properties being retrieved by the service in response to the request.</p>
        pub fn endpoint_properties_list(mut self, input: crate::model::EndpointProperties) -> Self {
            let mut v = self.endpoint_properties_list.unwrap_or_default();
            v.push(input);
            self.endpoint_properties_list = Some(v);
            self
        }
        /// <p>Displays a list of endpoint properties being retrieved by the service in response to the request.</p>
        pub fn set_endpoint_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndpointProperties>>,
        ) -> Self {
            self.endpoint_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEndpointsOutput`](crate::output::ListEndpointsOutput)
        pub fn build(self) -> crate::output::ListEndpointsOutput {
            crate::output::ListEndpointsOutput {
                endpoint_properties_list: self.endpoint_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEndpointsOutput {
    /// Creates a new builder-style object to manufacture [`ListEndpointsOutput`](crate::output::ListEndpointsOutput)
    pub fn builder() -> crate::output::list_endpoints_output::Builder {
        crate::output::list_endpoints_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDominantLanguageDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub dominant_language_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::DominantLanguageDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDominantLanguageDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub fn dominant_language_detection_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::DominantLanguageDetectionJobProperties]> {
        self.dominant_language_detection_job_properties_list
            .as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListDominantLanguageDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDominantLanguageDetectionJobsOutput");
        formatter.field(
            "dominant_language_detection_job_properties_list",
            &self.dominant_language_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListDominantLanguageDetectionJobsOutput`](crate::output::ListDominantLanguageDetectionJobsOutput)
pub mod list_dominant_language_detection_jobs_output {

    /// A builder for [`ListDominantLanguageDetectionJobsOutput`](crate::output::ListDominantLanguageDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dominant_language_detection_job_properties_list: std::option::Option<
            std::vec::Vec<crate::model::DominantLanguageDetectionJobProperties>,
        >,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `dominant_language_detection_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_dominant_language_detection_job_properties_list`](Self::set_dominant_language_detection_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn dominant_language_detection_job_properties_list(
            mut self,
            input: crate::model::DominantLanguageDetectionJobProperties,
        ) -> Self {
            let mut v = self
                .dominant_language_detection_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.dominant_language_detection_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_dominant_language_detection_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::DominantLanguageDetectionJobProperties>,
            >,
        ) -> Self {
            self.dominant_language_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDominantLanguageDetectionJobsOutput`](crate::output::ListDominantLanguageDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListDominantLanguageDetectionJobsOutput {
            crate::output::ListDominantLanguageDetectionJobsOutput {
                dominant_language_detection_job_properties_list: self
                    .dominant_language_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListDominantLanguageDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListDominantLanguageDetectionJobsOutput`](crate::output::ListDominantLanguageDetectionJobsOutput)
    pub fn builder() -> crate::output::list_dominant_language_detection_jobs_output::Builder {
        crate::output::list_dominant_language_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentClassifierSummariesOutput {
    /// <p>The list of summaries of document classifiers.</p>
    pub document_classifier_summaries_list:
        std::option::Option<std::vec::Vec<crate::model::DocumentClassifierSummary>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDocumentClassifierSummariesOutput {
    /// <p>The list of summaries of document classifiers.</p>
    pub fn document_classifier_summaries_list(
        &self,
    ) -> std::option::Option<&[crate::model::DocumentClassifierSummary]> {
        self.document_classifier_summaries_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListDocumentClassifierSummariesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentClassifierSummariesOutput");
        formatter.field(
            "document_classifier_summaries_list",
            &self.document_classifier_summaries_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListDocumentClassifierSummariesOutput`](crate::output::ListDocumentClassifierSummariesOutput)
pub mod list_document_classifier_summaries_output {

    /// A builder for [`ListDocumentClassifierSummariesOutput`](crate::output::ListDocumentClassifierSummariesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classifier_summaries_list:
            std::option::Option<std::vec::Vec<crate::model::DocumentClassifierSummary>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `document_classifier_summaries_list`.
        ///
        /// To override the contents of this collection use [`set_document_classifier_summaries_list`](Self::set_document_classifier_summaries_list).
        ///
        /// <p>The list of summaries of document classifiers.</p>
        pub fn document_classifier_summaries_list(
            mut self,
            input: crate::model::DocumentClassifierSummary,
        ) -> Self {
            let mut v = self.document_classifier_summaries_list.unwrap_or_default();
            v.push(input);
            self.document_classifier_summaries_list = Some(v);
            self
        }
        /// <p>The list of summaries of document classifiers.</p>
        pub fn set_document_classifier_summaries_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentClassifierSummary>>,
        ) -> Self {
            self.document_classifier_summaries_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDocumentClassifierSummariesOutput`](crate::output::ListDocumentClassifierSummariesOutput)
        pub fn build(self) -> crate::output::ListDocumentClassifierSummariesOutput {
            crate::output::ListDocumentClassifierSummariesOutput {
                document_classifier_summaries_list: self.document_classifier_summaries_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListDocumentClassifierSummariesOutput {
    /// Creates a new builder-style object to manufacture [`ListDocumentClassifierSummariesOutput`](crate::output::ListDocumentClassifierSummariesOutput)
    pub fn builder() -> crate::output::list_document_classifier_summaries_output::Builder {
        crate::output::list_document_classifier_summaries_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentClassifiersOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub document_classifier_properties_list:
        std::option::Option<std::vec::Vec<crate::model::DocumentClassifierProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDocumentClassifiersOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub fn document_classifier_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::DocumentClassifierProperties]> {
        self.document_classifier_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListDocumentClassifiersOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentClassifiersOutput");
        formatter.field(
            "document_classifier_properties_list",
            &self.document_classifier_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListDocumentClassifiersOutput`](crate::output::ListDocumentClassifiersOutput)
pub mod list_document_classifiers_output {

    /// A builder for [`ListDocumentClassifiersOutput`](crate::output::ListDocumentClassifiersOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classifier_properties_list:
            std::option::Option<std::vec::Vec<crate::model::DocumentClassifierProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `document_classifier_properties_list`.
        ///
        /// To override the contents of this collection use [`set_document_classifier_properties_list`](Self::set_document_classifier_properties_list).
        ///
        /// <p>A list containing the properties of each job returned.</p>
        pub fn document_classifier_properties_list(
            mut self,
            input: crate::model::DocumentClassifierProperties,
        ) -> Self {
            let mut v = self.document_classifier_properties_list.unwrap_or_default();
            v.push(input);
            self.document_classifier_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job returned.</p>
        pub fn set_document_classifier_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentClassifierProperties>>,
        ) -> Self {
            self.document_classifier_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDocumentClassifiersOutput`](crate::output::ListDocumentClassifiersOutput)
        pub fn build(self) -> crate::output::ListDocumentClassifiersOutput {
            crate::output::ListDocumentClassifiersOutput {
                document_classifier_properties_list: self.document_classifier_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListDocumentClassifiersOutput {
    /// Creates a new builder-style object to manufacture [`ListDocumentClassifiersOutput`](crate::output::ListDocumentClassifiersOutput)
    pub fn builder() -> crate::output::list_document_classifiers_output::Builder {
        crate::output::list_document_classifiers_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentClassificationJobsOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub document_classification_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::DocumentClassificationJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDocumentClassificationJobsOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub fn document_classification_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::DocumentClassificationJobProperties]> {
        self.document_classification_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListDocumentClassificationJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentClassificationJobsOutput");
        formatter.field(
            "document_classification_job_properties_list",
            &self.document_classification_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListDocumentClassificationJobsOutput`](crate::output::ListDocumentClassificationJobsOutput)
pub mod list_document_classification_jobs_output {

    /// A builder for [`ListDocumentClassificationJobsOutput`](crate::output::ListDocumentClassificationJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classification_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::DocumentClassificationJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `document_classification_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_document_classification_job_properties_list`](Self::set_document_classification_job_properties_list).
        ///
        /// <p>A list containing the properties of each job returned.</p>
        pub fn document_classification_job_properties_list(
            mut self,
            input: crate::model::DocumentClassificationJobProperties,
        ) -> Self {
            let mut v = self
                .document_classification_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.document_classification_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job returned.</p>
        pub fn set_document_classification_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::DocumentClassificationJobProperties>,
            >,
        ) -> Self {
            self.document_classification_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDocumentClassificationJobsOutput`](crate::output::ListDocumentClassificationJobsOutput)
        pub fn build(self) -> crate::output::ListDocumentClassificationJobsOutput {
            crate::output::ListDocumentClassificationJobsOutput {
                document_classification_job_properties_list: self
                    .document_classification_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListDocumentClassificationJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListDocumentClassificationJobsOutput`](crate::output::ListDocumentClassificationJobsOutput)
    pub fn builder() -> crate::output::list_document_classification_jobs_output::Builder {
        crate::output::list_document_classification_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportModelOutput {
    /// <p>The Amazon Resource Name (ARN) of the custom model being imported.</p>
    pub model_arn: std::option::Option<std::string::String>,
}
impl ImportModelOutput {
    /// <p>The Amazon Resource Name (ARN) of the custom model being imported.</p>
    pub fn model_arn(&self) -> std::option::Option<&str> {
        self.model_arn.as_deref()
    }
}
impl std::fmt::Debug for ImportModelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportModelOutput");
        formatter.field("model_arn", &self.model_arn);
        formatter.finish()
    }
}
/// See [`ImportModelOutput`](crate::output::ImportModelOutput)
pub mod import_model_output {

    /// A builder for [`ImportModelOutput`](crate::output::ImportModelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the custom model being imported.</p>
        pub fn model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the custom model being imported.</p>
        pub fn set_model_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportModelOutput`](crate::output::ImportModelOutput)
        pub fn build(self) -> crate::output::ImportModelOutput {
            crate::output::ImportModelOutput {
                model_arn: self.model_arn,
            }
        }
    }
}
impl ImportModelOutput {
    /// Creates a new builder-style object to manufacture [`ImportModelOutput`](crate::output::ImportModelOutput)
    pub fn builder() -> crate::output::import_model_output::Builder {
        crate::output::import_model_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectSyntaxOutput {
    /// <p>A collection of syntax tokens describing the text. For each token, the response provides the text, the token type, where the text begins and ends, and the level of confidence that Amazon Comprehend has that the token is correct. For a list of token types, see <code>how-syntax</code>.</p>
    pub syntax_tokens: std::option::Option<std::vec::Vec<crate::model::SyntaxToken>>,
}
impl DetectSyntaxOutput {
    /// <p>A collection of syntax tokens describing the text. For each token, the response provides the text, the token type, where the text begins and ends, and the level of confidence that Amazon Comprehend has that the token is correct. For a list of token types, see <code>how-syntax</code>.</p>
    pub fn syntax_tokens(&self) -> std::option::Option<&[crate::model::SyntaxToken]> {
        self.syntax_tokens.as_deref()
    }
}
impl std::fmt::Debug for DetectSyntaxOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectSyntaxOutput");
        formatter.field("syntax_tokens", &self.syntax_tokens);
        formatter.finish()
    }
}
/// See [`DetectSyntaxOutput`](crate::output::DetectSyntaxOutput)
pub mod detect_syntax_output {

    /// A builder for [`DetectSyntaxOutput`](crate::output::DetectSyntaxOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) syntax_tokens: std::option::Option<std::vec::Vec<crate::model::SyntaxToken>>,
    }
    impl Builder {
        /// Appends an item to `syntax_tokens`.
        ///
        /// To override the contents of this collection use [`set_syntax_tokens`](Self::set_syntax_tokens).
        ///
        /// <p>A collection of syntax tokens describing the text. For each token, the response provides the text, the token type, where the text begins and ends, and the level of confidence that Amazon Comprehend has that the token is correct. For a list of token types, see <code>how-syntax</code>.</p>
        pub fn syntax_tokens(mut self, input: crate::model::SyntaxToken) -> Self {
            let mut v = self.syntax_tokens.unwrap_or_default();
            v.push(input);
            self.syntax_tokens = Some(v);
            self
        }
        /// <p>A collection of syntax tokens describing the text. For each token, the response provides the text, the token type, where the text begins and ends, and the level of confidence that Amazon Comprehend has that the token is correct. For a list of token types, see <code>how-syntax</code>.</p>
        pub fn set_syntax_tokens(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SyntaxToken>>,
        ) -> Self {
            self.syntax_tokens = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectSyntaxOutput`](crate::output::DetectSyntaxOutput)
        pub fn build(self) -> crate::output::DetectSyntaxOutput {
            crate::output::DetectSyntaxOutput {
                syntax_tokens: self.syntax_tokens,
            }
        }
    }
}
impl DetectSyntaxOutput {
    /// Creates a new builder-style object to manufacture [`DetectSyntaxOutput`](crate::output::DetectSyntaxOutput)
    pub fn builder() -> crate::output::detect_syntax_output::Builder {
        crate::output::detect_syntax_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectSentimentOutput {
    /// <p>The inferred sentiment that Amazon Comprehend has the highest level of confidence in.</p>
    pub sentiment: std::option::Option<crate::model::SentimentType>,
    /// <p>An object that lists the sentiments, and their corresponding confidence levels.</p>
    pub sentiment_score: std::option::Option<crate::model::SentimentScore>,
}
impl DetectSentimentOutput {
    /// <p>The inferred sentiment that Amazon Comprehend has the highest level of confidence in.</p>
    pub fn sentiment(&self) -> std::option::Option<&crate::model::SentimentType> {
        self.sentiment.as_ref()
    }
    /// <p>An object that lists the sentiments, and their corresponding confidence levels.</p>
    pub fn sentiment_score(&self) -> std::option::Option<&crate::model::SentimentScore> {
        self.sentiment_score.as_ref()
    }
}
impl std::fmt::Debug for DetectSentimentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectSentimentOutput");
        formatter.field("sentiment", &self.sentiment);
        formatter.field("sentiment_score", &self.sentiment_score);
        formatter.finish()
    }
}
/// See [`DetectSentimentOutput`](crate::output::DetectSentimentOutput)
pub mod detect_sentiment_output {

    /// A builder for [`DetectSentimentOutput`](crate::output::DetectSentimentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sentiment: std::option::Option<crate::model::SentimentType>,
        pub(crate) sentiment_score: std::option::Option<crate::model::SentimentScore>,
    }
    impl Builder {
        /// <p>The inferred sentiment that Amazon Comprehend has the highest level of confidence in.</p>
        pub fn sentiment(mut self, input: crate::model::SentimentType) -> Self {
            self.sentiment = Some(input);
            self
        }
        /// <p>The inferred sentiment that Amazon Comprehend has the highest level of confidence in.</p>
        pub fn set_sentiment(
            mut self,
            input: std::option::Option<crate::model::SentimentType>,
        ) -> Self {
            self.sentiment = input;
            self
        }
        /// <p>An object that lists the sentiments, and their corresponding confidence levels.</p>
        pub fn sentiment_score(mut self, input: crate::model::SentimentScore) -> Self {
            self.sentiment_score = Some(input);
            self
        }
        /// <p>An object that lists the sentiments, and their corresponding confidence levels.</p>
        pub fn set_sentiment_score(
            mut self,
            input: std::option::Option<crate::model::SentimentScore>,
        ) -> Self {
            self.sentiment_score = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectSentimentOutput`](crate::output::DetectSentimentOutput)
        pub fn build(self) -> crate::output::DetectSentimentOutput {
            crate::output::DetectSentimentOutput {
                sentiment: self.sentiment,
                sentiment_score: self.sentiment_score,
            }
        }
    }
}
impl DetectSentimentOutput {
    /// Creates a new builder-style object to manufacture [`DetectSentimentOutput`](crate::output::DetectSentimentOutput)
    pub fn builder() -> crate::output::detect_sentiment_output::Builder {
        crate::output::detect_sentiment_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectPiiEntitiesOutput {
    /// <p>A collection of PII entities identified in the input text. For each entity, the response provides the entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::PiiEntity>>,
}
impl DetectPiiEntitiesOutput {
    /// <p>A collection of PII entities identified in the input text. For each entity, the response provides the entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::PiiEntity]> {
        self.entities.as_deref()
    }
}
impl std::fmt::Debug for DetectPiiEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectPiiEntitiesOutput");
        formatter.field("entities", &self.entities);
        formatter.finish()
    }
}
/// See [`DetectPiiEntitiesOutput`](crate::output::DetectPiiEntitiesOutput)
pub mod detect_pii_entities_output {

    /// A builder for [`DetectPiiEntitiesOutput`](crate::output::DetectPiiEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::PiiEntity>>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>A collection of PII entities identified in the input text. For each entity, the response provides the entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection.</p>
        pub fn entities(mut self, input: crate::model::PiiEntity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>A collection of PII entities identified in the input text. For each entity, the response provides the entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PiiEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectPiiEntitiesOutput`](crate::output::DetectPiiEntitiesOutput)
        pub fn build(self) -> crate::output::DetectPiiEntitiesOutput {
            crate::output::DetectPiiEntitiesOutput {
                entities: self.entities,
            }
        }
    }
}
impl DetectPiiEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`DetectPiiEntitiesOutput`](crate::output::DetectPiiEntitiesOutput)
    pub fn builder() -> crate::output::detect_pii_entities_output::Builder {
        crate::output::detect_pii_entities_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectKeyPhrasesOutput {
    /// <p>A collection of key phrases that Amazon Comprehend identified in the input text. For each key phrase, the response provides the text of the key phrase, where the key phrase begins and ends, and the level of confidence that Amazon Comprehend has in the accuracy of the detection. </p>
    pub key_phrases: std::option::Option<std::vec::Vec<crate::model::KeyPhrase>>,
}
impl DetectKeyPhrasesOutput {
    /// <p>A collection of key phrases that Amazon Comprehend identified in the input text. For each key phrase, the response provides the text of the key phrase, where the key phrase begins and ends, and the level of confidence that Amazon Comprehend has in the accuracy of the detection. </p>
    pub fn key_phrases(&self) -> std::option::Option<&[crate::model::KeyPhrase]> {
        self.key_phrases.as_deref()
    }
}
impl std::fmt::Debug for DetectKeyPhrasesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectKeyPhrasesOutput");
        formatter.field("key_phrases", &self.key_phrases);
        formatter.finish()
    }
}
/// See [`DetectKeyPhrasesOutput`](crate::output::DetectKeyPhrasesOutput)
pub mod detect_key_phrases_output {

    /// A builder for [`DetectKeyPhrasesOutput`](crate::output::DetectKeyPhrasesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_phrases: std::option::Option<std::vec::Vec<crate::model::KeyPhrase>>,
    }
    impl Builder {
        /// Appends an item to `key_phrases`.
        ///
        /// To override the contents of this collection use [`set_key_phrases`](Self::set_key_phrases).
        ///
        /// <p>A collection of key phrases that Amazon Comprehend identified in the input text. For each key phrase, the response provides the text of the key phrase, where the key phrase begins and ends, and the level of confidence that Amazon Comprehend has in the accuracy of the detection. </p>
        pub fn key_phrases(mut self, input: crate::model::KeyPhrase) -> Self {
            let mut v = self.key_phrases.unwrap_or_default();
            v.push(input);
            self.key_phrases = Some(v);
            self
        }
        /// <p>A collection of key phrases that Amazon Comprehend identified in the input text. For each key phrase, the response provides the text of the key phrase, where the key phrase begins and ends, and the level of confidence that Amazon Comprehend has in the accuracy of the detection. </p>
        pub fn set_key_phrases(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::KeyPhrase>>,
        ) -> Self {
            self.key_phrases = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectKeyPhrasesOutput`](crate::output::DetectKeyPhrasesOutput)
        pub fn build(self) -> crate::output::DetectKeyPhrasesOutput {
            crate::output::DetectKeyPhrasesOutput {
                key_phrases: self.key_phrases,
            }
        }
    }
}
impl DetectKeyPhrasesOutput {
    /// Creates a new builder-style object to manufacture [`DetectKeyPhrasesOutput`](crate::output::DetectKeyPhrasesOutput)
    pub fn builder() -> crate::output::detect_key_phrases_output::Builder {
        crate::output::detect_key_phrases_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectEntitiesOutput {
    /// <p>A collection of entities identified in the input text. For each entity, the response provides the entity text, entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection. </p>
    /// <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the entities that the model is trained to recognize. Otherwise, it detects the default entity types. For a list of default entity types, see <code>how-entities</code>.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
}
impl DetectEntitiesOutput {
    /// <p>A collection of entities identified in the input text. For each entity, the response provides the entity text, entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection. </p>
    /// <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the entities that the model is trained to recognize. Otherwise, it detects the default entity types. For a list of default entity types, see <code>how-entities</code>.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.entities.as_deref()
    }
}
impl std::fmt::Debug for DetectEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectEntitiesOutput");
        formatter.field("entities", &self.entities);
        formatter.finish()
    }
}
/// See [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
pub mod detect_entities_output {

    /// A builder for [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>A collection of entities identified in the input text. For each entity, the response provides the entity text, entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection. </p>
        /// <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the entities that the model is trained to recognize. Otherwise, it detects the default entity types. For a list of default entity types, see <code>how-entities</code>.</p>
        pub fn entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>A collection of entities identified in the input text. For each entity, the response provides the entity text, entity type, where the entity text begins and ends, and the level of confidence that Amazon Comprehend has in the detection. </p>
        /// <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the entities that the model is trained to recognize. Otherwise, it detects the default entity types. For a list of default entity types, see <code>how-entities</code>.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
        pub fn build(self) -> crate::output::DetectEntitiesOutput {
            crate::output::DetectEntitiesOutput {
                entities: self.entities,
            }
        }
    }
}
impl DetectEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
    pub fn builder() -> crate::output::detect_entities_output::Builder {
        crate::output::detect_entities_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectDominantLanguageOutput {
    /// <p>The languages that Amazon Comprehend detected in the input text. For each language, the response returns the RFC 5646 language code and the level of confidence that Amazon Comprehend has in the accuracy of its inference. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the <i>IETF Tools</i> web site.</p>
    pub languages: std::option::Option<std::vec::Vec<crate::model::DominantLanguage>>,
}
impl DetectDominantLanguageOutput {
    /// <p>The languages that Amazon Comprehend detected in the input text. For each language, the response returns the RFC 5646 language code and the level of confidence that Amazon Comprehend has in the accuracy of its inference. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the <i>IETF Tools</i> web site.</p>
    pub fn languages(&self) -> std::option::Option<&[crate::model::DominantLanguage]> {
        self.languages.as_deref()
    }
}
impl std::fmt::Debug for DetectDominantLanguageOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectDominantLanguageOutput");
        formatter.field("languages", &self.languages);
        formatter.finish()
    }
}
/// See [`DetectDominantLanguageOutput`](crate::output::DetectDominantLanguageOutput)
pub mod detect_dominant_language_output {

    /// A builder for [`DetectDominantLanguageOutput`](crate::output::DetectDominantLanguageOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) languages: std::option::Option<std::vec::Vec<crate::model::DominantLanguage>>,
    }
    impl Builder {
        /// Appends an item to `languages`.
        ///
        /// To override the contents of this collection use [`set_languages`](Self::set_languages).
        ///
        /// <p>The languages that Amazon Comprehend detected in the input text. For each language, the response returns the RFC 5646 language code and the level of confidence that Amazon Comprehend has in the accuracy of its inference. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the <i>IETF Tools</i> web site.</p>
        pub fn languages(mut self, input: crate::model::DominantLanguage) -> Self {
            let mut v = self.languages.unwrap_or_default();
            v.push(input);
            self.languages = Some(v);
            self
        }
        /// <p>The languages that Amazon Comprehend detected in the input text. For each language, the response returns the RFC 5646 language code and the level of confidence that Amazon Comprehend has in the accuracy of its inference. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the <i>IETF Tools</i> web site.</p>
        pub fn set_languages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DominantLanguage>>,
        ) -> Self {
            self.languages = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectDominantLanguageOutput`](crate::output::DetectDominantLanguageOutput)
        pub fn build(self) -> crate::output::DetectDominantLanguageOutput {
            crate::output::DetectDominantLanguageOutput {
                languages: self.languages,
            }
        }
    }
}
impl DetectDominantLanguageOutput {
    /// Creates a new builder-style object to manufacture [`DetectDominantLanguageOutput`](crate::output::DetectDominantLanguageOutput)
    pub fn builder() -> crate::output::detect_dominant_language_output::Builder {
        crate::output::detect_dominant_language_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTopicsDetectionJobOutput {
    /// <p>The list of properties for the requested job.</p>
    pub topics_detection_job_properties:
        std::option::Option<crate::model::TopicsDetectionJobProperties>,
}
impl DescribeTopicsDetectionJobOutput {
    /// <p>The list of properties for the requested job.</p>
    pub fn topics_detection_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::TopicsDetectionJobProperties> {
        self.topics_detection_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeTopicsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTopicsDetectionJobOutput");
        formatter.field(
            "topics_detection_job_properties",
            &self.topics_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeTopicsDetectionJobOutput`](crate::output::DescribeTopicsDetectionJobOutput)
pub mod describe_topics_detection_job_output {

    /// A builder for [`DescribeTopicsDetectionJobOutput`](crate::output::DescribeTopicsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) topics_detection_job_properties:
            std::option::Option<crate::model::TopicsDetectionJobProperties>,
    }
    impl Builder {
        /// <p>The list of properties for the requested job.</p>
        pub fn topics_detection_job_properties(
            mut self,
            input: crate::model::TopicsDetectionJobProperties,
        ) -> Self {
            self.topics_detection_job_properties = Some(input);
            self
        }
        /// <p>The list of properties for the requested job.</p>
        pub fn set_topics_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::TopicsDetectionJobProperties>,
        ) -> Self {
            self.topics_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeTopicsDetectionJobOutput`](crate::output::DescribeTopicsDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeTopicsDetectionJobOutput {
            crate::output::DescribeTopicsDetectionJobOutput {
                topics_detection_job_properties: self.topics_detection_job_properties,
            }
        }
    }
}
impl DescribeTopicsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeTopicsDetectionJobOutput`](crate::output::DescribeTopicsDetectionJobOutput)
    pub fn builder() -> crate::output::describe_topics_detection_job_output::Builder {
        crate::output::describe_topics_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTargetedSentimentDetectionJobOutput {
    /// <p>An object that contains the properties associated with a targeted sentiment detection job.</p>
    pub targeted_sentiment_detection_job_properties:
        std::option::Option<crate::model::TargetedSentimentDetectionJobProperties>,
}
impl DescribeTargetedSentimentDetectionJobOutput {
    /// <p>An object that contains the properties associated with a targeted sentiment detection job.</p>
    pub fn targeted_sentiment_detection_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::TargetedSentimentDetectionJobProperties> {
        self.targeted_sentiment_detection_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeTargetedSentimentDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTargetedSentimentDetectionJobOutput");
        formatter.field(
            "targeted_sentiment_detection_job_properties",
            &self.targeted_sentiment_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeTargetedSentimentDetectionJobOutput`](crate::output::DescribeTargetedSentimentDetectionJobOutput)
pub mod describe_targeted_sentiment_detection_job_output {

    /// A builder for [`DescribeTargetedSentimentDetectionJobOutput`](crate::output::DescribeTargetedSentimentDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) targeted_sentiment_detection_job_properties:
            std::option::Option<crate::model::TargetedSentimentDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a targeted sentiment detection job.</p>
        pub fn targeted_sentiment_detection_job_properties(
            mut self,
            input: crate::model::TargetedSentimentDetectionJobProperties,
        ) -> Self {
            self.targeted_sentiment_detection_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a targeted sentiment detection job.</p>
        pub fn set_targeted_sentiment_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::TargetedSentimentDetectionJobProperties>,
        ) -> Self {
            self.targeted_sentiment_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeTargetedSentimentDetectionJobOutput`](crate::output::DescribeTargetedSentimentDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeTargetedSentimentDetectionJobOutput {
            crate::output::DescribeTargetedSentimentDetectionJobOutput {
                targeted_sentiment_detection_job_properties: self
                    .targeted_sentiment_detection_job_properties,
            }
        }
    }
}
impl DescribeTargetedSentimentDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeTargetedSentimentDetectionJobOutput`](crate::output::DescribeTargetedSentimentDetectionJobOutput)
    pub fn builder() -> crate::output::describe_targeted_sentiment_detection_job_output::Builder {
        crate::output::describe_targeted_sentiment_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSentimentDetectionJobOutput {
    /// <p>An object that contains the properties associated with a sentiment detection job.</p>
    pub sentiment_detection_job_properties:
        std::option::Option<crate::model::SentimentDetectionJobProperties>,
}
impl DescribeSentimentDetectionJobOutput {
    /// <p>An object that contains the properties associated with a sentiment detection job.</p>
    pub fn sentiment_detection_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::SentimentDetectionJobProperties> {
        self.sentiment_detection_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeSentimentDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSentimentDetectionJobOutput");
        formatter.field(
            "sentiment_detection_job_properties",
            &self.sentiment_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeSentimentDetectionJobOutput`](crate::output::DescribeSentimentDetectionJobOutput)
pub mod describe_sentiment_detection_job_output {

    /// A builder for [`DescribeSentimentDetectionJobOutput`](crate::output::DescribeSentimentDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sentiment_detection_job_properties:
            std::option::Option<crate::model::SentimentDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a sentiment detection job.</p>
        pub fn sentiment_detection_job_properties(
            mut self,
            input: crate::model::SentimentDetectionJobProperties,
        ) -> Self {
            self.sentiment_detection_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a sentiment detection job.</p>
        pub fn set_sentiment_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::SentimentDetectionJobProperties>,
        ) -> Self {
            self.sentiment_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSentimentDetectionJobOutput`](crate::output::DescribeSentimentDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeSentimentDetectionJobOutput {
            crate::output::DescribeSentimentDetectionJobOutput {
                sentiment_detection_job_properties: self.sentiment_detection_job_properties,
            }
        }
    }
}
impl DescribeSentimentDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeSentimentDetectionJobOutput`](crate::output::DescribeSentimentDetectionJobOutput)
    pub fn builder() -> crate::output::describe_sentiment_detection_job_output::Builder {
        crate::output::describe_sentiment_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeResourcePolicyOutput {
    /// <p>The JSON body of the resource-based policy.</p>
    pub resource_policy: std::option::Option<std::string::String>,
    /// <p>The time at which the policy was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the policy was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The revision ID of the policy. Each time you modify a policy, Amazon Comprehend assigns a new revision ID, and it deletes the prior version of the policy.</p>
    pub policy_revision_id: std::option::Option<std::string::String>,
}
impl DescribeResourcePolicyOutput {
    /// <p>The JSON body of the resource-based policy.</p>
    pub fn resource_policy(&self) -> std::option::Option<&str> {
        self.resource_policy.as_deref()
    }
    /// <p>The time at which the policy was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time at which the policy was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The revision ID of the policy. Each time you modify a policy, Amazon Comprehend assigns a new revision ID, and it deletes the prior version of the policy.</p>
    pub fn policy_revision_id(&self) -> std::option::Option<&str> {
        self.policy_revision_id.as_deref()
    }
}
impl std::fmt::Debug for DescribeResourcePolicyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeResourcePolicyOutput");
        formatter.field("resource_policy", &self.resource_policy);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("policy_revision_id", &self.policy_revision_id);
        formatter.finish()
    }
}
/// See [`DescribeResourcePolicyOutput`](crate::output::DescribeResourcePolicyOutput)
pub mod describe_resource_policy_output {

    /// A builder for [`DescribeResourcePolicyOutput`](crate::output::DescribeResourcePolicyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_policy: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) policy_revision_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The JSON body of the resource-based policy.</p>
        pub fn resource_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_policy = Some(input.into());
            self
        }
        /// <p>The JSON body of the resource-based policy.</p>
        pub fn set_resource_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_policy = input;
            self
        }
        /// <p>The time at which the policy was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time at which the policy was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time at which the policy was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The time at which the policy was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The revision ID of the policy. Each time you modify a policy, Amazon Comprehend assigns a new revision ID, and it deletes the prior version of the policy.</p>
        pub fn policy_revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_revision_id = Some(input.into());
            self
        }
        /// <p>The revision ID of the policy. Each time you modify a policy, Amazon Comprehend assigns a new revision ID, and it deletes the prior version of the policy.</p>
        pub fn set_policy_revision_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_revision_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeResourcePolicyOutput`](crate::output::DescribeResourcePolicyOutput)
        pub fn build(self) -> crate::output::DescribeResourcePolicyOutput {
            crate::output::DescribeResourcePolicyOutput {
                resource_policy: self.resource_policy,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                policy_revision_id: self.policy_revision_id,
            }
        }
    }
}
impl DescribeResourcePolicyOutput {
    /// Creates a new builder-style object to manufacture [`DescribeResourcePolicyOutput`](crate::output::DescribeResourcePolicyOutput)
    pub fn builder() -> crate::output::describe_resource_policy_output::Builder {
        crate::output::describe_resource_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePiiEntitiesDetectionJobOutput {
    /// <p>Provides information about a PII entities detection job.</p>
    pub pii_entities_detection_job_properties:
        std::option::Option<crate::model::PiiEntitiesDetectionJobProperties>,
}
impl DescribePiiEntitiesDetectionJobOutput {
    /// <p>Provides information about a PII entities detection job.</p>
    pub fn pii_entities_detection_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::PiiEntitiesDetectionJobProperties> {
        self.pii_entities_detection_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribePiiEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePiiEntitiesDetectionJobOutput");
        formatter.field(
            "pii_entities_detection_job_properties",
            &self.pii_entities_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribePiiEntitiesDetectionJobOutput`](crate::output::DescribePiiEntitiesDetectionJobOutput)
pub mod describe_pii_entities_detection_job_output {

    /// A builder for [`DescribePiiEntitiesDetectionJobOutput`](crate::output::DescribePiiEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pii_entities_detection_job_properties:
            std::option::Option<crate::model::PiiEntitiesDetectionJobProperties>,
    }
    impl Builder {
        /// <p>Provides information about a PII entities detection job.</p>
        pub fn pii_entities_detection_job_properties(
            mut self,
            input: crate::model::PiiEntitiesDetectionJobProperties,
        ) -> Self {
            self.pii_entities_detection_job_properties = Some(input);
            self
        }
        /// <p>Provides information about a PII entities detection job.</p>
        pub fn set_pii_entities_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::PiiEntitiesDetectionJobProperties>,
        ) -> Self {
            self.pii_entities_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribePiiEntitiesDetectionJobOutput`](crate::output::DescribePiiEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribePiiEntitiesDetectionJobOutput {
            crate::output::DescribePiiEntitiesDetectionJobOutput {
                pii_entities_detection_job_properties: self.pii_entities_detection_job_properties,
            }
        }
    }
}
impl DescribePiiEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribePiiEntitiesDetectionJobOutput`](crate::output::DescribePiiEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::describe_pii_entities_detection_job_output::Builder {
        crate::output::describe_pii_entities_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeKeyPhrasesDetectionJobOutput {
    /// <p>An object that contains the properties associated with a key phrases detection job. </p>
    pub key_phrases_detection_job_properties:
        std::option::Option<crate::model::KeyPhrasesDetectionJobProperties>,
}
impl DescribeKeyPhrasesDetectionJobOutput {
    /// <p>An object that contains the properties associated with a key phrases detection job. </p>
    pub fn key_phrases_detection_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::KeyPhrasesDetectionJobProperties> {
        self.key_phrases_detection_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeKeyPhrasesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeKeyPhrasesDetectionJobOutput");
        formatter.field(
            "key_phrases_detection_job_properties",
            &self.key_phrases_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeKeyPhrasesDetectionJobOutput`](crate::output::DescribeKeyPhrasesDetectionJobOutput)
pub mod describe_key_phrases_detection_job_output {

    /// A builder for [`DescribeKeyPhrasesDetectionJobOutput`](crate::output::DescribeKeyPhrasesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_phrases_detection_job_properties:
            std::option::Option<crate::model::KeyPhrasesDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a key phrases detection job. </p>
        pub fn key_phrases_detection_job_properties(
            mut self,
            input: crate::model::KeyPhrasesDetectionJobProperties,
        ) -> Self {
            self.key_phrases_detection_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a key phrases detection job. </p>
        pub fn set_key_phrases_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::KeyPhrasesDetectionJobProperties>,
        ) -> Self {
            self.key_phrases_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeKeyPhrasesDetectionJobOutput`](crate::output::DescribeKeyPhrasesDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeKeyPhrasesDetectionJobOutput {
            crate::output::DescribeKeyPhrasesDetectionJobOutput {
                key_phrases_detection_job_properties: self.key_phrases_detection_job_properties,
            }
        }
    }
}
impl DescribeKeyPhrasesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeKeyPhrasesDetectionJobOutput`](crate::output::DescribeKeyPhrasesDetectionJobOutput)
    pub fn builder() -> crate::output::describe_key_phrases_detection_job_output::Builder {
        crate::output::describe_key_phrases_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEventsDetectionJobOutput {
    /// <p>An object that contains the properties associated with an event detection job.</p>
    pub events_detection_job_properties:
        std::option::Option<crate::model::EventsDetectionJobProperties>,
}
impl DescribeEventsDetectionJobOutput {
    /// <p>An object that contains the properties associated with an event detection job.</p>
    pub fn events_detection_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::EventsDetectionJobProperties> {
        self.events_detection_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeEventsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEventsDetectionJobOutput");
        formatter.field(
            "events_detection_job_properties",
            &self.events_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeEventsDetectionJobOutput`](crate::output::DescribeEventsDetectionJobOutput)
pub mod describe_events_detection_job_output {

    /// A builder for [`DescribeEventsDetectionJobOutput`](crate::output::DescribeEventsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) events_detection_job_properties:
            std::option::Option<crate::model::EventsDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with an event detection job.</p>
        pub fn events_detection_job_properties(
            mut self,
            input: crate::model::EventsDetectionJobProperties,
        ) -> Self {
            self.events_detection_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with an event detection job.</p>
        pub fn set_events_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::EventsDetectionJobProperties>,
        ) -> Self {
            self.events_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEventsDetectionJobOutput`](crate::output::DescribeEventsDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeEventsDetectionJobOutput {
            crate::output::DescribeEventsDetectionJobOutput {
                events_detection_job_properties: self.events_detection_job_properties,
            }
        }
    }
}
impl DescribeEventsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEventsDetectionJobOutput`](crate::output::DescribeEventsDetectionJobOutput)
    pub fn builder() -> crate::output::describe_events_detection_job_output::Builder {
        crate::output::describe_events_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEntityRecognizerOutput {
    /// <p>Describes information associated with an entity recognizer.</p>
    pub entity_recognizer_properties: std::option::Option<crate::model::EntityRecognizerProperties>,
}
impl DescribeEntityRecognizerOutput {
    /// <p>Describes information associated with an entity recognizer.</p>
    pub fn entity_recognizer_properties(
        &self,
    ) -> std::option::Option<&crate::model::EntityRecognizerProperties> {
        self.entity_recognizer_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeEntityRecognizerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEntityRecognizerOutput");
        formatter.field(
            "entity_recognizer_properties",
            &self.entity_recognizer_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeEntityRecognizerOutput`](crate::output::DescribeEntityRecognizerOutput)
pub mod describe_entity_recognizer_output {

    /// A builder for [`DescribeEntityRecognizerOutput`](crate::output::DescribeEntityRecognizerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_recognizer_properties:
            std::option::Option<crate::model::EntityRecognizerProperties>,
    }
    impl Builder {
        /// <p>Describes information associated with an entity recognizer.</p>
        pub fn entity_recognizer_properties(
            mut self,
            input: crate::model::EntityRecognizerProperties,
        ) -> Self {
            self.entity_recognizer_properties = Some(input);
            self
        }
        /// <p>Describes information associated with an entity recognizer.</p>
        pub fn set_entity_recognizer_properties(
            mut self,
            input: std::option::Option<crate::model::EntityRecognizerProperties>,
        ) -> Self {
            self.entity_recognizer_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEntityRecognizerOutput`](crate::output::DescribeEntityRecognizerOutput)
        pub fn build(self) -> crate::output::DescribeEntityRecognizerOutput {
            crate::output::DescribeEntityRecognizerOutput {
                entity_recognizer_properties: self.entity_recognizer_properties,
            }
        }
    }
}
impl DescribeEntityRecognizerOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEntityRecognizerOutput`](crate::output::DescribeEntityRecognizerOutput)
    pub fn builder() -> crate::output::describe_entity_recognizer_output::Builder {
        crate::output::describe_entity_recognizer_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEntitiesDetectionJobOutput {
    /// <p>An object that contains the properties associated with an entities detection job.</p>
    pub entities_detection_job_properties:
        std::option::Option<crate::model::EntitiesDetectionJobProperties>,
}
impl DescribeEntitiesDetectionJobOutput {
    /// <p>An object that contains the properties associated with an entities detection job.</p>
    pub fn entities_detection_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::EntitiesDetectionJobProperties> {
        self.entities_detection_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEntitiesDetectionJobOutput");
        formatter.field(
            "entities_detection_job_properties",
            &self.entities_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeEntitiesDetectionJobOutput`](crate::output::DescribeEntitiesDetectionJobOutput)
pub mod describe_entities_detection_job_output {

    /// A builder for [`DescribeEntitiesDetectionJobOutput`](crate::output::DescribeEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities_detection_job_properties:
            std::option::Option<crate::model::EntitiesDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with an entities detection job.</p>
        pub fn entities_detection_job_properties(
            mut self,
            input: crate::model::EntitiesDetectionJobProperties,
        ) -> Self {
            self.entities_detection_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with an entities detection job.</p>
        pub fn set_entities_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::EntitiesDetectionJobProperties>,
        ) -> Self {
            self.entities_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEntitiesDetectionJobOutput`](crate::output::DescribeEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeEntitiesDetectionJobOutput {
            crate::output::DescribeEntitiesDetectionJobOutput {
                entities_detection_job_properties: self.entities_detection_job_properties,
            }
        }
    }
}
impl DescribeEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEntitiesDetectionJobOutput`](crate::output::DescribeEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::describe_entities_detection_job_output::Builder {
        crate::output::describe_entities_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEndpointOutput {
    /// <p>Describes information associated with the specific endpoint.</p>
    pub endpoint_properties: std::option::Option<crate::model::EndpointProperties>,
}
impl DescribeEndpointOutput {
    /// <p>Describes information associated with the specific endpoint.</p>
    pub fn endpoint_properties(&self) -> std::option::Option<&crate::model::EndpointProperties> {
        self.endpoint_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeEndpointOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEndpointOutput");
        formatter.field("endpoint_properties", &self.endpoint_properties);
        formatter.finish()
    }
}
/// See [`DescribeEndpointOutput`](crate::output::DescribeEndpointOutput)
pub mod describe_endpoint_output {

    /// A builder for [`DescribeEndpointOutput`](crate::output::DescribeEndpointOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_properties: std::option::Option<crate::model::EndpointProperties>,
    }
    impl Builder {
        /// <p>Describes information associated with the specific endpoint.</p>
        pub fn endpoint_properties(mut self, input: crate::model::EndpointProperties) -> Self {
            self.endpoint_properties = Some(input);
            self
        }
        /// <p>Describes information associated with the specific endpoint.</p>
        pub fn set_endpoint_properties(
            mut self,
            input: std::option::Option<crate::model::EndpointProperties>,
        ) -> Self {
            self.endpoint_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEndpointOutput`](crate::output::DescribeEndpointOutput)
        pub fn build(self) -> crate::output::DescribeEndpointOutput {
            crate::output::DescribeEndpointOutput {
                endpoint_properties: self.endpoint_properties,
            }
        }
    }
}
impl DescribeEndpointOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEndpointOutput`](crate::output::DescribeEndpointOutput)
    pub fn builder() -> crate::output::describe_endpoint_output::Builder {
        crate::output::describe_endpoint_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDominantLanguageDetectionJobOutput {
    /// <p>An object that contains the properties associated with a dominant language detection job.</p>
    pub dominant_language_detection_job_properties:
        std::option::Option<crate::model::DominantLanguageDetectionJobProperties>,
}
impl DescribeDominantLanguageDetectionJobOutput {
    /// <p>An object that contains the properties associated with a dominant language detection job.</p>
    pub fn dominant_language_detection_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::DominantLanguageDetectionJobProperties> {
        self.dominant_language_detection_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeDominantLanguageDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDominantLanguageDetectionJobOutput");
        formatter.field(
            "dominant_language_detection_job_properties",
            &self.dominant_language_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeDominantLanguageDetectionJobOutput`](crate::output::DescribeDominantLanguageDetectionJobOutput)
pub mod describe_dominant_language_detection_job_output {

    /// A builder for [`DescribeDominantLanguageDetectionJobOutput`](crate::output::DescribeDominantLanguageDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dominant_language_detection_job_properties:
            std::option::Option<crate::model::DominantLanguageDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a dominant language detection job.</p>
        pub fn dominant_language_detection_job_properties(
            mut self,
            input: crate::model::DominantLanguageDetectionJobProperties,
        ) -> Self {
            self.dominant_language_detection_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a dominant language detection job.</p>
        pub fn set_dominant_language_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::DominantLanguageDetectionJobProperties>,
        ) -> Self {
            self.dominant_language_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDominantLanguageDetectionJobOutput`](crate::output::DescribeDominantLanguageDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeDominantLanguageDetectionJobOutput {
            crate::output::DescribeDominantLanguageDetectionJobOutput {
                dominant_language_detection_job_properties: self
                    .dominant_language_detection_job_properties,
            }
        }
    }
}
impl DescribeDominantLanguageDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeDominantLanguageDetectionJobOutput`](crate::output::DescribeDominantLanguageDetectionJobOutput)
    pub fn builder() -> crate::output::describe_dominant_language_detection_job_output::Builder {
        crate::output::describe_dominant_language_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDocumentClassifierOutput {
    /// <p>An object that contains the properties associated with a document classifier.</p>
    pub document_classifier_properties:
        std::option::Option<crate::model::DocumentClassifierProperties>,
}
impl DescribeDocumentClassifierOutput {
    /// <p>An object that contains the properties associated with a document classifier.</p>
    pub fn document_classifier_properties(
        &self,
    ) -> std::option::Option<&crate::model::DocumentClassifierProperties> {
        self.document_classifier_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeDocumentClassifierOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDocumentClassifierOutput");
        formatter.field(
            "document_classifier_properties",
            &self.document_classifier_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeDocumentClassifierOutput`](crate::output::DescribeDocumentClassifierOutput)
pub mod describe_document_classifier_output {

    /// A builder for [`DescribeDocumentClassifierOutput`](crate::output::DescribeDocumentClassifierOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classifier_properties:
            std::option::Option<crate::model::DocumentClassifierProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a document classifier.</p>
        pub fn document_classifier_properties(
            mut self,
            input: crate::model::DocumentClassifierProperties,
        ) -> Self {
            self.document_classifier_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a document classifier.</p>
        pub fn set_document_classifier_properties(
            mut self,
            input: std::option::Option<crate::model::DocumentClassifierProperties>,
        ) -> Self {
            self.document_classifier_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDocumentClassifierOutput`](crate::output::DescribeDocumentClassifierOutput)
        pub fn build(self) -> crate::output::DescribeDocumentClassifierOutput {
            crate::output::DescribeDocumentClassifierOutput {
                document_classifier_properties: self.document_classifier_properties,
            }
        }
    }
}
impl DescribeDocumentClassifierOutput {
    /// Creates a new builder-style object to manufacture [`DescribeDocumentClassifierOutput`](crate::output::DescribeDocumentClassifierOutput)
    pub fn builder() -> crate::output::describe_document_classifier_output::Builder {
        crate::output::describe_document_classifier_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDocumentClassificationJobOutput {
    /// <p>An object that describes the properties associated with the document classification job.</p>
    pub document_classification_job_properties:
        std::option::Option<crate::model::DocumentClassificationJobProperties>,
}
impl DescribeDocumentClassificationJobOutput {
    /// <p>An object that describes the properties associated with the document classification job.</p>
    pub fn document_classification_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::DocumentClassificationJobProperties> {
        self.document_classification_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeDocumentClassificationJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDocumentClassificationJobOutput");
        formatter.field(
            "document_classification_job_properties",
            &self.document_classification_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeDocumentClassificationJobOutput`](crate::output::DescribeDocumentClassificationJobOutput)
pub mod describe_document_classification_job_output {

    /// A builder for [`DescribeDocumentClassificationJobOutput`](crate::output::DescribeDocumentClassificationJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classification_job_properties:
            std::option::Option<crate::model::DocumentClassificationJobProperties>,
    }
    impl Builder {
        /// <p>An object that describes the properties associated with the document classification job.</p>
        pub fn document_classification_job_properties(
            mut self,
            input: crate::model::DocumentClassificationJobProperties,
        ) -> Self {
            self.document_classification_job_properties = Some(input);
            self
        }
        /// <p>An object that describes the properties associated with the document classification job.</p>
        pub fn set_document_classification_job_properties(
            mut self,
            input: std::option::Option<crate::model::DocumentClassificationJobProperties>,
        ) -> Self {
            self.document_classification_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDocumentClassificationJobOutput`](crate::output::DescribeDocumentClassificationJobOutput)
        pub fn build(self) -> crate::output::DescribeDocumentClassificationJobOutput {
            crate::output::DescribeDocumentClassificationJobOutput {
                document_classification_job_properties: self.document_classification_job_properties,
            }
        }
    }
}
impl DescribeDocumentClassificationJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeDocumentClassificationJobOutput`](crate::output::DescribeDocumentClassificationJobOutput)
    pub fn builder() -> crate::output::describe_document_classification_job_output::Builder {
        crate::output::describe_document_classification_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteResourcePolicyOutput {}
impl std::fmt::Debug for DeleteResourcePolicyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteResourcePolicyOutput");
        formatter.finish()
    }
}
/// See [`DeleteResourcePolicyOutput`](crate::output::DeleteResourcePolicyOutput)
pub mod delete_resource_policy_output {

    /// A builder for [`DeleteResourcePolicyOutput`](crate::output::DeleteResourcePolicyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteResourcePolicyOutput`](crate::output::DeleteResourcePolicyOutput)
        pub fn build(self) -> crate::output::DeleteResourcePolicyOutput {
            crate::output::DeleteResourcePolicyOutput {}
        }
    }
}
impl DeleteResourcePolicyOutput {
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyOutput`](crate::output::DeleteResourcePolicyOutput)
    pub fn builder() -> crate::output::delete_resource_policy_output::Builder {
        crate::output::delete_resource_policy_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteEntityRecognizerOutput {}
impl std::fmt::Debug for DeleteEntityRecognizerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteEntityRecognizerOutput");
        formatter.finish()
    }
}
/// See [`DeleteEntityRecognizerOutput`](crate::output::DeleteEntityRecognizerOutput)
pub mod delete_entity_recognizer_output {

    /// A builder for [`DeleteEntityRecognizerOutput`](crate::output::DeleteEntityRecognizerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteEntityRecognizerOutput`](crate::output::DeleteEntityRecognizerOutput)
        pub fn build(self) -> crate::output::DeleteEntityRecognizerOutput {
            crate::output::DeleteEntityRecognizerOutput {}
        }
    }
}
impl DeleteEntityRecognizerOutput {
    /// Creates a new builder-style object to manufacture [`DeleteEntityRecognizerOutput`](crate::output::DeleteEntityRecognizerOutput)
    pub fn builder() -> crate::output::delete_entity_recognizer_output::Builder {
        crate::output::delete_entity_recognizer_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteEndpointOutput {}
impl std::fmt::Debug for DeleteEndpointOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteEndpointOutput");
        formatter.finish()
    }
}
/// See [`DeleteEndpointOutput`](crate::output::DeleteEndpointOutput)
pub mod delete_endpoint_output {

    /// A builder for [`DeleteEndpointOutput`](crate::output::DeleteEndpointOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteEndpointOutput`](crate::output::DeleteEndpointOutput)
        pub fn build(self) -> crate::output::DeleteEndpointOutput {
            crate::output::DeleteEndpointOutput {}
        }
    }
}
impl DeleteEndpointOutput {
    /// Creates a new builder-style object to manufacture [`DeleteEndpointOutput`](crate::output::DeleteEndpointOutput)
    pub fn builder() -> crate::output::delete_endpoint_output::Builder {
        crate::output::delete_endpoint_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDocumentClassifierOutput {}
impl std::fmt::Debug for DeleteDocumentClassifierOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDocumentClassifierOutput");
        formatter.finish()
    }
}
/// See [`DeleteDocumentClassifierOutput`](crate::output::DeleteDocumentClassifierOutput)
pub mod delete_document_classifier_output {

    /// A builder for [`DeleteDocumentClassifierOutput`](crate::output::DeleteDocumentClassifierOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteDocumentClassifierOutput`](crate::output::DeleteDocumentClassifierOutput)
        pub fn build(self) -> crate::output::DeleteDocumentClassifierOutput {
            crate::output::DeleteDocumentClassifierOutput {}
        }
    }
}
impl DeleteDocumentClassifierOutput {
    /// Creates a new builder-style object to manufacture [`DeleteDocumentClassifierOutput`](crate::output::DeleteDocumentClassifierOutput)
    pub fn builder() -> crate::output::delete_document_classifier_output::Builder {
        crate::output::delete_document_classifier_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEntityRecognizerOutput {
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    pub entity_recognizer_arn: std::option::Option<std::string::String>,
}
impl CreateEntityRecognizerOutput {
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    pub fn entity_recognizer_arn(&self) -> std::option::Option<&str> {
        self.entity_recognizer_arn.as_deref()
    }
}
impl std::fmt::Debug for CreateEntityRecognizerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEntityRecognizerOutput");
        formatter.field("entity_recognizer_arn", &self.entity_recognizer_arn);
        formatter.finish()
    }
}
/// See [`CreateEntityRecognizerOutput`](crate::output::CreateEntityRecognizerOutput)
pub mod create_entity_recognizer_output {

    /// A builder for [`CreateEntityRecognizerOutput`](crate::output::CreateEntityRecognizerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_recognizer_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
        pub fn entity_recognizer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_recognizer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
        pub fn set_entity_recognizer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.entity_recognizer_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateEntityRecognizerOutput`](crate::output::CreateEntityRecognizerOutput)
        pub fn build(self) -> crate::output::CreateEntityRecognizerOutput {
            crate::output::CreateEntityRecognizerOutput {
                entity_recognizer_arn: self.entity_recognizer_arn,
            }
        }
    }
}
impl CreateEntityRecognizerOutput {
    /// Creates a new builder-style object to manufacture [`CreateEntityRecognizerOutput`](crate::output::CreateEntityRecognizerOutput)
    pub fn builder() -> crate::output::create_entity_recognizer_output::Builder {
        crate::output::create_entity_recognizer_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEndpointOutput {
    /// <p>The Amazon Resource Number (ARN) of the endpoint being created.</p>
    pub endpoint_arn: std::option::Option<std::string::String>,
}
impl CreateEndpointOutput {
    /// <p>The Amazon Resource Number (ARN) of the endpoint being created.</p>
    pub fn endpoint_arn(&self) -> std::option::Option<&str> {
        self.endpoint_arn.as_deref()
    }
}
impl std::fmt::Debug for CreateEndpointOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEndpointOutput");
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.finish()
    }
}
/// See [`CreateEndpointOutput`](crate::output::CreateEndpointOutput)
pub mod create_endpoint_output {

    /// A builder for [`CreateEndpointOutput`](crate::output::CreateEndpointOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Number (ARN) of the endpoint being created.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the endpoint being created.</p>
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateEndpointOutput`](crate::output::CreateEndpointOutput)
        pub fn build(self) -> crate::output::CreateEndpointOutput {
            crate::output::CreateEndpointOutput {
                endpoint_arn: self.endpoint_arn,
            }
        }
    }
}
impl CreateEndpointOutput {
    /// Creates a new builder-style object to manufacture [`CreateEndpointOutput`](crate::output::CreateEndpointOutput)
    pub fn builder() -> crate::output::create_endpoint_output::Builder {
        crate::output::create_endpoint_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDocumentClassifierOutput {
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
    pub document_classifier_arn: std::option::Option<std::string::String>,
}
impl CreateDocumentClassifierOutput {
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
    pub fn document_classifier_arn(&self) -> std::option::Option<&str> {
        self.document_classifier_arn.as_deref()
    }
}
impl std::fmt::Debug for CreateDocumentClassifierOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDocumentClassifierOutput");
        formatter.field("document_classifier_arn", &self.document_classifier_arn);
        formatter.finish()
    }
}
/// See [`CreateDocumentClassifierOutput`](crate::output::CreateDocumentClassifierOutput)
pub mod create_document_classifier_output {

    /// A builder for [`CreateDocumentClassifierOutput`](crate::output::CreateDocumentClassifierOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classifier_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
        pub fn document_classifier_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_classifier_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
        pub fn set_document_classifier_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_classifier_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDocumentClassifierOutput`](crate::output::CreateDocumentClassifierOutput)
        pub fn build(self) -> crate::output::CreateDocumentClassifierOutput {
            crate::output::CreateDocumentClassifierOutput {
                document_classifier_arn: self.document_classifier_arn,
            }
        }
    }
}
impl CreateDocumentClassifierOutput {
    /// Creates a new builder-style object to manufacture [`CreateDocumentClassifierOutput`](crate::output::CreateDocumentClassifierOutput)
    pub fn builder() -> crate::output::create_document_classifier_output::Builder {
        crate::output::create_document_classifier_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContainsPiiEntitiesOutput {
    /// <p>The labels used in the document being analyzed. Individual labels represent personally identifiable information (PII) entity types.</p>
    pub labels: std::option::Option<std::vec::Vec<crate::model::EntityLabel>>,
}
impl ContainsPiiEntitiesOutput {
    /// <p>The labels used in the document being analyzed. Individual labels represent personally identifiable information (PII) entity types.</p>
    pub fn labels(&self) -> std::option::Option<&[crate::model::EntityLabel]> {
        self.labels.as_deref()
    }
}
impl std::fmt::Debug for ContainsPiiEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContainsPiiEntitiesOutput");
        formatter.field("labels", &self.labels);
        formatter.finish()
    }
}
/// See [`ContainsPiiEntitiesOutput`](crate::output::ContainsPiiEntitiesOutput)
pub mod contains_pii_entities_output {

    /// A builder for [`ContainsPiiEntitiesOutput`](crate::output::ContainsPiiEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) labels: std::option::Option<std::vec::Vec<crate::model::EntityLabel>>,
    }
    impl Builder {
        /// Appends an item to `labels`.
        ///
        /// To override the contents of this collection use [`set_labels`](Self::set_labels).
        ///
        /// <p>The labels used in the document being analyzed. Individual labels represent personally identifiable information (PII) entity types.</p>
        pub fn labels(mut self, input: crate::model::EntityLabel) -> Self {
            let mut v = self.labels.unwrap_or_default();
            v.push(input);
            self.labels = Some(v);
            self
        }
        /// <p>The labels used in the document being analyzed. Individual labels represent personally identifiable information (PII) entity types.</p>
        pub fn set_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntityLabel>>,
        ) -> Self {
            self.labels = input;
            self
        }
        /// Consumes the builder and constructs a [`ContainsPiiEntitiesOutput`](crate::output::ContainsPiiEntitiesOutput)
        pub fn build(self) -> crate::output::ContainsPiiEntitiesOutput {
            crate::output::ContainsPiiEntitiesOutput {
                labels: self.labels,
            }
        }
    }
}
impl ContainsPiiEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`ContainsPiiEntitiesOutput`](crate::output::ContainsPiiEntitiesOutput)
    pub fn builder() -> crate::output::contains_pii_entities_output::Builder {
        crate::output::contains_pii_entities_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClassifyDocumentOutput {
    /// <p>The classes used by the document being analyzed. These are used for multi-class trained models. Individual classes are mutually exclusive and each document is expected to have only a single class assigned to it. For example, an animal can be a dog or a cat, but not both at the same time. </p>
    pub classes: std::option::Option<std::vec::Vec<crate::model::DocumentClass>>,
    /// <p>The labels used the document being analyzed. These are used for multi-label trained models. Individual labels represent different categories that are related in some manner and are not mutually exclusive. For example, a movie can be just an action movie, or it can be an action movie, a science fiction movie, and a comedy, all at the same time. </p>
    pub labels: std::option::Option<std::vec::Vec<crate::model::DocumentLabel>>,
}
impl ClassifyDocumentOutput {
    /// <p>The classes used by the document being analyzed. These are used for multi-class trained models. Individual classes are mutually exclusive and each document is expected to have only a single class assigned to it. For example, an animal can be a dog or a cat, but not both at the same time. </p>
    pub fn classes(&self) -> std::option::Option<&[crate::model::DocumentClass]> {
        self.classes.as_deref()
    }
    /// <p>The labels used the document being analyzed. These are used for multi-label trained models. Individual labels represent different categories that are related in some manner and are not mutually exclusive. For example, a movie can be just an action movie, or it can be an action movie, a science fiction movie, and a comedy, all at the same time. </p>
    pub fn labels(&self) -> std::option::Option<&[crate::model::DocumentLabel]> {
        self.labels.as_deref()
    }
}
impl std::fmt::Debug for ClassifyDocumentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClassifyDocumentOutput");
        formatter.field("classes", &self.classes);
        formatter.field("labels", &self.labels);
        formatter.finish()
    }
}
/// See [`ClassifyDocumentOutput`](crate::output::ClassifyDocumentOutput)
pub mod classify_document_output {

    /// A builder for [`ClassifyDocumentOutput`](crate::output::ClassifyDocumentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) classes: std::option::Option<std::vec::Vec<crate::model::DocumentClass>>,
        pub(crate) labels: std::option::Option<std::vec::Vec<crate::model::DocumentLabel>>,
    }
    impl Builder {
        /// Appends an item to `classes`.
        ///
        /// To override the contents of this collection use [`set_classes`](Self::set_classes).
        ///
        /// <p>The classes used by the document being analyzed. These are used for multi-class trained models. Individual classes are mutually exclusive and each document is expected to have only a single class assigned to it. For example, an animal can be a dog or a cat, but not both at the same time. </p>
        pub fn classes(mut self, input: crate::model::DocumentClass) -> Self {
            let mut v = self.classes.unwrap_or_default();
            v.push(input);
            self.classes = Some(v);
            self
        }
        /// <p>The classes used by the document being analyzed. These are used for multi-class trained models. Individual classes are mutually exclusive and each document is expected to have only a single class assigned to it. For example, an animal can be a dog or a cat, but not both at the same time. </p>
        pub fn set_classes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentClass>>,
        ) -> Self {
            self.classes = input;
            self
        }
        /// Appends an item to `labels`.
        ///
        /// To override the contents of this collection use [`set_labels`](Self::set_labels).
        ///
        /// <p>The labels used the document being analyzed. These are used for multi-label trained models. Individual labels represent different categories that are related in some manner and are not mutually exclusive. For example, a movie can be just an action movie, or it can be an action movie, a science fiction movie, and a comedy, all at the same time. </p>
        pub fn labels(mut self, input: crate::model::DocumentLabel) -> Self {
            let mut v = self.labels.unwrap_or_default();
            v.push(input);
            self.labels = Some(v);
            self
        }
        /// <p>The labels used the document being analyzed. These are used for multi-label trained models. Individual labels represent different categories that are related in some manner and are not mutually exclusive. For example, a movie can be just an action movie, or it can be an action movie, a science fiction movie, and a comedy, all at the same time. </p>
        pub fn set_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentLabel>>,
        ) -> Self {
            self.labels = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassifyDocumentOutput`](crate::output::ClassifyDocumentOutput)
        pub fn build(self) -> crate::output::ClassifyDocumentOutput {
            crate::output::ClassifyDocumentOutput {
                classes: self.classes,
                labels: self.labels,
            }
        }
    }
}
impl ClassifyDocumentOutput {
    /// Creates a new builder-style object to manufacture [`ClassifyDocumentOutput`](crate::output::ClassifyDocumentOutput)
    pub fn builder() -> crate::output::classify_document_output::Builder {
        crate::output::classify_document_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectSyntaxOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub result_list: std::option::Option<std::vec::Vec<crate::model::BatchDetectSyntaxItemResult>>,
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl BatchDetectSyntaxOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub fn result_list(&self) -> std::option::Option<&[crate::model::BatchDetectSyntaxItemResult]> {
        self.result_list.as_deref()
    }
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub fn error_list(&self) -> std::option::Option<&[crate::model::BatchItemError]> {
        self.error_list.as_deref()
    }
}
impl std::fmt::Debug for BatchDetectSyntaxOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectSyntaxOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectSyntaxOutput`](crate::output::BatchDetectSyntaxOutput)
pub mod batch_detect_syntax_output {

    /// A builder for [`BatchDetectSyntaxOutput`](crate::output::BatchDetectSyntaxOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectSyntaxItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        /// Appends an item to `result_list`.
        ///
        /// To override the contents of this collection use [`set_result_list`](Self::set_result_list).
        ///
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn result_list(mut self, input: crate::model::BatchDetectSyntaxItemResult) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input);
            self.result_list = Some(v);
            self
        }
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn set_result_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchDetectSyntaxItemResult>>,
        ) -> Self {
            self.result_list = input;
            self
        }
        /// Appends an item to `error_list`.
        ///
        /// To override the contents of this collection use [`set_error_list`](Self::set_error_list).
        ///
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn error_list(mut self, input: crate::model::BatchItemError) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input);
            self.error_list = Some(v);
            self
        }
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectSyntaxOutput`](crate::output::BatchDetectSyntaxOutput)
        pub fn build(self) -> crate::output::BatchDetectSyntaxOutput {
            crate::output::BatchDetectSyntaxOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectSyntaxOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectSyntaxOutput`](crate::output::BatchDetectSyntaxOutput)
    pub fn builder() -> crate::output::batch_detect_syntax_output::Builder {
        crate::output::batch_detect_syntax_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectSentimentOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub result_list:
        std::option::Option<std::vec::Vec<crate::model::BatchDetectSentimentItemResult>>,
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl BatchDetectSentimentOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub fn result_list(
        &self,
    ) -> std::option::Option<&[crate::model::BatchDetectSentimentItemResult]> {
        self.result_list.as_deref()
    }
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub fn error_list(&self) -> std::option::Option<&[crate::model::BatchItemError]> {
        self.error_list.as_deref()
    }
}
impl std::fmt::Debug for BatchDetectSentimentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectSentimentOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectSentimentOutput`](crate::output::BatchDetectSentimentOutput)
pub mod batch_detect_sentiment_output {

    /// A builder for [`BatchDetectSentimentOutput`](crate::output::BatchDetectSentimentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectSentimentItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        /// Appends an item to `result_list`.
        ///
        /// To override the contents of this collection use [`set_result_list`](Self::set_result_list).
        ///
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn result_list(mut self, input: crate::model::BatchDetectSentimentItemResult) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input);
            self.result_list = Some(v);
            self
        }
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn set_result_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchDetectSentimentItemResult>>,
        ) -> Self {
            self.result_list = input;
            self
        }
        /// Appends an item to `error_list`.
        ///
        /// To override the contents of this collection use [`set_error_list`](Self::set_error_list).
        ///
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn error_list(mut self, input: crate::model::BatchItemError) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input);
            self.error_list = Some(v);
            self
        }
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectSentimentOutput`](crate::output::BatchDetectSentimentOutput)
        pub fn build(self) -> crate::output::BatchDetectSentimentOutput {
            crate::output::BatchDetectSentimentOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectSentimentOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectSentimentOutput`](crate::output::BatchDetectSentimentOutput)
    pub fn builder() -> crate::output::batch_detect_sentiment_output::Builder {
        crate::output::batch_detect_sentiment_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectKeyPhrasesOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub result_list:
        std::option::Option<std::vec::Vec<crate::model::BatchDetectKeyPhrasesItemResult>>,
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl BatchDetectKeyPhrasesOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub fn result_list(
        &self,
    ) -> std::option::Option<&[crate::model::BatchDetectKeyPhrasesItemResult]> {
        self.result_list.as_deref()
    }
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub fn error_list(&self) -> std::option::Option<&[crate::model::BatchItemError]> {
        self.error_list.as_deref()
    }
}
impl std::fmt::Debug for BatchDetectKeyPhrasesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectKeyPhrasesOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectKeyPhrasesOutput`](crate::output::BatchDetectKeyPhrasesOutput)
pub mod batch_detect_key_phrases_output {

    /// A builder for [`BatchDetectKeyPhrasesOutput`](crate::output::BatchDetectKeyPhrasesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectKeyPhrasesItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        /// Appends an item to `result_list`.
        ///
        /// To override the contents of this collection use [`set_result_list`](Self::set_result_list).
        ///
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn result_list(mut self, input: crate::model::BatchDetectKeyPhrasesItemResult) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input);
            self.result_list = Some(v);
            self
        }
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn set_result_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::BatchDetectKeyPhrasesItemResult>,
            >,
        ) -> Self {
            self.result_list = input;
            self
        }
        /// Appends an item to `error_list`.
        ///
        /// To override the contents of this collection use [`set_error_list`](Self::set_error_list).
        ///
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn error_list(mut self, input: crate::model::BatchItemError) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input);
            self.error_list = Some(v);
            self
        }
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectKeyPhrasesOutput`](crate::output::BatchDetectKeyPhrasesOutput)
        pub fn build(self) -> crate::output::BatchDetectKeyPhrasesOutput {
            crate::output::BatchDetectKeyPhrasesOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectKeyPhrasesOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectKeyPhrasesOutput`](crate::output::BatchDetectKeyPhrasesOutput)
    pub fn builder() -> crate::output::batch_detect_key_phrases_output::Builder {
        crate::output::batch_detect_key_phrases_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectEntitiesOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub result_list:
        std::option::Option<std::vec::Vec<crate::model::BatchDetectEntitiesItemResult>>,
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl BatchDetectEntitiesOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub fn result_list(
        &self,
    ) -> std::option::Option<&[crate::model::BatchDetectEntitiesItemResult]> {
        self.result_list.as_deref()
    }
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub fn error_list(&self) -> std::option::Option<&[crate::model::BatchItemError]> {
        self.error_list.as_deref()
    }
}
impl std::fmt::Debug for BatchDetectEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectEntitiesOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectEntitiesOutput`](crate::output::BatchDetectEntitiesOutput)
pub mod batch_detect_entities_output {

    /// A builder for [`BatchDetectEntitiesOutput`](crate::output::BatchDetectEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectEntitiesItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        /// Appends an item to `result_list`.
        ///
        /// To override the contents of this collection use [`set_result_list`](Self::set_result_list).
        ///
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn result_list(mut self, input: crate::model::BatchDetectEntitiesItemResult) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input);
            self.result_list = Some(v);
            self
        }
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn set_result_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchDetectEntitiesItemResult>>,
        ) -> Self {
            self.result_list = input;
            self
        }
        /// Appends an item to `error_list`.
        ///
        /// To override the contents of this collection use [`set_error_list`](Self::set_error_list).
        ///
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn error_list(mut self, input: crate::model::BatchItemError) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input);
            self.error_list = Some(v);
            self
        }
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectEntitiesOutput`](crate::output::BatchDetectEntitiesOutput)
        pub fn build(self) -> crate::output::BatchDetectEntitiesOutput {
            crate::output::BatchDetectEntitiesOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectEntitiesOutput`](crate::output::BatchDetectEntitiesOutput)
    pub fn builder() -> crate::output::batch_detect_entities_output::Builder {
        crate::output::batch_detect_entities_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectDominantLanguageOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub result_list:
        std::option::Option<std::vec::Vec<crate::model::BatchDetectDominantLanguageItemResult>>,
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl BatchDetectDominantLanguageOutput {
    /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub fn result_list(
        &self,
    ) -> std::option::Option<&[crate::model::BatchDetectDominantLanguageItemResult]> {
        self.result_list.as_deref()
    }
    /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
    pub fn error_list(&self) -> std::option::Option<&[crate::model::BatchItemError]> {
        self.error_list.as_deref()
    }
}
impl std::fmt::Debug for BatchDetectDominantLanguageOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectDominantLanguageOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectDominantLanguageOutput`](crate::output::BatchDetectDominantLanguageOutput)
pub mod batch_detect_dominant_language_output {

    /// A builder for [`BatchDetectDominantLanguageOutput`](crate::output::BatchDetectDominantLanguageOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectDominantLanguageItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        /// Appends an item to `result_list`.
        ///
        /// To override the contents of this collection use [`set_result_list`](Self::set_result_list).
        ///
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn result_list(
            mut self,
            input: crate::model::BatchDetectDominantLanguageItemResult,
        ) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input);
            self.result_list = Some(v);
            self
        }
        /// <p>A list of objects containing the results of the operation. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If all of the documents contain an error, the <code>ResultList</code> is empty.</p>
        pub fn set_result_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::BatchDetectDominantLanguageItemResult>,
            >,
        ) -> Self {
            self.result_list = input;
            self
        }
        /// Appends an item to `error_list`.
        ///
        /// To override the contents of this collection use [`set_error_list`](Self::set_error_list).
        ///
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn error_list(mut self, input: crate::model::BatchItemError) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input);
            self.error_list = Some(v);
            self
        }
        /// <p>A list containing one object for each document that contained an error. The results are sorted in ascending order by the <code>Index</code> field and match the order of the documents in the input list. If there are no errors in the batch, the <code>ErrorList</code> is empty.</p>
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectDominantLanguageOutput`](crate::output::BatchDetectDominantLanguageOutput)
        pub fn build(self) -> crate::output::BatchDetectDominantLanguageOutput {
            crate::output::BatchDetectDominantLanguageOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectDominantLanguageOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectDominantLanguageOutput`](crate::output::BatchDetectDominantLanguageOutput)
    pub fn builder() -> crate::output::batch_detect_dominant_language_output::Builder {
        crate::output::batch_detect_dominant_language_output::Builder::default()
    }
}
