// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEndpointOutput {}
impl std::fmt::Debug for UpdateEndpointOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEndpointOutput");
        formatter.finish()
    }
}
/// See [`UpdateEndpointOutput`](crate::output::UpdateEndpointOutput)
pub mod update_endpoint_output {
    /// A builder for [`UpdateEndpointOutput`](crate::output::UpdateEndpointOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateEndpointOutput`](crate::output::UpdateEndpointOutput)
        pub fn build(self) -> crate::output::UpdateEndpointOutput {
            crate::output::UpdateEndpointOutput {}
        }
    }
}
impl UpdateEndpointOutput {
    /// Creates a new builder-style object to manufacture [`UpdateEndpointOutput`](crate::output::UpdateEndpointOutput)
    pub fn builder() -> crate::output::update_endpoint_output::Builder {
        crate::output::update_endpoint_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceOutput {}
impl std::fmt::Debug for UntagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceOutput");
        formatter.finish()
    }
}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput)
pub mod untag_resource_output {
    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput)
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {}
        }
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceOutput {}
impl std::fmt::Debug for TagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceOutput");
        formatter.finish()
    }
}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput)
pub mod tag_resource_output {
    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput)
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {}
        }
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput)
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopTrainingEntityRecognizerOutput {}
impl std::fmt::Debug for StopTrainingEntityRecognizerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopTrainingEntityRecognizerOutput");
        formatter.finish()
    }
}
/// See [`StopTrainingEntityRecognizerOutput`](crate::output::StopTrainingEntityRecognizerOutput)
pub mod stop_training_entity_recognizer_output {
    /// A builder for [`StopTrainingEntityRecognizerOutput`](crate::output::StopTrainingEntityRecognizerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StopTrainingEntityRecognizerOutput`](crate::output::StopTrainingEntityRecognizerOutput)
        pub fn build(self) -> crate::output::StopTrainingEntityRecognizerOutput {
            crate::output::StopTrainingEntityRecognizerOutput {}
        }
    }
}
impl StopTrainingEntityRecognizerOutput {
    /// Creates a new builder-style object to manufacture [`StopTrainingEntityRecognizerOutput`](crate::output::StopTrainingEntityRecognizerOutput)
    pub fn builder() -> crate::output::stop_training_entity_recognizer_output::Builder {
        crate::output::stop_training_entity_recognizer_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopTrainingDocumentClassifierOutput {}
impl std::fmt::Debug for StopTrainingDocumentClassifierOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopTrainingDocumentClassifierOutput");
        formatter.finish()
    }
}
/// See [`StopTrainingDocumentClassifierOutput`](crate::output::StopTrainingDocumentClassifierOutput)
pub mod stop_training_document_classifier_output {
    /// A builder for [`StopTrainingDocumentClassifierOutput`](crate::output::StopTrainingDocumentClassifierOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StopTrainingDocumentClassifierOutput`](crate::output::StopTrainingDocumentClassifierOutput)
        pub fn build(self) -> crate::output::StopTrainingDocumentClassifierOutput {
            crate::output::StopTrainingDocumentClassifierOutput {}
        }
    }
}
impl StopTrainingDocumentClassifierOutput {
    /// Creates a new builder-style object to manufacture [`StopTrainingDocumentClassifierOutput`](crate::output::StopTrainingDocumentClassifierOutput)
    pub fn builder() -> crate::output::stop_training_document_classifier_output::Builder {
        crate::output::stop_training_document_classifier_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopSentimentDetectionJobOutput {
    /// <p>The identifier of the sentiment detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
    /// <code>STOPPED</code> if the job was previously stopped with the
    /// <code>StopSentimentDetectionJob</code> operation.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StopSentimentDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopSentimentDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopSentimentDetectionJobOutput`](crate::output::StopSentimentDetectionJobOutput)
pub mod stop_sentiment_detection_job_output {
    /// A builder for [`StopSentimentDetectionJobOutput`](crate::output::StopSentimentDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the sentiment detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
        /// <code>STOPPED</code> if the job was previously stopped with the
        /// <code>StopSentimentDetectionJob</code> operation.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopSentimentDetectionJobOutput`](crate::output::StopSentimentDetectionJobOutput)
        pub fn build(self) -> crate::output::StopSentimentDetectionJobOutput {
            crate::output::StopSentimentDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopSentimentDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopSentimentDetectionJobOutput`](crate::output::StopSentimentDetectionJobOutput)
    pub fn builder() -> crate::output::stop_sentiment_detection_job_output::Builder {
        crate::output::stop_sentiment_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopPiiEntitiesDetectionJobOutput {
    /// <p>The identifier of the PII entities detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The status of the PII entities detection job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StopPiiEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopPiiEntitiesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopPiiEntitiesDetectionJobOutput`](crate::output::StopPiiEntitiesDetectionJobOutput)
pub mod stop_pii_entities_detection_job_output {
    /// A builder for [`StopPiiEntitiesDetectionJobOutput`](crate::output::StopPiiEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the PII entities detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The status of the PII entities detection job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopPiiEntitiesDetectionJobOutput`](crate::output::StopPiiEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::StopPiiEntitiesDetectionJobOutput {
            crate::output::StopPiiEntitiesDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopPiiEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopPiiEntitiesDetectionJobOutput`](crate::output::StopPiiEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::stop_pii_entities_detection_job_output::Builder {
        crate::output::stop_pii_entities_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopKeyPhrasesDetectionJobOutput {
    /// <p>The identifier of the key phrases detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
    /// <code>STOPPED</code> if the job was previously stopped with the
    /// <code>StopKeyPhrasesDetectionJob</code> operation.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StopKeyPhrasesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopKeyPhrasesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopKeyPhrasesDetectionJobOutput`](crate::output::StopKeyPhrasesDetectionJobOutput)
pub mod stop_key_phrases_detection_job_output {
    /// A builder for [`StopKeyPhrasesDetectionJobOutput`](crate::output::StopKeyPhrasesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the key phrases detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
        /// <code>STOPPED</code> if the job was previously stopped with the
        /// <code>StopKeyPhrasesDetectionJob</code> operation.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopKeyPhrasesDetectionJobOutput`](crate::output::StopKeyPhrasesDetectionJobOutput)
        pub fn build(self) -> crate::output::StopKeyPhrasesDetectionJobOutput {
            crate::output::StopKeyPhrasesDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopKeyPhrasesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopKeyPhrasesDetectionJobOutput`](crate::output::StopKeyPhrasesDetectionJobOutput)
    pub fn builder() -> crate::output::stop_key_phrases_detection_job_output::Builder {
        crate::output::stop_key_phrases_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopEventsDetectionJobOutput {
    /// <p>The identifier of the events detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The status of the events detection job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StopEventsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopEventsDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopEventsDetectionJobOutput`](crate::output::StopEventsDetectionJobOutput)
pub mod stop_events_detection_job_output {
    /// A builder for [`StopEventsDetectionJobOutput`](crate::output::StopEventsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the events detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The status of the events detection job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopEventsDetectionJobOutput`](crate::output::StopEventsDetectionJobOutput)
        pub fn build(self) -> crate::output::StopEventsDetectionJobOutput {
            crate::output::StopEventsDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopEventsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopEventsDetectionJobOutput`](crate::output::StopEventsDetectionJobOutput)
    pub fn builder() -> crate::output::stop_events_detection_job_output::Builder {
        crate::output::stop_events_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopEntitiesDetectionJobOutput {
    /// <p>The identifier of the entities detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
    /// <code>STOPPED</code> if the job was previously stopped with the
    /// <code>StopEntitiesDetectionJob</code> operation.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StopEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopEntitiesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopEntitiesDetectionJobOutput`](crate::output::StopEntitiesDetectionJobOutput)
pub mod stop_entities_detection_job_output {
    /// A builder for [`StopEntitiesDetectionJobOutput`](crate::output::StopEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the entities detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
        /// <code>STOPPED</code> if the job was previously stopped with the
        /// <code>StopEntitiesDetectionJob</code> operation.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopEntitiesDetectionJobOutput`](crate::output::StopEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::StopEntitiesDetectionJobOutput {
            crate::output::StopEntitiesDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopEntitiesDetectionJobOutput`](crate::output::StopEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::stop_entities_detection_job_output::Builder {
        crate::output::stop_entities_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopDominantLanguageDetectionJobOutput {
    /// <p>The identifier of the dominant language detection job to stop.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
    /// <code>STOPPED</code> if the job was previously stopped with the
    /// <code>StopDominantLanguageDetectionJob</code> operation.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StopDominantLanguageDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopDominantLanguageDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StopDominantLanguageDetectionJobOutput`](crate::output::StopDominantLanguageDetectionJobOutput)
pub mod stop_dominant_language_detection_job_output {
    /// A builder for [`StopDominantLanguageDetectionJobOutput`](crate::output::StopDominantLanguageDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier of the dominant language detection job to stop.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>Either <code>STOP_REQUESTED</code> if the job is currently running, or
        /// <code>STOPPED</code> if the job was previously stopped with the
        /// <code>StopDominantLanguageDetectionJob</code> operation.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StopDominantLanguageDetectionJobOutput`](crate::output::StopDominantLanguageDetectionJobOutput)
        pub fn build(self) -> crate::output::StopDominantLanguageDetectionJobOutput {
            crate::output::StopDominantLanguageDetectionJobOutput {
                job_id: self.job_id,
                job_status: self.job_status,
            }
        }
    }
}
impl StopDominantLanguageDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopDominantLanguageDetectionJobOutput`](crate::output::StopDominantLanguageDetectionJobOutput)
    pub fn builder() -> crate::output::stop_dominant_language_detection_job_output::Builder {
        crate::output::stop_dominant_language_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartTopicsDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of the job, use this identifier
    /// with the <code>DescribeTopicDetectionJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully
    /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
    /// format of the ARN is as follows:</p>
    /// <p>
    /// <code>arn:<partition>:comprehend:<region>:<account-id>:topics-detection-job/<job-id></code>
    /// </p>
    /// <p>The following is an example job ARN:</p>
    /// <p>
    /// <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code>
    /// </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job: </p>
    /// <ul>
    /// <li>
    /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
    /// </li>
    /// <li>
    /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    /// </li>
    /// <li>
    /// <p>COMPLETED - The job was successfully completed and the output is
    /// available.</p>
    /// </li>
    /// <li>
    /// <p>FAILED - The job did not complete. To get details, use the
    /// <code>DescribeTopicDetectionJob</code> operation.</p>
    /// </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StartTopicsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartTopicsDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartTopicsDetectionJobOutput`](crate::output::StartTopicsDetectionJobOutput)
pub mod start_topics_detection_job_output {
    /// A builder for [`StartTopicsDetectionJobOutput`](crate::output::StartTopicsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of the job, use this identifier
        /// with the <code>DescribeTopicDetectionJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully
        /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
        /// format of the ARN is as follows:</p>
        /// <p>
        /// <code>arn:<partition>:comprehend:<region>:<account-id>:topics-detection-job/<job-id></code>
        /// </p>
        /// <p>The following is an example job ARN:</p>
        /// <p>
        /// <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code>
        /// </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job: </p>
        /// <ul>
        /// <li>
        /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
        /// </li>
        /// <li>
        /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
        /// </li>
        /// <li>
        /// <p>COMPLETED - The job was successfully completed and the output is
        /// available.</p>
        /// </li>
        /// <li>
        /// <p>FAILED - The job did not complete. To get details, use the
        /// <code>DescribeTopicDetectionJob</code> operation.</p>
        /// </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartTopicsDetectionJobOutput`](crate::output::StartTopicsDetectionJobOutput)
        pub fn build(self) -> crate::output::StartTopicsDetectionJobOutput {
            crate::output::StartTopicsDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartTopicsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartTopicsDetectionJobOutput`](crate::output::StartTopicsDetectionJobOutput)
    pub fn builder() -> crate::output::start_topics_detection_job_output::Builder {
        crate::output::start_topics_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartSentimentDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    /// the  operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully
    /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
    /// format of the ARN is as follows:</p>
    /// <p>
    /// <code>arn:<partition>:comprehend:<region>:<account-id>:sentiment-detection-job/<job-id></code>
    /// </p>
    /// <p>The following is an example job ARN:</p>
    /// <p>
    /// <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
    /// </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li>
    /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
    /// </li>
    /// <li>
    /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    /// </li>
    /// <li>
    /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
    /// </li>
    /// <li>
    /// <p>FAILED - The job did not complete. To get details, use the  operation.</p>
    /// </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StartSentimentDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartSentimentDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartSentimentDetectionJobOutput`](crate::output::StartSentimentDetectionJobOutput)
pub mod start_sentiment_detection_job_output {
    /// A builder for [`StartSentimentDetectionJobOutput`](crate::output::StartSentimentDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
        /// the  operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully
        /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
        /// format of the ARN is as follows:</p>
        /// <p>
        /// <code>arn:<partition>:comprehend:<region>:<account-id>:sentiment-detection-job/<job-id></code>
        /// </p>
        /// <p>The following is an example job ARN:</p>
        /// <p>
        /// <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
        /// </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li>
        /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
        /// </li>
        /// <li>
        /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
        /// </li>
        /// <li>
        /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
        /// </li>
        /// <li>
        /// <p>FAILED - The job did not complete. To get details, use the  operation.</p>
        /// </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartSentimentDetectionJobOutput`](crate::output::StartSentimentDetectionJobOutput)
        pub fn build(self) -> crate::output::StartSentimentDetectionJobOutput {
            crate::output::StartSentimentDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartSentimentDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartSentimentDetectionJobOutput`](crate::output::StartSentimentDetectionJobOutput)
    pub fn builder() -> crate::output::start_sentiment_detection_job_output::Builder {
        crate::output::start_sentiment_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartPiiEntitiesDetectionJobOutput {
    /// <p>The identifier generated for the job.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the PII entity detection job. It is a unique, fully
    /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
    /// format of the ARN is as follows:</p>
    /// <p>
    /// <code>arn:<partition>:comprehend:<region>:<account-id>:pii-entities-detection-job/<job-id></code>
    /// </p>
    /// <p>The following is an example job ARN:</p>
    /// <p>
    /// <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
    /// </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StartPiiEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartPiiEntitiesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartPiiEntitiesDetectionJobOutput`](crate::output::StartPiiEntitiesDetectionJobOutput)
pub mod start_pii_entities_detection_job_output {
    /// A builder for [`StartPiiEntitiesDetectionJobOutput`](crate::output::StartPiiEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the PII entity detection job. It is a unique, fully
        /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
        /// format of the ARN is as follows:</p>
        /// <p>
        /// <code>arn:<partition>:comprehend:<region>:<account-id>:pii-entities-detection-job/<job-id></code>
        /// </p>
        /// <p>The following is an example job ARN:</p>
        /// <p>
        /// <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
        /// </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartPiiEntitiesDetectionJobOutput`](crate::output::StartPiiEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::StartPiiEntitiesDetectionJobOutput {
            crate::output::StartPiiEntitiesDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartPiiEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartPiiEntitiesDetectionJobOutput`](crate::output::StartPiiEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::start_pii_entities_detection_job_output::Builder {
        crate::output::start_pii_entities_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartKeyPhrasesDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    /// the  operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the key phrase detection job. It is a unique, fully
    /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
    /// format of the ARN is as follows:</p>
    /// <p>
    /// <code>arn:<partition>:comprehend:<region>:<account-id>:key-phrases-detection-job/<job-id></code>
    /// </p>
    /// <p>The following is an example job ARN:</p>
    /// <p>
    /// <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
    /// </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li>
    /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
    /// </li>
    /// <li>
    /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    /// </li>
    /// <li>
    /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
    /// </li>
    /// <li>
    /// <p>FAILED - The job did not complete. To get details, use the  operation.</p>
    /// </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StartKeyPhrasesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartKeyPhrasesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartKeyPhrasesDetectionJobOutput`](crate::output::StartKeyPhrasesDetectionJobOutput)
pub mod start_key_phrases_detection_job_output {
    /// A builder for [`StartKeyPhrasesDetectionJobOutput`](crate::output::StartKeyPhrasesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
        /// the  operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the key phrase detection job. It is a unique, fully
        /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
        /// format of the ARN is as follows:</p>
        /// <p>
        /// <code>arn:<partition>:comprehend:<region>:<account-id>:key-phrases-detection-job/<job-id></code>
        /// </p>
        /// <p>The following is an example job ARN:</p>
        /// <p>
        /// <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
        /// </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li>
        /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
        /// </li>
        /// <li>
        /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
        /// </li>
        /// <li>
        /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
        /// </li>
        /// <li>
        /// <p>FAILED - The job did not complete. To get details, use the  operation.</p>
        /// </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartKeyPhrasesDetectionJobOutput`](crate::output::StartKeyPhrasesDetectionJobOutput)
        pub fn build(self) -> crate::output::StartKeyPhrasesDetectionJobOutput {
            crate::output::StartKeyPhrasesDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartKeyPhrasesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartKeyPhrasesDetectionJobOutput`](crate::output::StartKeyPhrasesDetectionJobOutput)
    pub fn builder() -> crate::output::start_key_phrases_detection_job_output::Builder {
        crate::output::start_key_phrases_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartEventsDetectionJobOutput {
    /// <p>An unique identifier for the request. If you don't set the client request token, Amazon
    /// Comprehend generates one.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully
    /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
    /// format of the ARN is as follows:</p>
    /// <p>
    /// <code>arn:<partition>:comprehend:<region>:<account-id>:events-detection-job/<job-id></code>
    /// </p>
    /// <p>The following is an example job ARN:</p>
    /// <p>
    /// <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
    /// </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the events detection job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StartEventsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartEventsDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartEventsDetectionJobOutput`](crate::output::StartEventsDetectionJobOutput)
pub mod start_events_detection_job_output {
    /// A builder for [`StartEventsDetectionJobOutput`](crate::output::StartEventsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>An unique identifier for the request. If you don't set the client request token, Amazon
        /// Comprehend generates one.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully
        /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
        /// format of the ARN is as follows:</p>
        /// <p>
        /// <code>arn:<partition>:comprehend:<region>:<account-id>:events-detection-job/<job-id></code>
        /// </p>
        /// <p>The following is an example job ARN:</p>
        /// <p>
        /// <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
        /// </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the events detection job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartEventsDetectionJobOutput`](crate::output::StartEventsDetectionJobOutput)
        pub fn build(self) -> crate::output::StartEventsDetectionJobOutput {
            crate::output::StartEventsDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartEventsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartEventsDetectionJobOutput`](crate::output::StartEventsDetectionJobOutput)
    pub fn builder() -> crate::output::start_events_detection_job_output::Builder {
        crate::output::start_events_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartEntitiesDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with
    /// the  operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully
    /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
    /// format of the ARN is as follows:</p>
    /// <p>
    /// <code>arn:<partition>:comprehend:<region>:<account-id>:entities-detection-job/<job-id></code>
    /// </p>
    /// <p>The following is an example job ARN:</p>
    /// <p>
    /// <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
    /// </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li>
    /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
    /// </li>
    /// <li>
    /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    /// </li>
    /// <li>
    /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
    /// </li>
    /// <li>
    /// <p>FAILED - The job did not complete. To get details, use the  operation.</p>
    /// </li>
    /// <li>
    /// <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is
    /// processing the request.</p>
    /// </li>
    /// <li>
    /// <p>STOPPED - The job was successfully stopped without completing.</p>
    /// </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StartEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartEntitiesDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartEntitiesDetectionJobOutput`](crate::output::StartEntitiesDetectionJobOutput)
pub mod start_entities_detection_job_output {
    /// A builder for [`StartEntitiesDetectionJobOutput`](crate::output::StartEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with
        /// the  operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully
        /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
        /// format of the ARN is as follows:</p>
        /// <p>
        /// <code>arn:<partition>:comprehend:<region>:<account-id>:entities-detection-job/<job-id></code>
        /// </p>
        /// <p>The following is an example job ARN:</p>
        /// <p>
        /// <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
        /// </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li>
        /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
        /// </li>
        /// <li>
        /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
        /// </li>
        /// <li>
        /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
        /// </li>
        /// <li>
        /// <p>FAILED - The job did not complete. To get details, use the  operation.</p>
        /// </li>
        /// <li>
        /// <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is
        /// processing the request.</p>
        /// </li>
        /// <li>
        /// <p>STOPPED - The job was successfully stopped without completing.</p>
        /// </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartEntitiesDetectionJobOutput`](crate::output::StartEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::StartEntitiesDetectionJobOutput {
            crate::output::StartEntitiesDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartEntitiesDetectionJobOutput`](crate::output::StartEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::start_entities_detection_job_output::Builder {
        crate::output::start_entities_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartDominantLanguageDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    /// the  operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique,
    /// fully qualified identifier for the job. It includes the AWS account, Region, and the job ID.
    /// The format of the ARN is as follows:</p>
    /// <p>
    /// <code>arn:<partition>:comprehend:<region>:<account-id>:dominant-language-detection-job/<job-id></code>
    /// </p>
    /// <p>The following is an example job ARN:</p>
    /// <p>
    /// <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
    /// </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job. </p>
    /// <ul>
    /// <li>
    /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
    /// </li>
    /// <li>
    /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    /// </li>
    /// <li>
    /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
    /// </li>
    /// <li>
    /// <p>FAILED - The job did not complete. To get details, use the  operation.</p>
    /// </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StartDominantLanguageDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartDominantLanguageDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartDominantLanguageDetectionJobOutput`](crate::output::StartDominantLanguageDetectionJobOutput)
pub mod start_dominant_language_detection_job_output {
    /// A builder for [`StartDominantLanguageDetectionJobOutput`](crate::output::StartDominantLanguageDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
        /// the  operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique,
        /// fully qualified identifier for the job. It includes the AWS account, Region, and the job ID.
        /// The format of the ARN is as follows:</p>
        /// <p>
        /// <code>arn:<partition>:comprehend:<region>:<account-id>:dominant-language-detection-job/<job-id></code>
        /// </p>
        /// <p>The following is an example job ARN:</p>
        /// <p>
        /// <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code>
        /// </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job. </p>
        /// <ul>
        /// <li>
        /// <p>SUBMITTED - The job has been received and is queued for processing.</p>
        /// </li>
        /// <li>
        /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
        /// </li>
        /// <li>
        /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
        /// </li>
        /// <li>
        /// <p>FAILED - The job did not complete. To get details, use the  operation.</p>
        /// </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartDominantLanguageDetectionJobOutput`](crate::output::StartDominantLanguageDetectionJobOutput)
        pub fn build(self) -> crate::output::StartDominantLanguageDetectionJobOutput {
            crate::output::StartDominantLanguageDetectionJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartDominantLanguageDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartDominantLanguageDetectionJobOutput`](crate::output::StartDominantLanguageDetectionJobOutput)
    pub fn builder() -> crate::output::start_dominant_language_detection_job_output::Builder {
        crate::output::start_dominant_language_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartDocumentClassificationJobOutput {
    /// <p>The identifier generated for the job. To get the status of the job, use this identifier
    /// with the  operation.</p>
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully
    /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
    /// format of the ARN is as follows:</p>
    /// <p>
    /// <code>arn:<partition>:comprehend:<region>:<account-id>:document-classification-job/<job-id></code>
    /// </p>
    /// <p>The following is an example job ARN:</p>
    /// <p>
    /// <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code>
    /// </p>
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The status of the job:</p>
    /// <ul>
    /// <li>
    /// <p>SUBMITTED - The job has been received and queued for processing.</p>
    /// </li>
    /// <li>
    /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
    /// </li>
    /// <li>
    /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
    /// </li>
    /// <li>
    /// <p>FAILED - The job did not complete. For details, use the  operation.</p>
    /// </li>
    /// <li>
    /// <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is
    /// processing the request.</p>
    /// </li>
    /// <li>
    /// <p>STOPPED - The job was successfully stopped without completing.</p>
    /// </li>
    /// </ul>
    pub job_status: std::option::Option<crate::model::JobStatus>,
}
impl std::fmt::Debug for StartDocumentClassificationJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartDocumentClassificationJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_arn", &self.job_arn);
        formatter.field("job_status", &self.job_status);
        formatter.finish()
    }
}
/// See [`StartDocumentClassificationJobOutput`](crate::output::StartDocumentClassificationJobOutput)
pub mod start_document_classification_job_output {
    /// A builder for [`StartDocumentClassificationJobOutput`](crate::output::StartDocumentClassificationJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of the job, use this identifier
        /// with the  operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully
        /// qualified identifier for the job. It includes the AWS account, Region, and the job ID. The
        /// format of the ARN is as follows:</p>
        /// <p>
        /// <code>arn:<partition>:comprehend:<region>:<account-id>:document-classification-job/<job-id></code>
        /// </p>
        /// <p>The following is an example job ARN:</p>
        /// <p>
        /// <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code>
        /// </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The status of the job:</p>
        /// <ul>
        /// <li>
        /// <p>SUBMITTED - The job has been received and queued for processing.</p>
        /// </li>
        /// <li>
        /// <p>IN_PROGRESS - Amazon Comprehend is processing the job.</p>
        /// </li>
        /// <li>
        /// <p>COMPLETED - The job was successfully completed and the output is available.</p>
        /// </li>
        /// <li>
        /// <p>FAILED - The job did not complete. For details, use the  operation.</p>
        /// </li>
        /// <li>
        /// <p>STOP_REQUESTED - Amazon Comprehend has received a stop request for the job and is
        /// processing the request.</p>
        /// </li>
        /// <li>
        /// <p>STOPPED - The job was successfully stopped without completing.</p>
        /// </li>
        /// </ul>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StartDocumentClassificationJobOutput`](crate::output::StartDocumentClassificationJobOutput)
        pub fn build(self) -> crate::output::StartDocumentClassificationJobOutput {
            crate::output::StartDocumentClassificationJobOutput {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_status: self.job_status,
            }
        }
    }
}
impl StartDocumentClassificationJobOutput {
    /// Creates a new builder-style object to manufacture [`StartDocumentClassificationJobOutput`](crate::output::StartDocumentClassificationJobOutput)
    pub fn builder() -> crate::output::start_document_classification_job_output::Builder {
        crate::output::start_document_classification_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTopicsDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub topics_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::TopicsDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTopicsDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTopicsDetectionJobsOutput");
        formatter.field(
            "topics_detection_job_properties_list",
            &self.topics_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListTopicsDetectionJobsOutput`](crate::output::ListTopicsDetectionJobsOutput)
pub mod list_topics_detection_jobs_output {
    /// A builder for [`ListTopicsDetectionJobsOutput`](crate::output::ListTopicsDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) topics_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::TopicsDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn topics_detection_job_properties_list(
            mut self,
            input: impl Into<crate::model::TopicsDetectionJobProperties>,
        ) -> Self {
            let mut v = self
                .topics_detection_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.topics_detection_job_properties_list = Some(v);
            self
        }
        pub fn set_topics_detection_job_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TopicsDetectionJobProperties>>,
        ) -> Self {
            self.topics_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTopicsDetectionJobsOutput`](crate::output::ListTopicsDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListTopicsDetectionJobsOutput {
            crate::output::ListTopicsDetectionJobsOutput {
                topics_detection_job_properties_list: self.topics_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListTopicsDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListTopicsDetectionJobsOutput`](crate::output::ListTopicsDetectionJobsOutput)
    pub fn builder() -> crate::output::list_topics_detection_jobs_output::Builder {
        crate::output::list_topics_detection_jobs_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutput {
    /// <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource you are
    /// querying.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>Tags associated with the Amazon Comprehend resource being queried. A tag is a key-value
    /// pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with
    /// "Sales" as the key might be added to a resource to indicate its use by the sales department.
    /// </p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ListTagsForResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
pub mod list_tags_for_resource_output {
    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the given Amazon Comprehend resource you are
        /// querying.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            }
        }
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSentimentDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub sentiment_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::SentimentDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListSentimentDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSentimentDetectionJobsOutput");
        formatter.field(
            "sentiment_detection_job_properties_list",
            &self.sentiment_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListSentimentDetectionJobsOutput`](crate::output::ListSentimentDetectionJobsOutput)
pub mod list_sentiment_detection_jobs_output {
    /// A builder for [`ListSentimentDetectionJobsOutput`](crate::output::ListSentimentDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sentiment_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::SentimentDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn sentiment_detection_job_properties_list(
            mut self,
            input: impl Into<crate::model::SentimentDetectionJobProperties>,
        ) -> Self {
            let mut v = self
                .sentiment_detection_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.sentiment_detection_job_properties_list = Some(v);
            self
        }
        pub fn set_sentiment_detection_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::SentimentDetectionJobProperties>,
            >,
        ) -> Self {
            self.sentiment_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSentimentDetectionJobsOutput`](crate::output::ListSentimentDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListSentimentDetectionJobsOutput {
            crate::output::ListSentimentDetectionJobsOutput {
                sentiment_detection_job_properties_list: self
                    .sentiment_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListSentimentDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListSentimentDetectionJobsOutput`](crate::output::ListSentimentDetectionJobsOutput)
    pub fn builder() -> crate::output::list_sentiment_detection_jobs_output::Builder {
        crate::output::list_sentiment_detection_jobs_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPiiEntitiesDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub pii_entities_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::PiiEntitiesDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPiiEntitiesDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPiiEntitiesDetectionJobsOutput");
        formatter.field(
            "pii_entities_detection_job_properties_list",
            &self.pii_entities_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListPiiEntitiesDetectionJobsOutput`](crate::output::ListPiiEntitiesDetectionJobsOutput)
pub mod list_pii_entities_detection_jobs_output {
    /// A builder for [`ListPiiEntitiesDetectionJobsOutput`](crate::output::ListPiiEntitiesDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pii_entities_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::PiiEntitiesDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn pii_entities_detection_job_properties_list(
            mut self,
            input: impl Into<crate::model::PiiEntitiesDetectionJobProperties>,
        ) -> Self {
            let mut v = self
                .pii_entities_detection_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.pii_entities_detection_job_properties_list = Some(v);
            self
        }
        pub fn set_pii_entities_detection_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::PiiEntitiesDetectionJobProperties>,
            >,
        ) -> Self {
            self.pii_entities_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPiiEntitiesDetectionJobsOutput`](crate::output::ListPiiEntitiesDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListPiiEntitiesDetectionJobsOutput {
            crate::output::ListPiiEntitiesDetectionJobsOutput {
                pii_entities_detection_job_properties_list: self
                    .pii_entities_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListPiiEntitiesDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListPiiEntitiesDetectionJobsOutput`](crate::output::ListPiiEntitiesDetectionJobsOutput)
    pub fn builder() -> crate::output::list_pii_entities_detection_jobs_output::Builder {
        crate::output::list_pii_entities_detection_jobs_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListKeyPhrasesDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub key_phrases_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::KeyPhrasesDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListKeyPhrasesDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListKeyPhrasesDetectionJobsOutput");
        formatter.field(
            "key_phrases_detection_job_properties_list",
            &self.key_phrases_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListKeyPhrasesDetectionJobsOutput`](crate::output::ListKeyPhrasesDetectionJobsOutput)
pub mod list_key_phrases_detection_jobs_output {
    /// A builder for [`ListKeyPhrasesDetectionJobsOutput`](crate::output::ListKeyPhrasesDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_phrases_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::KeyPhrasesDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn key_phrases_detection_job_properties_list(
            mut self,
            input: impl Into<crate::model::KeyPhrasesDetectionJobProperties>,
        ) -> Self {
            let mut v = self
                .key_phrases_detection_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.key_phrases_detection_job_properties_list = Some(v);
            self
        }
        pub fn set_key_phrases_detection_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::KeyPhrasesDetectionJobProperties>,
            >,
        ) -> Self {
            self.key_phrases_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListKeyPhrasesDetectionJobsOutput`](crate::output::ListKeyPhrasesDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListKeyPhrasesDetectionJobsOutput {
            crate::output::ListKeyPhrasesDetectionJobsOutput {
                key_phrases_detection_job_properties_list: self
                    .key_phrases_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListKeyPhrasesDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListKeyPhrasesDetectionJobsOutput`](crate::output::ListKeyPhrasesDetectionJobsOutput)
    pub fn builder() -> crate::output::list_key_phrases_detection_jobs_output::Builder {
        crate::output::list_key_phrases_detection_jobs_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEventsDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub events_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::EventsDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEventsDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEventsDetectionJobsOutput");
        formatter.field(
            "events_detection_job_properties_list",
            &self.events_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEventsDetectionJobsOutput`](crate::output::ListEventsDetectionJobsOutput)
pub mod list_events_detection_jobs_output {
    /// A builder for [`ListEventsDetectionJobsOutput`](crate::output::ListEventsDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) events_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::EventsDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn events_detection_job_properties_list(
            mut self,
            input: impl Into<crate::model::EventsDetectionJobProperties>,
        ) -> Self {
            let mut v = self
                .events_detection_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.events_detection_job_properties_list = Some(v);
            self
        }
        pub fn set_events_detection_job_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EventsDetectionJobProperties>>,
        ) -> Self {
            self.events_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEventsDetectionJobsOutput`](crate::output::ListEventsDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListEventsDetectionJobsOutput {
            crate::output::ListEventsDetectionJobsOutput {
                events_detection_job_properties_list: self.events_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEventsDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListEventsDetectionJobsOutput`](crate::output::ListEventsDetectionJobsOutput)
    pub fn builder() -> crate::output::list_events_detection_jobs_output::Builder {
        crate::output::list_events_detection_jobs_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEntityRecognizersOutput {
    /// <p>The list of properties of an entity recognizer.</p>
    pub entity_recognizer_properties_list:
        std::option::Option<std::vec::Vec<crate::model::EntityRecognizerProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEntityRecognizersOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEntityRecognizersOutput");
        formatter.field(
            "entity_recognizer_properties_list",
            &self.entity_recognizer_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEntityRecognizersOutput`](crate::output::ListEntityRecognizersOutput)
pub mod list_entity_recognizers_output {
    /// A builder for [`ListEntityRecognizersOutput`](crate::output::ListEntityRecognizersOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_recognizer_properties_list:
            std::option::Option<std::vec::Vec<crate::model::EntityRecognizerProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn entity_recognizer_properties_list(
            mut self,
            input: impl Into<crate::model::EntityRecognizerProperties>,
        ) -> Self {
            let mut v = self.entity_recognizer_properties_list.unwrap_or_default();
            v.push(input.into());
            self.entity_recognizer_properties_list = Some(v);
            self
        }
        pub fn set_entity_recognizer_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntityRecognizerProperties>>,
        ) -> Self {
            self.entity_recognizer_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEntityRecognizersOutput`](crate::output::ListEntityRecognizersOutput)
        pub fn build(self) -> crate::output::ListEntityRecognizersOutput {
            crate::output::ListEntityRecognizersOutput {
                entity_recognizer_properties_list: self.entity_recognizer_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEntityRecognizersOutput {
    /// Creates a new builder-style object to manufacture [`ListEntityRecognizersOutput`](crate::output::ListEntityRecognizersOutput)
    pub fn builder() -> crate::output::list_entity_recognizers_output::Builder {
        crate::output::list_entity_recognizers_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEntitiesDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub entities_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::EntitiesDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEntitiesDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEntitiesDetectionJobsOutput");
        formatter.field(
            "entities_detection_job_properties_list",
            &self.entities_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEntitiesDetectionJobsOutput`](crate::output::ListEntitiesDetectionJobsOutput)
pub mod list_entities_detection_jobs_output {
    /// A builder for [`ListEntitiesDetectionJobsOutput`](crate::output::ListEntitiesDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities_detection_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::EntitiesDetectionJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn entities_detection_job_properties_list(
            mut self,
            input: impl Into<crate::model::EntitiesDetectionJobProperties>,
        ) -> Self {
            let mut v = self
                .entities_detection_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.entities_detection_job_properties_list = Some(v);
            self
        }
        pub fn set_entities_detection_job_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntitiesDetectionJobProperties>>,
        ) -> Self {
            self.entities_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEntitiesDetectionJobsOutput`](crate::output::ListEntitiesDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListEntitiesDetectionJobsOutput {
            crate::output::ListEntitiesDetectionJobsOutput {
                entities_detection_job_properties_list: self.entities_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEntitiesDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListEntitiesDetectionJobsOutput`](crate::output::ListEntitiesDetectionJobsOutput)
    pub fn builder() -> crate::output::list_entities_detection_jobs_output::Builder {
        crate::output::list_entities_detection_jobs_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEndpointsOutput {
    /// <p>Displays a list of endpoint properties being retrieved by the service in response to the
    /// request.</p>
    pub endpoint_properties_list:
        std::option::Option<std::vec::Vec<crate::model::EndpointProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEndpointsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEndpointsOutput");
        formatter.field("endpoint_properties_list", &self.endpoint_properties_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEndpointsOutput`](crate::output::ListEndpointsOutput)
pub mod list_endpoints_output {
    /// A builder for [`ListEndpointsOutput`](crate::output::ListEndpointsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_properties_list:
            std::option::Option<std::vec::Vec<crate::model::EndpointProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn endpoint_properties_list(
            mut self,
            input: impl Into<crate::model::EndpointProperties>,
        ) -> Self {
            let mut v = self.endpoint_properties_list.unwrap_or_default();
            v.push(input.into());
            self.endpoint_properties_list = Some(v);
            self
        }
        pub fn set_endpoint_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndpointProperties>>,
        ) -> Self {
            self.endpoint_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEndpointsOutput`](crate::output::ListEndpointsOutput)
        pub fn build(self) -> crate::output::ListEndpointsOutput {
            crate::output::ListEndpointsOutput {
                endpoint_properties_list: self.endpoint_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEndpointsOutput {
    /// Creates a new builder-style object to manufacture [`ListEndpointsOutput`](crate::output::ListEndpointsOutput)
    pub fn builder() -> crate::output::list_endpoints_output::Builder {
        crate::output::list_endpoints_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDominantLanguageDetectionJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub dominant_language_detection_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::DominantLanguageDetectionJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDominantLanguageDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDominantLanguageDetectionJobsOutput");
        formatter.field(
            "dominant_language_detection_job_properties_list",
            &self.dominant_language_detection_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListDominantLanguageDetectionJobsOutput`](crate::output::ListDominantLanguageDetectionJobsOutput)
pub mod list_dominant_language_detection_jobs_output {
    /// A builder for [`ListDominantLanguageDetectionJobsOutput`](crate::output::ListDominantLanguageDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dominant_language_detection_job_properties_list: std::option::Option<
            std::vec::Vec<crate::model::DominantLanguageDetectionJobProperties>,
        >,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn dominant_language_detection_job_properties_list(
            mut self,
            input: impl Into<crate::model::DominantLanguageDetectionJobProperties>,
        ) -> Self {
            let mut v = self
                .dominant_language_detection_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.dominant_language_detection_job_properties_list = Some(v);
            self
        }
        pub fn set_dominant_language_detection_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::DominantLanguageDetectionJobProperties>,
            >,
        ) -> Self {
            self.dominant_language_detection_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDominantLanguageDetectionJobsOutput`](crate::output::ListDominantLanguageDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListDominantLanguageDetectionJobsOutput {
            crate::output::ListDominantLanguageDetectionJobsOutput {
                dominant_language_detection_job_properties_list: self
                    .dominant_language_detection_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListDominantLanguageDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListDominantLanguageDetectionJobsOutput`](crate::output::ListDominantLanguageDetectionJobsOutput)
    pub fn builder() -> crate::output::list_dominant_language_detection_jobs_output::Builder {
        crate::output::list_dominant_language_detection_jobs_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentClassifiersOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub document_classifier_properties_list:
        std::option::Option<std::vec::Vec<crate::model::DocumentClassifierProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDocumentClassifiersOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentClassifiersOutput");
        formatter.field(
            "document_classifier_properties_list",
            &self.document_classifier_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListDocumentClassifiersOutput`](crate::output::ListDocumentClassifiersOutput)
pub mod list_document_classifiers_output {
    /// A builder for [`ListDocumentClassifiersOutput`](crate::output::ListDocumentClassifiersOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classifier_properties_list:
            std::option::Option<std::vec::Vec<crate::model::DocumentClassifierProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn document_classifier_properties_list(
            mut self,
            input: impl Into<crate::model::DocumentClassifierProperties>,
        ) -> Self {
            let mut v = self.document_classifier_properties_list.unwrap_or_default();
            v.push(input.into());
            self.document_classifier_properties_list = Some(v);
            self
        }
        pub fn set_document_classifier_properties_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentClassifierProperties>>,
        ) -> Self {
            self.document_classifier_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDocumentClassifiersOutput`](crate::output::ListDocumentClassifiersOutput)
        pub fn build(self) -> crate::output::ListDocumentClassifiersOutput {
            crate::output::ListDocumentClassifiersOutput {
                document_classifier_properties_list: self.document_classifier_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListDocumentClassifiersOutput {
    /// Creates a new builder-style object to manufacture [`ListDocumentClassifiersOutput`](crate::output::ListDocumentClassifiersOutput)
    pub fn builder() -> crate::output::list_document_classifiers_output::Builder {
        crate::output::list_document_classifiers_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDocumentClassificationJobsOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub document_classification_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::DocumentClassificationJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDocumentClassificationJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDocumentClassificationJobsOutput");
        formatter.field(
            "document_classification_job_properties_list",
            &self.document_classification_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListDocumentClassificationJobsOutput`](crate::output::ListDocumentClassificationJobsOutput)
pub mod list_document_classification_jobs_output {
    /// A builder for [`ListDocumentClassificationJobsOutput`](crate::output::ListDocumentClassificationJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classification_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::DocumentClassificationJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn document_classification_job_properties_list(
            mut self,
            input: impl Into<crate::model::DocumentClassificationJobProperties>,
        ) -> Self {
            let mut v = self
                .document_classification_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.document_classification_job_properties_list = Some(v);
            self
        }
        pub fn set_document_classification_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::DocumentClassificationJobProperties>,
            >,
        ) -> Self {
            self.document_classification_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDocumentClassificationJobsOutput`](crate::output::ListDocumentClassificationJobsOutput)
        pub fn build(self) -> crate::output::ListDocumentClassificationJobsOutput {
            crate::output::ListDocumentClassificationJobsOutput {
                document_classification_job_properties_list: self
                    .document_classification_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListDocumentClassificationJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListDocumentClassificationJobsOutput`](crate::output::ListDocumentClassificationJobsOutput)
    pub fn builder() -> crate::output::list_document_classification_jobs_output::Builder {
        crate::output::list_document_classification_jobs_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectSyntaxOutput {
    /// <p>A collection of syntax tokens describing the text. For each token, the response provides
    /// the text, the token type, where the text begins and ends, and the level of confidence that
    /// Amazon Comprehend has that the token is correct. For a list of token types, see <a>how-syntax</a>.</p>
    pub syntax_tokens: std::option::Option<std::vec::Vec<crate::model::SyntaxToken>>,
}
impl std::fmt::Debug for DetectSyntaxOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectSyntaxOutput");
        formatter.field("syntax_tokens", &self.syntax_tokens);
        formatter.finish()
    }
}
/// See [`DetectSyntaxOutput`](crate::output::DetectSyntaxOutput)
pub mod detect_syntax_output {
    /// A builder for [`DetectSyntaxOutput`](crate::output::DetectSyntaxOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) syntax_tokens: std::option::Option<std::vec::Vec<crate::model::SyntaxToken>>,
    }
    impl Builder {
        pub fn syntax_tokens(mut self, input: impl Into<crate::model::SyntaxToken>) -> Self {
            let mut v = self.syntax_tokens.unwrap_or_default();
            v.push(input.into());
            self.syntax_tokens = Some(v);
            self
        }
        pub fn set_syntax_tokens(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SyntaxToken>>,
        ) -> Self {
            self.syntax_tokens = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectSyntaxOutput`](crate::output::DetectSyntaxOutput)
        pub fn build(self) -> crate::output::DetectSyntaxOutput {
            crate::output::DetectSyntaxOutput {
                syntax_tokens: self.syntax_tokens,
            }
        }
    }
}
impl DetectSyntaxOutput {
    /// Creates a new builder-style object to manufacture [`DetectSyntaxOutput`](crate::output::DetectSyntaxOutput)
    pub fn builder() -> crate::output::detect_syntax_output::Builder {
        crate::output::detect_syntax_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectSentimentOutput {
    /// <p>The inferred sentiment that Amazon Comprehend has the highest level of confidence
    /// in.</p>
    pub sentiment: std::option::Option<crate::model::SentimentType>,
    /// <p>An object that lists the sentiments, and their corresponding confidence
    /// levels.</p>
    pub sentiment_score: std::option::Option<crate::model::SentimentScore>,
}
impl std::fmt::Debug for DetectSentimentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectSentimentOutput");
        formatter.field("sentiment", &self.sentiment);
        formatter.field("sentiment_score", &self.sentiment_score);
        formatter.finish()
    }
}
/// See [`DetectSentimentOutput`](crate::output::DetectSentimentOutput)
pub mod detect_sentiment_output {
    /// A builder for [`DetectSentimentOutput`](crate::output::DetectSentimentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sentiment: std::option::Option<crate::model::SentimentType>,
        pub(crate) sentiment_score: std::option::Option<crate::model::SentimentScore>,
    }
    impl Builder {
        /// <p>The inferred sentiment that Amazon Comprehend has the highest level of confidence
        /// in.</p>
        pub fn sentiment(mut self, input: crate::model::SentimentType) -> Self {
            self.sentiment = Some(input);
            self
        }
        pub fn set_sentiment(
            mut self,
            input: std::option::Option<crate::model::SentimentType>,
        ) -> Self {
            self.sentiment = input;
            self
        }
        /// <p>An object that lists the sentiments, and their corresponding confidence
        /// levels.</p>
        pub fn sentiment_score(mut self, input: crate::model::SentimentScore) -> Self {
            self.sentiment_score = Some(input);
            self
        }
        pub fn set_sentiment_score(
            mut self,
            input: std::option::Option<crate::model::SentimentScore>,
        ) -> Self {
            self.sentiment_score = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectSentimentOutput`](crate::output::DetectSentimentOutput)
        pub fn build(self) -> crate::output::DetectSentimentOutput {
            crate::output::DetectSentimentOutput {
                sentiment: self.sentiment,
                sentiment_score: self.sentiment_score,
            }
        }
    }
}
impl DetectSentimentOutput {
    /// Creates a new builder-style object to manufacture [`DetectSentimentOutput`](crate::output::DetectSentimentOutput)
    pub fn builder() -> crate::output::detect_sentiment_output::Builder {
        crate::output::detect_sentiment_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectPiiEntitiesOutput {
    /// <p>A collection of PII entities identified in the input text. For each entity, the response
    /// provides the entity type, where the entity text begins and ends, and the level of confidence
    /// that Amazon Comprehend has in the detection.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::PiiEntity>>,
}
impl std::fmt::Debug for DetectPiiEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectPiiEntitiesOutput");
        formatter.field("entities", &self.entities);
        formatter.finish()
    }
}
/// See [`DetectPiiEntitiesOutput`](crate::output::DetectPiiEntitiesOutput)
pub mod detect_pii_entities_output {
    /// A builder for [`DetectPiiEntitiesOutput`](crate::output::DetectPiiEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::PiiEntity>>,
    }
    impl Builder {
        pub fn entities(mut self, input: impl Into<crate::model::PiiEntity>) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input.into());
            self.entities = Some(v);
            self
        }
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PiiEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectPiiEntitiesOutput`](crate::output::DetectPiiEntitiesOutput)
        pub fn build(self) -> crate::output::DetectPiiEntitiesOutput {
            crate::output::DetectPiiEntitiesOutput {
                entities: self.entities,
            }
        }
    }
}
impl DetectPiiEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`DetectPiiEntitiesOutput`](crate::output::DetectPiiEntitiesOutput)
    pub fn builder() -> crate::output::detect_pii_entities_output::Builder {
        crate::output::detect_pii_entities_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectKeyPhrasesOutput {
    /// <p>A collection of key phrases that Amazon Comprehend identified in the input text. For
    /// each key phrase, the response provides the text of the key phrase, where the key phrase begins
    /// and ends, and the level of confidence that Amazon Comprehend has in the accuracy of the
    /// detection. </p>
    pub key_phrases: std::option::Option<std::vec::Vec<crate::model::KeyPhrase>>,
}
impl std::fmt::Debug for DetectKeyPhrasesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectKeyPhrasesOutput");
        formatter.field("key_phrases", &self.key_phrases);
        formatter.finish()
    }
}
/// See [`DetectKeyPhrasesOutput`](crate::output::DetectKeyPhrasesOutput)
pub mod detect_key_phrases_output {
    /// A builder for [`DetectKeyPhrasesOutput`](crate::output::DetectKeyPhrasesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_phrases: std::option::Option<std::vec::Vec<crate::model::KeyPhrase>>,
    }
    impl Builder {
        pub fn key_phrases(mut self, input: impl Into<crate::model::KeyPhrase>) -> Self {
            let mut v = self.key_phrases.unwrap_or_default();
            v.push(input.into());
            self.key_phrases = Some(v);
            self
        }
        pub fn set_key_phrases(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::KeyPhrase>>,
        ) -> Self {
            self.key_phrases = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectKeyPhrasesOutput`](crate::output::DetectKeyPhrasesOutput)
        pub fn build(self) -> crate::output::DetectKeyPhrasesOutput {
            crate::output::DetectKeyPhrasesOutput {
                key_phrases: self.key_phrases,
            }
        }
    }
}
impl DetectKeyPhrasesOutput {
    /// Creates a new builder-style object to manufacture [`DetectKeyPhrasesOutput`](crate::output::DetectKeyPhrasesOutput)
    pub fn builder() -> crate::output::detect_key_phrases_output::Builder {
        crate::output::detect_key_phrases_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectEntitiesOutput {
    /// <p>A collection of entities identified in the input text. For each entity, the response
    /// provides the entity text, entity type, where the entity text begins and ends, and the level of
    /// confidence that Amazon Comprehend has in the detection. </p>
    /// <p>If your request uses a custom entity recognition model, Amazon Comprehend detects the
    /// entities that the model is trained to recognize. Otherwise, it detects the default entity
    /// types. For a list of default entity types, see <a>how-entities</a>.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
}
impl std::fmt::Debug for DetectEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectEntitiesOutput");
        formatter.field("entities", &self.entities);
        formatter.finish()
    }
}
/// See [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
pub mod detect_entities_output {
    /// A builder for [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    }
    impl Builder {
        pub fn entities(mut self, input: impl Into<crate::model::Entity>) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input.into());
            self.entities = Some(v);
            self
        }
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
        pub fn build(self) -> crate::output::DetectEntitiesOutput {
            crate::output::DetectEntitiesOutput {
                entities: self.entities,
            }
        }
    }
}
impl DetectEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
    pub fn builder() -> crate::output::detect_entities_output::Builder {
        crate::output::detect_entities_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectDominantLanguageOutput {
    /// <p>The languages that Amazon Comprehend detected in the input text. For each language, the
    /// response returns the RFC 5646 language code and the level of confidence that Amazon Comprehend
    /// has in the accuracy of its inference. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the
    /// <i>IETF Tools</i> web site.</p>
    pub languages: std::option::Option<std::vec::Vec<crate::model::DominantLanguage>>,
}
impl std::fmt::Debug for DetectDominantLanguageOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectDominantLanguageOutput");
        formatter.field("languages", &self.languages);
        formatter.finish()
    }
}
/// See [`DetectDominantLanguageOutput`](crate::output::DetectDominantLanguageOutput)
pub mod detect_dominant_language_output {
    /// A builder for [`DetectDominantLanguageOutput`](crate::output::DetectDominantLanguageOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) languages: std::option::Option<std::vec::Vec<crate::model::DominantLanguage>>,
    }
    impl Builder {
        pub fn languages(mut self, input: impl Into<crate::model::DominantLanguage>) -> Self {
            let mut v = self.languages.unwrap_or_default();
            v.push(input.into());
            self.languages = Some(v);
            self
        }
        pub fn set_languages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DominantLanguage>>,
        ) -> Self {
            self.languages = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectDominantLanguageOutput`](crate::output::DetectDominantLanguageOutput)
        pub fn build(self) -> crate::output::DetectDominantLanguageOutput {
            crate::output::DetectDominantLanguageOutput {
                languages: self.languages,
            }
        }
    }
}
impl DetectDominantLanguageOutput {
    /// Creates a new builder-style object to manufacture [`DetectDominantLanguageOutput`](crate::output::DetectDominantLanguageOutput)
    pub fn builder() -> crate::output::detect_dominant_language_output::Builder {
        crate::output::detect_dominant_language_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeTopicsDetectionJobOutput {
    /// <p>The list of properties for the requested job.</p>
    pub topics_detection_job_properties:
        std::option::Option<crate::model::TopicsDetectionJobProperties>,
}
impl std::fmt::Debug for DescribeTopicsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeTopicsDetectionJobOutput");
        formatter.field(
            "topics_detection_job_properties",
            &self.topics_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeTopicsDetectionJobOutput`](crate::output::DescribeTopicsDetectionJobOutput)
pub mod describe_topics_detection_job_output {
    /// A builder for [`DescribeTopicsDetectionJobOutput`](crate::output::DescribeTopicsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) topics_detection_job_properties:
            std::option::Option<crate::model::TopicsDetectionJobProperties>,
    }
    impl Builder {
        /// <p>The list of properties for the requested job.</p>
        pub fn topics_detection_job_properties(
            mut self,
            input: crate::model::TopicsDetectionJobProperties,
        ) -> Self {
            self.topics_detection_job_properties = Some(input);
            self
        }
        pub fn set_topics_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::TopicsDetectionJobProperties>,
        ) -> Self {
            self.topics_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeTopicsDetectionJobOutput`](crate::output::DescribeTopicsDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeTopicsDetectionJobOutput {
            crate::output::DescribeTopicsDetectionJobOutput {
                topics_detection_job_properties: self.topics_detection_job_properties,
            }
        }
    }
}
impl DescribeTopicsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeTopicsDetectionJobOutput`](crate::output::DescribeTopicsDetectionJobOutput)
    pub fn builder() -> crate::output::describe_topics_detection_job_output::Builder {
        crate::output::describe_topics_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSentimentDetectionJobOutput {
    /// <p>An object that contains the properties associated with a sentiment detection job.</p>
    pub sentiment_detection_job_properties:
        std::option::Option<crate::model::SentimentDetectionJobProperties>,
}
impl std::fmt::Debug for DescribeSentimentDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSentimentDetectionJobOutput");
        formatter.field(
            "sentiment_detection_job_properties",
            &self.sentiment_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeSentimentDetectionJobOutput`](crate::output::DescribeSentimentDetectionJobOutput)
pub mod describe_sentiment_detection_job_output {
    /// A builder for [`DescribeSentimentDetectionJobOutput`](crate::output::DescribeSentimentDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sentiment_detection_job_properties:
            std::option::Option<crate::model::SentimentDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a sentiment detection job.</p>
        pub fn sentiment_detection_job_properties(
            mut self,
            input: crate::model::SentimentDetectionJobProperties,
        ) -> Self {
            self.sentiment_detection_job_properties = Some(input);
            self
        }
        pub fn set_sentiment_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::SentimentDetectionJobProperties>,
        ) -> Self {
            self.sentiment_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSentimentDetectionJobOutput`](crate::output::DescribeSentimentDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeSentimentDetectionJobOutput {
            crate::output::DescribeSentimentDetectionJobOutput {
                sentiment_detection_job_properties: self.sentiment_detection_job_properties,
            }
        }
    }
}
impl DescribeSentimentDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeSentimentDetectionJobOutput`](crate::output::DescribeSentimentDetectionJobOutput)
    pub fn builder() -> crate::output::describe_sentiment_detection_job_output::Builder {
        crate::output::describe_sentiment_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePiiEntitiesDetectionJobOutput {
    /// <p>Provides information about a PII entities detection job.</p>
    pub pii_entities_detection_job_properties:
        std::option::Option<crate::model::PiiEntitiesDetectionJobProperties>,
}
impl std::fmt::Debug for DescribePiiEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePiiEntitiesDetectionJobOutput");
        formatter.field(
            "pii_entities_detection_job_properties",
            &self.pii_entities_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribePiiEntitiesDetectionJobOutput`](crate::output::DescribePiiEntitiesDetectionJobOutput)
pub mod describe_pii_entities_detection_job_output {
    /// A builder for [`DescribePiiEntitiesDetectionJobOutput`](crate::output::DescribePiiEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pii_entities_detection_job_properties:
            std::option::Option<crate::model::PiiEntitiesDetectionJobProperties>,
    }
    impl Builder {
        /// <p>Provides information about a PII entities detection job.</p>
        pub fn pii_entities_detection_job_properties(
            mut self,
            input: crate::model::PiiEntitiesDetectionJobProperties,
        ) -> Self {
            self.pii_entities_detection_job_properties = Some(input);
            self
        }
        pub fn set_pii_entities_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::PiiEntitiesDetectionJobProperties>,
        ) -> Self {
            self.pii_entities_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribePiiEntitiesDetectionJobOutput`](crate::output::DescribePiiEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribePiiEntitiesDetectionJobOutput {
            crate::output::DescribePiiEntitiesDetectionJobOutput {
                pii_entities_detection_job_properties: self.pii_entities_detection_job_properties,
            }
        }
    }
}
impl DescribePiiEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribePiiEntitiesDetectionJobOutput`](crate::output::DescribePiiEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::describe_pii_entities_detection_job_output::Builder {
        crate::output::describe_pii_entities_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeKeyPhrasesDetectionJobOutput {
    /// <p>An object that contains the properties associated with a key phrases detection job.
    /// </p>
    pub key_phrases_detection_job_properties:
        std::option::Option<crate::model::KeyPhrasesDetectionJobProperties>,
}
impl std::fmt::Debug for DescribeKeyPhrasesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeKeyPhrasesDetectionJobOutput");
        formatter.field(
            "key_phrases_detection_job_properties",
            &self.key_phrases_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeKeyPhrasesDetectionJobOutput`](crate::output::DescribeKeyPhrasesDetectionJobOutput)
pub mod describe_key_phrases_detection_job_output {
    /// A builder for [`DescribeKeyPhrasesDetectionJobOutput`](crate::output::DescribeKeyPhrasesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_phrases_detection_job_properties:
            std::option::Option<crate::model::KeyPhrasesDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a key phrases detection job.
        /// </p>
        pub fn key_phrases_detection_job_properties(
            mut self,
            input: crate::model::KeyPhrasesDetectionJobProperties,
        ) -> Self {
            self.key_phrases_detection_job_properties = Some(input);
            self
        }
        pub fn set_key_phrases_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::KeyPhrasesDetectionJobProperties>,
        ) -> Self {
            self.key_phrases_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeKeyPhrasesDetectionJobOutput`](crate::output::DescribeKeyPhrasesDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeKeyPhrasesDetectionJobOutput {
            crate::output::DescribeKeyPhrasesDetectionJobOutput {
                key_phrases_detection_job_properties: self.key_phrases_detection_job_properties,
            }
        }
    }
}
impl DescribeKeyPhrasesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeKeyPhrasesDetectionJobOutput`](crate::output::DescribeKeyPhrasesDetectionJobOutput)
    pub fn builder() -> crate::output::describe_key_phrases_detection_job_output::Builder {
        crate::output::describe_key_phrases_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEventsDetectionJobOutput {
    /// <p>An object that contains the properties associated with an event detection job.</p>
    pub events_detection_job_properties:
        std::option::Option<crate::model::EventsDetectionJobProperties>,
}
impl std::fmt::Debug for DescribeEventsDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEventsDetectionJobOutput");
        formatter.field(
            "events_detection_job_properties",
            &self.events_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeEventsDetectionJobOutput`](crate::output::DescribeEventsDetectionJobOutput)
pub mod describe_events_detection_job_output {
    /// A builder for [`DescribeEventsDetectionJobOutput`](crate::output::DescribeEventsDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) events_detection_job_properties:
            std::option::Option<crate::model::EventsDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with an event detection job.</p>
        pub fn events_detection_job_properties(
            mut self,
            input: crate::model::EventsDetectionJobProperties,
        ) -> Self {
            self.events_detection_job_properties = Some(input);
            self
        }
        pub fn set_events_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::EventsDetectionJobProperties>,
        ) -> Self {
            self.events_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEventsDetectionJobOutput`](crate::output::DescribeEventsDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeEventsDetectionJobOutput {
            crate::output::DescribeEventsDetectionJobOutput {
                events_detection_job_properties: self.events_detection_job_properties,
            }
        }
    }
}
impl DescribeEventsDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEventsDetectionJobOutput`](crate::output::DescribeEventsDetectionJobOutput)
    pub fn builder() -> crate::output::describe_events_detection_job_output::Builder {
        crate::output::describe_events_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEntityRecognizerOutput {
    /// <p>Describes information associated with an entity recognizer.</p>
    pub entity_recognizer_properties: std::option::Option<crate::model::EntityRecognizerProperties>,
}
impl std::fmt::Debug for DescribeEntityRecognizerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEntityRecognizerOutput");
        formatter.field(
            "entity_recognizer_properties",
            &self.entity_recognizer_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeEntityRecognizerOutput`](crate::output::DescribeEntityRecognizerOutput)
pub mod describe_entity_recognizer_output {
    /// A builder for [`DescribeEntityRecognizerOutput`](crate::output::DescribeEntityRecognizerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_recognizer_properties:
            std::option::Option<crate::model::EntityRecognizerProperties>,
    }
    impl Builder {
        /// <p>Describes information associated with an entity recognizer.</p>
        pub fn entity_recognizer_properties(
            mut self,
            input: crate::model::EntityRecognizerProperties,
        ) -> Self {
            self.entity_recognizer_properties = Some(input);
            self
        }
        pub fn set_entity_recognizer_properties(
            mut self,
            input: std::option::Option<crate::model::EntityRecognizerProperties>,
        ) -> Self {
            self.entity_recognizer_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEntityRecognizerOutput`](crate::output::DescribeEntityRecognizerOutput)
        pub fn build(self) -> crate::output::DescribeEntityRecognizerOutput {
            crate::output::DescribeEntityRecognizerOutput {
                entity_recognizer_properties: self.entity_recognizer_properties,
            }
        }
    }
}
impl DescribeEntityRecognizerOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEntityRecognizerOutput`](crate::output::DescribeEntityRecognizerOutput)
    pub fn builder() -> crate::output::describe_entity_recognizer_output::Builder {
        crate::output::describe_entity_recognizer_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEntitiesDetectionJobOutput {
    /// <p>An object that contains the properties associated with an entities detection job.</p>
    pub entities_detection_job_properties:
        std::option::Option<crate::model::EntitiesDetectionJobProperties>,
}
impl std::fmt::Debug for DescribeEntitiesDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEntitiesDetectionJobOutput");
        formatter.field(
            "entities_detection_job_properties",
            &self.entities_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeEntitiesDetectionJobOutput`](crate::output::DescribeEntitiesDetectionJobOutput)
pub mod describe_entities_detection_job_output {
    /// A builder for [`DescribeEntitiesDetectionJobOutput`](crate::output::DescribeEntitiesDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities_detection_job_properties:
            std::option::Option<crate::model::EntitiesDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with an entities detection job.</p>
        pub fn entities_detection_job_properties(
            mut self,
            input: crate::model::EntitiesDetectionJobProperties,
        ) -> Self {
            self.entities_detection_job_properties = Some(input);
            self
        }
        pub fn set_entities_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::EntitiesDetectionJobProperties>,
        ) -> Self {
            self.entities_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEntitiesDetectionJobOutput`](crate::output::DescribeEntitiesDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeEntitiesDetectionJobOutput {
            crate::output::DescribeEntitiesDetectionJobOutput {
                entities_detection_job_properties: self.entities_detection_job_properties,
            }
        }
    }
}
impl DescribeEntitiesDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEntitiesDetectionJobOutput`](crate::output::DescribeEntitiesDetectionJobOutput)
    pub fn builder() -> crate::output::describe_entities_detection_job_output::Builder {
        crate::output::describe_entities_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEndpointOutput {
    /// <p>Describes information associated with the specific endpoint.</p>
    pub endpoint_properties: std::option::Option<crate::model::EndpointProperties>,
}
impl std::fmt::Debug for DescribeEndpointOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEndpointOutput");
        formatter.field("endpoint_properties", &self.endpoint_properties);
        formatter.finish()
    }
}
/// See [`DescribeEndpointOutput`](crate::output::DescribeEndpointOutput)
pub mod describe_endpoint_output {
    /// A builder for [`DescribeEndpointOutput`](crate::output::DescribeEndpointOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_properties: std::option::Option<crate::model::EndpointProperties>,
    }
    impl Builder {
        /// <p>Describes information associated with the specific endpoint.</p>
        pub fn endpoint_properties(mut self, input: crate::model::EndpointProperties) -> Self {
            self.endpoint_properties = Some(input);
            self
        }
        pub fn set_endpoint_properties(
            mut self,
            input: std::option::Option<crate::model::EndpointProperties>,
        ) -> Self {
            self.endpoint_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEndpointOutput`](crate::output::DescribeEndpointOutput)
        pub fn build(self) -> crate::output::DescribeEndpointOutput {
            crate::output::DescribeEndpointOutput {
                endpoint_properties: self.endpoint_properties,
            }
        }
    }
}
impl DescribeEndpointOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEndpointOutput`](crate::output::DescribeEndpointOutput)
    pub fn builder() -> crate::output::describe_endpoint_output::Builder {
        crate::output::describe_endpoint_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDominantLanguageDetectionJobOutput {
    /// <p>An object that contains the properties associated with a dominant language detection
    /// job.</p>
    pub dominant_language_detection_job_properties:
        std::option::Option<crate::model::DominantLanguageDetectionJobProperties>,
}
impl std::fmt::Debug for DescribeDominantLanguageDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDominantLanguageDetectionJobOutput");
        formatter.field(
            "dominant_language_detection_job_properties",
            &self.dominant_language_detection_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeDominantLanguageDetectionJobOutput`](crate::output::DescribeDominantLanguageDetectionJobOutput)
pub mod describe_dominant_language_detection_job_output {
    /// A builder for [`DescribeDominantLanguageDetectionJobOutput`](crate::output::DescribeDominantLanguageDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dominant_language_detection_job_properties:
            std::option::Option<crate::model::DominantLanguageDetectionJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a dominant language detection
        /// job.</p>
        pub fn dominant_language_detection_job_properties(
            mut self,
            input: crate::model::DominantLanguageDetectionJobProperties,
        ) -> Self {
            self.dominant_language_detection_job_properties = Some(input);
            self
        }
        pub fn set_dominant_language_detection_job_properties(
            mut self,
            input: std::option::Option<crate::model::DominantLanguageDetectionJobProperties>,
        ) -> Self {
            self.dominant_language_detection_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDominantLanguageDetectionJobOutput`](crate::output::DescribeDominantLanguageDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribeDominantLanguageDetectionJobOutput {
            crate::output::DescribeDominantLanguageDetectionJobOutput {
                dominant_language_detection_job_properties: self
                    .dominant_language_detection_job_properties,
            }
        }
    }
}
impl DescribeDominantLanguageDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeDominantLanguageDetectionJobOutput`](crate::output::DescribeDominantLanguageDetectionJobOutput)
    pub fn builder() -> crate::output::describe_dominant_language_detection_job_output::Builder {
        crate::output::describe_dominant_language_detection_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDocumentClassifierOutput {
    /// <p>An object that contains the properties associated with a document classifier.</p>
    pub document_classifier_properties:
        std::option::Option<crate::model::DocumentClassifierProperties>,
}
impl std::fmt::Debug for DescribeDocumentClassifierOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDocumentClassifierOutput");
        formatter.field(
            "document_classifier_properties",
            &self.document_classifier_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeDocumentClassifierOutput`](crate::output::DescribeDocumentClassifierOutput)
pub mod describe_document_classifier_output {
    /// A builder for [`DescribeDocumentClassifierOutput`](crate::output::DescribeDocumentClassifierOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classifier_properties:
            std::option::Option<crate::model::DocumentClassifierProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a document classifier.</p>
        pub fn document_classifier_properties(
            mut self,
            input: crate::model::DocumentClassifierProperties,
        ) -> Self {
            self.document_classifier_properties = Some(input);
            self
        }
        pub fn set_document_classifier_properties(
            mut self,
            input: std::option::Option<crate::model::DocumentClassifierProperties>,
        ) -> Self {
            self.document_classifier_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDocumentClassifierOutput`](crate::output::DescribeDocumentClassifierOutput)
        pub fn build(self) -> crate::output::DescribeDocumentClassifierOutput {
            crate::output::DescribeDocumentClassifierOutput {
                document_classifier_properties: self.document_classifier_properties,
            }
        }
    }
}
impl DescribeDocumentClassifierOutput {
    /// Creates a new builder-style object to manufacture [`DescribeDocumentClassifierOutput`](crate::output::DescribeDocumentClassifierOutput)
    pub fn builder() -> crate::output::describe_document_classifier_output::Builder {
        crate::output::describe_document_classifier_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDocumentClassificationJobOutput {
    /// <p>An object that describes the properties associated with the document classification
    /// job.</p>
    pub document_classification_job_properties:
        std::option::Option<crate::model::DocumentClassificationJobProperties>,
}
impl std::fmt::Debug for DescribeDocumentClassificationJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDocumentClassificationJobOutput");
        formatter.field(
            "document_classification_job_properties",
            &self.document_classification_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeDocumentClassificationJobOutput`](crate::output::DescribeDocumentClassificationJobOutput)
pub mod describe_document_classification_job_output {
    /// A builder for [`DescribeDocumentClassificationJobOutput`](crate::output::DescribeDocumentClassificationJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classification_job_properties:
            std::option::Option<crate::model::DocumentClassificationJobProperties>,
    }
    impl Builder {
        /// <p>An object that describes the properties associated with the document classification
        /// job.</p>
        pub fn document_classification_job_properties(
            mut self,
            input: crate::model::DocumentClassificationJobProperties,
        ) -> Self {
            self.document_classification_job_properties = Some(input);
            self
        }
        pub fn set_document_classification_job_properties(
            mut self,
            input: std::option::Option<crate::model::DocumentClassificationJobProperties>,
        ) -> Self {
            self.document_classification_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDocumentClassificationJobOutput`](crate::output::DescribeDocumentClassificationJobOutput)
        pub fn build(self) -> crate::output::DescribeDocumentClassificationJobOutput {
            crate::output::DescribeDocumentClassificationJobOutput {
                document_classification_job_properties: self.document_classification_job_properties,
            }
        }
    }
}
impl DescribeDocumentClassificationJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeDocumentClassificationJobOutput`](crate::output::DescribeDocumentClassificationJobOutput)
    pub fn builder() -> crate::output::describe_document_classification_job_output::Builder {
        crate::output::describe_document_classification_job_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteEntityRecognizerOutput {}
impl std::fmt::Debug for DeleteEntityRecognizerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteEntityRecognizerOutput");
        formatter.finish()
    }
}
/// See [`DeleteEntityRecognizerOutput`](crate::output::DeleteEntityRecognizerOutput)
pub mod delete_entity_recognizer_output {
    /// A builder for [`DeleteEntityRecognizerOutput`](crate::output::DeleteEntityRecognizerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteEntityRecognizerOutput`](crate::output::DeleteEntityRecognizerOutput)
        pub fn build(self) -> crate::output::DeleteEntityRecognizerOutput {
            crate::output::DeleteEntityRecognizerOutput {}
        }
    }
}
impl DeleteEntityRecognizerOutput {
    /// Creates a new builder-style object to manufacture [`DeleteEntityRecognizerOutput`](crate::output::DeleteEntityRecognizerOutput)
    pub fn builder() -> crate::output::delete_entity_recognizer_output::Builder {
        crate::output::delete_entity_recognizer_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteEndpointOutput {}
impl std::fmt::Debug for DeleteEndpointOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteEndpointOutput");
        formatter.finish()
    }
}
/// See [`DeleteEndpointOutput`](crate::output::DeleteEndpointOutput)
pub mod delete_endpoint_output {
    /// A builder for [`DeleteEndpointOutput`](crate::output::DeleteEndpointOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteEndpointOutput`](crate::output::DeleteEndpointOutput)
        pub fn build(self) -> crate::output::DeleteEndpointOutput {
            crate::output::DeleteEndpointOutput {}
        }
    }
}
impl DeleteEndpointOutput {
    /// Creates a new builder-style object to manufacture [`DeleteEndpointOutput`](crate::output::DeleteEndpointOutput)
    pub fn builder() -> crate::output::delete_endpoint_output::Builder {
        crate::output::delete_endpoint_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDocumentClassifierOutput {}
impl std::fmt::Debug for DeleteDocumentClassifierOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDocumentClassifierOutput");
        formatter.finish()
    }
}
/// See [`DeleteDocumentClassifierOutput`](crate::output::DeleteDocumentClassifierOutput)
pub mod delete_document_classifier_output {
    /// A builder for [`DeleteDocumentClassifierOutput`](crate::output::DeleteDocumentClassifierOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteDocumentClassifierOutput`](crate::output::DeleteDocumentClassifierOutput)
        pub fn build(self) -> crate::output::DeleteDocumentClassifierOutput {
            crate::output::DeleteDocumentClassifierOutput {}
        }
    }
}
impl DeleteDocumentClassifierOutput {
    /// Creates a new builder-style object to manufacture [`DeleteDocumentClassifierOutput`](crate::output::DeleteDocumentClassifierOutput)
    pub fn builder() -> crate::output::delete_document_classifier_output::Builder {
        crate::output::delete_document_classifier_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEntityRecognizerOutput {
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    pub entity_recognizer_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateEntityRecognizerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEntityRecognizerOutput");
        formatter.field("entity_recognizer_arn", &self.entity_recognizer_arn);
        formatter.finish()
    }
}
/// See [`CreateEntityRecognizerOutput`](crate::output::CreateEntityRecognizerOutput)
pub mod create_entity_recognizer_output {
    /// A builder for [`CreateEntityRecognizerOutput`](crate::output::CreateEntityRecognizerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entity_recognizer_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
        pub fn entity_recognizer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_recognizer_arn = Some(input.into());
            self
        }
        pub fn set_entity_recognizer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.entity_recognizer_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateEntityRecognizerOutput`](crate::output::CreateEntityRecognizerOutput)
        pub fn build(self) -> crate::output::CreateEntityRecognizerOutput {
            crate::output::CreateEntityRecognizerOutput {
                entity_recognizer_arn: self.entity_recognizer_arn,
            }
        }
    }
}
impl CreateEntityRecognizerOutput {
    /// Creates a new builder-style object to manufacture [`CreateEntityRecognizerOutput`](crate::output::CreateEntityRecognizerOutput)
    pub fn builder() -> crate::output::create_entity_recognizer_output::Builder {
        crate::output::create_entity_recognizer_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEndpointOutput {
    /// <p>The Amazon Resource Number (ARN) of the endpoint being created.</p>
    pub endpoint_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateEndpointOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEndpointOutput");
        formatter.field("endpoint_arn", &self.endpoint_arn);
        formatter.finish()
    }
}
/// See [`CreateEndpointOutput`](crate::output::CreateEndpointOutput)
pub mod create_endpoint_output {
    /// A builder for [`CreateEndpointOutput`](crate::output::CreateEndpointOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Number (ARN) of the endpoint being created.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_arn = Some(input.into());
            self
        }
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateEndpointOutput`](crate::output::CreateEndpointOutput)
        pub fn build(self) -> crate::output::CreateEndpointOutput {
            crate::output::CreateEndpointOutput {
                endpoint_arn: self.endpoint_arn,
            }
        }
    }
}
impl CreateEndpointOutput {
    /// Creates a new builder-style object to manufacture [`CreateEndpointOutput`](crate::output::CreateEndpointOutput)
    pub fn builder() -> crate::output::create_endpoint_output::Builder {
        crate::output::create_endpoint_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDocumentClassifierOutput {
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
    pub document_classifier_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateDocumentClassifierOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDocumentClassifierOutput");
        formatter.field("document_classifier_arn", &self.document_classifier_arn);
        formatter.finish()
    }
}
/// See [`CreateDocumentClassifierOutput`](crate::output::CreateDocumentClassifierOutput)
pub mod create_document_classifier_output {
    /// A builder for [`CreateDocumentClassifierOutput`](crate::output::CreateDocumentClassifierOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classifier_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
        pub fn document_classifier_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_classifier_arn = Some(input.into());
            self
        }
        pub fn set_document_classifier_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_classifier_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDocumentClassifierOutput`](crate::output::CreateDocumentClassifierOutput)
        pub fn build(self) -> crate::output::CreateDocumentClassifierOutput {
            crate::output::CreateDocumentClassifierOutput {
                document_classifier_arn: self.document_classifier_arn,
            }
        }
    }
}
impl CreateDocumentClassifierOutput {
    /// Creates a new builder-style object to manufacture [`CreateDocumentClassifierOutput`](crate::output::CreateDocumentClassifierOutput)
    pub fn builder() -> crate::output::create_document_classifier_output::Builder {
        crate::output::create_document_classifier_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContainsPiiEntitiesOutput {
    /// <p>The labels used in the document being analyzed. Individual labels represent personally
    /// identifiable information (PII) entity types.</p>
    pub labels: std::option::Option<std::vec::Vec<crate::model::EntityLabel>>,
}
impl std::fmt::Debug for ContainsPiiEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContainsPiiEntitiesOutput");
        formatter.field("labels", &self.labels);
        formatter.finish()
    }
}
/// See [`ContainsPiiEntitiesOutput`](crate::output::ContainsPiiEntitiesOutput)
pub mod contains_pii_entities_output {
    /// A builder for [`ContainsPiiEntitiesOutput`](crate::output::ContainsPiiEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) labels: std::option::Option<std::vec::Vec<crate::model::EntityLabel>>,
    }
    impl Builder {
        pub fn labels(mut self, input: impl Into<crate::model::EntityLabel>) -> Self {
            let mut v = self.labels.unwrap_or_default();
            v.push(input.into());
            self.labels = Some(v);
            self
        }
        pub fn set_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntityLabel>>,
        ) -> Self {
            self.labels = input;
            self
        }
        /// Consumes the builder and constructs a [`ContainsPiiEntitiesOutput`](crate::output::ContainsPiiEntitiesOutput)
        pub fn build(self) -> crate::output::ContainsPiiEntitiesOutput {
            crate::output::ContainsPiiEntitiesOutput {
                labels: self.labels,
            }
        }
    }
}
impl ContainsPiiEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`ContainsPiiEntitiesOutput`](crate::output::ContainsPiiEntitiesOutput)
    pub fn builder() -> crate::output::contains_pii_entities_output::Builder {
        crate::output::contains_pii_entities_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClassifyDocumentOutput {
    /// <p>The classes used by the document being analyzed. These are used for multi-class trained
    /// models. Individual classes are mutually exclusive and each document is expected to have only a
    /// single class assigned to it. For example, an animal can be a dog or a cat, but not both at the
    /// same time. </p>
    pub classes: std::option::Option<std::vec::Vec<crate::model::DocumentClass>>,
    /// <p>The labels used the document being analyzed. These are used for multi-label trained
    /// models. Individual labels represent different categories that are related in some manner and
    /// are not mutually exclusive. For example, a movie can be just an action movie, or it can be an
    /// action movie, a science fiction movie, and a comedy, all at the same time. </p>
    pub labels: std::option::Option<std::vec::Vec<crate::model::DocumentLabel>>,
}
impl std::fmt::Debug for ClassifyDocumentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClassifyDocumentOutput");
        formatter.field("classes", &self.classes);
        formatter.field("labels", &self.labels);
        formatter.finish()
    }
}
/// See [`ClassifyDocumentOutput`](crate::output::ClassifyDocumentOutput)
pub mod classify_document_output {
    /// A builder for [`ClassifyDocumentOutput`](crate::output::ClassifyDocumentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) classes: std::option::Option<std::vec::Vec<crate::model::DocumentClass>>,
        pub(crate) labels: std::option::Option<std::vec::Vec<crate::model::DocumentLabel>>,
    }
    impl Builder {
        pub fn classes(mut self, input: impl Into<crate::model::DocumentClass>) -> Self {
            let mut v = self.classes.unwrap_or_default();
            v.push(input.into());
            self.classes = Some(v);
            self
        }
        pub fn set_classes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentClass>>,
        ) -> Self {
            self.classes = input;
            self
        }
        pub fn labels(mut self, input: impl Into<crate::model::DocumentLabel>) -> Self {
            let mut v = self.labels.unwrap_or_default();
            v.push(input.into());
            self.labels = Some(v);
            self
        }
        pub fn set_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentLabel>>,
        ) -> Self {
            self.labels = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassifyDocumentOutput`](crate::output::ClassifyDocumentOutput)
        pub fn build(self) -> crate::output::ClassifyDocumentOutput {
            crate::output::ClassifyDocumentOutput {
                classes: self.classes,
                labels: self.labels,
            }
        }
    }
}
impl ClassifyDocumentOutput {
    /// Creates a new builder-style object to manufacture [`ClassifyDocumentOutput`](crate::output::ClassifyDocumentOutput)
    pub fn builder() -> crate::output::classify_document_output::Builder {
        crate::output::classify_document_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectSyntaxOutput {
    /// <p>A list of  objects containing the results
    /// of the operation. The results are sorted in ascending order by the <code>Index</code> field
    /// and match the order of the documents in the input list. If all of the documents contain an
    /// error, the <code>ResultList</code> is empty.</p>
    pub result_list: std::option::Option<std::vec::Vec<crate::model::BatchDetectSyntaxItemResult>>,
    /// <p>A list containing one  object for each document that
    /// contained an error. The results are sorted in ascending order by the <code>Index</code> field
    /// and match the order of the documents in the input list. If there are no errors in the batch,
    /// the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl std::fmt::Debug for BatchDetectSyntaxOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectSyntaxOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectSyntaxOutput`](crate::output::BatchDetectSyntaxOutput)
pub mod batch_detect_syntax_output {
    /// A builder for [`BatchDetectSyntaxOutput`](crate::output::BatchDetectSyntaxOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectSyntaxItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        pub fn result_list(
            mut self,
            input: impl Into<crate::model::BatchDetectSyntaxItemResult>,
        ) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input.into());
            self.result_list = Some(v);
            self
        }
        pub fn set_result_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchDetectSyntaxItemResult>>,
        ) -> Self {
            self.result_list = input;
            self
        }
        pub fn error_list(mut self, input: impl Into<crate::model::BatchItemError>) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input.into());
            self.error_list = Some(v);
            self
        }
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectSyntaxOutput`](crate::output::BatchDetectSyntaxOutput)
        pub fn build(self) -> crate::output::BatchDetectSyntaxOutput {
            crate::output::BatchDetectSyntaxOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectSyntaxOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectSyntaxOutput`](crate::output::BatchDetectSyntaxOutput)
    pub fn builder() -> crate::output::batch_detect_syntax_output::Builder {
        crate::output::batch_detect_syntax_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectSentimentOutput {
    /// <p>A list of  objects containing the
    /// results of the operation. The results are sorted in ascending order by the <code>Index</code>
    /// field and match the order of the documents in the input list. If all of the documents contain
    /// an error, the <code>ResultList</code> is empty.</p>
    pub result_list:
        std::option::Option<std::vec::Vec<crate::model::BatchDetectSentimentItemResult>>,
    /// <p>A list containing one  object for each document
    /// that contained an error. The results are sorted in ascending order by the <code>Index</code>
    /// field and match the order of the documents in the input list. If there are no errors in the
    /// batch, the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl std::fmt::Debug for BatchDetectSentimentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectSentimentOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectSentimentOutput`](crate::output::BatchDetectSentimentOutput)
pub mod batch_detect_sentiment_output {
    /// A builder for [`BatchDetectSentimentOutput`](crate::output::BatchDetectSentimentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectSentimentItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        pub fn result_list(
            mut self,
            input: impl Into<crate::model::BatchDetectSentimentItemResult>,
        ) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input.into());
            self.result_list = Some(v);
            self
        }
        pub fn set_result_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchDetectSentimentItemResult>>,
        ) -> Self {
            self.result_list = input;
            self
        }
        pub fn error_list(mut self, input: impl Into<crate::model::BatchItemError>) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input.into());
            self.error_list = Some(v);
            self
        }
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectSentimentOutput`](crate::output::BatchDetectSentimentOutput)
        pub fn build(self) -> crate::output::BatchDetectSentimentOutput {
            crate::output::BatchDetectSentimentOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectSentimentOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectSentimentOutput`](crate::output::BatchDetectSentimentOutput)
    pub fn builder() -> crate::output::batch_detect_sentiment_output::Builder {
        crate::output::batch_detect_sentiment_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectKeyPhrasesOutput {
    /// <p>A list of  objects containing the
    /// results of the operation. The results are sorted in ascending order by the <code>Index</code>
    /// field and match the order of the documents in the input list. If all of the documents contain
    /// an error, the <code>ResultList</code> is empty.</p>
    pub result_list:
        std::option::Option<std::vec::Vec<crate::model::BatchDetectKeyPhrasesItemResult>>,
    /// <p>A list containing one  object for each document
    /// that contained an error. The results are sorted in ascending order by the <code>Index</code>
    /// field and match the order of the documents in the input list. If there are no errors in the
    /// batch, the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl std::fmt::Debug for BatchDetectKeyPhrasesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectKeyPhrasesOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectKeyPhrasesOutput`](crate::output::BatchDetectKeyPhrasesOutput)
pub mod batch_detect_key_phrases_output {
    /// A builder for [`BatchDetectKeyPhrasesOutput`](crate::output::BatchDetectKeyPhrasesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectKeyPhrasesItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        pub fn result_list(
            mut self,
            input: impl Into<crate::model::BatchDetectKeyPhrasesItemResult>,
        ) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input.into());
            self.result_list = Some(v);
            self
        }
        pub fn set_result_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::BatchDetectKeyPhrasesItemResult>,
            >,
        ) -> Self {
            self.result_list = input;
            self
        }
        pub fn error_list(mut self, input: impl Into<crate::model::BatchItemError>) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input.into());
            self.error_list = Some(v);
            self
        }
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectKeyPhrasesOutput`](crate::output::BatchDetectKeyPhrasesOutput)
        pub fn build(self) -> crate::output::BatchDetectKeyPhrasesOutput {
            crate::output::BatchDetectKeyPhrasesOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectKeyPhrasesOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectKeyPhrasesOutput`](crate::output::BatchDetectKeyPhrasesOutput)
    pub fn builder() -> crate::output::batch_detect_key_phrases_output::Builder {
        crate::output::batch_detect_key_phrases_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectEntitiesOutput {
    /// <p>A list of  objects containing the
    /// results of the operation. The results are sorted in ascending order by the <code>Index</code>
    /// field and match the order of the documents in the input list. If all of the documents contain
    /// an error, the <code>ResultList</code> is empty.</p>
    pub result_list:
        std::option::Option<std::vec::Vec<crate::model::BatchDetectEntitiesItemResult>>,
    /// <p>A list containing one  object for each document
    /// that contained an error. The results are sorted in ascending order by the <code>Index</code>
    /// field and match the order of the documents in the input list. If there are no errors in the
    /// batch, the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl std::fmt::Debug for BatchDetectEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectEntitiesOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectEntitiesOutput`](crate::output::BatchDetectEntitiesOutput)
pub mod batch_detect_entities_output {
    /// A builder for [`BatchDetectEntitiesOutput`](crate::output::BatchDetectEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectEntitiesItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        pub fn result_list(
            mut self,
            input: impl Into<crate::model::BatchDetectEntitiesItemResult>,
        ) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input.into());
            self.result_list = Some(v);
            self
        }
        pub fn set_result_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchDetectEntitiesItemResult>>,
        ) -> Self {
            self.result_list = input;
            self
        }
        pub fn error_list(mut self, input: impl Into<crate::model::BatchItemError>) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input.into());
            self.error_list = Some(v);
            self
        }
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectEntitiesOutput`](crate::output::BatchDetectEntitiesOutput)
        pub fn build(self) -> crate::output::BatchDetectEntitiesOutput {
            crate::output::BatchDetectEntitiesOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectEntitiesOutput`](crate::output::BatchDetectEntitiesOutput)
    pub fn builder() -> crate::output::batch_detect_entities_output::Builder {
        crate::output::batch_detect_entities_output::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchDetectDominantLanguageOutput {
    /// <p>A list of  objects
    /// containing the results of the operation. The results are sorted in ascending order by the
    /// <code>Index</code> field and match the order of the documents in the input list. If all of
    /// the documents contain an error, the <code>ResultList</code> is empty.</p>
    pub result_list:
        std::option::Option<std::vec::Vec<crate::model::BatchDetectDominantLanguageItemResult>>,
    /// <p>A list containing one  object for each document
    /// that contained an error. The results are sorted in ascending order by the <code>Index</code>
    /// field and match the order of the documents in the input list. If there are no errors in the
    /// batch, the <code>ErrorList</code> is empty.</p>
    pub error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
}
impl std::fmt::Debug for BatchDetectDominantLanguageOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchDetectDominantLanguageOutput");
        formatter.field("result_list", &self.result_list);
        formatter.field("error_list", &self.error_list);
        formatter.finish()
    }
}
/// See [`BatchDetectDominantLanguageOutput`](crate::output::BatchDetectDominantLanguageOutput)
pub mod batch_detect_dominant_language_output {
    /// A builder for [`BatchDetectDominantLanguageOutput`](crate::output::BatchDetectDominantLanguageOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_list:
            std::option::Option<std::vec::Vec<crate::model::BatchDetectDominantLanguageItemResult>>,
        pub(crate) error_list: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
    }
    impl Builder {
        pub fn result_list(
            mut self,
            input: impl Into<crate::model::BatchDetectDominantLanguageItemResult>,
        ) -> Self {
            let mut v = self.result_list.unwrap_or_default();
            v.push(input.into());
            self.result_list = Some(v);
            self
        }
        pub fn set_result_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::BatchDetectDominantLanguageItemResult>,
            >,
        ) -> Self {
            self.result_list = input;
            self
        }
        pub fn error_list(mut self, input: impl Into<crate::model::BatchItemError>) -> Self {
            let mut v = self.error_list.unwrap_or_default();
            v.push(input.into());
            self.error_list = Some(v);
            self
        }
        pub fn set_error_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BatchItemError>>,
        ) -> Self {
            self.error_list = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectDominantLanguageOutput`](crate::output::BatchDetectDominantLanguageOutput)
        pub fn build(self) -> crate::output::BatchDetectDominantLanguageOutput {
            crate::output::BatchDetectDominantLanguageOutput {
                result_list: self.result_list,
                error_list: self.error_list,
            }
        }
    }
}
impl BatchDetectDominantLanguageOutput {
    /// Creates a new builder-style object to manufacture [`BatchDetectDominantLanguageOutput`](crate::output::BatchDetectDominantLanguageOutput)
    pub fn builder() -> crate::output::batch_detect_dominant_language_output::Builder {
        crate::output::batch_detect_dominant_language_output::Builder::default()
    }
}
