// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides additional detail about why the request failed:</p>
/// <ul>
/// <li> <p>Document size is too large - Check the size of your file and resubmit the request.</p> </li>
/// <li> <p>Document type is not supported - Check the file type and resubmit the request.</p> </li>
/// <li> <p>Too many pages in the document - Check the number of pages in your file and resubmit the request.</p> </li>
/// <li> <p>Access denied to Amazon Textract - Verify that your account has permission to use Amazon Textract API operations and resubmit the request.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRequestDetail {
    /// <p>Reason code is <code>INVALID_DOCUMENT</code>.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::InvalidRequestDetailReason>,
}
impl InvalidRequestDetail {
    /// <p>Reason code is <code>INVALID_DOCUMENT</code>.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::InvalidRequestDetailReason> {
        self.reason.as_ref()
    }
}
/// See [`InvalidRequestDetail`](crate::model::InvalidRequestDetail).
pub mod invalid_request_detail {

    /// A builder for [`InvalidRequestDetail`](crate::model::InvalidRequestDetail).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reason: std::option::Option<crate::model::InvalidRequestDetailReason>,
    }
    impl Builder {
        /// <p>Reason code is <code>INVALID_DOCUMENT</code>.</p>
        pub fn reason(mut self, input: crate::model::InvalidRequestDetailReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>Reason code is <code>INVALID_DOCUMENT</code>.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::InvalidRequestDetailReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestDetail`](crate::model::InvalidRequestDetail).
        pub fn build(self) -> crate::model::InvalidRequestDetail {
            crate::model::InvalidRequestDetail {
                reason: self.reason,
            }
        }
    }
}
impl InvalidRequestDetail {
    /// Creates a new builder-style object to manufacture [`InvalidRequestDetail`](crate::model::InvalidRequestDetail).
    pub fn builder() -> crate::model::invalid_request_detail::Builder {
        crate::model::invalid_request_detail::Builder::default()
    }
}

/// When writing a match expression against `InvalidRequestDetailReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let invalidrequestdetailreason = unimplemented!();
/// match invalidrequestdetailreason {
///     InvalidRequestDetailReason::DocumentSizeExceeded => { /* ... */ },
///     InvalidRequestDetailReason::PageLimitExceeded => { /* ... */ },
///     InvalidRequestDetailReason::TextractAccessDenied => { /* ... */ },
///     InvalidRequestDetailReason::UnsupportedDocType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `invalidrequestdetailreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InvalidRequestDetailReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InvalidRequestDetailReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InvalidRequestDetailReason::NewFeature` is defined.
/// Specifically, when `invalidrequestdetailreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InvalidRequestDetailReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InvalidRequestDetailReason {
    #[allow(missing_docs)] // documentation missing in model
    DocumentSizeExceeded,
    #[allow(missing_docs)] // documentation missing in model
    PageLimitExceeded,
    #[allow(missing_docs)] // documentation missing in model
    TextractAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    UnsupportedDocType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InvalidRequestDetailReason {
    fn from(s: &str) -> Self {
        match s {
            "DOCUMENT_SIZE_EXCEEDED" => InvalidRequestDetailReason::DocumentSizeExceeded,
            "PAGE_LIMIT_EXCEEDED" => InvalidRequestDetailReason::PageLimitExceeded,
            "TEXTRACT_ACCESS_DENIED" => InvalidRequestDetailReason::TextractAccessDenied,
            "UNSUPPORTED_DOC_TYPE" => InvalidRequestDetailReason::UnsupportedDocType,
            other => InvalidRequestDetailReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for InvalidRequestDetailReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InvalidRequestDetailReason::from(s))
    }
}
impl InvalidRequestDetailReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InvalidRequestDetailReason::DocumentSizeExceeded => "DOCUMENT_SIZE_EXCEEDED",
            InvalidRequestDetailReason::PageLimitExceeded => "PAGE_LIMIT_EXCEEDED",
            InvalidRequestDetailReason::TextractAccessDenied => "TEXTRACT_ACCESS_DENIED",
            InvalidRequestDetailReason::UnsupportedDocType => "UNSUPPORTED_DOC_TYPE",
            InvalidRequestDetailReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DOCUMENT_SIZE_EXCEEDED",
            "PAGE_LIMIT_EXCEEDED",
            "TEXTRACT_ACCESS_DENIED",
            "UNSUPPORTED_DOC_TYPE",
        ]
    }
}
impl AsRef<str> for InvalidRequestDetailReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InvalidRequestReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let invalidrequestreason = unimplemented!();
/// match invalidrequestreason {
///     InvalidRequestReason::InvalidDocument => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `invalidrequestreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InvalidRequestReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InvalidRequestReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InvalidRequestReason::NewFeature` is defined.
/// Specifically, when `invalidrequestreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InvalidRequestReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InvalidRequestReason {
    #[allow(missing_docs)] // documentation missing in model
    InvalidDocument,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InvalidRequestReason {
    fn from(s: &str) -> Self {
        match s {
            "INVALID_DOCUMENT" => InvalidRequestReason::InvalidDocument,
            other => {
                InvalidRequestReason::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for InvalidRequestReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InvalidRequestReason::from(s))
    }
}
impl InvalidRequestReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InvalidRequestReason::InvalidDocument => "INVALID_DOCUMENT",
            InvalidRequestReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INVALID_DOCUMENT"]
    }
}
impl AsRef<str> for InvalidRequestReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A key-value pair that adds as a metadata to a resource used by Amazon Comprehend. For example, a tag with the key-value pair ‘Department’:’Sales’ might be added to a resource to indicate its use by a particular department. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The initial part of a key-value pair that forms a tag associated with a given resource. For instance, if you want to show which resources are used by which departments, you might use “Department” as the key portion of the pair, with multiple possible values such as “sales,” “legal,” and “administration.” </p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p> The second part of a key-value pair that forms a tag associated with a given resource. For instance, if you want to show which resources are used by which departments, you might use “Department” as the initial (key) portion of the pair, with a value of “sales” to indicate the sales department. </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The initial part of a key-value pair that forms a tag associated with a given resource. For instance, if you want to show which resources are used by which departments, you might use “Department” as the key portion of the pair, with multiple possible values such as “sales,” “legal,” and “administration.” </p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p> The second part of a key-value pair that forms a tag associated with a given resource. For instance, if you want to show which resources are used by which departments, you might use “Department” as the initial (key) portion of the pair, with a value of “sales” to indicate the sales department. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The initial part of a key-value pair that forms a tag associated with a given resource. For instance, if you want to show which resources are used by which departments, you might use “Department” as the key portion of the pair, with multiple possible values such as “sales,” “legal,” and “administration.” </p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The initial part of a key-value pair that forms a tag associated with a given resource. For instance, if you want to show which resources are used by which departments, you might use “Department” as the key portion of the pair, with multiple possible values such as “sales,” “legal,” and “administration.” </p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p> The second part of a key-value pair that forms a tag associated with a given resource. For instance, if you want to show which resources are used by which departments, you might use “Department” as the initial (key) portion of the pair, with a value of “sales” to indicate the sales department. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p> The second part of a key-value pair that forms a tag associated with a given resource. For instance, if you want to show which resources are used by which departments, you might use “Department” as the initial (key) portion of the pair, with a value of “sales” to indicate the sales department. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// When writing a match expression against `JobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jobstatus = unimplemented!();
/// match jobstatus {
///     JobStatus::Completed => { /* ... */ },
///     JobStatus::Failed => { /* ... */ },
///     JobStatus::InProgress => { /* ... */ },
///     JobStatus::Stopped => { /* ... */ },
///     JobStatus::StopRequested => { /* ... */ },
///     JobStatus::Submitted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobStatus::NewFeature` is defined.
/// Specifically, when `jobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    StopRequested,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => JobStatus::Completed,
            "FAILED" => JobStatus::Failed,
            "IN_PROGRESS" => JobStatus::InProgress,
            "STOPPED" => JobStatus::Stopped,
            "STOP_REQUESTED" => JobStatus::StopRequested,
            "SUBMITTED" => JobStatus::Submitted,
            other => JobStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobStatus::from(s))
    }
}
impl JobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobStatus::Completed => "COMPLETED",
            JobStatus::Failed => "FAILED",
            JobStatus::InProgress => "IN_PROGRESS",
            JobStatus::Stopped => "STOPPED",
            JobStatus::StopRequested => "STOP_REQUESTED",
            JobStatus::Submitted => "SUBMITTED",
            JobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "FAILED",
            "IN_PROGRESS",
            "STOPPED",
            "STOP_REQUESTED",
            "SUBMITTED",
        ]
    }
}
impl AsRef<str> for JobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Configuration parameters for an optional private Virtual Private Cloud (VPC) containing the resources you are using for the job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcConfig {
    /// <p>The ID number for a security group on an instance of your private VPC. Security groups on your VPC function serve as a virtual firewall to control inbound and outbound traffic and provides security for the resources that you’ll be accessing on the VPC. This ID number is preceded by "sg-", for instance: "sg-03b388029b0a285ea". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html">Security Groups for your VPC</a>. </p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID for each subnet being used in your private VPC. This subnet is a subset of the a range of IPv4 addresses used by the VPC and is specific to a given availability zone in the VPC’s region. This ID number is preceded by "subnet-", for instance: "subnet-04ccf456919e69055". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">VPCs and Subnets</a>. </p>
    #[doc(hidden)]
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcConfig {
    /// <p>The ID number for a security group on an instance of your private VPC. Security groups on your VPC function serve as a virtual firewall to control inbound and outbound traffic and provides security for the resources that you’ll be accessing on the VPC. This ID number is preceded by "sg-", for instance: "sg-03b388029b0a285ea". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html">Security Groups for your VPC</a>. </p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
    /// <p>The ID for each subnet being used in your private VPC. This subnet is a subset of the a range of IPv4 addresses used by the VPC and is specific to a given availability zone in the VPC’s region. This ID number is preceded by "subnet-", for instance: "subnet-04ccf456919e69055". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">VPCs and Subnets</a>. </p>
    pub fn subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.subnets.as_deref()
    }
}
/// See [`VpcConfig`](crate::model::VpcConfig).
pub mod vpc_config {

    /// A builder for [`VpcConfig`](crate::model::VpcConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The ID number for a security group on an instance of your private VPC. Security groups on your VPC function serve as a virtual firewall to control inbound and outbound traffic and provides security for the resources that you’ll be accessing on the VPC. This ID number is preceded by "sg-", for instance: "sg-03b388029b0a285ea". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html">Security Groups for your VPC</a>. </p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The ID number for a security group on an instance of your private VPC. Security groups on your VPC function serve as a virtual firewall to control inbound and outbound traffic and provides security for the resources that you’ll be accessing on the VPC. This ID number is preceded by "sg-", for instance: "sg-03b388029b0a285ea". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html">Security Groups for your VPC</a>. </p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>The ID for each subnet being used in your private VPC. This subnet is a subset of the a range of IPv4 addresses used by the VPC and is specific to a given availability zone in the VPC’s region. This ID number is preceded by "subnet-", for instance: "subnet-04ccf456919e69055". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">VPCs and Subnets</a>. </p>
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>The ID for each subnet being used in your private VPC. This subnet is a subset of the a range of IPv4 addresses used by the VPC and is specific to a given availability zone in the VPC’s region. This ID number is preceded by "subnet-", for instance: "subnet-04ccf456919e69055". For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html">VPCs and Subnets</a>. </p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfig`](crate::model::VpcConfig).
        pub fn build(self) -> crate::model::VpcConfig {
            crate::model::VpcConfig {
                security_group_ids: self.security_group_ids,
                subnets: self.subnets,
            }
        }
    }
}
impl VpcConfig {
    /// Creates a new builder-style object to manufacture [`VpcConfig`](crate::model::VpcConfig).
    pub fn builder() -> crate::model::vpc_config::Builder {
        crate::model::vpc_config::Builder::default()
    }
}

/// <p>Provides configuration parameters for the output of inference jobs.</p>
/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutputDataConfig {
    /// <p>When you use the <code>OutputDataConfig</code> object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of the output file.</p>
    /// <p>When the topic detection job is finished, the service creates an output file in a directory specific to the job. The <code>S3Uri</code> field contains the location of the output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the ouput of the operation.</p>
    /// <p> For a PII entity detection job, the output file is plain text, not a compressed archive. The output file name is the same as the input file, with <code>.out</code> appended at the end. </p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>KMS Key Alias: <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>ARN of a KMS Key Alias: <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl OutputDataConfig {
    /// <p>When you use the <code>OutputDataConfig</code> object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of the output file.</p>
    /// <p>When the topic detection job is finished, the service creates an output file in a directory specific to the job. The <code>S3Uri</code> field contains the location of the output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the ouput of the operation.</p>
    /// <p> For a PII entity detection job, the output file is plain text, not a compressed archive. The output file name is the same as the input file, with <code>.out</code> appended at the end. </p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>KMS Key Alias: <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>ARN of a KMS Key Alias: <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
    /// </ul>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
/// See [`OutputDataConfig`](crate::model::OutputDataConfig).
pub mod output_data_config {

    /// A builder for [`OutputDataConfig`](crate::model::OutputDataConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>When you use the <code>OutputDataConfig</code> object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of the output file.</p>
        /// <p>When the topic detection job is finished, the service creates an output file in a directory specific to the job. The <code>S3Uri</code> field contains the location of the output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the ouput of the operation.</p>
        /// <p> For a PII entity detection job, the output file is plain text, not a compressed archive. The output file name is the same as the input file, with <code>.out</code> appended at the end. </p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>When you use the <code>OutputDataConfig</code> object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of the output file.</p>
        /// <p>When the topic detection job is finished, the service creates an output file in a directory specific to the job. The <code>S3Uri</code> field contains the location of the output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the ouput of the operation.</p>
        /// <p> For a PII entity detection job, the output file is plain text, not a compressed archive. The output file name is the same as the input file, with <code>.out</code> appended at the end. </p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>KMS Key Alias: <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>ARN of a KMS Key Alias: <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
        /// </ul>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>KMS Key Alias: <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>ARN of a KMS Key Alias: <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
        /// </ul>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputDataConfig`](crate::model::OutputDataConfig).
        pub fn build(self) -> crate::model::OutputDataConfig {
            crate::model::OutputDataConfig {
                s3_uri: self.s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl OutputDataConfig {
    /// Creates a new builder-style object to manufacture [`OutputDataConfig`](crate::model::OutputDataConfig).
    pub fn builder() -> crate::model::output_data_config::Builder {
        crate::model::output_data_config::Builder::default()
    }
}

/// <p>The input properties for an inference job. The document reader config field applies only to non-text inputs for custom analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InputDataConfig {
    /// <p>The Amazon S3 URI for the input data. The URI must be in same region as the API endpoint that you are calling. The URI can point to a single input file or it can provide the prefix for a collection of data files. </p>
    /// <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a single file, Amazon Comprehend uses that file as input. If more than one file begins with the prefix, Amazon Comprehend uses all of them as input.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>Specifies how the text in an input file should be processed:</p>
    /// <ul>
    /// <li> <p> <code>ONE_DOC_PER_FILE</code> - Each file is considered a separate document. Use this option when you are processing large documents, such as newspaper articles or scientific papers.</p> </li>
    /// <li> <p> <code>ONE_DOC_PER_LINE</code> - Each line in a file is considered a separate document. Use this option when you are processing many short documents, such as text messages.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub input_format: std::option::Option<crate::model::InputFormat>,
    /// <p>Provides configuration parameters to override the default actions for extracting text from PDF documents and image files.</p>
    #[doc(hidden)]
    pub document_reader_config: std::option::Option<crate::model::DocumentReaderConfig>,
}
impl InputDataConfig {
    /// <p>The Amazon S3 URI for the input data. The URI must be in same region as the API endpoint that you are calling. The URI can point to a single input file or it can provide the prefix for a collection of data files. </p>
    /// <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a single file, Amazon Comprehend uses that file as input. If more than one file begins with the prefix, Amazon Comprehend uses all of them as input.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>Specifies how the text in an input file should be processed:</p>
    /// <ul>
    /// <li> <p> <code>ONE_DOC_PER_FILE</code> - Each file is considered a separate document. Use this option when you are processing large documents, such as newspaper articles or scientific papers.</p> </li>
    /// <li> <p> <code>ONE_DOC_PER_LINE</code> - Each line in a file is considered a separate document. Use this option when you are processing many short documents, such as text messages.</p> </li>
    /// </ul>
    pub fn input_format(&self) -> std::option::Option<&crate::model::InputFormat> {
        self.input_format.as_ref()
    }
    /// <p>Provides configuration parameters to override the default actions for extracting text from PDF documents and image files.</p>
    pub fn document_reader_config(
        &self,
    ) -> std::option::Option<&crate::model::DocumentReaderConfig> {
        self.document_reader_config.as_ref()
    }
}
/// See [`InputDataConfig`](crate::model::InputDataConfig).
pub mod input_data_config {

    /// A builder for [`InputDataConfig`](crate::model::InputDataConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) input_format: std::option::Option<crate::model::InputFormat>,
        pub(crate) document_reader_config: std::option::Option<crate::model::DocumentReaderConfig>,
    }
    impl Builder {
        /// <p>The Amazon S3 URI for the input data. The URI must be in same region as the API endpoint that you are calling. The URI can point to a single input file or it can provide the prefix for a collection of data files. </p>
        /// <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a single file, Amazon Comprehend uses that file as input. If more than one file begins with the prefix, Amazon Comprehend uses all of them as input.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI for the input data. The URI must be in same region as the API endpoint that you are calling. The URI can point to a single input file or it can provide the prefix for a collection of data files. </p>
        /// <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a single file, Amazon Comprehend uses that file as input. If more than one file begins with the prefix, Amazon Comprehend uses all of them as input.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>Specifies how the text in an input file should be processed:</p>
        /// <ul>
        /// <li> <p> <code>ONE_DOC_PER_FILE</code> - Each file is considered a separate document. Use this option when you are processing large documents, such as newspaper articles or scientific papers.</p> </li>
        /// <li> <p> <code>ONE_DOC_PER_LINE</code> - Each line in a file is considered a separate document. Use this option when you are processing many short documents, such as text messages.</p> </li>
        /// </ul>
        pub fn input_format(mut self, input: crate::model::InputFormat) -> Self {
            self.input_format = Some(input);
            self
        }
        /// <p>Specifies how the text in an input file should be processed:</p>
        /// <ul>
        /// <li> <p> <code>ONE_DOC_PER_FILE</code> - Each file is considered a separate document. Use this option when you are processing large documents, such as newspaper articles or scientific papers.</p> </li>
        /// <li> <p> <code>ONE_DOC_PER_LINE</code> - Each line in a file is considered a separate document. Use this option when you are processing many short documents, such as text messages.</p> </li>
        /// </ul>
        pub fn set_input_format(
            mut self,
            input: std::option::Option<crate::model::InputFormat>,
        ) -> Self {
            self.input_format = input;
            self
        }
        /// <p>Provides configuration parameters to override the default actions for extracting text from PDF documents and image files.</p>
        pub fn document_reader_config(mut self, input: crate::model::DocumentReaderConfig) -> Self {
            self.document_reader_config = Some(input);
            self
        }
        /// <p>Provides configuration parameters to override the default actions for extracting text from PDF documents and image files.</p>
        pub fn set_document_reader_config(
            mut self,
            input: std::option::Option<crate::model::DocumentReaderConfig>,
        ) -> Self {
            self.document_reader_config = input;
            self
        }
        /// Consumes the builder and constructs a [`InputDataConfig`](crate::model::InputDataConfig).
        pub fn build(self) -> crate::model::InputDataConfig {
            crate::model::InputDataConfig {
                s3_uri: self.s3_uri,
                input_format: self.input_format,
                document_reader_config: self.document_reader_config,
            }
        }
    }
}
impl InputDataConfig {
    /// Creates a new builder-style object to manufacture [`InputDataConfig`](crate::model::InputDataConfig).
    pub fn builder() -> crate::model::input_data_config::Builder {
        crate::model::input_data_config::Builder::default()
    }
}

/// <p>Provides configuration parameters to override the default actions for extracting text from PDF documents and image files. </p>
/// <p> By default, Amazon Comprehend performs the following actions to extract text from files, based on the input file type: </p>
/// <ul>
/// <li> <p> <b>Word files</b> - Amazon Comprehend parser extracts the text. </p> </li>
/// <li> <p> <b>Digital PDF files</b> - Amazon Comprehend parser extracts the text. </p> </li>
/// <li> <p> <b>Image files and scanned PDF files</b> - Amazon Comprehend uses the Amazon Textract <code>DetectDocumentText</code> API to extract the text. </p> </li>
/// </ul>
/// <p> <code>DocumentReaderConfig</code> does not apply to plain text files or Word files.</p>
/// <p> For image files and PDF documents, you can override these default actions using the fields listed below. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/detecting-cer.html#detecting-cer-pdf"> Setting text extraction options</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentReaderConfig {
    /// <p>This field defines the Amazon Textract API operation that Amazon Comprehend uses to extract text from PDF files and image files. Enter one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>TEXTRACT_DETECT_DOCUMENT_TEXT</code> - The Amazon Comprehend service uses the <code>DetectDocumentText</code> API operation. </p> </li>
    /// <li> <p> <code>TEXTRACT_ANALYZE_DOCUMENT</code> - The Amazon Comprehend service uses the <code>AnalyzeDocument</code> API operation. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub document_read_action: std::option::Option<crate::model::DocumentReadAction>,
    /// <p>Determines the text extraction actions for PDF files. Enter one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>SERVICE_DEFAULT</code> - use the Amazon Comprehend service defaults for PDF files.</p> </li>
    /// <li> <p> <code>FORCE_DOCUMENT_READ_ACTION</code> - Amazon Comprehend uses the Textract API specified by DocumentReadAction for all PDF files, including digital PDF files. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub document_read_mode: std::option::Option<crate::model::DocumentReadMode>,
    /// <p>Specifies the type of Amazon Textract features to apply. If you chose <code>TEXTRACT_ANALYZE_DOCUMENT</code> as the read action, you must specify one or both of the following values:</p>
    /// <ul>
    /// <li> <p> <code>TABLES</code> - Returns information about any tables that are detected in the input document. </p> </li>
    /// <li> <p> <code>FORMS</code> - Returns information and the data from any forms that are detected in the input document. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub feature_types: std::option::Option<std::vec::Vec<crate::model::DocumentReadFeatureTypes>>,
}
impl DocumentReaderConfig {
    /// <p>This field defines the Amazon Textract API operation that Amazon Comprehend uses to extract text from PDF files and image files. Enter one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>TEXTRACT_DETECT_DOCUMENT_TEXT</code> - The Amazon Comprehend service uses the <code>DetectDocumentText</code> API operation. </p> </li>
    /// <li> <p> <code>TEXTRACT_ANALYZE_DOCUMENT</code> - The Amazon Comprehend service uses the <code>AnalyzeDocument</code> API operation. </p> </li>
    /// </ul>
    pub fn document_read_action(&self) -> std::option::Option<&crate::model::DocumentReadAction> {
        self.document_read_action.as_ref()
    }
    /// <p>Determines the text extraction actions for PDF files. Enter one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>SERVICE_DEFAULT</code> - use the Amazon Comprehend service defaults for PDF files.</p> </li>
    /// <li> <p> <code>FORCE_DOCUMENT_READ_ACTION</code> - Amazon Comprehend uses the Textract API specified by DocumentReadAction for all PDF files, including digital PDF files. </p> </li>
    /// </ul>
    pub fn document_read_mode(&self) -> std::option::Option<&crate::model::DocumentReadMode> {
        self.document_read_mode.as_ref()
    }
    /// <p>Specifies the type of Amazon Textract features to apply. If you chose <code>TEXTRACT_ANALYZE_DOCUMENT</code> as the read action, you must specify one or both of the following values:</p>
    /// <ul>
    /// <li> <p> <code>TABLES</code> - Returns information about any tables that are detected in the input document. </p> </li>
    /// <li> <p> <code>FORMS</code> - Returns information and the data from any forms that are detected in the input document. </p> </li>
    /// </ul>
    pub fn feature_types(&self) -> std::option::Option<&[crate::model::DocumentReadFeatureTypes]> {
        self.feature_types.as_deref()
    }
}
/// See [`DocumentReaderConfig`](crate::model::DocumentReaderConfig).
pub mod document_reader_config {

    /// A builder for [`DocumentReaderConfig`](crate::model::DocumentReaderConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_read_action: std::option::Option<crate::model::DocumentReadAction>,
        pub(crate) document_read_mode: std::option::Option<crate::model::DocumentReadMode>,
        pub(crate) feature_types:
            std::option::Option<std::vec::Vec<crate::model::DocumentReadFeatureTypes>>,
    }
    impl Builder {
        /// <p>This field defines the Amazon Textract API operation that Amazon Comprehend uses to extract text from PDF files and image files. Enter one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>TEXTRACT_DETECT_DOCUMENT_TEXT</code> - The Amazon Comprehend service uses the <code>DetectDocumentText</code> API operation. </p> </li>
        /// <li> <p> <code>TEXTRACT_ANALYZE_DOCUMENT</code> - The Amazon Comprehend service uses the <code>AnalyzeDocument</code> API operation. </p> </li>
        /// </ul>
        pub fn document_read_action(mut self, input: crate::model::DocumentReadAction) -> Self {
            self.document_read_action = Some(input);
            self
        }
        /// <p>This field defines the Amazon Textract API operation that Amazon Comprehend uses to extract text from PDF files and image files. Enter one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>TEXTRACT_DETECT_DOCUMENT_TEXT</code> - The Amazon Comprehend service uses the <code>DetectDocumentText</code> API operation. </p> </li>
        /// <li> <p> <code>TEXTRACT_ANALYZE_DOCUMENT</code> - The Amazon Comprehend service uses the <code>AnalyzeDocument</code> API operation. </p> </li>
        /// </ul>
        pub fn set_document_read_action(
            mut self,
            input: std::option::Option<crate::model::DocumentReadAction>,
        ) -> Self {
            self.document_read_action = input;
            self
        }
        /// <p>Determines the text extraction actions for PDF files. Enter one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>SERVICE_DEFAULT</code> - use the Amazon Comprehend service defaults for PDF files.</p> </li>
        /// <li> <p> <code>FORCE_DOCUMENT_READ_ACTION</code> - Amazon Comprehend uses the Textract API specified by DocumentReadAction for all PDF files, including digital PDF files. </p> </li>
        /// </ul>
        pub fn document_read_mode(mut self, input: crate::model::DocumentReadMode) -> Self {
            self.document_read_mode = Some(input);
            self
        }
        /// <p>Determines the text extraction actions for PDF files. Enter one of the following values:</p>
        /// <ul>
        /// <li> <p> <code>SERVICE_DEFAULT</code> - use the Amazon Comprehend service defaults for PDF files.</p> </li>
        /// <li> <p> <code>FORCE_DOCUMENT_READ_ACTION</code> - Amazon Comprehend uses the Textract API specified by DocumentReadAction for all PDF files, including digital PDF files. </p> </li>
        /// </ul>
        pub fn set_document_read_mode(
            mut self,
            input: std::option::Option<crate::model::DocumentReadMode>,
        ) -> Self {
            self.document_read_mode = input;
            self
        }
        /// Appends an item to `feature_types`.
        ///
        /// To override the contents of this collection use [`set_feature_types`](Self::set_feature_types).
        ///
        /// <p>Specifies the type of Amazon Textract features to apply. If you chose <code>TEXTRACT_ANALYZE_DOCUMENT</code> as the read action, you must specify one or both of the following values:</p>
        /// <ul>
        /// <li> <p> <code>TABLES</code> - Returns information about any tables that are detected in the input document. </p> </li>
        /// <li> <p> <code>FORMS</code> - Returns information and the data from any forms that are detected in the input document. </p> </li>
        /// </ul>
        pub fn feature_types(mut self, input: crate::model::DocumentReadFeatureTypes) -> Self {
            let mut v = self.feature_types.unwrap_or_default();
            v.push(input);
            self.feature_types = Some(v);
            self
        }
        /// <p>Specifies the type of Amazon Textract features to apply. If you chose <code>TEXTRACT_ANALYZE_DOCUMENT</code> as the read action, you must specify one or both of the following values:</p>
        /// <ul>
        /// <li> <p> <code>TABLES</code> - Returns information about any tables that are detected in the input document. </p> </li>
        /// <li> <p> <code>FORMS</code> - Returns information and the data from any forms that are detected in the input document. </p> </li>
        /// </ul>
        pub fn set_feature_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DocumentReadFeatureTypes>>,
        ) -> Self {
            self.feature_types = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentReaderConfig`](crate::model::DocumentReaderConfig).
        pub fn build(self) -> crate::model::DocumentReaderConfig {
            crate::model::DocumentReaderConfig {
                document_read_action: self.document_read_action,
                document_read_mode: self.document_read_mode,
                feature_types: self.feature_types,
            }
        }
    }
}
impl DocumentReaderConfig {
    /// Creates a new builder-style object to manufacture [`DocumentReaderConfig`](crate::model::DocumentReaderConfig).
    pub fn builder() -> crate::model::document_reader_config::Builder {
        crate::model::document_reader_config::Builder::default()
    }
}

/// When writing a match expression against `DocumentReadFeatureTypes`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let documentreadfeaturetypes = unimplemented!();
/// match documentreadfeaturetypes {
///     DocumentReadFeatureTypes::Forms => { /* ... */ },
///     DocumentReadFeatureTypes::Tables => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `documentreadfeaturetypes` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DocumentReadFeatureTypes::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DocumentReadFeatureTypes::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DocumentReadFeatureTypes::NewFeature` is defined.
/// Specifically, when `documentreadfeaturetypes` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DocumentReadFeatureTypes::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Specifies the type of Amazon Textract features to apply. If you chose <code>TEXTRACT_ANALYZE_DOCUMENT</code>
/// as the read action, you must specify one or both of the following values:</p>
/// <ul>
/// <li>
/// <p>
/// <code>TABLES</code> - Returns additional information about any tables that are detected in the input document. </p>
/// </li>
/// <li>
/// <p>
/// <code>FORMS</code> - Returns additional information about any forms that are detected in the input document. </p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentReadFeatureTypes {
    #[allow(missing_docs)] // documentation missing in model
    Forms,
    #[allow(missing_docs)] // documentation missing in model
    Tables,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DocumentReadFeatureTypes {
    fn from(s: &str) -> Self {
        match s {
            "FORMS" => DocumentReadFeatureTypes::Forms,
            "TABLES" => DocumentReadFeatureTypes::Tables,
            other => DocumentReadFeatureTypes::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DocumentReadFeatureTypes {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DocumentReadFeatureTypes::from(s))
    }
}
impl DocumentReadFeatureTypes {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DocumentReadFeatureTypes::Forms => "FORMS",
            DocumentReadFeatureTypes::Tables => "TABLES",
            DocumentReadFeatureTypes::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FORMS", "TABLES"]
    }
}
impl AsRef<str> for DocumentReadFeatureTypes {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DocumentReadMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let documentreadmode = unimplemented!();
/// match documentreadmode {
///     DocumentReadMode::ForceDocumentReadAction => { /* ... */ },
///     DocumentReadMode::ServiceDefault => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `documentreadmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DocumentReadMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DocumentReadMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DocumentReadMode::NewFeature` is defined.
/// Specifically, when `documentreadmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DocumentReadMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentReadMode {
    #[allow(missing_docs)] // documentation missing in model
    ForceDocumentReadAction,
    #[allow(missing_docs)] // documentation missing in model
    ServiceDefault,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DocumentReadMode {
    fn from(s: &str) -> Self {
        match s {
            "FORCE_DOCUMENT_READ_ACTION" => DocumentReadMode::ForceDocumentReadAction,
            "SERVICE_DEFAULT" => DocumentReadMode::ServiceDefault,
            other => DocumentReadMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DocumentReadMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DocumentReadMode::from(s))
    }
}
impl DocumentReadMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DocumentReadMode::ForceDocumentReadAction => "FORCE_DOCUMENT_READ_ACTION",
            DocumentReadMode::ServiceDefault => "SERVICE_DEFAULT",
            DocumentReadMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FORCE_DOCUMENT_READ_ACTION", "SERVICE_DEFAULT"]
    }
}
impl AsRef<str> for DocumentReadMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DocumentReadAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let documentreadaction = unimplemented!();
/// match documentreadaction {
///     DocumentReadAction::TextractAnalyzeDocument => { /* ... */ },
///     DocumentReadAction::TextractDetectDocumentText => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `documentreadaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DocumentReadAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DocumentReadAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DocumentReadAction::NewFeature` is defined.
/// Specifically, when `documentreadaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DocumentReadAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentReadAction {
    #[allow(missing_docs)] // documentation missing in model
    TextractAnalyzeDocument,
    #[allow(missing_docs)] // documentation missing in model
    TextractDetectDocumentText,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DocumentReadAction {
    fn from(s: &str) -> Self {
        match s {
            "TEXTRACT_ANALYZE_DOCUMENT" => DocumentReadAction::TextractAnalyzeDocument,
            "TEXTRACT_DETECT_DOCUMENT_TEXT" => DocumentReadAction::TextractDetectDocumentText,
            other => {
                DocumentReadAction::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DocumentReadAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DocumentReadAction::from(s))
    }
}
impl DocumentReadAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DocumentReadAction::TextractAnalyzeDocument => "TEXTRACT_ANALYZE_DOCUMENT",
            DocumentReadAction::TextractDetectDocumentText => "TEXTRACT_DETECT_DOCUMENT_TEXT",
            DocumentReadAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TEXTRACT_ANALYZE_DOCUMENT", "TEXTRACT_DETECT_DOCUMENT_TEXT"]
    }
}
impl AsRef<str> for DocumentReadAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InputFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let inputformat = unimplemented!();
/// match inputformat {
///     InputFormat::OneDocPerFile => { /* ... */ },
///     InputFormat::OneDocPerLine => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `inputformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InputFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InputFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InputFormat::NewFeature` is defined.
/// Specifically, when `inputformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InputFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InputFormat {
    #[allow(missing_docs)] // documentation missing in model
    OneDocPerFile,
    #[allow(missing_docs)] // documentation missing in model
    OneDocPerLine,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InputFormat {
    fn from(s: &str) -> Self {
        match s {
            "ONE_DOC_PER_FILE" => InputFormat::OneDocPerFile,
            "ONE_DOC_PER_LINE" => InputFormat::OneDocPerLine,
            other => InputFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for InputFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InputFormat::from(s))
    }
}
impl InputFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InputFormat::OneDocPerFile => "ONE_DOC_PER_FILE",
            InputFormat::OneDocPerLine => "ONE_DOC_PER_LINE",
            InputFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ONE_DOC_PER_FILE", "ONE_DOC_PER_LINE"]
    }
}
impl AsRef<str> for InputFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LanguageCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let languagecode = unimplemented!();
/// match languagecode {
///     LanguageCode::Ar => { /* ... */ },
///     LanguageCode::De => { /* ... */ },
///     LanguageCode::En => { /* ... */ },
///     LanguageCode::Es => { /* ... */ },
///     LanguageCode::Fr => { /* ... */ },
///     LanguageCode::Hi => { /* ... */ },
///     LanguageCode::It => { /* ... */ },
///     LanguageCode::Ja => { /* ... */ },
///     LanguageCode::Ko => { /* ... */ },
///     LanguageCode::Pt => { /* ... */ },
///     LanguageCode::Zh => { /* ... */ },
///     LanguageCode::ZhTw => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `languagecode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LanguageCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LanguageCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LanguageCode::NewFeature` is defined.
/// Specifically, when `languagecode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LanguageCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LanguageCode {
    #[allow(missing_docs)] // documentation missing in model
    Ar,
    #[allow(missing_docs)] // documentation missing in model
    De,
    #[allow(missing_docs)] // documentation missing in model
    En,
    #[allow(missing_docs)] // documentation missing in model
    Es,
    #[allow(missing_docs)] // documentation missing in model
    Fr,
    #[allow(missing_docs)] // documentation missing in model
    Hi,
    #[allow(missing_docs)] // documentation missing in model
    It,
    #[allow(missing_docs)] // documentation missing in model
    Ja,
    #[allow(missing_docs)] // documentation missing in model
    Ko,
    #[allow(missing_docs)] // documentation missing in model
    Pt,
    #[allow(missing_docs)] // documentation missing in model
    Zh,
    #[allow(missing_docs)] // documentation missing in model
    ZhTw,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "ar" => LanguageCode::Ar,
            "de" => LanguageCode::De,
            "en" => LanguageCode::En,
            "es" => LanguageCode::Es,
            "fr" => LanguageCode::Fr,
            "hi" => LanguageCode::Hi,
            "it" => LanguageCode::It,
            "ja" => LanguageCode::Ja,
            "ko" => LanguageCode::Ko,
            "pt" => LanguageCode::Pt,
            "zh" => LanguageCode::Zh,
            "zh-TW" => LanguageCode::ZhTw,
            other => LanguageCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LanguageCode::from(s))
    }
}
impl LanguageCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LanguageCode::Ar => "ar",
            LanguageCode::De => "de",
            LanguageCode::En => "en",
            LanguageCode::Es => "es",
            LanguageCode::Fr => "fr",
            LanguageCode::Hi => "hi",
            LanguageCode::It => "it",
            LanguageCode::Ja => "ja",
            LanguageCode::Ko => "ko",
            LanguageCode::Pt => "pt",
            LanguageCode::Zh => "zh",
            LanguageCode::ZhTw => "zh-TW",
            LanguageCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ar", "de", "en", "es", "fr", "hi", "it", "ja", "ko", "pt", "zh", "zh-TW",
        ]
    }
}
impl AsRef<str> for LanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides configuration parameters for PII entity redaction.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RedactionConfig {
    /// <p>An array of the types of PII entities that Amazon Comprehend detects in the input text for your request.</p>
    #[doc(hidden)]
    pub pii_entity_types: std::option::Option<std::vec::Vec<crate::model::PiiEntityType>>,
    /// <p>Specifies whether the PII entity is redacted with the mask character or the entity type.</p>
    #[doc(hidden)]
    pub mask_mode: std::option::Option<crate::model::PiiEntitiesDetectionMaskMode>,
    /// <p>A character that replaces each character in the redacted PII entity.</p>
    #[doc(hidden)]
    pub mask_character: std::option::Option<std::string::String>,
}
impl RedactionConfig {
    /// <p>An array of the types of PII entities that Amazon Comprehend detects in the input text for your request.</p>
    pub fn pii_entity_types(&self) -> std::option::Option<&[crate::model::PiiEntityType]> {
        self.pii_entity_types.as_deref()
    }
    /// <p>Specifies whether the PII entity is redacted with the mask character or the entity type.</p>
    pub fn mask_mode(&self) -> std::option::Option<&crate::model::PiiEntitiesDetectionMaskMode> {
        self.mask_mode.as_ref()
    }
    /// <p>A character that replaces each character in the redacted PII entity.</p>
    pub fn mask_character(&self) -> std::option::Option<&str> {
        self.mask_character.as_deref()
    }
}
/// See [`RedactionConfig`](crate::model::RedactionConfig).
pub mod redaction_config {

    /// A builder for [`RedactionConfig`](crate::model::RedactionConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pii_entity_types:
            std::option::Option<std::vec::Vec<crate::model::PiiEntityType>>,
        pub(crate) mask_mode: std::option::Option<crate::model::PiiEntitiesDetectionMaskMode>,
        pub(crate) mask_character: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `pii_entity_types`.
        ///
        /// To override the contents of this collection use [`set_pii_entity_types`](Self::set_pii_entity_types).
        ///
        /// <p>An array of the types of PII entities that Amazon Comprehend detects in the input text for your request.</p>
        pub fn pii_entity_types(mut self, input: crate::model::PiiEntityType) -> Self {
            let mut v = self.pii_entity_types.unwrap_or_default();
            v.push(input);
            self.pii_entity_types = Some(v);
            self
        }
        /// <p>An array of the types of PII entities that Amazon Comprehend detects in the input text for your request.</p>
        pub fn set_pii_entity_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PiiEntityType>>,
        ) -> Self {
            self.pii_entity_types = input;
            self
        }
        /// <p>Specifies whether the PII entity is redacted with the mask character or the entity type.</p>
        pub fn mask_mode(mut self, input: crate::model::PiiEntitiesDetectionMaskMode) -> Self {
            self.mask_mode = Some(input);
            self
        }
        /// <p>Specifies whether the PII entity is redacted with the mask character or the entity type.</p>
        pub fn set_mask_mode(
            mut self,
            input: std::option::Option<crate::model::PiiEntitiesDetectionMaskMode>,
        ) -> Self {
            self.mask_mode = input;
            self
        }
        /// <p>A character that replaces each character in the redacted PII entity.</p>
        pub fn mask_character(mut self, input: impl Into<std::string::String>) -> Self {
            self.mask_character = Some(input.into());
            self
        }
        /// <p>A character that replaces each character in the redacted PII entity.</p>
        pub fn set_mask_character(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.mask_character = input;
            self
        }
        /// Consumes the builder and constructs a [`RedactionConfig`](crate::model::RedactionConfig).
        pub fn build(self) -> crate::model::RedactionConfig {
            crate::model::RedactionConfig {
                pii_entity_types: self.pii_entity_types,
                mask_mode: self.mask_mode,
                mask_character: self.mask_character,
            }
        }
    }
}
impl RedactionConfig {
    /// Creates a new builder-style object to manufacture [`RedactionConfig`](crate::model::RedactionConfig).
    pub fn builder() -> crate::model::redaction_config::Builder {
        crate::model::redaction_config::Builder::default()
    }
}

/// When writing a match expression against `PiiEntitiesDetectionMaskMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let piientitiesdetectionmaskmode = unimplemented!();
/// match piientitiesdetectionmaskmode {
///     PiiEntitiesDetectionMaskMode::Mask => { /* ... */ },
///     PiiEntitiesDetectionMaskMode::ReplaceWithPiiEntityType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `piientitiesdetectionmaskmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PiiEntitiesDetectionMaskMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PiiEntitiesDetectionMaskMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PiiEntitiesDetectionMaskMode::NewFeature` is defined.
/// Specifically, when `piientitiesdetectionmaskmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PiiEntitiesDetectionMaskMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PiiEntitiesDetectionMaskMode {
    #[allow(missing_docs)] // documentation missing in model
    Mask,
    #[allow(missing_docs)] // documentation missing in model
    ReplaceWithPiiEntityType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PiiEntitiesDetectionMaskMode {
    fn from(s: &str) -> Self {
        match s {
            "MASK" => PiiEntitiesDetectionMaskMode::Mask,
            "REPLACE_WITH_PII_ENTITY_TYPE" => {
                PiiEntitiesDetectionMaskMode::ReplaceWithPiiEntityType
            }
            other => PiiEntitiesDetectionMaskMode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PiiEntitiesDetectionMaskMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PiiEntitiesDetectionMaskMode::from(s))
    }
}
impl PiiEntitiesDetectionMaskMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PiiEntitiesDetectionMaskMode::Mask => "MASK",
            PiiEntitiesDetectionMaskMode::ReplaceWithPiiEntityType => {
                "REPLACE_WITH_PII_ENTITY_TYPE"
            }
            PiiEntitiesDetectionMaskMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MASK", "REPLACE_WITH_PII_ENTITY_TYPE"]
    }
}
impl AsRef<str> for PiiEntitiesDetectionMaskMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PiiEntityType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let piientitytype = unimplemented!();
/// match piientitytype {
///     PiiEntityType::Address => { /* ... */ },
///     PiiEntityType::Age => { /* ... */ },
///     PiiEntityType::All => { /* ... */ },
///     PiiEntityType::AwsAccessKey => { /* ... */ },
///     PiiEntityType::AwsSecretKey => { /* ... */ },
///     PiiEntityType::BankAccountNumber => { /* ... */ },
///     PiiEntityType::BankRouting => { /* ... */ },
///     PiiEntityType::CaHealthNumber => { /* ... */ },
///     PiiEntityType::CaSocialInsuranceNumber => { /* ... */ },
///     PiiEntityType::CreditDebitCvv => { /* ... */ },
///     PiiEntityType::CreditDebitExpiry => { /* ... */ },
///     PiiEntityType::CreditDebitNumber => { /* ... */ },
///     PiiEntityType::DateTime => { /* ... */ },
///     PiiEntityType::DriverId => { /* ... */ },
///     PiiEntityType::Email => { /* ... */ },
///     PiiEntityType::InternationalBankAccountNumber => { /* ... */ },
///     PiiEntityType::InAadhaar => { /* ... */ },
///     PiiEntityType::InNrega => { /* ... */ },
///     PiiEntityType::InPermanentAccountNumber => { /* ... */ },
///     PiiEntityType::InVoterNumber => { /* ... */ },
///     PiiEntityType::IpAddress => { /* ... */ },
///     PiiEntityType::LicensePlate => { /* ... */ },
///     PiiEntityType::MacAddress => { /* ... */ },
///     PiiEntityType::Name => { /* ... */ },
///     PiiEntityType::PassportNumber => { /* ... */ },
///     PiiEntityType::Password => { /* ... */ },
///     PiiEntityType::Phone => { /* ... */ },
///     PiiEntityType::Pin => { /* ... */ },
///     PiiEntityType::Ssn => { /* ... */ },
///     PiiEntityType::SwiftCode => { /* ... */ },
///     PiiEntityType::UkNationalHealthServiceNumber => { /* ... */ },
///     PiiEntityType::UkNationalInsuranceNumber => { /* ... */ },
///     PiiEntityType::UkUniqueTaxpayerReferenceNumber => { /* ... */ },
///     PiiEntityType::Url => { /* ... */ },
///     PiiEntityType::Username => { /* ... */ },
///     PiiEntityType::UsIndividualTaxIdentificationNumber => { /* ... */ },
///     PiiEntityType::VehicleIdentificationNumber => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `piientitytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PiiEntityType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PiiEntityType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PiiEntityType::NewFeature` is defined.
/// Specifically, when `piientitytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PiiEntityType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PiiEntityType {
    #[allow(missing_docs)] // documentation missing in model
    Address,
    #[allow(missing_docs)] // documentation missing in model
    Age,
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    AwsAccessKey,
    #[allow(missing_docs)] // documentation missing in model
    AwsSecretKey,
    #[allow(missing_docs)] // documentation missing in model
    BankAccountNumber,
    #[allow(missing_docs)] // documentation missing in model
    BankRouting,
    #[allow(missing_docs)] // documentation missing in model
    CaHealthNumber,
    #[allow(missing_docs)] // documentation missing in model
    CaSocialInsuranceNumber,
    #[allow(missing_docs)] // documentation missing in model
    CreditDebitCvv,
    #[allow(missing_docs)] // documentation missing in model
    CreditDebitExpiry,
    #[allow(missing_docs)] // documentation missing in model
    CreditDebitNumber,
    #[allow(missing_docs)] // documentation missing in model
    DateTime,
    #[allow(missing_docs)] // documentation missing in model
    DriverId,
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    InternationalBankAccountNumber,
    #[allow(missing_docs)] // documentation missing in model
    InAadhaar,
    #[allow(missing_docs)] // documentation missing in model
    InNrega,
    #[allow(missing_docs)] // documentation missing in model
    InPermanentAccountNumber,
    #[allow(missing_docs)] // documentation missing in model
    InVoterNumber,
    #[allow(missing_docs)] // documentation missing in model
    IpAddress,
    #[allow(missing_docs)] // documentation missing in model
    LicensePlate,
    #[allow(missing_docs)] // documentation missing in model
    MacAddress,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    PassportNumber,
    #[allow(missing_docs)] // documentation missing in model
    Password,
    #[allow(missing_docs)] // documentation missing in model
    Phone,
    #[allow(missing_docs)] // documentation missing in model
    Pin,
    #[allow(missing_docs)] // documentation missing in model
    Ssn,
    #[allow(missing_docs)] // documentation missing in model
    SwiftCode,
    #[allow(missing_docs)] // documentation missing in model
    UkNationalHealthServiceNumber,
    #[allow(missing_docs)] // documentation missing in model
    UkNationalInsuranceNumber,
    #[allow(missing_docs)] // documentation missing in model
    UkUniqueTaxpayerReferenceNumber,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    #[allow(missing_docs)] // documentation missing in model
    Username,
    #[allow(missing_docs)] // documentation missing in model
    UsIndividualTaxIdentificationNumber,
    #[allow(missing_docs)] // documentation missing in model
    VehicleIdentificationNumber,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PiiEntityType {
    fn from(s: &str) -> Self {
        match s {
            "ADDRESS" => PiiEntityType::Address,
            "AGE" => PiiEntityType::Age,
            "ALL" => PiiEntityType::All,
            "AWS_ACCESS_KEY" => PiiEntityType::AwsAccessKey,
            "AWS_SECRET_KEY" => PiiEntityType::AwsSecretKey,
            "BANK_ACCOUNT_NUMBER" => PiiEntityType::BankAccountNumber,
            "BANK_ROUTING" => PiiEntityType::BankRouting,
            "CA_HEALTH_NUMBER" => PiiEntityType::CaHealthNumber,
            "CA_SOCIAL_INSURANCE_NUMBER" => PiiEntityType::CaSocialInsuranceNumber,
            "CREDIT_DEBIT_CVV" => PiiEntityType::CreditDebitCvv,
            "CREDIT_DEBIT_EXPIRY" => PiiEntityType::CreditDebitExpiry,
            "CREDIT_DEBIT_NUMBER" => PiiEntityType::CreditDebitNumber,
            "DATE_TIME" => PiiEntityType::DateTime,
            "DRIVER_ID" => PiiEntityType::DriverId,
            "EMAIL" => PiiEntityType::Email,
            "INTERNATIONAL_BANK_ACCOUNT_NUMBER" => PiiEntityType::InternationalBankAccountNumber,
            "IN_AADHAAR" => PiiEntityType::InAadhaar,
            "IN_NREGA" => PiiEntityType::InNrega,
            "IN_PERMANENT_ACCOUNT_NUMBER" => PiiEntityType::InPermanentAccountNumber,
            "IN_VOTER_NUMBER" => PiiEntityType::InVoterNumber,
            "IP_ADDRESS" => PiiEntityType::IpAddress,
            "LICENSE_PLATE" => PiiEntityType::LicensePlate,
            "MAC_ADDRESS" => PiiEntityType::MacAddress,
            "NAME" => PiiEntityType::Name,
            "PASSPORT_NUMBER" => PiiEntityType::PassportNumber,
            "PASSWORD" => PiiEntityType::Password,
            "PHONE" => PiiEntityType::Phone,
            "PIN" => PiiEntityType::Pin,
            "SSN" => PiiEntityType::Ssn,
            "SWIFT_CODE" => PiiEntityType::SwiftCode,
            "UK_NATIONAL_HEALTH_SERVICE_NUMBER" => PiiEntityType::UkNationalHealthServiceNumber,
            "UK_NATIONAL_INSURANCE_NUMBER" => PiiEntityType::UkNationalInsuranceNumber,
            "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER" => PiiEntityType::UkUniqueTaxpayerReferenceNumber,
            "URL" => PiiEntityType::Url,
            "USERNAME" => PiiEntityType::Username,
            "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER" => {
                PiiEntityType::UsIndividualTaxIdentificationNumber
            }
            "VEHICLE_IDENTIFICATION_NUMBER" => PiiEntityType::VehicleIdentificationNumber,
            other => PiiEntityType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PiiEntityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PiiEntityType::from(s))
    }
}
impl PiiEntityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PiiEntityType::Address => "ADDRESS",
            PiiEntityType::Age => "AGE",
            PiiEntityType::All => "ALL",
            PiiEntityType::AwsAccessKey => "AWS_ACCESS_KEY",
            PiiEntityType::AwsSecretKey => "AWS_SECRET_KEY",
            PiiEntityType::BankAccountNumber => "BANK_ACCOUNT_NUMBER",
            PiiEntityType::BankRouting => "BANK_ROUTING",
            PiiEntityType::CaHealthNumber => "CA_HEALTH_NUMBER",
            PiiEntityType::CaSocialInsuranceNumber => "CA_SOCIAL_INSURANCE_NUMBER",
            PiiEntityType::CreditDebitCvv => "CREDIT_DEBIT_CVV",
            PiiEntityType::CreditDebitExpiry => "CREDIT_DEBIT_EXPIRY",
            PiiEntityType::CreditDebitNumber => "CREDIT_DEBIT_NUMBER",
            PiiEntityType::DateTime => "DATE_TIME",
            PiiEntityType::DriverId => "DRIVER_ID",
            PiiEntityType::Email => "EMAIL",
            PiiEntityType::InternationalBankAccountNumber => "INTERNATIONAL_BANK_ACCOUNT_NUMBER",
            PiiEntityType::InAadhaar => "IN_AADHAAR",
            PiiEntityType::InNrega => "IN_NREGA",
            PiiEntityType::InPermanentAccountNumber => "IN_PERMANENT_ACCOUNT_NUMBER",
            PiiEntityType::InVoterNumber => "IN_VOTER_NUMBER",
            PiiEntityType::IpAddress => "IP_ADDRESS",
            PiiEntityType::LicensePlate => "LICENSE_PLATE",
            PiiEntityType::MacAddress => "MAC_ADDRESS",
            PiiEntityType::Name => "NAME",
            PiiEntityType::PassportNumber => "PASSPORT_NUMBER",
            PiiEntityType::Password => "PASSWORD",
            PiiEntityType::Phone => "PHONE",
            PiiEntityType::Pin => "PIN",
            PiiEntityType::Ssn => "SSN",
            PiiEntityType::SwiftCode => "SWIFT_CODE",
            PiiEntityType::UkNationalHealthServiceNumber => "UK_NATIONAL_HEALTH_SERVICE_NUMBER",
            PiiEntityType::UkNationalInsuranceNumber => "UK_NATIONAL_INSURANCE_NUMBER",
            PiiEntityType::UkUniqueTaxpayerReferenceNumber => "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER",
            PiiEntityType::Url => "URL",
            PiiEntityType::Username => "USERNAME",
            PiiEntityType::UsIndividualTaxIdentificationNumber => {
                "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            }
            PiiEntityType::VehicleIdentificationNumber => "VEHICLE_IDENTIFICATION_NUMBER",
            PiiEntityType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ADDRESS",
            "AGE",
            "ALL",
            "AWS_ACCESS_KEY",
            "AWS_SECRET_KEY",
            "BANK_ACCOUNT_NUMBER",
            "BANK_ROUTING",
            "CA_HEALTH_NUMBER",
            "CA_SOCIAL_INSURANCE_NUMBER",
            "CREDIT_DEBIT_CVV",
            "CREDIT_DEBIT_EXPIRY",
            "CREDIT_DEBIT_NUMBER",
            "DATE_TIME",
            "DRIVER_ID",
            "EMAIL",
            "INTERNATIONAL_BANK_ACCOUNT_NUMBER",
            "IN_AADHAAR",
            "IN_NREGA",
            "IN_PERMANENT_ACCOUNT_NUMBER",
            "IN_VOTER_NUMBER",
            "IP_ADDRESS",
            "LICENSE_PLATE",
            "MAC_ADDRESS",
            "NAME",
            "PASSPORT_NUMBER",
            "PASSWORD",
            "PHONE",
            "PIN",
            "SSN",
            "SWIFT_CODE",
            "UK_NATIONAL_HEALTH_SERVICE_NUMBER",
            "UK_NATIONAL_INSURANCE_NUMBER",
            "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER",
            "URL",
            "USERNAME",
            "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER",
            "VEHICLE_IDENTIFICATION_NUMBER",
        ]
    }
}
impl AsRef<str> for PiiEntityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PiiEntitiesDetectionMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let piientitiesdetectionmode = unimplemented!();
/// match piientitiesdetectionmode {
///     PiiEntitiesDetectionMode::OnlyOffsets => { /* ... */ },
///     PiiEntitiesDetectionMode::OnlyRedaction => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `piientitiesdetectionmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PiiEntitiesDetectionMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PiiEntitiesDetectionMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PiiEntitiesDetectionMode::NewFeature` is defined.
/// Specifically, when `piientitiesdetectionmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PiiEntitiesDetectionMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PiiEntitiesDetectionMode {
    #[allow(missing_docs)] // documentation missing in model
    OnlyOffsets,
    #[allow(missing_docs)] // documentation missing in model
    OnlyRedaction,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PiiEntitiesDetectionMode {
    fn from(s: &str) -> Self {
        match s {
            "ONLY_OFFSETS" => PiiEntitiesDetectionMode::OnlyOffsets,
            "ONLY_REDACTION" => PiiEntitiesDetectionMode::OnlyRedaction,
            other => PiiEntitiesDetectionMode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PiiEntitiesDetectionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PiiEntitiesDetectionMode::from(s))
    }
}
impl PiiEntitiesDetectionMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PiiEntitiesDetectionMode::OnlyOffsets => "ONLY_OFFSETS",
            PiiEntitiesDetectionMode::OnlyRedaction => "ONLY_REDACTION",
            PiiEntitiesDetectionMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ONLY_OFFSETS", "ONLY_REDACTION"]
    }
}
impl AsRef<str> for PiiEntitiesDetectionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about a topic detection job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TopicsDetectionJobProperties {
    /// <p>The identifier assigned to the topic detection job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :topics-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:topics-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name of the topic detection job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The current status of the topic detection job. If the status is <code>Failed</code>, the reason for the failure is shown in the <code>Message</code> field.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>A description for the status of a job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the topic detection job was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the topic detection job was completed.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The input data configuration supplied when you created the topic detection job.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data configuration supplied when you created the topic detection job.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The number of topics to detect supplied when you created the topic detection job. The default is 10. </p>
    #[doc(hidden)]
    pub number_of_topics: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your job data. </p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p>Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your topic detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl TopicsDetectionJobProperties {
    /// <p>The identifier assigned to the topic detection job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :topics-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:topics-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The name of the topic detection job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The current status of the topic detection job. If the status is <code>Failed</code>, the reason for the failure is shown in the <code>Message</code> field.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>A description for the status of a job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the topic detection job was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the topic detection job was completed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The input data configuration supplied when you created the topic detection job.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data configuration supplied when you created the topic detection job.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The number of topics to detect supplied when you created the topic detection job. The default is 10. </p>
    pub fn number_of_topics(&self) -> std::option::Option<i32> {
        self.number_of_topics
    }
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your job data. </p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p>Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your topic detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
/// See [`TopicsDetectionJobProperties`](crate::model::TopicsDetectionJobProperties).
pub mod topics_detection_job_properties {

    /// A builder for [`TopicsDetectionJobProperties`](crate::model::TopicsDetectionJobProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) number_of_topics: std::option::Option<i32>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>The identifier assigned to the topic detection job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier assigned to the topic detection job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :topics-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:topics-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the topics detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :topics-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:topics-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The name of the topic detection job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name of the topic detection job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The current status of the topic detection job. If the status is <code>Failed</code>, the reason for the failure is shown in the <code>Message</code> field.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the topic detection job. If the status is <code>Failed</code>, the reason for the failure is shown in the <code>Message</code> field.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>A description for the status of a job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description for the status of a job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the topic detection job was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the topic detection job was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the topic detection job was completed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the topic detection job was completed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The input data configuration supplied when you created the topic detection job.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data configuration supplied when you created the topic detection job.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data configuration supplied when you created the topic detection job.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data configuration supplied when you created the topic detection job.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The number of topics to detect supplied when you created the topic detection job. The default is 10. </p>
        pub fn number_of_topics(mut self, input: i32) -> Self {
            self.number_of_topics = Some(input);
            self
        }
        /// <p>The number of topics to detect supplied when you created the topic detection job. The default is 10. </p>
        pub fn set_number_of_topics(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_topics = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your job data. </p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your job data. </p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p>Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your topic detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p>Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your topic detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`TopicsDetectionJobProperties`](crate::model::TopicsDetectionJobProperties).
        pub fn build(self) -> crate::model::TopicsDetectionJobProperties {
            crate::model::TopicsDetectionJobProperties {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_name: self.job_name,
                job_status: self.job_status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                number_of_topics: self.number_of_topics,
                data_access_role_arn: self.data_access_role_arn,
                volume_kms_key_id: self.volume_kms_key_id,
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl TopicsDetectionJobProperties {
    /// Creates a new builder-style object to manufacture [`TopicsDetectionJobProperties`](crate::model::TopicsDetectionJobProperties).
    pub fn builder() -> crate::model::topics_detection_job_properties::Builder {
        crate::model::topics_detection_job_properties::Builder::default()
    }
}

/// <p>Provides information for filtering topic detection jobs. For more information, see .</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TopicsDetectionJobFilter {
    /// <p></p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of topic detection jobs based on job status. Returns only jobs with the specified status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Only returns jobs submitted before the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Only returns jobs submitted after the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl TopicsDetectionJobFilter {
    /// <p></p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filters the list of topic detection jobs based on job status. Returns only jobs with the specified status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Only returns jobs submitted before the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Only returns jobs submitted after the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`TopicsDetectionJobFilter`](crate::model::TopicsDetectionJobFilter).
pub mod topics_detection_job_filter {

    /// A builder for [`TopicsDetectionJobFilter`](crate::model::TopicsDetectionJobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p></p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filters the list of topic detection jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Filters the list of topic detection jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Only returns jobs submitted before the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Only returns jobs submitted before the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Only returns jobs submitted after the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Only returns jobs submitted after the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`TopicsDetectionJobFilter`](crate::model::TopicsDetectionJobFilter).
        pub fn build(self) -> crate::model::TopicsDetectionJobFilter {
            crate::model::TopicsDetectionJobFilter {
                job_name: self.job_name,
                job_status: self.job_status,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl TopicsDetectionJobFilter {
    /// Creates a new builder-style object to manufacture [`TopicsDetectionJobFilter`](crate::model::TopicsDetectionJobFilter).
    pub fn builder() -> crate::model::topics_detection_job_filter::Builder {
        crate::model::topics_detection_job_filter::Builder::default()
    }
}

/// <p>Provides information about a targeted sentiment detection job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TargetedSentimentDetectionJobProperties {
    /// <p>The identifier assigned to the targeted sentiment detection job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the targeted sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :targeted-sentiment-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:targeted-sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name that you assigned to the targeted sentiment detection job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The current status of the targeted sentiment detection job. If the status is <code>FAILED</code>, the <code>Messages</code> field shows the reason for the failure.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>A description of the status of a job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the targeted sentiment detection job was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the targeted sentiment detection job ended.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The input properties for an inference job. The document reader config field applies only to non-text inputs for custom analysis.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>Provides configuration parameters for the output of inference jobs.</p>
    /// <p></p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The language code of the input documents.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the targeted sentiment detection job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p> Configuration parameters for an optional private Virtual Private Cloud (VPC) containing the resources you are using for the job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl TargetedSentimentDetectionJobProperties {
    /// <p>The identifier assigned to the targeted sentiment detection job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the targeted sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :targeted-sentiment-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:targeted-sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The name that you assigned to the targeted sentiment detection job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The current status of the targeted sentiment detection job. If the status is <code>FAILED</code>, the <code>Messages</code> field shows the reason for the failure.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>A description of the status of a job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the targeted sentiment detection job was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the targeted sentiment detection job ended.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The input properties for an inference job. The document reader config field applies only to non-text inputs for custom analysis.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>Provides configuration parameters for the output of inference jobs.</p>
    /// <p></p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The language code of the input documents.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the targeted sentiment detection job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p> Configuration parameters for an optional private Virtual Private Cloud (VPC) containing the resources you are using for the job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
/// See [`TargetedSentimentDetectionJobProperties`](crate::model::TargetedSentimentDetectionJobProperties).
pub mod targeted_sentiment_detection_job_properties {

    /// A builder for [`TargetedSentimentDetectionJobProperties`](crate::model::TargetedSentimentDetectionJobProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>The identifier assigned to the targeted sentiment detection job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier assigned to the targeted sentiment detection job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the targeted sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :targeted-sentiment-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:targeted-sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the targeted sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :targeted-sentiment-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:targeted-sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The name that you assigned to the targeted sentiment detection job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned to the targeted sentiment detection job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The current status of the targeted sentiment detection job. If the status is <code>FAILED</code>, the <code>Messages</code> field shows the reason for the failure.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the targeted sentiment detection job. If the status is <code>FAILED</code>, the <code>Messages</code> field shows the reason for the failure.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the targeted sentiment detection job was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the targeted sentiment detection job was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the targeted sentiment detection job ended.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the targeted sentiment detection job ended.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The input properties for an inference job. The document reader config field applies only to non-text inputs for custom analysis.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input properties for an inference job. The document reader config field applies only to non-text inputs for custom analysis.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>Provides configuration parameters for the output of inference jobs.</p>
        /// <p></p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>Provides configuration parameters for the output of inference jobs.</p>
        /// <p></p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the targeted sentiment detection job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the targeted sentiment detection job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p> Configuration parameters for an optional private Virtual Private Cloud (VPC) containing the resources you are using for the job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p> Configuration parameters for an optional private Virtual Private Cloud (VPC) containing the resources you are using for the job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetedSentimentDetectionJobProperties`](crate::model::TargetedSentimentDetectionJobProperties).
        pub fn build(self) -> crate::model::TargetedSentimentDetectionJobProperties {
            crate::model::TargetedSentimentDetectionJobProperties {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_name: self.job_name,
                job_status: self.job_status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                language_code: self.language_code,
                data_access_role_arn: self.data_access_role_arn,
                volume_kms_key_id: self.volume_kms_key_id,
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl TargetedSentimentDetectionJobProperties {
    /// Creates a new builder-style object to manufacture [`TargetedSentimentDetectionJobProperties`](crate::model::TargetedSentimentDetectionJobProperties).
    pub fn builder() -> crate::model::targeted_sentiment_detection_job_properties::Builder {
        crate::model::targeted_sentiment_detection_job_properties::Builder::default()
    }
}

/// <p>Provides information for filtering a list of dominant language detection jobs. For more information, see the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TargetedSentimentDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl TargetedSentimentDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`TargetedSentimentDetectionJobFilter`](crate::model::TargetedSentimentDetectionJobFilter).
pub mod targeted_sentiment_detection_job_filter {

    /// A builder for [`TargetedSentimentDetectionJobFilter`](crate::model::TargetedSentimentDetectionJobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filters on the name of the job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>Filters on the name of the job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetedSentimentDetectionJobFilter`](crate::model::TargetedSentimentDetectionJobFilter).
        pub fn build(self) -> crate::model::TargetedSentimentDetectionJobFilter {
            crate::model::TargetedSentimentDetectionJobFilter {
                job_name: self.job_name,
                job_status: self.job_status,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl TargetedSentimentDetectionJobFilter {
    /// Creates a new builder-style object to manufacture [`TargetedSentimentDetectionJobFilter`](crate::model::TargetedSentimentDetectionJobFilter).
    pub fn builder() -> crate::model::targeted_sentiment_detection_job_filter::Builder {
        crate::model::targeted_sentiment_detection_job_filter::Builder::default()
    }
}

/// <p>Provides information about a sentiment detection job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SentimentDetectionJobProperties {
    /// <p>The identifier assigned to the sentiment detection job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :sentiment-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name that you assigned to the sentiment detection job</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The current status of the sentiment detection job. If the status is <code>FAILED</code>, the <code>Messages</code> field shows the reason for the failure.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>A description of the status of a job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the sentiment detection job was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the sentiment detection job ended.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The input data configuration that you supplied when you created the sentiment detection job.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data configuration that you supplied when you created the sentiment detection job.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The language code of the input documents.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your sentiment detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl SentimentDetectionJobProperties {
    /// <p>The identifier assigned to the sentiment detection job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :sentiment-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The name that you assigned to the sentiment detection job</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The current status of the sentiment detection job. If the status is <code>FAILED</code>, the <code>Messages</code> field shows the reason for the failure.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>A description of the status of a job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the sentiment detection job was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the sentiment detection job ended.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The input data configuration that you supplied when you created the sentiment detection job.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data configuration that you supplied when you created the sentiment detection job.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The language code of the input documents.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your sentiment detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
/// See [`SentimentDetectionJobProperties`](crate::model::SentimentDetectionJobProperties).
pub mod sentiment_detection_job_properties {

    /// A builder for [`SentimentDetectionJobProperties`](crate::model::SentimentDetectionJobProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>The identifier assigned to the sentiment detection job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier assigned to the sentiment detection job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :sentiment-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the sentiment detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :sentiment-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:sentiment-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The name that you assigned to the sentiment detection job</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned to the sentiment detection job</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The current status of the sentiment detection job. If the status is <code>FAILED</code>, the <code>Messages</code> field shows the reason for the failure.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the sentiment detection job. If the status is <code>FAILED</code>, the <code>Messages</code> field shows the reason for the failure.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the sentiment detection job was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the sentiment detection job was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the sentiment detection job ended.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the sentiment detection job ended.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The input data configuration that you supplied when you created the sentiment detection job.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data configuration that you supplied when you created the sentiment detection job.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data configuration that you supplied when you created the sentiment detection job.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data configuration that you supplied when you created the sentiment detection job.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your sentiment detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your sentiment detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`SentimentDetectionJobProperties`](crate::model::SentimentDetectionJobProperties).
        pub fn build(self) -> crate::model::SentimentDetectionJobProperties {
            crate::model::SentimentDetectionJobProperties {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_name: self.job_name,
                job_status: self.job_status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                language_code: self.language_code,
                data_access_role_arn: self.data_access_role_arn,
                volume_kms_key_id: self.volume_kms_key_id,
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl SentimentDetectionJobProperties {
    /// Creates a new builder-style object to manufacture [`SentimentDetectionJobProperties`](crate::model::SentimentDetectionJobProperties).
    pub fn builder() -> crate::model::sentiment_detection_job_properties::Builder {
        crate::model::sentiment_detection_job_properties::Builder::default()
    }
}

/// <p>Provides information for filtering a list of dominant language detection jobs. For more information, see the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SentimentDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl SentimentDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`SentimentDetectionJobFilter`](crate::model::SentimentDetectionJobFilter).
pub mod sentiment_detection_job_filter {

    /// A builder for [`SentimentDetectionJobFilter`](crate::model::SentimentDetectionJobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filters on the name of the job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>Filters on the name of the job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`SentimentDetectionJobFilter`](crate::model::SentimentDetectionJobFilter).
        pub fn build(self) -> crate::model::SentimentDetectionJobFilter {
            crate::model::SentimentDetectionJobFilter {
                job_name: self.job_name,
                job_status: self.job_status,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl SentimentDetectionJobFilter {
    /// Creates a new builder-style object to manufacture [`SentimentDetectionJobFilter`](crate::model::SentimentDetectionJobFilter).
    pub fn builder() -> crate::model::sentiment_detection_job_filter::Builder {
        crate::model::sentiment_detection_job_filter::Builder::default()
    }
}

/// <p>Provides information about a PII entities detection job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PiiEntitiesDetectionJobProperties {
    /// <p>The identifier assigned to the PII entities detection job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the PII entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :pii-entities-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name that you assigned the PII entities detection job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The current status of the PII entities detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>A description of the status of a job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the PII entities detection job was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the PII entities detection job completed.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The input properties for a PII entities detection job.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data configuration that you supplied when you created the PII entities detection job.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::PiiOutputDataConfig>,
    /// <p>Provides configuration parameters for PII entity redaction.</p>
    /// <p>This parameter is required if you set the <code>Mode</code> parameter to <code>ONLY_REDACTION</code>. In that case, you must provide a <code>RedactionConfig</code> definition that includes the <code>PiiEntityTypes</code> parameter.</p>
    #[doc(hidden)]
    pub redaction_config: std::option::Option<crate::model::RedactionConfig>,
    /// <p>The language code of the input documents</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>Specifies whether the output provides the locations (offsets) of PII entities or a file in which PII entities are redacted.</p>
    #[doc(hidden)]
    pub mode: std::option::Option<crate::model::PiiEntitiesDetectionMode>,
}
impl PiiEntitiesDetectionJobProperties {
    /// <p>The identifier assigned to the PII entities detection job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the PII entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :pii-entities-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The name that you assigned the PII entities detection job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The current status of the PII entities detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>A description of the status of a job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the PII entities detection job was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the PII entities detection job completed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The input properties for a PII entities detection job.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data configuration that you supplied when you created the PII entities detection job.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::PiiOutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>Provides configuration parameters for PII entity redaction.</p>
    /// <p>This parameter is required if you set the <code>Mode</code> parameter to <code>ONLY_REDACTION</code>. In that case, you must provide a <code>RedactionConfig</code> definition that includes the <code>PiiEntityTypes</code> parameter.</p>
    pub fn redaction_config(&self) -> std::option::Option<&crate::model::RedactionConfig> {
        self.redaction_config.as_ref()
    }
    /// <p>The language code of the input documents</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>Specifies whether the output provides the locations (offsets) of PII entities or a file in which PII entities are redacted.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::PiiEntitiesDetectionMode> {
        self.mode.as_ref()
    }
}
/// See [`PiiEntitiesDetectionJobProperties`](crate::model::PiiEntitiesDetectionJobProperties).
pub mod pii_entities_detection_job_properties {

    /// A builder for [`PiiEntitiesDetectionJobProperties`](crate::model::PiiEntitiesDetectionJobProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::PiiOutputDataConfig>,
        pub(crate) redaction_config: std::option::Option<crate::model::RedactionConfig>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) mode: std::option::Option<crate::model::PiiEntitiesDetectionMode>,
    }
    impl Builder {
        /// <p>The identifier assigned to the PII entities detection job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier assigned to the PII entities detection job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the PII entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :pii-entities-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the PII entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :pii-entities-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:pii-entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The name that you assigned the PII entities detection job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned the PII entities detection job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The current status of the PII entities detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the PII entities detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the PII entities detection job was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the PII entities detection job was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the PII entities detection job completed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the PII entities detection job completed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The input properties for a PII entities detection job.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input properties for a PII entities detection job.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data configuration that you supplied when you created the PII entities detection job.</p>
        pub fn output_data_config(mut self, input: crate::model::PiiOutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data configuration that you supplied when you created the PII entities detection job.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::PiiOutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>Provides configuration parameters for PII entity redaction.</p>
        /// <p>This parameter is required if you set the <code>Mode</code> parameter to <code>ONLY_REDACTION</code>. In that case, you must provide a <code>RedactionConfig</code> definition that includes the <code>PiiEntityTypes</code> parameter.</p>
        pub fn redaction_config(mut self, input: crate::model::RedactionConfig) -> Self {
            self.redaction_config = Some(input);
            self
        }
        /// <p>Provides configuration parameters for PII entity redaction.</p>
        /// <p>This parameter is required if you set the <code>Mode</code> parameter to <code>ONLY_REDACTION</code>. In that case, you must provide a <code>RedactionConfig</code> definition that includes the <code>PiiEntityTypes</code> parameter.</p>
        pub fn set_redaction_config(
            mut self,
            input: std::option::Option<crate::model::RedactionConfig>,
        ) -> Self {
            self.redaction_config = input;
            self
        }
        /// <p>The language code of the input documents</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the input documents</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>Specifies whether the output provides the locations (offsets) of PII entities or a file in which PII entities are redacted.</p>
        pub fn mode(mut self, input: crate::model::PiiEntitiesDetectionMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>Specifies whether the output provides the locations (offsets) of PII entities or a file in which PII entities are redacted.</p>
        pub fn set_mode(
            mut self,
            input: std::option::Option<crate::model::PiiEntitiesDetectionMode>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`PiiEntitiesDetectionJobProperties`](crate::model::PiiEntitiesDetectionJobProperties).
        pub fn build(self) -> crate::model::PiiEntitiesDetectionJobProperties {
            crate::model::PiiEntitiesDetectionJobProperties {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_name: self.job_name,
                job_status: self.job_status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                redaction_config: self.redaction_config,
                language_code: self.language_code,
                data_access_role_arn: self.data_access_role_arn,
                mode: self.mode,
            }
        }
    }
}
impl PiiEntitiesDetectionJobProperties {
    /// Creates a new builder-style object to manufacture [`PiiEntitiesDetectionJobProperties`](crate::model::PiiEntitiesDetectionJobProperties).
    pub fn builder() -> crate::model::pii_entities_detection_job_properties::Builder {
        crate::model::pii_entities_detection_job_properties::Builder::default()
    }
}

/// <p>Provides configuration parameters for the output of PII entity detection jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PiiOutputDataConfig {
    /// <p>When you use the <code>PiiOutputDataConfig</code> object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. </p>
    /// <p> For a PII entity detection job, the output file is plain text, not a compressed archive. The output file name is the same as the input file, with <code>.out</code> appended at the end. </p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl PiiOutputDataConfig {
    /// <p>When you use the <code>PiiOutputDataConfig</code> object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. </p>
    /// <p> For a PII entity detection job, the output file is plain text, not a compressed archive. The output file name is the same as the input file, with <code>.out</code> appended at the end. </p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
/// See [`PiiOutputDataConfig`](crate::model::PiiOutputDataConfig).
pub mod pii_output_data_config {

    /// A builder for [`PiiOutputDataConfig`](crate::model::PiiOutputDataConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>When you use the <code>PiiOutputDataConfig</code> object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. </p>
        /// <p> For a PII entity detection job, the output file is plain text, not a compressed archive. The output file name is the same as the input file, with <code>.out</code> appended at the end. </p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>When you use the <code>PiiOutputDataConfig</code> object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. </p>
        /// <p> For a PII entity detection job, the output file is plain text, not a compressed archive. The output file name is the same as the input file, with <code>.out</code> appended at the end. </p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PiiOutputDataConfig`](crate::model::PiiOutputDataConfig).
        pub fn build(self) -> crate::model::PiiOutputDataConfig {
            crate::model::PiiOutputDataConfig {
                s3_uri: self.s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl PiiOutputDataConfig {
    /// Creates a new builder-style object to manufacture [`PiiOutputDataConfig`](crate::model::PiiOutputDataConfig).
    pub fn builder() -> crate::model::pii_output_data_config::Builder {
        crate::model::pii_output_data_config::Builder::default()
    }
}

/// <p>Provides information for filtering a list of PII entity detection jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PiiEntitiesDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl PiiEntitiesDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`PiiEntitiesDetectionJobFilter`](crate::model::PiiEntitiesDetectionJobFilter).
pub mod pii_entities_detection_job_filter {

    /// A builder for [`PiiEntitiesDetectionJobFilter`](crate::model::PiiEntitiesDetectionJobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filters on the name of the job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>Filters on the name of the job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`PiiEntitiesDetectionJobFilter`](crate::model::PiiEntitiesDetectionJobFilter).
        pub fn build(self) -> crate::model::PiiEntitiesDetectionJobFilter {
            crate::model::PiiEntitiesDetectionJobFilter {
                job_name: self.job_name,
                job_status: self.job_status,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl PiiEntitiesDetectionJobFilter {
    /// Creates a new builder-style object to manufacture [`PiiEntitiesDetectionJobFilter`](crate::model::PiiEntitiesDetectionJobFilter).
    pub fn builder() -> crate::model::pii_entities_detection_job_filter::Builder {
        crate::model::pii_entities_detection_job_filter::Builder::default()
    }
}

/// <p>Provides information about a key phrases detection job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KeyPhrasesDetectionJobProperties {
    /// <p>The identifier assigned to the key phrases detection job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the key phrases detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :key-phrases-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name that you assigned the key phrases detection job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The current status of the key phrases detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>A description of the status of a job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the key phrases detection job was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the key phrases detection job completed.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The input data configuration that you supplied when you created the key phrases detection job.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data configuration that you supplied when you created the key phrases detection job.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The language code of the input documents.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your key phrases detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl KeyPhrasesDetectionJobProperties {
    /// <p>The identifier assigned to the key phrases detection job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the key phrases detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :key-phrases-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The name that you assigned the key phrases detection job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The current status of the key phrases detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>A description of the status of a job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the key phrases detection job was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the key phrases detection job completed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The input data configuration that you supplied when you created the key phrases detection job.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data configuration that you supplied when you created the key phrases detection job.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The language code of the input documents.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your key phrases detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
/// See [`KeyPhrasesDetectionJobProperties`](crate::model::KeyPhrasesDetectionJobProperties).
pub mod key_phrases_detection_job_properties {

    /// A builder for [`KeyPhrasesDetectionJobProperties`](crate::model::KeyPhrasesDetectionJobProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>The identifier assigned to the key phrases detection job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier assigned to the key phrases detection job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the key phrases detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :key-phrases-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the key phrases detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :key-phrases-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:key-phrases-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The name that you assigned the key phrases detection job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned the key phrases detection job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The current status of the key phrases detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the key phrases detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the key phrases detection job was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the key phrases detection job was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the key phrases detection job completed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the key phrases detection job completed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The input data configuration that you supplied when you created the key phrases detection job.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data configuration that you supplied when you created the key phrases detection job.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data configuration that you supplied when you created the key phrases detection job.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data configuration that you supplied when you created the key phrases detection job.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your key phrases detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your key phrases detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`KeyPhrasesDetectionJobProperties`](crate::model::KeyPhrasesDetectionJobProperties).
        pub fn build(self) -> crate::model::KeyPhrasesDetectionJobProperties {
            crate::model::KeyPhrasesDetectionJobProperties {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_name: self.job_name,
                job_status: self.job_status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                language_code: self.language_code,
                data_access_role_arn: self.data_access_role_arn,
                volume_kms_key_id: self.volume_kms_key_id,
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl KeyPhrasesDetectionJobProperties {
    /// Creates a new builder-style object to manufacture [`KeyPhrasesDetectionJobProperties`](crate::model::KeyPhrasesDetectionJobProperties).
    pub fn builder() -> crate::model::key_phrases_detection_job_properties::Builder {
        crate::model::key_phrases_detection_job_properties::Builder::default()
    }
}

/// <p>Provides information for filtering a list of dominant language detection jobs. For more information, see the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KeyPhrasesDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl KeyPhrasesDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`KeyPhrasesDetectionJobFilter`](crate::model::KeyPhrasesDetectionJobFilter).
pub mod key_phrases_detection_job_filter {

    /// A builder for [`KeyPhrasesDetectionJobFilter`](crate::model::KeyPhrasesDetectionJobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filters on the name of the job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>Filters on the name of the job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`KeyPhrasesDetectionJobFilter`](crate::model::KeyPhrasesDetectionJobFilter).
        pub fn build(self) -> crate::model::KeyPhrasesDetectionJobFilter {
            crate::model::KeyPhrasesDetectionJobFilter {
                job_name: self.job_name,
                job_status: self.job_status,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl KeyPhrasesDetectionJobFilter {
    /// Creates a new builder-style object to manufacture [`KeyPhrasesDetectionJobFilter`](crate::model::KeyPhrasesDetectionJobFilter).
    pub fn builder() -> crate::model::key_phrases_detection_job_filter::Builder {
        crate::model::key_phrases_detection_job_filter::Builder::default()
    }
}

/// <p>Provides information about an events detection job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventsDetectionJobProperties {
    /// <p>The identifier assigned to the events detection job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :events-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name you assigned the events detection job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The current status of the events detection job.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>A description of the status of the events detection job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the events detection job was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the events detection job completed.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The input data configuration that you supplied when you created the events detection job.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data configuration that you supplied when you created the events detection job.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The language code of the input documents.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identify and Access Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>The types of events that are detected by the job.</p>
    #[doc(hidden)]
    pub target_event_types: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl EventsDetectionJobProperties {
    /// <p>The identifier assigned to the events detection job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :events-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The name you assigned the events detection job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The current status of the events detection job.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>A description of the status of the events detection job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the events detection job was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the events detection job completed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The input data configuration that you supplied when you created the events detection job.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data configuration that you supplied when you created the events detection job.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The language code of the input documents.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the AWS Identify and Access Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>The types of events that are detected by the job.</p>
    pub fn target_event_types(&self) -> std::option::Option<&[std::string::String]> {
        self.target_event_types.as_deref()
    }
}
/// See [`EventsDetectionJobProperties`](crate::model::EventsDetectionJobProperties).
pub mod events_detection_job_properties {

    /// A builder for [`EventsDetectionJobProperties`](crate::model::EventsDetectionJobProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) target_event_types: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The identifier assigned to the events detection job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier assigned to the events detection job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :events-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the events detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :events-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:events-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The name you assigned the events detection job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name you assigned the events detection job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The current status of the events detection job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the events detection job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>A description of the status of the events detection job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the status of the events detection job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the events detection job was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the events detection job was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the events detection job completed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the events detection job completed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The input data configuration that you supplied when you created the events detection job.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data configuration that you supplied when you created the events detection job.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data configuration that you supplied when you created the events detection job.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data configuration that you supplied when you created the events detection job.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identify and Access Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identify and Access Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// Appends an item to `target_event_types`.
        ///
        /// To override the contents of this collection use [`set_target_event_types`](Self::set_target_event_types).
        ///
        /// <p>The types of events that are detected by the job.</p>
        pub fn target_event_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_event_types.unwrap_or_default();
            v.push(input.into());
            self.target_event_types = Some(v);
            self
        }
        /// <p>The types of events that are detected by the job.</p>
        pub fn set_target_event_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_event_types = input;
            self
        }
        /// Consumes the builder and constructs a [`EventsDetectionJobProperties`](crate::model::EventsDetectionJobProperties).
        pub fn build(self) -> crate::model::EventsDetectionJobProperties {
            crate::model::EventsDetectionJobProperties {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_name: self.job_name,
                job_status: self.job_status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                language_code: self.language_code,
                data_access_role_arn: self.data_access_role_arn,
                target_event_types: self.target_event_types,
            }
        }
    }
}
impl EventsDetectionJobProperties {
    /// Creates a new builder-style object to manufacture [`EventsDetectionJobProperties`](crate::model::EventsDetectionJobProperties).
    pub fn builder() -> crate::model::events_detection_job_properties::Builder {
        crate::model::events_detection_job_properties::Builder::default()
    }
}

/// <p>Provides information for filtering a list of event detection jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventsDetectionJobFilter {
    /// <p>Filters on the name of the events detection job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl EventsDetectionJobFilter {
    /// <p>Filters on the name of the events detection job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`EventsDetectionJobFilter`](crate::model::EventsDetectionJobFilter).
pub mod events_detection_job_filter {

    /// A builder for [`EventsDetectionJobFilter`](crate::model::EventsDetectionJobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filters on the name of the events detection job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>Filters on the name of the events detection job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`EventsDetectionJobFilter`](crate::model::EventsDetectionJobFilter).
        pub fn build(self) -> crate::model::EventsDetectionJobFilter {
            crate::model::EventsDetectionJobFilter {
                job_name: self.job_name,
                job_status: self.job_status,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl EventsDetectionJobFilter {
    /// Creates a new builder-style object to manufacture [`EventsDetectionJobFilter`](crate::model::EventsDetectionJobFilter).
    pub fn builder() -> crate::model::events_detection_job_filter::Builder {
        crate::model::events_detection_job_filter::Builder::default()
    }
}

/// <p> Describes the information about an entity recognizer and its versions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityRecognizerSummary {
    /// <p> The name that you assigned the entity recognizer.</p>
    #[doc(hidden)]
    pub recognizer_name: std::option::Option<std::string::String>,
    /// <p> The number of versions you created.</p>
    #[doc(hidden)]
    pub number_of_versions: std::option::Option<i32>,
    /// <p> The time that the latest entity recognizer version was submitted for processing.</p>
    #[doc(hidden)]
    pub latest_version_created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The version name you assigned to the latest entity recognizer version.</p>
    #[doc(hidden)]
    pub latest_version_name: std::option::Option<std::string::String>,
    /// <p> Provides the status of the latest entity recognizer version.</p>
    #[doc(hidden)]
    pub latest_version_status: std::option::Option<crate::model::ModelStatus>,
}
impl EntityRecognizerSummary {
    /// <p> The name that you assigned the entity recognizer.</p>
    pub fn recognizer_name(&self) -> std::option::Option<&str> {
        self.recognizer_name.as_deref()
    }
    /// <p> The number of versions you created.</p>
    pub fn number_of_versions(&self) -> std::option::Option<i32> {
        self.number_of_versions
    }
    /// <p> The time that the latest entity recognizer version was submitted for processing.</p>
    pub fn latest_version_created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.latest_version_created_at.as_ref()
    }
    /// <p> The version name you assigned to the latest entity recognizer version.</p>
    pub fn latest_version_name(&self) -> std::option::Option<&str> {
        self.latest_version_name.as_deref()
    }
    /// <p> Provides the status of the latest entity recognizer version.</p>
    pub fn latest_version_status(&self) -> std::option::Option<&crate::model::ModelStatus> {
        self.latest_version_status.as_ref()
    }
}
/// See [`EntityRecognizerSummary`](crate::model::EntityRecognizerSummary).
pub mod entity_recognizer_summary {

    /// A builder for [`EntityRecognizerSummary`](crate::model::EntityRecognizerSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recognizer_name: std::option::Option<std::string::String>,
        pub(crate) number_of_versions: std::option::Option<i32>,
        pub(crate) latest_version_created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) latest_version_name: std::option::Option<std::string::String>,
        pub(crate) latest_version_status: std::option::Option<crate::model::ModelStatus>,
    }
    impl Builder {
        /// <p> The name that you assigned the entity recognizer.</p>
        pub fn recognizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.recognizer_name = Some(input.into());
            self
        }
        /// <p> The name that you assigned the entity recognizer.</p>
        pub fn set_recognizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recognizer_name = input;
            self
        }
        /// <p> The number of versions you created.</p>
        pub fn number_of_versions(mut self, input: i32) -> Self {
            self.number_of_versions = Some(input);
            self
        }
        /// <p> The number of versions you created.</p>
        pub fn set_number_of_versions(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_versions = input;
            self
        }
        /// <p> The time that the latest entity recognizer version was submitted for processing.</p>
        pub fn latest_version_created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.latest_version_created_at = Some(input);
            self
        }
        /// <p> The time that the latest entity recognizer version was submitted for processing.</p>
        pub fn set_latest_version_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.latest_version_created_at = input;
            self
        }
        /// <p> The version name you assigned to the latest entity recognizer version.</p>
        pub fn latest_version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.latest_version_name = Some(input.into());
            self
        }
        /// <p> The version name you assigned to the latest entity recognizer version.</p>
        pub fn set_latest_version_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_version_name = input;
            self
        }
        /// <p> Provides the status of the latest entity recognizer version.</p>
        pub fn latest_version_status(mut self, input: crate::model::ModelStatus) -> Self {
            self.latest_version_status = Some(input);
            self
        }
        /// <p> Provides the status of the latest entity recognizer version.</p>
        pub fn set_latest_version_status(
            mut self,
            input: std::option::Option<crate::model::ModelStatus>,
        ) -> Self {
            self.latest_version_status = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerSummary`](crate::model::EntityRecognizerSummary).
        pub fn build(self) -> crate::model::EntityRecognizerSummary {
            crate::model::EntityRecognizerSummary {
                recognizer_name: self.recognizer_name,
                number_of_versions: self.number_of_versions,
                latest_version_created_at: self.latest_version_created_at,
                latest_version_name: self.latest_version_name,
                latest_version_status: self.latest_version_status,
            }
        }
    }
}
impl EntityRecognizerSummary {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerSummary`](crate::model::EntityRecognizerSummary).
    pub fn builder() -> crate::model::entity_recognizer_summary::Builder {
        crate::model::entity_recognizer_summary::Builder::default()
    }
}

/// When writing a match expression against `ModelStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modelstatus = unimplemented!();
/// match modelstatus {
///     ModelStatus::Deleting => { /* ... */ },
///     ModelStatus::InError => { /* ... */ },
///     ModelStatus::Stopped => { /* ... */ },
///     ModelStatus::StopRequested => { /* ... */ },
///     ModelStatus::Submitted => { /* ... */ },
///     ModelStatus::Trained => { /* ... */ },
///     ModelStatus::Training => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modelstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelStatus::NewFeature` is defined.
/// Specifically, when `modelstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelStatus {
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    InError,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    StopRequested,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    #[allow(missing_docs)] // documentation missing in model
    Trained,
    #[allow(missing_docs)] // documentation missing in model
    Training,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelStatus {
    fn from(s: &str) -> Self {
        match s {
            "DELETING" => ModelStatus::Deleting,
            "IN_ERROR" => ModelStatus::InError,
            "STOPPED" => ModelStatus::Stopped,
            "STOP_REQUESTED" => ModelStatus::StopRequested,
            "SUBMITTED" => ModelStatus::Submitted,
            "TRAINED" => ModelStatus::Trained,
            "TRAINING" => ModelStatus::Training,
            other => ModelStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ModelStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelStatus::from(s))
    }
}
impl ModelStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelStatus::Deleting => "DELETING",
            ModelStatus::InError => "IN_ERROR",
            ModelStatus::Stopped => "STOPPED",
            ModelStatus::StopRequested => "STOP_REQUESTED",
            ModelStatus::Submitted => "SUBMITTED",
            ModelStatus::Trained => "TRAINED",
            ModelStatus::Training => "TRAINING",
            ModelStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DELETING",
            "IN_ERROR",
            "STOPPED",
            "STOP_REQUESTED",
            "SUBMITTED",
            "TRAINED",
            "TRAINING",
        ]
    }
}
impl AsRef<str> for ModelStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes information about an entity recognizer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EntityRecognizerProperties {
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    #[doc(hidden)]
    pub entity_recognizer_arn: std::option::Option<std::string::String>,
    /// <p> The language of the input documents. All documents must be in the same language. Only English ("en") is currently supported.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>Provides the status of the entity recognizer.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ModelStatus>,
    /// <p> A description of the status of the recognizer.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the recognizer was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the recognizer creation completed.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that training of the entity recognizer started.</p>
    #[doc(hidden)]
    pub training_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that training of the entity recognizer was completed.</p>
    #[doc(hidden)]
    pub training_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The input data properties of an entity recognizer.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::EntityRecognizerInputDataConfig>,
    /// <p> Provides information about an entity recognizer.</p>
    #[doc(hidden)]
    pub recognizer_metadata: std::option::Option<crate::model::EntityRecognizerMetadata>,
    /// <p> The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your custom entity recognizer. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt trained custom models. The ModelKmsKeyId can be either of the following formats: </p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub model_kms_key_id: std::option::Option<std::string::String>,
    /// <p>The version name you assigned to the entity recognizer.</p>
    #[doc(hidden)]
    pub version_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the source model. This model was imported from a different AWS account to create the entity recognizer model in your AWS account.</p>
    #[doc(hidden)]
    pub source_model_arn: std::option::Option<std::string::String>,
}
impl EntityRecognizerProperties {
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    pub fn entity_recognizer_arn(&self) -> std::option::Option<&str> {
        self.entity_recognizer_arn.as_deref()
    }
    /// <p> The language of the input documents. All documents must be in the same language. Only English ("en") is currently supported.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>Provides the status of the entity recognizer.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ModelStatus> {
        self.status.as_ref()
    }
    /// <p> A description of the status of the recognizer.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the recognizer was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the recognizer creation completed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The time that training of the entity recognizer started.</p>
    pub fn training_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.training_start_time.as_ref()
    }
    /// <p>The time that training of the entity recognizer was completed.</p>
    pub fn training_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.training_end_time.as_ref()
    }
    /// <p>The input data properties of an entity recognizer.</p>
    pub fn input_data_config(
        &self,
    ) -> std::option::Option<&crate::model::EntityRecognizerInputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p> Provides information about an entity recognizer.</p>
    pub fn recognizer_metadata(
        &self,
    ) -> std::option::Option<&crate::model::EntityRecognizerMetadata> {
        self.recognizer_metadata.as_ref()
    }
    /// <p> The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your custom entity recognizer. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt trained custom models. The ModelKmsKeyId can be either of the following formats: </p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn model_kms_key_id(&self) -> std::option::Option<&str> {
        self.model_kms_key_id.as_deref()
    }
    /// <p>The version name you assigned to the entity recognizer.</p>
    pub fn version_name(&self) -> std::option::Option<&str> {
        self.version_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the source model. This model was imported from a different AWS account to create the entity recognizer model in your AWS account.</p>
    pub fn source_model_arn(&self) -> std::option::Option<&str> {
        self.source_model_arn.as_deref()
    }
}
impl std::fmt::Debug for EntityRecognizerProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EntityRecognizerProperties");
        formatter.field("entity_recognizer_arn", &self.entity_recognizer_arn);
        formatter.field("language_code", &self.language_code);
        formatter.field("status", &self.status);
        formatter.field("message", &self.message);
        formatter.field("submit_time", &self.submit_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("training_start_time", &self.training_start_time);
        formatter.field("training_end_time", &self.training_end_time);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("recognizer_metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("model_kms_key_id", &self.model_kms_key_id);
        formatter.field("version_name", &self.version_name);
        formatter.field("source_model_arn", &self.source_model_arn);
        formatter.finish()
    }
}
/// See [`EntityRecognizerProperties`](crate::model::EntityRecognizerProperties).
pub mod entity_recognizer_properties {

    /// A builder for [`EntityRecognizerProperties`](crate::model::EntityRecognizerProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) entity_recognizer_arn: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) status: std::option::Option<crate::model::ModelStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_data_config:
            std::option::Option<crate::model::EntityRecognizerInputDataConfig>,
        pub(crate) recognizer_metadata: std::option::Option<crate::model::EntityRecognizerMetadata>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
        pub(crate) model_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) version_name: std::option::Option<std::string::String>,
        pub(crate) source_model_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
        pub fn entity_recognizer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_recognizer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
        pub fn set_entity_recognizer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.entity_recognizer_arn = input;
            self
        }
        /// <p> The language of the input documents. All documents must be in the same language. Only English ("en") is currently supported.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p> The language of the input documents. All documents must be in the same language. Only English ("en") is currently supported.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>Provides the status of the entity recognizer.</p>
        pub fn status(mut self, input: crate::model::ModelStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Provides the status of the entity recognizer.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ModelStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p> A description of the status of the recognizer.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p> A description of the status of the recognizer.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the recognizer was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the recognizer was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the recognizer creation completed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the recognizer creation completed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The time that training of the entity recognizer started.</p>
        pub fn training_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.training_start_time = Some(input);
            self
        }
        /// <p>The time that training of the entity recognizer started.</p>
        pub fn set_training_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.training_start_time = input;
            self
        }
        /// <p>The time that training of the entity recognizer was completed.</p>
        pub fn training_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.training_end_time = Some(input);
            self
        }
        /// <p>The time that training of the entity recognizer was completed.</p>
        pub fn set_training_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.training_end_time = input;
            self
        }
        /// <p>The input data properties of an entity recognizer.</p>
        pub fn input_data_config(
            mut self,
            input: crate::model::EntityRecognizerInputDataConfig,
        ) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data properties of an entity recognizer.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::EntityRecognizerInputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p> Provides information about an entity recognizer.</p>
        pub fn recognizer_metadata(
            mut self,
            input: crate::model::EntityRecognizerMetadata,
        ) -> Self {
            self.recognizer_metadata = Some(input);
            self
        }
        /// <p> Provides information about an entity recognizer.</p>
        pub fn set_recognizer_metadata(
            mut self,
            input: std::option::Option<crate::model::EntityRecognizerMetadata>,
        ) -> Self {
            self.recognizer_metadata = input;
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your custom entity recognizer. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your custom entity recognizer. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt trained custom models. The ModelKmsKeyId can be either of the following formats: </p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn model_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt trained custom models. The ModelKmsKeyId can be either of the following formats: </p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_model_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_kms_key_id = input;
            self
        }
        /// <p>The version name you assigned to the entity recognizer.</p>
        pub fn version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_name = Some(input.into());
            self
        }
        /// <p>The version name you assigned to the entity recognizer.</p>
        pub fn set_version_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source model. This model was imported from a different AWS account to create the entity recognizer model in your AWS account.</p>
        pub fn source_model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_model_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source model. This model was imported from a different AWS account to create the entity recognizer model in your AWS account.</p>
        pub fn set_source_model_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_model_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerProperties`](crate::model::EntityRecognizerProperties).
        pub fn build(self) -> crate::model::EntityRecognizerProperties {
            crate::model::EntityRecognizerProperties {
                entity_recognizer_arn: self.entity_recognizer_arn,
                language_code: self.language_code,
                status: self.status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                training_start_time: self.training_start_time,
                training_end_time: self.training_end_time,
                input_data_config: self.input_data_config,
                recognizer_metadata: self.recognizer_metadata,
                data_access_role_arn: self.data_access_role_arn,
                volume_kms_key_id: self.volume_kms_key_id,
                vpc_config: self.vpc_config,
                model_kms_key_id: self.model_kms_key_id,
                version_name: self.version_name,
                source_model_arn: self.source_model_arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("entity_recognizer_arn", &self.entity_recognizer_arn);
            formatter.field("language_code", &self.language_code);
            formatter.field("status", &self.status);
            formatter.field("message", &self.message);
            formatter.field("submit_time", &self.submit_time);
            formatter.field("end_time", &self.end_time);
            formatter.field("training_start_time", &self.training_start_time);
            formatter.field("training_end_time", &self.training_end_time);
            formatter.field("input_data_config", &self.input_data_config);
            formatter.field("recognizer_metadata", &"*** Sensitive Data Redacted ***");
            formatter.field("data_access_role_arn", &self.data_access_role_arn);
            formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
            formatter.field("vpc_config", &self.vpc_config);
            formatter.field("model_kms_key_id", &self.model_kms_key_id);
            formatter.field("version_name", &self.version_name);
            formatter.field("source_model_arn", &self.source_model_arn);
            formatter.finish()
        }
    }
}
impl EntityRecognizerProperties {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerProperties`](crate::model::EntityRecognizerProperties).
    pub fn builder() -> crate::model::entity_recognizer_properties::Builder {
        crate::model::entity_recognizer_properties::Builder::default()
    }
}

/// <p>Detailed information about an entity recognizer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EntityRecognizerMetadata {
    /// <p> The number of documents in the input data that were used to train the entity recognizer. Typically this is 80 to 90 percent of the input documents.</p>
    #[doc(hidden)]
    pub number_of_trained_documents: std::option::Option<i32>,
    /// <p> The number of documents in the input data that were used to test the entity recognizer. Typically this is 10 to 20 percent of the input documents.</p>
    #[doc(hidden)]
    pub number_of_test_documents: std::option::Option<i32>,
    /// <p>Detailed information about the accuracy of an entity recognizer.</p>
    #[doc(hidden)]
    pub evaluation_metrics: std::option::Option<crate::model::EntityRecognizerEvaluationMetrics>,
    /// <p>Entity types from the metadata of an entity recognizer.</p>
    #[doc(hidden)]
    pub entity_types: std::option::Option<
        std::vec::Vec<crate::model::EntityRecognizerMetadataEntityTypesListItem>,
    >,
}
impl EntityRecognizerMetadata {
    /// <p> The number of documents in the input data that were used to train the entity recognizer. Typically this is 80 to 90 percent of the input documents.</p>
    pub fn number_of_trained_documents(&self) -> std::option::Option<i32> {
        self.number_of_trained_documents
    }
    /// <p> The number of documents in the input data that were used to test the entity recognizer. Typically this is 10 to 20 percent of the input documents.</p>
    pub fn number_of_test_documents(&self) -> std::option::Option<i32> {
        self.number_of_test_documents
    }
    /// <p>Detailed information about the accuracy of an entity recognizer.</p>
    pub fn evaluation_metrics(
        &self,
    ) -> std::option::Option<&crate::model::EntityRecognizerEvaluationMetrics> {
        self.evaluation_metrics.as_ref()
    }
    /// <p>Entity types from the metadata of an entity recognizer.</p>
    pub fn entity_types(
        &self,
    ) -> std::option::Option<&[crate::model::EntityRecognizerMetadataEntityTypesListItem]> {
        self.entity_types.as_deref()
    }
}
impl std::fmt::Debug for EntityRecognizerMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EntityRecognizerMetadata");
        formatter.field(
            "number_of_trained_documents",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field(
            "number_of_test_documents",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("evaluation_metrics", &"*** Sensitive Data Redacted ***");
        formatter.field("entity_types", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`EntityRecognizerMetadata`](crate::model::EntityRecognizerMetadata).
pub mod entity_recognizer_metadata {

    /// A builder for [`EntityRecognizerMetadata`](crate::model::EntityRecognizerMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) number_of_trained_documents: std::option::Option<i32>,
        pub(crate) number_of_test_documents: std::option::Option<i32>,
        pub(crate) evaluation_metrics:
            std::option::Option<crate::model::EntityRecognizerEvaluationMetrics>,
        pub(crate) entity_types: std::option::Option<
            std::vec::Vec<crate::model::EntityRecognizerMetadataEntityTypesListItem>,
        >,
    }
    impl Builder {
        /// <p> The number of documents in the input data that were used to train the entity recognizer. Typically this is 80 to 90 percent of the input documents.</p>
        pub fn number_of_trained_documents(mut self, input: i32) -> Self {
            self.number_of_trained_documents = Some(input);
            self
        }
        /// <p> The number of documents in the input data that were used to train the entity recognizer. Typically this is 80 to 90 percent of the input documents.</p>
        pub fn set_number_of_trained_documents(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_trained_documents = input;
            self
        }
        /// <p> The number of documents in the input data that were used to test the entity recognizer. Typically this is 10 to 20 percent of the input documents.</p>
        pub fn number_of_test_documents(mut self, input: i32) -> Self {
            self.number_of_test_documents = Some(input);
            self
        }
        /// <p> The number of documents in the input data that were used to test the entity recognizer. Typically this is 10 to 20 percent of the input documents.</p>
        pub fn set_number_of_test_documents(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_test_documents = input;
            self
        }
        /// <p>Detailed information about the accuracy of an entity recognizer.</p>
        pub fn evaluation_metrics(
            mut self,
            input: crate::model::EntityRecognizerEvaluationMetrics,
        ) -> Self {
            self.evaluation_metrics = Some(input);
            self
        }
        /// <p>Detailed information about the accuracy of an entity recognizer.</p>
        pub fn set_evaluation_metrics(
            mut self,
            input: std::option::Option<crate::model::EntityRecognizerEvaluationMetrics>,
        ) -> Self {
            self.evaluation_metrics = input;
            self
        }
        /// Appends an item to `entity_types`.
        ///
        /// To override the contents of this collection use [`set_entity_types`](Self::set_entity_types).
        ///
        /// <p>Entity types from the metadata of an entity recognizer.</p>
        pub fn entity_types(
            mut self,
            input: crate::model::EntityRecognizerMetadataEntityTypesListItem,
        ) -> Self {
            let mut v = self.entity_types.unwrap_or_default();
            v.push(input);
            self.entity_types = Some(v);
            self
        }
        /// <p>Entity types from the metadata of an entity recognizer.</p>
        pub fn set_entity_types(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::EntityRecognizerMetadataEntityTypesListItem>,
            >,
        ) -> Self {
            self.entity_types = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerMetadata`](crate::model::EntityRecognizerMetadata).
        pub fn build(self) -> crate::model::EntityRecognizerMetadata {
            crate::model::EntityRecognizerMetadata {
                number_of_trained_documents: self.number_of_trained_documents,
                number_of_test_documents: self.number_of_test_documents,
                evaluation_metrics: self.evaluation_metrics,
                entity_types: self.entity_types,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field(
                "number_of_trained_documents",
                &"*** Sensitive Data Redacted ***",
            );
            formatter.field(
                "number_of_test_documents",
                &"*** Sensitive Data Redacted ***",
            );
            formatter.field("evaluation_metrics", &"*** Sensitive Data Redacted ***");
            formatter.field("entity_types", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl EntityRecognizerMetadata {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerMetadata`](crate::model::EntityRecognizerMetadata).
    pub fn builder() -> crate::model::entity_recognizer_metadata::Builder {
        crate::model::entity_recognizer_metadata::Builder::default()
    }
}

/// <p>Individual item from the list of entity types in the metadata of an entity recognizer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityRecognizerMetadataEntityTypesListItem {
    /// <p>Type of entity from the list of entity types in the metadata of an entity recognizer. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Detailed information about the accuracy of the entity recognizer for a specific item on the list of entity types. </p>
    #[doc(hidden)]
    pub evaluation_metrics: std::option::Option<crate::model::EntityTypesEvaluationMetrics>,
    /// <p>Indicates the number of times the given entity type was seen in the training data. </p>
    #[doc(hidden)]
    pub number_of_train_mentions: std::option::Option<i32>,
}
impl EntityRecognizerMetadataEntityTypesListItem {
    /// <p>Type of entity from the list of entity types in the metadata of an entity recognizer. </p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Detailed information about the accuracy of the entity recognizer for a specific item on the list of entity types. </p>
    pub fn evaluation_metrics(
        &self,
    ) -> std::option::Option<&crate::model::EntityTypesEvaluationMetrics> {
        self.evaluation_metrics.as_ref()
    }
    /// <p>Indicates the number of times the given entity type was seen in the training data. </p>
    pub fn number_of_train_mentions(&self) -> std::option::Option<i32> {
        self.number_of_train_mentions
    }
}
/// See [`EntityRecognizerMetadataEntityTypesListItem`](crate::model::EntityRecognizerMetadataEntityTypesListItem).
pub mod entity_recognizer_metadata_entity_types_list_item {

    /// A builder for [`EntityRecognizerMetadataEntityTypesListItem`](crate::model::EntityRecognizerMetadataEntityTypesListItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) evaluation_metrics:
            std::option::Option<crate::model::EntityTypesEvaluationMetrics>,
        pub(crate) number_of_train_mentions: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Type of entity from the list of entity types in the metadata of an entity recognizer. </p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>Type of entity from the list of entity types in the metadata of an entity recognizer. </p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Detailed information about the accuracy of the entity recognizer for a specific item on the list of entity types. </p>
        pub fn evaluation_metrics(
            mut self,
            input: crate::model::EntityTypesEvaluationMetrics,
        ) -> Self {
            self.evaluation_metrics = Some(input);
            self
        }
        /// <p>Detailed information about the accuracy of the entity recognizer for a specific item on the list of entity types. </p>
        pub fn set_evaluation_metrics(
            mut self,
            input: std::option::Option<crate::model::EntityTypesEvaluationMetrics>,
        ) -> Self {
            self.evaluation_metrics = input;
            self
        }
        /// <p>Indicates the number of times the given entity type was seen in the training data. </p>
        pub fn number_of_train_mentions(mut self, input: i32) -> Self {
            self.number_of_train_mentions = Some(input);
            self
        }
        /// <p>Indicates the number of times the given entity type was seen in the training data. </p>
        pub fn set_number_of_train_mentions(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_train_mentions = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerMetadataEntityTypesListItem`](crate::model::EntityRecognizerMetadataEntityTypesListItem).
        pub fn build(self) -> crate::model::EntityRecognizerMetadataEntityTypesListItem {
            crate::model::EntityRecognizerMetadataEntityTypesListItem {
                r#type: self.r#type,
                evaluation_metrics: self.evaluation_metrics,
                number_of_train_mentions: self.number_of_train_mentions,
            }
        }
    }
}
impl EntityRecognizerMetadataEntityTypesListItem {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerMetadataEntityTypesListItem`](crate::model::EntityRecognizerMetadataEntityTypesListItem).
    pub fn builder() -> crate::model::entity_recognizer_metadata_entity_types_list_item::Builder {
        crate::model::entity_recognizer_metadata_entity_types_list_item::Builder::default()
    }
}

/// <p>Detailed information about the accuracy of an entity recognizer for a specific entity type. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityTypesEvaluationMetrics {
    /// <p>A measure of the usefulness of the recognizer results for a specific entity type in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. </p>
    #[doc(hidden)]
    pub precision: std::option::Option<f64>,
    /// <p>A measure of how complete the recognizer results are for a specific entity type in the test data. High recall means that the recognizer returned most of the relevant results.</p>
    #[doc(hidden)]
    pub recall: std::option::Option<f64>,
    /// <p>A measure of how accurate the recognizer results are for a specific entity type in the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
    #[doc(hidden)]
    pub f1_score: std::option::Option<f64>,
}
impl EntityTypesEvaluationMetrics {
    /// <p>A measure of the usefulness of the recognizer results for a specific entity type in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. </p>
    pub fn precision(&self) -> std::option::Option<f64> {
        self.precision
    }
    /// <p>A measure of how complete the recognizer results are for a specific entity type in the test data. High recall means that the recognizer returned most of the relevant results.</p>
    pub fn recall(&self) -> std::option::Option<f64> {
        self.recall
    }
    /// <p>A measure of how accurate the recognizer results are for a specific entity type in the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
    pub fn f1_score(&self) -> std::option::Option<f64> {
        self.f1_score
    }
}
/// See [`EntityTypesEvaluationMetrics`](crate::model::EntityTypesEvaluationMetrics).
pub mod entity_types_evaluation_metrics {

    /// A builder for [`EntityTypesEvaluationMetrics`](crate::model::EntityTypesEvaluationMetrics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) precision: std::option::Option<f64>,
        pub(crate) recall: std::option::Option<f64>,
        pub(crate) f1_score: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>A measure of the usefulness of the recognizer results for a specific entity type in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. </p>
        pub fn precision(mut self, input: f64) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p>A measure of the usefulness of the recognizer results for a specific entity type in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. </p>
        pub fn set_precision(mut self, input: std::option::Option<f64>) -> Self {
            self.precision = input;
            self
        }
        /// <p>A measure of how complete the recognizer results are for a specific entity type in the test data. High recall means that the recognizer returned most of the relevant results.</p>
        pub fn recall(mut self, input: f64) -> Self {
            self.recall = Some(input);
            self
        }
        /// <p>A measure of how complete the recognizer results are for a specific entity type in the test data. High recall means that the recognizer returned most of the relevant results.</p>
        pub fn set_recall(mut self, input: std::option::Option<f64>) -> Self {
            self.recall = input;
            self
        }
        /// <p>A measure of how accurate the recognizer results are for a specific entity type in the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
        pub fn f1_score(mut self, input: f64) -> Self {
            self.f1_score = Some(input);
            self
        }
        /// <p>A measure of how accurate the recognizer results are for a specific entity type in the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
        pub fn set_f1_score(mut self, input: std::option::Option<f64>) -> Self {
            self.f1_score = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityTypesEvaluationMetrics`](crate::model::EntityTypesEvaluationMetrics).
        pub fn build(self) -> crate::model::EntityTypesEvaluationMetrics {
            crate::model::EntityTypesEvaluationMetrics {
                precision: self.precision,
                recall: self.recall,
                f1_score: self.f1_score,
            }
        }
    }
}
impl EntityTypesEvaluationMetrics {
    /// Creates a new builder-style object to manufacture [`EntityTypesEvaluationMetrics`](crate::model::EntityTypesEvaluationMetrics).
    pub fn builder() -> crate::model::entity_types_evaluation_metrics::Builder {
        crate::model::entity_types_evaluation_metrics::Builder::default()
    }
}

/// <p>Detailed information about the accuracy of an entity recognizer. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityRecognizerEvaluationMetrics {
    /// <p>A measure of the usefulness of the recognizer results in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. </p>
    #[doc(hidden)]
    pub precision: std::option::Option<f64>,
    /// <p>A measure of how complete the recognizer results are for the test data. High recall means that the recognizer returned most of the relevant results.</p>
    #[doc(hidden)]
    pub recall: std::option::Option<f64>,
    /// <p>A measure of how accurate the recognizer results are for the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. For plain text entity recognizer models, the range is 0 to 100, where 100 is the best score. For PDF/Word entity recognizer models, the range is 0 to 1, where 1 is the best score. </p>
    #[doc(hidden)]
    pub f1_score: std::option::Option<f64>,
}
impl EntityRecognizerEvaluationMetrics {
    /// <p>A measure of the usefulness of the recognizer results in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. </p>
    pub fn precision(&self) -> std::option::Option<f64> {
        self.precision
    }
    /// <p>A measure of how complete the recognizer results are for the test data. High recall means that the recognizer returned most of the relevant results.</p>
    pub fn recall(&self) -> std::option::Option<f64> {
        self.recall
    }
    /// <p>A measure of how accurate the recognizer results are for the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. For plain text entity recognizer models, the range is 0 to 100, where 100 is the best score. For PDF/Word entity recognizer models, the range is 0 to 1, where 1 is the best score. </p>
    pub fn f1_score(&self) -> std::option::Option<f64> {
        self.f1_score
    }
}
/// See [`EntityRecognizerEvaluationMetrics`](crate::model::EntityRecognizerEvaluationMetrics).
pub mod entity_recognizer_evaluation_metrics {

    /// A builder for [`EntityRecognizerEvaluationMetrics`](crate::model::EntityRecognizerEvaluationMetrics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) precision: std::option::Option<f64>,
        pub(crate) recall: std::option::Option<f64>,
        pub(crate) f1_score: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>A measure of the usefulness of the recognizer results in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. </p>
        pub fn precision(mut self, input: f64) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p>A measure of the usefulness of the recognizer results in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. </p>
        pub fn set_precision(mut self, input: std::option::Option<f64>) -> Self {
            self.precision = input;
            self
        }
        /// <p>A measure of how complete the recognizer results are for the test data. High recall means that the recognizer returned most of the relevant results.</p>
        pub fn recall(mut self, input: f64) -> Self {
            self.recall = Some(input);
            self
        }
        /// <p>A measure of how complete the recognizer results are for the test data. High recall means that the recognizer returned most of the relevant results.</p>
        pub fn set_recall(mut self, input: std::option::Option<f64>) -> Self {
            self.recall = input;
            self
        }
        /// <p>A measure of how accurate the recognizer results are for the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. For plain text entity recognizer models, the range is 0 to 100, where 100 is the best score. For PDF/Word entity recognizer models, the range is 0 to 1, where 1 is the best score. </p>
        pub fn f1_score(mut self, input: f64) -> Self {
            self.f1_score = Some(input);
            self
        }
        /// <p>A measure of how accurate the recognizer results are for the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. For plain text entity recognizer models, the range is 0 to 100, where 100 is the best score. For PDF/Word entity recognizer models, the range is 0 to 1, where 1 is the best score. </p>
        pub fn set_f1_score(mut self, input: std::option::Option<f64>) -> Self {
            self.f1_score = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerEvaluationMetrics`](crate::model::EntityRecognizerEvaluationMetrics).
        pub fn build(self) -> crate::model::EntityRecognizerEvaluationMetrics {
            crate::model::EntityRecognizerEvaluationMetrics {
                precision: self.precision,
                recall: self.recall,
                f1_score: self.f1_score,
            }
        }
    }
}
impl EntityRecognizerEvaluationMetrics {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerEvaluationMetrics`](crate::model::EntityRecognizerEvaluationMetrics).
    pub fn builder() -> crate::model::entity_recognizer_evaluation_metrics::Builder {
        crate::model::entity_recognizer_evaluation_metrics::Builder::default()
    }
}

/// <p>Specifies the format and location of the input data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityRecognizerInputDataConfig {
    /// <p>The format of your training data:</p>
    /// <ul>
    /// <li> <p> <code>COMPREHEND_CSV</code>: A CSV file that supplements your training documents. The CSV file contains information about the custom entities that your trained model will detect. The required format of the file depends on whether you are providing annotations or an entity list.</p> <p>If you use this value, you must provide your CSV file by using either the <code>Annotations</code> or <code>EntityList</code> parameters. You must provide your training documents by using the <code>Documents</code> parameter.</p> </li>
    /// <li> <p> <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON object that contains a training document and its labels. Each label annotates a named entity in the training document. </p> <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter in your request.</p> </li>
    /// </ul>
    /// <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the default.</p>
    #[doc(hidden)]
    pub data_format: std::option::Option<crate::model::EntityRecognizerDataFormat>,
    /// <p>The entity types in the labeled training data that Amazon Comprehend uses to train the custom entity recognizer. Any entity types that you don't specify are ignored.</p>
    /// <p>A maximum of 25 entity types can be used at one time to train an entity recognizer. Entity types must not contain the following invalid characters: \n (line break), \\n (escaped line break), \r (carriage return), \\r (escaped carriage return), \t (tab), \\t (escaped tab), space, and , (comma). </p>
    #[doc(hidden)]
    pub entity_types: std::option::Option<std::vec::Vec<crate::model::EntityTypesListItem>>,
    /// <p>The S3 location of the folder that contains the training documents for your custom entity recognizer.</p>
    /// <p>This parameter is required if you set <code>DataFormat</code> to <code>COMPREHEND_CSV</code>.</p>
    #[doc(hidden)]
    pub documents: std::option::Option<crate::model::EntityRecognizerDocuments>,
    /// <p>The S3 location of the CSV file that annotates your training documents.</p>
    #[doc(hidden)]
    pub annotations: std::option::Option<crate::model::EntityRecognizerAnnotations>,
    /// <p>The S3 location of the CSV file that has the entity list for your custom entity recognizer.</p>
    #[doc(hidden)]
    pub entity_list: std::option::Option<crate::model::EntityRecognizerEntityList>,
    /// <p>A list of augmented manifest files that provide training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
    /// <p>This parameter is required if you set <code>DataFormat</code> to <code>AUGMENTED_MANIFEST</code>.</p>
    #[doc(hidden)]
    pub augmented_manifests:
        std::option::Option<std::vec::Vec<crate::model::AugmentedManifestsListItem>>,
}
impl EntityRecognizerInputDataConfig {
    /// <p>The format of your training data:</p>
    /// <ul>
    /// <li> <p> <code>COMPREHEND_CSV</code>: A CSV file that supplements your training documents. The CSV file contains information about the custom entities that your trained model will detect. The required format of the file depends on whether you are providing annotations or an entity list.</p> <p>If you use this value, you must provide your CSV file by using either the <code>Annotations</code> or <code>EntityList</code> parameters. You must provide your training documents by using the <code>Documents</code> parameter.</p> </li>
    /// <li> <p> <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON object that contains a training document and its labels. Each label annotates a named entity in the training document. </p> <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter in your request.</p> </li>
    /// </ul>
    /// <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the default.</p>
    pub fn data_format(&self) -> std::option::Option<&crate::model::EntityRecognizerDataFormat> {
        self.data_format.as_ref()
    }
    /// <p>The entity types in the labeled training data that Amazon Comprehend uses to train the custom entity recognizer. Any entity types that you don't specify are ignored.</p>
    /// <p>A maximum of 25 entity types can be used at one time to train an entity recognizer. Entity types must not contain the following invalid characters: \n (line break), \\n (escaped line break), \r (carriage return), \\r (escaped carriage return), \t (tab), \\t (escaped tab), space, and , (comma). </p>
    pub fn entity_types(&self) -> std::option::Option<&[crate::model::EntityTypesListItem]> {
        self.entity_types.as_deref()
    }
    /// <p>The S3 location of the folder that contains the training documents for your custom entity recognizer.</p>
    /// <p>This parameter is required if you set <code>DataFormat</code> to <code>COMPREHEND_CSV</code>.</p>
    pub fn documents(&self) -> std::option::Option<&crate::model::EntityRecognizerDocuments> {
        self.documents.as_ref()
    }
    /// <p>The S3 location of the CSV file that annotates your training documents.</p>
    pub fn annotations(&self) -> std::option::Option<&crate::model::EntityRecognizerAnnotations> {
        self.annotations.as_ref()
    }
    /// <p>The S3 location of the CSV file that has the entity list for your custom entity recognizer.</p>
    pub fn entity_list(&self) -> std::option::Option<&crate::model::EntityRecognizerEntityList> {
        self.entity_list.as_ref()
    }
    /// <p>A list of augmented manifest files that provide training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
    /// <p>This parameter is required if you set <code>DataFormat</code> to <code>AUGMENTED_MANIFEST</code>.</p>
    pub fn augmented_manifests(
        &self,
    ) -> std::option::Option<&[crate::model::AugmentedManifestsListItem]> {
        self.augmented_manifests.as_deref()
    }
}
/// See [`EntityRecognizerInputDataConfig`](crate::model::EntityRecognizerInputDataConfig).
pub mod entity_recognizer_input_data_config {

    /// A builder for [`EntityRecognizerInputDataConfig`](crate::model::EntityRecognizerInputDataConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_format: std::option::Option<crate::model::EntityRecognizerDataFormat>,
        pub(crate) entity_types:
            std::option::Option<std::vec::Vec<crate::model::EntityTypesListItem>>,
        pub(crate) documents: std::option::Option<crate::model::EntityRecognizerDocuments>,
        pub(crate) annotations: std::option::Option<crate::model::EntityRecognizerAnnotations>,
        pub(crate) entity_list: std::option::Option<crate::model::EntityRecognizerEntityList>,
        pub(crate) augmented_manifests:
            std::option::Option<std::vec::Vec<crate::model::AugmentedManifestsListItem>>,
    }
    impl Builder {
        /// <p>The format of your training data:</p>
        /// <ul>
        /// <li> <p> <code>COMPREHEND_CSV</code>: A CSV file that supplements your training documents. The CSV file contains information about the custom entities that your trained model will detect. The required format of the file depends on whether you are providing annotations or an entity list.</p> <p>If you use this value, you must provide your CSV file by using either the <code>Annotations</code> or <code>EntityList</code> parameters. You must provide your training documents by using the <code>Documents</code> parameter.</p> </li>
        /// <li> <p> <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON object that contains a training document and its labels. Each label annotates a named entity in the training document. </p> <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter in your request.</p> </li>
        /// </ul>
        /// <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the default.</p>
        pub fn data_format(mut self, input: crate::model::EntityRecognizerDataFormat) -> Self {
            self.data_format = Some(input);
            self
        }
        /// <p>The format of your training data:</p>
        /// <ul>
        /// <li> <p> <code>COMPREHEND_CSV</code>: A CSV file that supplements your training documents. The CSV file contains information about the custom entities that your trained model will detect. The required format of the file depends on whether you are providing annotations or an entity list.</p> <p>If you use this value, you must provide your CSV file by using either the <code>Annotations</code> or <code>EntityList</code> parameters. You must provide your training documents by using the <code>Documents</code> parameter.</p> </li>
        /// <li> <p> <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON object that contains a training document and its labels. Each label annotates a named entity in the training document. </p> <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter in your request.</p> </li>
        /// </ul>
        /// <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the default.</p>
        pub fn set_data_format(
            mut self,
            input: std::option::Option<crate::model::EntityRecognizerDataFormat>,
        ) -> Self {
            self.data_format = input;
            self
        }
        /// Appends an item to `entity_types`.
        ///
        /// To override the contents of this collection use [`set_entity_types`](Self::set_entity_types).
        ///
        /// <p>The entity types in the labeled training data that Amazon Comprehend uses to train the custom entity recognizer. Any entity types that you don't specify are ignored.</p>
        /// <p>A maximum of 25 entity types can be used at one time to train an entity recognizer. Entity types must not contain the following invalid characters: \n (line break), \\n (escaped line break), \r (carriage return), \\r (escaped carriage return), \t (tab), \\t (escaped tab), space, and , (comma). </p>
        pub fn entity_types(mut self, input: crate::model::EntityTypesListItem) -> Self {
            let mut v = self.entity_types.unwrap_or_default();
            v.push(input);
            self.entity_types = Some(v);
            self
        }
        /// <p>The entity types in the labeled training data that Amazon Comprehend uses to train the custom entity recognizer. Any entity types that you don't specify are ignored.</p>
        /// <p>A maximum of 25 entity types can be used at one time to train an entity recognizer. Entity types must not contain the following invalid characters: \n (line break), \\n (escaped line break), \r (carriage return), \\r (escaped carriage return), \t (tab), \\t (escaped tab), space, and , (comma). </p>
        pub fn set_entity_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntityTypesListItem>>,
        ) -> Self {
            self.entity_types = input;
            self
        }
        /// <p>The S3 location of the folder that contains the training documents for your custom entity recognizer.</p>
        /// <p>This parameter is required if you set <code>DataFormat</code> to <code>COMPREHEND_CSV</code>.</p>
        pub fn documents(mut self, input: crate::model::EntityRecognizerDocuments) -> Self {
            self.documents = Some(input);
            self
        }
        /// <p>The S3 location of the folder that contains the training documents for your custom entity recognizer.</p>
        /// <p>This parameter is required if you set <code>DataFormat</code> to <code>COMPREHEND_CSV</code>.</p>
        pub fn set_documents(
            mut self,
            input: std::option::Option<crate::model::EntityRecognizerDocuments>,
        ) -> Self {
            self.documents = input;
            self
        }
        /// <p>The S3 location of the CSV file that annotates your training documents.</p>
        pub fn annotations(mut self, input: crate::model::EntityRecognizerAnnotations) -> Self {
            self.annotations = Some(input);
            self
        }
        /// <p>The S3 location of the CSV file that annotates your training documents.</p>
        pub fn set_annotations(
            mut self,
            input: std::option::Option<crate::model::EntityRecognizerAnnotations>,
        ) -> Self {
            self.annotations = input;
            self
        }
        /// <p>The S3 location of the CSV file that has the entity list for your custom entity recognizer.</p>
        pub fn entity_list(mut self, input: crate::model::EntityRecognizerEntityList) -> Self {
            self.entity_list = Some(input);
            self
        }
        /// <p>The S3 location of the CSV file that has the entity list for your custom entity recognizer.</p>
        pub fn set_entity_list(
            mut self,
            input: std::option::Option<crate::model::EntityRecognizerEntityList>,
        ) -> Self {
            self.entity_list = input;
            self
        }
        /// Appends an item to `augmented_manifests`.
        ///
        /// To override the contents of this collection use [`set_augmented_manifests`](Self::set_augmented_manifests).
        ///
        /// <p>A list of augmented manifest files that provide training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
        /// <p>This parameter is required if you set <code>DataFormat</code> to <code>AUGMENTED_MANIFEST</code>.</p>
        pub fn augmented_manifests(
            mut self,
            input: crate::model::AugmentedManifestsListItem,
        ) -> Self {
            let mut v = self.augmented_manifests.unwrap_or_default();
            v.push(input);
            self.augmented_manifests = Some(v);
            self
        }
        /// <p>A list of augmented manifest files that provide training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
        /// <p>This parameter is required if you set <code>DataFormat</code> to <code>AUGMENTED_MANIFEST</code>.</p>
        pub fn set_augmented_manifests(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AugmentedManifestsListItem>>,
        ) -> Self {
            self.augmented_manifests = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerInputDataConfig`](crate::model::EntityRecognizerInputDataConfig).
        pub fn build(self) -> crate::model::EntityRecognizerInputDataConfig {
            crate::model::EntityRecognizerInputDataConfig {
                data_format: self.data_format,
                entity_types: self.entity_types,
                documents: self.documents,
                annotations: self.annotations,
                entity_list: self.entity_list,
                augmented_manifests: self.augmented_manifests,
            }
        }
    }
}
impl EntityRecognizerInputDataConfig {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerInputDataConfig`](crate::model::EntityRecognizerInputDataConfig).
    pub fn builder() -> crate::model::entity_recognizer_input_data_config::Builder {
        crate::model::entity_recognizer_input_data_config::Builder::default()
    }
}

/// <p>An augmented manifest file that provides training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AugmentedManifestsListItem {
    /// <p>The Amazon S3 location of the augmented manifest file.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The purpose of the data you've provided in the augmented manifest. You can either train or test this data. If you don't specify, the default is train.</p>
    /// <p>TRAIN - all of the documents in the manifest will be used for training. If no test documents are provided, Amazon Comprehend will automatically reserve a portion of the training documents for testing.</p>
    /// <p> TEST - all of the documents in the manifest will be used for testing.</p>
    #[doc(hidden)]
    pub split: std::option::Option<crate::model::Split>,
    /// <p>The JSON attribute that contains the annotations for your training documents. The number of attribute names that you specify depends on whether your augmented manifest file is the output of a single labeling job or a chained labeling job.</p>
    /// <p>If your file is the output of a single labeling job, specify the LabelAttributeName key that was used when the job was created in Ground Truth.</p>
    /// <p>If your file is the output of a chained labeling job, specify the LabelAttributeName key for one or more jobs in the chain. Each LabelAttributeName key provides the annotations from an individual job.</p>
    #[doc(hidden)]
    pub attribute_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The S3 prefix to the annotation files that are referred in the augmented manifest file.</p>
    #[doc(hidden)]
    pub annotation_data_s3_uri: std::option::Option<std::string::String>,
    /// <p>The S3 prefix to the source files (PDFs) that are referred to in the augmented manifest file.</p>
    #[doc(hidden)]
    pub source_documents_s3_uri: std::option::Option<std::string::String>,
    /// <p>The type of augmented manifest. PlainTextDocument or SemiStructuredDocument. If you don't specify, the default is PlainTextDocument. </p>
    /// <ul>
    /// <li> <p> <code>PLAIN_TEXT_DOCUMENT</code> A document type that represents any unicode text that is encoded in UTF-8.</p> </li>
    /// <li> <p> <code>SEMI_STRUCTURED_DOCUMENT</code> A document type with positional and structural context, like a PDF. For training with Amazon Comprehend, only PDFs are supported. For inference, Amazon Comprehend support PDFs, DOCX and TXT.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub document_type: std::option::Option<crate::model::AugmentedManifestsDocumentTypeFormat>,
}
impl AugmentedManifestsListItem {
    /// <p>The Amazon S3 location of the augmented manifest file.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>The purpose of the data you've provided in the augmented manifest. You can either train or test this data. If you don't specify, the default is train.</p>
    /// <p>TRAIN - all of the documents in the manifest will be used for training. If no test documents are provided, Amazon Comprehend will automatically reserve a portion of the training documents for testing.</p>
    /// <p> TEST - all of the documents in the manifest will be used for testing.</p>
    pub fn split(&self) -> std::option::Option<&crate::model::Split> {
        self.split.as_ref()
    }
    /// <p>The JSON attribute that contains the annotations for your training documents. The number of attribute names that you specify depends on whether your augmented manifest file is the output of a single labeling job or a chained labeling job.</p>
    /// <p>If your file is the output of a single labeling job, specify the LabelAttributeName key that was used when the job was created in Ground Truth.</p>
    /// <p>If your file is the output of a chained labeling job, specify the LabelAttributeName key for one or more jobs in the chain. Each LabelAttributeName key provides the annotations from an individual job.</p>
    pub fn attribute_names(&self) -> std::option::Option<&[std::string::String]> {
        self.attribute_names.as_deref()
    }
    /// <p>The S3 prefix to the annotation files that are referred in the augmented manifest file.</p>
    pub fn annotation_data_s3_uri(&self) -> std::option::Option<&str> {
        self.annotation_data_s3_uri.as_deref()
    }
    /// <p>The S3 prefix to the source files (PDFs) that are referred to in the augmented manifest file.</p>
    pub fn source_documents_s3_uri(&self) -> std::option::Option<&str> {
        self.source_documents_s3_uri.as_deref()
    }
    /// <p>The type of augmented manifest. PlainTextDocument or SemiStructuredDocument. If you don't specify, the default is PlainTextDocument. </p>
    /// <ul>
    /// <li> <p> <code>PLAIN_TEXT_DOCUMENT</code> A document type that represents any unicode text that is encoded in UTF-8.</p> </li>
    /// <li> <p> <code>SEMI_STRUCTURED_DOCUMENT</code> A document type with positional and structural context, like a PDF. For training with Amazon Comprehend, only PDFs are supported. For inference, Amazon Comprehend support PDFs, DOCX and TXT.</p> </li>
    /// </ul>
    pub fn document_type(
        &self,
    ) -> std::option::Option<&crate::model::AugmentedManifestsDocumentTypeFormat> {
        self.document_type.as_ref()
    }
}
/// See [`AugmentedManifestsListItem`](crate::model::AugmentedManifestsListItem).
pub mod augmented_manifests_list_item {

    /// A builder for [`AugmentedManifestsListItem`](crate::model::AugmentedManifestsListItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) split: std::option::Option<crate::model::Split>,
        pub(crate) attribute_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) annotation_data_s3_uri: std::option::Option<std::string::String>,
        pub(crate) source_documents_s3_uri: std::option::Option<std::string::String>,
        pub(crate) document_type:
            std::option::Option<crate::model::AugmentedManifestsDocumentTypeFormat>,
    }
    impl Builder {
        /// <p>The Amazon S3 location of the augmented manifest file.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of the augmented manifest file.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The purpose of the data you've provided in the augmented manifest. You can either train or test this data. If you don't specify, the default is train.</p>
        /// <p>TRAIN - all of the documents in the manifest will be used for training. If no test documents are provided, Amazon Comprehend will automatically reserve a portion of the training documents for testing.</p>
        /// <p> TEST - all of the documents in the manifest will be used for testing.</p>
        pub fn split(mut self, input: crate::model::Split) -> Self {
            self.split = Some(input);
            self
        }
        /// <p>The purpose of the data you've provided in the augmented manifest. You can either train or test this data. If you don't specify, the default is train.</p>
        /// <p>TRAIN - all of the documents in the manifest will be used for training. If no test documents are provided, Amazon Comprehend will automatically reserve a portion of the training documents for testing.</p>
        /// <p> TEST - all of the documents in the manifest will be used for testing.</p>
        pub fn set_split(mut self, input: std::option::Option<crate::model::Split>) -> Self {
            self.split = input;
            self
        }
        /// Appends an item to `attribute_names`.
        ///
        /// To override the contents of this collection use [`set_attribute_names`](Self::set_attribute_names).
        ///
        /// <p>The JSON attribute that contains the annotations for your training documents. The number of attribute names that you specify depends on whether your augmented manifest file is the output of a single labeling job or a chained labeling job.</p>
        /// <p>If your file is the output of a single labeling job, specify the LabelAttributeName key that was used when the job was created in Ground Truth.</p>
        /// <p>If your file is the output of a chained labeling job, specify the LabelAttributeName key for one or more jobs in the chain. Each LabelAttributeName key provides the annotations from an individual job.</p>
        pub fn attribute_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.attribute_names.unwrap_or_default();
            v.push(input.into());
            self.attribute_names = Some(v);
            self
        }
        /// <p>The JSON attribute that contains the annotations for your training documents. The number of attribute names that you specify depends on whether your augmented manifest file is the output of a single labeling job or a chained labeling job.</p>
        /// <p>If your file is the output of a single labeling job, specify the LabelAttributeName key that was used when the job was created in Ground Truth.</p>
        /// <p>If your file is the output of a chained labeling job, specify the LabelAttributeName key for one or more jobs in the chain. Each LabelAttributeName key provides the annotations from an individual job.</p>
        pub fn set_attribute_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.attribute_names = input;
            self
        }
        /// <p>The S3 prefix to the annotation files that are referred in the augmented manifest file.</p>
        pub fn annotation_data_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.annotation_data_s3_uri = Some(input.into());
            self
        }
        /// <p>The S3 prefix to the annotation files that are referred in the augmented manifest file.</p>
        pub fn set_annotation_data_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.annotation_data_s3_uri = input;
            self
        }
        /// <p>The S3 prefix to the source files (PDFs) that are referred to in the augmented manifest file.</p>
        pub fn source_documents_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_documents_s3_uri = Some(input.into());
            self
        }
        /// <p>The S3 prefix to the source files (PDFs) that are referred to in the augmented manifest file.</p>
        pub fn set_source_documents_s3_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_documents_s3_uri = input;
            self
        }
        /// <p>The type of augmented manifest. PlainTextDocument or SemiStructuredDocument. If you don't specify, the default is PlainTextDocument. </p>
        /// <ul>
        /// <li> <p> <code>PLAIN_TEXT_DOCUMENT</code> A document type that represents any unicode text that is encoded in UTF-8.</p> </li>
        /// <li> <p> <code>SEMI_STRUCTURED_DOCUMENT</code> A document type with positional and structural context, like a PDF. For training with Amazon Comprehend, only PDFs are supported. For inference, Amazon Comprehend support PDFs, DOCX and TXT.</p> </li>
        /// </ul>
        pub fn document_type(
            mut self,
            input: crate::model::AugmentedManifestsDocumentTypeFormat,
        ) -> Self {
            self.document_type = Some(input);
            self
        }
        /// <p>The type of augmented manifest. PlainTextDocument or SemiStructuredDocument. If you don't specify, the default is PlainTextDocument. </p>
        /// <ul>
        /// <li> <p> <code>PLAIN_TEXT_DOCUMENT</code> A document type that represents any unicode text that is encoded in UTF-8.</p> </li>
        /// <li> <p> <code>SEMI_STRUCTURED_DOCUMENT</code> A document type with positional and structural context, like a PDF. For training with Amazon Comprehend, only PDFs are supported. For inference, Amazon Comprehend support PDFs, DOCX and TXT.</p> </li>
        /// </ul>
        pub fn set_document_type(
            mut self,
            input: std::option::Option<crate::model::AugmentedManifestsDocumentTypeFormat>,
        ) -> Self {
            self.document_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AugmentedManifestsListItem`](crate::model::AugmentedManifestsListItem).
        pub fn build(self) -> crate::model::AugmentedManifestsListItem {
            crate::model::AugmentedManifestsListItem {
                s3_uri: self.s3_uri,
                split: self.split,
                attribute_names: self.attribute_names,
                annotation_data_s3_uri: self.annotation_data_s3_uri,
                source_documents_s3_uri: self.source_documents_s3_uri,
                document_type: self.document_type,
            }
        }
    }
}
impl AugmentedManifestsListItem {
    /// Creates a new builder-style object to manufacture [`AugmentedManifestsListItem`](crate::model::AugmentedManifestsListItem).
    pub fn builder() -> crate::model::augmented_manifests_list_item::Builder {
        crate::model::augmented_manifests_list_item::Builder::default()
    }
}

/// When writing a match expression against `AugmentedManifestsDocumentTypeFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let augmentedmanifestsdocumenttypeformat = unimplemented!();
/// match augmentedmanifestsdocumenttypeformat {
///     AugmentedManifestsDocumentTypeFormat::PlainTextDocument => { /* ... */ },
///     AugmentedManifestsDocumentTypeFormat::SemiStructuredDocument => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `augmentedmanifestsdocumenttypeformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AugmentedManifestsDocumentTypeFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AugmentedManifestsDocumentTypeFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AugmentedManifestsDocumentTypeFormat::NewFeature` is defined.
/// Specifically, when `augmentedmanifestsdocumenttypeformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AugmentedManifestsDocumentTypeFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AugmentedManifestsDocumentTypeFormat {
    #[allow(missing_docs)] // documentation missing in model
    PlainTextDocument,
    #[allow(missing_docs)] // documentation missing in model
    SemiStructuredDocument,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AugmentedManifestsDocumentTypeFormat {
    fn from(s: &str) -> Self {
        match s {
            "PLAIN_TEXT_DOCUMENT" => AugmentedManifestsDocumentTypeFormat::PlainTextDocument,
            "SEMI_STRUCTURED_DOCUMENT" => {
                AugmentedManifestsDocumentTypeFormat::SemiStructuredDocument
            }
            other => AugmentedManifestsDocumentTypeFormat::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for AugmentedManifestsDocumentTypeFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AugmentedManifestsDocumentTypeFormat::from(s))
    }
}
impl AugmentedManifestsDocumentTypeFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AugmentedManifestsDocumentTypeFormat::PlainTextDocument => "PLAIN_TEXT_DOCUMENT",
            AugmentedManifestsDocumentTypeFormat::SemiStructuredDocument => {
                "SEMI_STRUCTURED_DOCUMENT"
            }
            AugmentedManifestsDocumentTypeFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PLAIN_TEXT_DOCUMENT", "SEMI_STRUCTURED_DOCUMENT"]
    }
}
impl AsRef<str> for AugmentedManifestsDocumentTypeFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Split`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let split = unimplemented!();
/// match split {
///     Split::Test => { /* ... */ },
///     Split::Train => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `split` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Split::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Split::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Split::NewFeature` is defined.
/// Specifically, when `split` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Split::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Split {
    #[allow(missing_docs)] // documentation missing in model
    Test,
    #[allow(missing_docs)] // documentation missing in model
    Train,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Split {
    fn from(s: &str) -> Self {
        match s {
            "TEST" => Split::Test,
            "TRAIN" => Split::Train,
            other => Split::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Split {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Split::from(s))
    }
}
impl Split {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Split::Test => "TEST",
            Split::Train => "TRAIN",
            Split::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TEST", "TRAIN"]
    }
}
impl AsRef<str> for Split {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the entity recognizer submitted with an entity recognizer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityRecognizerEntityList {
    /// <p>Specifies the Amazon S3 location where the entity list is located. The URI must be in the same region as the API endpoint that you are calling.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
}
impl EntityRecognizerEntityList {
    /// <p>Specifies the Amazon S3 location where the entity list is located. The URI must be in the same region as the API endpoint that you are calling.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
}
/// See [`EntityRecognizerEntityList`](crate::model::EntityRecognizerEntityList).
pub mod entity_recognizer_entity_list {

    /// A builder for [`EntityRecognizerEntityList`](crate::model::EntityRecognizerEntityList).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the Amazon S3 location where the entity list is located. The URI must be in the same region as the API endpoint that you are calling.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>Specifies the Amazon S3 location where the entity list is located. The URI must be in the same region as the API endpoint that you are calling.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerEntityList`](crate::model::EntityRecognizerEntityList).
        pub fn build(self) -> crate::model::EntityRecognizerEntityList {
            crate::model::EntityRecognizerEntityList {
                s3_uri: self.s3_uri,
            }
        }
    }
}
impl EntityRecognizerEntityList {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerEntityList`](crate::model::EntityRecognizerEntityList).
    pub fn builder() -> crate::model::entity_recognizer_entity_list::Builder {
        crate::model::entity_recognizer_entity_list::Builder::default()
    }
}

/// <p>Describes the annotations associated with a entity recognizer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityRecognizerAnnotations {
    /// <p> Specifies the Amazon S3 location where the annotations for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p> Specifies the Amazon S3 location where the test annotations for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
    #[doc(hidden)]
    pub test_s3_uri: std::option::Option<std::string::String>,
}
impl EntityRecognizerAnnotations {
    /// <p> Specifies the Amazon S3 location where the annotations for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p> Specifies the Amazon S3 location where the test annotations for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
    pub fn test_s3_uri(&self) -> std::option::Option<&str> {
        self.test_s3_uri.as_deref()
    }
}
/// See [`EntityRecognizerAnnotations`](crate::model::EntityRecognizerAnnotations).
pub mod entity_recognizer_annotations {

    /// A builder for [`EntityRecognizerAnnotations`](crate::model::EntityRecognizerAnnotations).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) test_s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Specifies the Amazon S3 location where the annotations for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p> Specifies the Amazon S3 location where the annotations for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p> Specifies the Amazon S3 location where the test annotations for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
        pub fn test_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.test_s3_uri = Some(input.into());
            self
        }
        /// <p> Specifies the Amazon S3 location where the test annotations for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
        pub fn set_test_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.test_s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerAnnotations`](crate::model::EntityRecognizerAnnotations).
        pub fn build(self) -> crate::model::EntityRecognizerAnnotations {
            crate::model::EntityRecognizerAnnotations {
                s3_uri: self.s3_uri,
                test_s3_uri: self.test_s3_uri,
            }
        }
    }
}
impl EntityRecognizerAnnotations {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerAnnotations`](crate::model::EntityRecognizerAnnotations).
    pub fn builder() -> crate::model::entity_recognizer_annotations::Builder {
        crate::model::entity_recognizer_annotations::Builder::default()
    }
}

/// <p>Describes the training documents submitted with an entity recognizer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityRecognizerDocuments {
    /// <p> Specifies the Amazon S3 location where the training documents for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p> Specifies the Amazon S3 location where the test documents for an entity recognizer are located. The URI must be in the same AWS Region as the API endpoint that you are calling.</p>
    #[doc(hidden)]
    pub test_s3_uri: std::option::Option<std::string::String>,
    /// <p> Specifies how the text in an input file should be processed. This is optional, and the default is ONE_DOC_PER_LINE. ONE_DOC_PER_FILE - Each file is considered a separate document. Use this option when you are processing large documents, such as newspaper articles or scientific papers. ONE_DOC_PER_LINE - Each line in a file is considered a separate document. Use this option when you are processing many short documents, such as text messages.</p>
    #[doc(hidden)]
    pub input_format: std::option::Option<crate::model::InputFormat>,
}
impl EntityRecognizerDocuments {
    /// <p> Specifies the Amazon S3 location where the training documents for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p> Specifies the Amazon S3 location where the test documents for an entity recognizer are located. The URI must be in the same AWS Region as the API endpoint that you are calling.</p>
    pub fn test_s3_uri(&self) -> std::option::Option<&str> {
        self.test_s3_uri.as_deref()
    }
    /// <p> Specifies how the text in an input file should be processed. This is optional, and the default is ONE_DOC_PER_LINE. ONE_DOC_PER_FILE - Each file is considered a separate document. Use this option when you are processing large documents, such as newspaper articles or scientific papers. ONE_DOC_PER_LINE - Each line in a file is considered a separate document. Use this option when you are processing many short documents, such as text messages.</p>
    pub fn input_format(&self) -> std::option::Option<&crate::model::InputFormat> {
        self.input_format.as_ref()
    }
}
/// See [`EntityRecognizerDocuments`](crate::model::EntityRecognizerDocuments).
pub mod entity_recognizer_documents {

    /// A builder for [`EntityRecognizerDocuments`](crate::model::EntityRecognizerDocuments).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) test_s3_uri: std::option::Option<std::string::String>,
        pub(crate) input_format: std::option::Option<crate::model::InputFormat>,
    }
    impl Builder {
        /// <p> Specifies the Amazon S3 location where the training documents for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p> Specifies the Amazon S3 location where the training documents for an entity recognizer are located. The URI must be in the same region as the API endpoint that you are calling.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p> Specifies the Amazon S3 location where the test documents for an entity recognizer are located. The URI must be in the same AWS Region as the API endpoint that you are calling.</p>
        pub fn test_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.test_s3_uri = Some(input.into());
            self
        }
        /// <p> Specifies the Amazon S3 location where the test documents for an entity recognizer are located. The URI must be in the same AWS Region as the API endpoint that you are calling.</p>
        pub fn set_test_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.test_s3_uri = input;
            self
        }
        /// <p> Specifies how the text in an input file should be processed. This is optional, and the default is ONE_DOC_PER_LINE. ONE_DOC_PER_FILE - Each file is considered a separate document. Use this option when you are processing large documents, such as newspaper articles or scientific papers. ONE_DOC_PER_LINE - Each line in a file is considered a separate document. Use this option when you are processing many short documents, such as text messages.</p>
        pub fn input_format(mut self, input: crate::model::InputFormat) -> Self {
            self.input_format = Some(input);
            self
        }
        /// <p> Specifies how the text in an input file should be processed. This is optional, and the default is ONE_DOC_PER_LINE. ONE_DOC_PER_FILE - Each file is considered a separate document. Use this option when you are processing large documents, such as newspaper articles or scientific papers. ONE_DOC_PER_LINE - Each line in a file is considered a separate document. Use this option when you are processing many short documents, such as text messages.</p>
        pub fn set_input_format(
            mut self,
            input: std::option::Option<crate::model::InputFormat>,
        ) -> Self {
            self.input_format = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerDocuments`](crate::model::EntityRecognizerDocuments).
        pub fn build(self) -> crate::model::EntityRecognizerDocuments {
            crate::model::EntityRecognizerDocuments {
                s3_uri: self.s3_uri,
                test_s3_uri: self.test_s3_uri,
                input_format: self.input_format,
            }
        }
    }
}
impl EntityRecognizerDocuments {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerDocuments`](crate::model::EntityRecognizerDocuments).
    pub fn builder() -> crate::model::entity_recognizer_documents::Builder {
        crate::model::entity_recognizer_documents::Builder::default()
    }
}

/// <p>An entity type within a labeled training dataset that Amazon Comprehend uses to train a custom entity recognizer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityTypesListItem {
    /// <p>An entity type within a labeled training dataset that Amazon Comprehend uses to train a custom entity recognizer.</p>
    /// <p>Entity types must not contain the following invalid characters: \n (line break), \\n (escaped line break, \r (carriage return), \\r (escaped carriage return), \t (tab), \\t (escaped tab), space, and , (comma).</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl EntityTypesListItem {
    /// <p>An entity type within a labeled training dataset that Amazon Comprehend uses to train a custom entity recognizer.</p>
    /// <p>Entity types must not contain the following invalid characters: \n (line break), \\n (escaped line break, \r (carriage return), \\r (escaped carriage return), \t (tab), \\t (escaped tab), space, and , (comma).</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
/// See [`EntityTypesListItem`](crate::model::EntityTypesListItem).
pub mod entity_types_list_item {

    /// A builder for [`EntityTypesListItem`](crate::model::EntityTypesListItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An entity type within a labeled training dataset that Amazon Comprehend uses to train a custom entity recognizer.</p>
        /// <p>Entity types must not contain the following invalid characters: \n (line break), \\n (escaped line break, \r (carriage return), \\r (escaped carriage return), \t (tab), \\t (escaped tab), space, and , (comma).</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>An entity type within a labeled training dataset that Amazon Comprehend uses to train a custom entity recognizer.</p>
        /// <p>Entity types must not contain the following invalid characters: \n (line break), \\n (escaped line break, \r (carriage return), \\r (escaped carriage return), \t (tab), \\t (escaped tab), space, and , (comma).</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityTypesListItem`](crate::model::EntityTypesListItem).
        pub fn build(self) -> crate::model::EntityTypesListItem {
            crate::model::EntityTypesListItem {
                r#type: self.r#type,
            }
        }
    }
}
impl EntityTypesListItem {
    /// Creates a new builder-style object to manufacture [`EntityTypesListItem`](crate::model::EntityTypesListItem).
    pub fn builder() -> crate::model::entity_types_list_item::Builder {
        crate::model::entity_types_list_item::Builder::default()
    }
}

/// When writing a match expression against `EntityRecognizerDataFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let entityrecognizerdataformat = unimplemented!();
/// match entityrecognizerdataformat {
///     EntityRecognizerDataFormat::AugmentedManifest => { /* ... */ },
///     EntityRecognizerDataFormat::ComprehendCsv => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `entityrecognizerdataformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EntityRecognizerDataFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EntityRecognizerDataFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EntityRecognizerDataFormat::NewFeature` is defined.
/// Specifically, when `entityrecognizerdataformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EntityRecognizerDataFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EntityRecognizerDataFormat {
    #[allow(missing_docs)] // documentation missing in model
    AugmentedManifest,
    #[allow(missing_docs)] // documentation missing in model
    ComprehendCsv,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EntityRecognizerDataFormat {
    fn from(s: &str) -> Self {
        match s {
            "AUGMENTED_MANIFEST" => EntityRecognizerDataFormat::AugmentedManifest,
            "COMPREHEND_CSV" => EntityRecognizerDataFormat::ComprehendCsv,
            other => EntityRecognizerDataFormat::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for EntityRecognizerDataFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EntityRecognizerDataFormat::from(s))
    }
}
impl EntityRecognizerDataFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EntityRecognizerDataFormat::AugmentedManifest => "AUGMENTED_MANIFEST",
            EntityRecognizerDataFormat::ComprehendCsv => "COMPREHEND_CSV",
            EntityRecognizerDataFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUGMENTED_MANIFEST", "COMPREHEND_CSV"]
    }
}
impl AsRef<str> for EntityRecognizerDataFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information for filtering a list of entity recognizers. You can only specify one filtering parameter in a request. For more information, see the operation./&gt;</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityRecognizerFilter {
    /// <p>The status of an entity recognizer.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ModelStatus>,
    /// <p>The name that you assigned the entity recognizer.</p>
    #[doc(hidden)]
    pub recognizer_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of entities based on the time that the list was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of entities based on the time that the list was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl EntityRecognizerFilter {
    /// <p>The status of an entity recognizer.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ModelStatus> {
        self.status.as_ref()
    }
    /// <p>The name that you assigned the entity recognizer.</p>
    pub fn recognizer_name(&self) -> std::option::Option<&str> {
        self.recognizer_name.as_deref()
    }
    /// <p>Filters the list of entities based on the time that the list was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of entities based on the time that the list was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`EntityRecognizerFilter`](crate::model::EntityRecognizerFilter).
pub mod entity_recognizer_filter {

    /// A builder for [`EntityRecognizerFilter`](crate::model::EntityRecognizerFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ModelStatus>,
        pub(crate) recognizer_name: std::option::Option<std::string::String>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The status of an entity recognizer.</p>
        pub fn status(mut self, input: crate::model::ModelStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of an entity recognizer.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ModelStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The name that you assigned the entity recognizer.</p>
        pub fn recognizer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.recognizer_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned the entity recognizer.</p>
        pub fn set_recognizer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recognizer_name = input;
            self
        }
        /// <p>Filters the list of entities based on the time that the list was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of entities based on the time that the list was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of entities based on the time that the list was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of entities based on the time that the list was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityRecognizerFilter`](crate::model::EntityRecognizerFilter).
        pub fn build(self) -> crate::model::EntityRecognizerFilter {
            crate::model::EntityRecognizerFilter {
                status: self.status,
                recognizer_name: self.recognizer_name,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl EntityRecognizerFilter {
    /// Creates a new builder-style object to manufacture [`EntityRecognizerFilter`](crate::model::EntityRecognizerFilter).
    pub fn builder() -> crate::model::entity_recognizer_filter::Builder {
        crate::model::entity_recognizer_filter::Builder::default()
    }
}

/// <p>Provides information about an entities detection job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntitiesDetectionJobProperties {
    /// <p>The identifier assigned to the entities detection job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :entities-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name that you assigned the entities detection job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The current status of the entities detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>A description of the status of a job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the entities detection job was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the entities detection job completed</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    #[doc(hidden)]
    pub entity_recognizer_arn: std::option::Option<std::string::String>,
    /// <p>The input data configuration that you supplied when you created the entities detection job.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data configuration that you supplied when you created the entities detection job. </p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The language code of the input documents.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your entity detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl EntitiesDetectionJobProperties {
    /// <p>The identifier assigned to the entities detection job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :entities-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The name that you assigned the entities detection job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The current status of the entities detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>A description of the status of a job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the entities detection job was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the entities detection job completed</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
    pub fn entity_recognizer_arn(&self) -> std::option::Option<&str> {
        self.entity_recognizer_arn.as_deref()
    }
    /// <p>The input data configuration that you supplied when you created the entities detection job.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data configuration that you supplied when you created the entities detection job. </p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The language code of the input documents.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your entity detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
/// See [`EntitiesDetectionJobProperties`](crate::model::EntitiesDetectionJobProperties).
pub mod entities_detection_job_properties {

    /// A builder for [`EntitiesDetectionJobProperties`](crate::model::EntitiesDetectionJobProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) entity_recognizer_arn: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>The identifier assigned to the entities detection job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier assigned to the entities detection job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :entities-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the entities detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :entities-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:entities-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The name that you assigned the entities detection job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned the entities detection job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The current status of the entities detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the entities detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the status of a job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the entities detection job was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the entities detection job was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the entities detection job completed</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the entities detection job completed</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
        pub fn entity_recognizer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_recognizer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the entity recognizer.</p>
        pub fn set_entity_recognizer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.entity_recognizer_arn = input;
            self
        }
        /// <p>The input data configuration that you supplied when you created the entities detection job.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data configuration that you supplied when you created the entities detection job.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data configuration that you supplied when you created the entities detection job. </p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data configuration that you supplied when you created the entities detection job. </p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the input documents.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your entity detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your entity detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`EntitiesDetectionJobProperties`](crate::model::EntitiesDetectionJobProperties).
        pub fn build(self) -> crate::model::EntitiesDetectionJobProperties {
            crate::model::EntitiesDetectionJobProperties {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_name: self.job_name,
                job_status: self.job_status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                entity_recognizer_arn: self.entity_recognizer_arn,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                language_code: self.language_code,
                data_access_role_arn: self.data_access_role_arn,
                volume_kms_key_id: self.volume_kms_key_id,
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl EntitiesDetectionJobProperties {
    /// Creates a new builder-style object to manufacture [`EntitiesDetectionJobProperties`](crate::model::EntitiesDetectionJobProperties).
    pub fn builder() -> crate::model::entities_detection_job_properties::Builder {
        crate::model::entities_detection_job_properties::Builder::default()
    }
}

/// <p>Provides information for filtering a list of dominant language detection jobs. For more information, see the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntitiesDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl EntitiesDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`EntitiesDetectionJobFilter`](crate::model::EntitiesDetectionJobFilter).
pub mod entities_detection_job_filter {

    /// A builder for [`EntitiesDetectionJobFilter`](crate::model::EntitiesDetectionJobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filters on the name of the job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>Filters on the name of the job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`EntitiesDetectionJobFilter`](crate::model::EntitiesDetectionJobFilter).
        pub fn build(self) -> crate::model::EntitiesDetectionJobFilter {
            crate::model::EntitiesDetectionJobFilter {
                job_name: self.job_name,
                job_status: self.job_status,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl EntitiesDetectionJobFilter {
    /// Creates a new builder-style object to manufacture [`EntitiesDetectionJobFilter`](crate::model::EntitiesDetectionJobFilter).
    pub fn builder() -> crate::model::entities_detection_job_filter::Builder {
        crate::model::entities_detection_job_filter::Builder::default()
    }
}

/// <p>Specifies information about the specified endpoint. For information about endpoints, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/manage-endpoints.html">Managing endpoints</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointProperties {
    /// <p>The Amazon Resource Number (ARN) of the endpoint.</p>
    #[doc(hidden)]
    pub endpoint_arn: std::option::Option<std::string::String>,
    /// <p>Specifies the status of the endpoint. Because the endpoint updates and creation are asynchronous, so customers will need to wait for the endpoint to be <code>Ready</code> status before making inference requests.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::EndpointStatus>,
    /// <p>Specifies a reason for failure in cases of <code>Failed</code> status.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
    #[doc(hidden)]
    pub model_arn: std::option::Option<std::string::String>,
    /// <p>ARN of the new model to use for updating an existing endpoint. This ARN is going to be different from the model ARN when the update is in progress</p>
    #[doc(hidden)]
    pub desired_model_arn: std::option::Option<std::string::String>,
    /// <p>The desired number of inference units to be used by the model using this endpoint. Each inference unit represents of a throughput of 100 characters per second.</p>
    #[doc(hidden)]
    pub desired_inference_units: std::option::Option<i32>,
    /// <p>The number of inference units currently used by the model using this endpoint.</p>
    #[doc(hidden)]
    pub current_inference_units: std::option::Option<i32>,
    /// <p>The creation date and time of the endpoint.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time that the endpoint was last modified.</p>
    #[doc(hidden)]
    pub last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that grants Amazon Comprehend read access to trained custom models encrypted with a customer managed key (ModelKmsKeyId).</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>Data access role ARN to use in case the new model is encrypted with a customer KMS key.</p>
    #[doc(hidden)]
    pub desired_data_access_role_arn: std::option::Option<std::string::String>,
}
impl EndpointProperties {
    /// <p>The Amazon Resource Number (ARN) of the endpoint.</p>
    pub fn endpoint_arn(&self) -> std::option::Option<&str> {
        self.endpoint_arn.as_deref()
    }
    /// <p>Specifies the status of the endpoint. Because the endpoint updates and creation are asynchronous, so customers will need to wait for the endpoint to be <code>Ready</code> status before making inference requests.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::EndpointStatus> {
        self.status.as_ref()
    }
    /// <p>Specifies a reason for failure in cases of <code>Failed</code> status.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
    pub fn model_arn(&self) -> std::option::Option<&str> {
        self.model_arn.as_deref()
    }
    /// <p>ARN of the new model to use for updating an existing endpoint. This ARN is going to be different from the model ARN when the update is in progress</p>
    pub fn desired_model_arn(&self) -> std::option::Option<&str> {
        self.desired_model_arn.as_deref()
    }
    /// <p>The desired number of inference units to be used by the model using this endpoint. Each inference unit represents of a throughput of 100 characters per second.</p>
    pub fn desired_inference_units(&self) -> std::option::Option<i32> {
        self.desired_inference_units
    }
    /// <p>The number of inference units currently used by the model using this endpoint.</p>
    pub fn current_inference_units(&self) -> std::option::Option<i32> {
        self.current_inference_units
    }
    /// <p>The creation date and time of the endpoint.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The date and time that the endpoint was last modified.</p>
    pub fn last_modified_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that grants Amazon Comprehend read access to trained custom models encrypted with a customer managed key (ModelKmsKeyId).</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>Data access role ARN to use in case the new model is encrypted with a customer KMS key.</p>
    pub fn desired_data_access_role_arn(&self) -> std::option::Option<&str> {
        self.desired_data_access_role_arn.as_deref()
    }
}
/// See [`EndpointProperties`](crate::model::EndpointProperties).
pub mod endpoint_properties {

    /// A builder for [`EndpointProperties`](crate::model::EndpointProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::EndpointStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) model_arn: std::option::Option<std::string::String>,
        pub(crate) desired_model_arn: std::option::Option<std::string::String>,
        pub(crate) desired_inference_units: std::option::Option<i32>,
        pub(crate) current_inference_units: std::option::Option<i32>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) desired_data_access_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Number (ARN) of the endpoint.</p>
        pub fn endpoint_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the endpoint.</p>
        pub fn set_endpoint_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint_arn = input;
            self
        }
        /// <p>Specifies the status of the endpoint. Because the endpoint updates and creation are asynchronous, so customers will need to wait for the endpoint to be <code>Ready</code> status before making inference requests.</p>
        pub fn status(mut self, input: crate::model::EndpointStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Specifies the status of the endpoint. Because the endpoint updates and creation are asynchronous, so customers will need to wait for the endpoint to be <code>Ready</code> status before making inference requests.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::EndpointStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Specifies a reason for failure in cases of <code>Failed</code> status.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Specifies a reason for failure in cases of <code>Failed</code> status.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
        pub fn model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
        pub fn set_model_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_arn = input;
            self
        }
        /// <p>ARN of the new model to use for updating an existing endpoint. This ARN is going to be different from the model ARN when the update is in progress</p>
        pub fn desired_model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.desired_model_arn = Some(input.into());
            self
        }
        /// <p>ARN of the new model to use for updating an existing endpoint. This ARN is going to be different from the model ARN when the update is in progress</p>
        pub fn set_desired_model_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.desired_model_arn = input;
            self
        }
        /// <p>The desired number of inference units to be used by the model using this endpoint. Each inference unit represents of a throughput of 100 characters per second.</p>
        pub fn desired_inference_units(mut self, input: i32) -> Self {
            self.desired_inference_units = Some(input);
            self
        }
        /// <p>The desired number of inference units to be used by the model using this endpoint. Each inference unit represents of a throughput of 100 characters per second.</p>
        pub fn set_desired_inference_units(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_inference_units = input;
            self
        }
        /// <p>The number of inference units currently used by the model using this endpoint.</p>
        pub fn current_inference_units(mut self, input: i32) -> Self {
            self.current_inference_units = Some(input);
            self
        }
        /// <p>The number of inference units currently used by the model using this endpoint.</p>
        pub fn set_current_inference_units(mut self, input: std::option::Option<i32>) -> Self {
            self.current_inference_units = input;
            self
        }
        /// <p>The creation date and time of the endpoint.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation date and time of the endpoint.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The date and time that the endpoint was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the endpoint was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that grants Amazon Comprehend read access to trained custom models encrypted with a customer managed key (ModelKmsKeyId).</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that grants Amazon Comprehend read access to trained custom models encrypted with a customer managed key (ModelKmsKeyId).</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>Data access role ARN to use in case the new model is encrypted with a customer KMS key.</p>
        pub fn desired_data_access_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.desired_data_access_role_arn = Some(input.into());
            self
        }
        /// <p>Data access role ARN to use in case the new model is encrypted with a customer KMS key.</p>
        pub fn set_desired_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.desired_data_access_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointProperties`](crate::model::EndpointProperties).
        pub fn build(self) -> crate::model::EndpointProperties {
            crate::model::EndpointProperties {
                endpoint_arn: self.endpoint_arn,
                status: self.status,
                message: self.message,
                model_arn: self.model_arn,
                desired_model_arn: self.desired_model_arn,
                desired_inference_units: self.desired_inference_units,
                current_inference_units: self.current_inference_units,
                creation_time: self.creation_time,
                last_modified_time: self.last_modified_time,
                data_access_role_arn: self.data_access_role_arn,
                desired_data_access_role_arn: self.desired_data_access_role_arn,
            }
        }
    }
}
impl EndpointProperties {
    /// Creates a new builder-style object to manufacture [`EndpointProperties`](crate::model::EndpointProperties).
    pub fn builder() -> crate::model::endpoint_properties::Builder {
        crate::model::endpoint_properties::Builder::default()
    }
}

/// When writing a match expression against `EndpointStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let endpointstatus = unimplemented!();
/// match endpointstatus {
///     EndpointStatus::Creating => { /* ... */ },
///     EndpointStatus::Deleting => { /* ... */ },
///     EndpointStatus::Failed => { /* ... */ },
///     EndpointStatus::InService => { /* ... */ },
///     EndpointStatus::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `endpointstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EndpointStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EndpointStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EndpointStatus::NewFeature` is defined.
/// Specifically, when `endpointstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EndpointStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointStatus {
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InService,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EndpointStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATING" => EndpointStatus::Creating,
            "DELETING" => EndpointStatus::Deleting,
            "FAILED" => EndpointStatus::Failed,
            "IN_SERVICE" => EndpointStatus::InService,
            "UPDATING" => EndpointStatus::Updating,
            other => EndpointStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EndpointStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointStatus::from(s))
    }
}
impl EndpointStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndpointStatus::Creating => "CREATING",
            EndpointStatus::Deleting => "DELETING",
            EndpointStatus::Failed => "FAILED",
            EndpointStatus::InService => "IN_SERVICE",
            EndpointStatus::Updating => "UPDATING",
            EndpointStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATING", "DELETING", "FAILED", "IN_SERVICE", "UPDATING"]
    }
}
impl AsRef<str> for EndpointStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The filter used to determine which endpoints are returned. You can filter jobs on their name, model, status, or the date and time that they were created. You can only set one filter at a time. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointFilter {
    /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
    #[doc(hidden)]
    pub model_arn: std::option::Option<std::string::String>,
    /// <p>Specifies the status of the endpoint being returned. Possible values are: Creating, Ready, Updating, Deleting, Failed.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::EndpointStatus>,
    /// <p>Specifies a date before which the returned endpoint or endpoints were created.</p>
    #[doc(hidden)]
    pub creation_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Specifies a date after which the returned endpoint or endpoints were created.</p>
    #[doc(hidden)]
    pub creation_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl EndpointFilter {
    /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
    pub fn model_arn(&self) -> std::option::Option<&str> {
        self.model_arn.as_deref()
    }
    /// <p>Specifies the status of the endpoint being returned. Possible values are: Creating, Ready, Updating, Deleting, Failed.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::EndpointStatus> {
        self.status.as_ref()
    }
    /// <p>Specifies a date before which the returned endpoint or endpoints were created.</p>
    pub fn creation_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time_before.as_ref()
    }
    /// <p>Specifies a date after which the returned endpoint or endpoints were created.</p>
    pub fn creation_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time_after.as_ref()
    }
}
/// See [`EndpointFilter`](crate::model::EndpointFilter).
pub mod endpoint_filter {

    /// A builder for [`EndpointFilter`](crate::model::EndpointFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::EndpointStatus>,
        pub(crate) creation_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) creation_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
        pub fn model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the model to which the endpoint is attached.</p>
        pub fn set_model_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_arn = input;
            self
        }
        /// <p>Specifies the status of the endpoint being returned. Possible values are: Creating, Ready, Updating, Deleting, Failed.</p>
        pub fn status(mut self, input: crate::model::EndpointStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Specifies the status of the endpoint being returned. Possible values are: Creating, Ready, Updating, Deleting, Failed.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::EndpointStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Specifies a date before which the returned endpoint or endpoints were created.</p>
        pub fn creation_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time_before = Some(input);
            self
        }
        /// <p>Specifies a date before which the returned endpoint or endpoints were created.</p>
        pub fn set_creation_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time_before = input;
            self
        }
        /// <p>Specifies a date after which the returned endpoint or endpoints were created.</p>
        pub fn creation_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time_after = Some(input);
            self
        }
        /// <p>Specifies a date after which the returned endpoint or endpoints were created.</p>
        pub fn set_creation_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointFilter`](crate::model::EndpointFilter).
        pub fn build(self) -> crate::model::EndpointFilter {
            crate::model::EndpointFilter {
                model_arn: self.model_arn,
                status: self.status,
                creation_time_before: self.creation_time_before,
                creation_time_after: self.creation_time_after,
            }
        }
    }
}
impl EndpointFilter {
    /// Creates a new builder-style object to manufacture [`EndpointFilter`](crate::model::EndpointFilter).
    pub fn builder() -> crate::model::endpoint_filter::Builder {
        crate::model::endpoint_filter::Builder::default()
    }
}

/// <p>Provides information about a dominant language detection job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DominantLanguageDetectionJobProperties {
    /// <p>The identifier assigned to the dominant language detection job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :dominant-language-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name that you assigned to the dominant language detection job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The current status of the dominant language detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>A description for the status of a job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the dominant language detection job was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the dominant language detection job completed.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The input data configuration that you supplied when you created the dominant language detection job.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data configuration that you supplied when you created the dominant language detection job.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your dominant language detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl DominantLanguageDetectionJobProperties {
    /// <p>The identifier assigned to the dominant language detection job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :dominant-language-detection-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The name that you assigned to the dominant language detection job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The current status of the dominant language detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>A description for the status of a job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the dominant language detection job was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the dominant language detection job completed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The input data configuration that you supplied when you created the dominant language detection job.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data configuration that you supplied when you created the dominant language detection job.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your dominant language detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
/// See [`DominantLanguageDetectionJobProperties`](crate::model::DominantLanguageDetectionJobProperties).
pub mod dominant_language_detection_job_properties {

    /// A builder for [`DominantLanguageDetectionJobProperties`](crate::model::DominantLanguageDetectionJobProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>The identifier assigned to the dominant language detection job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier assigned to the dominant language detection job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :dominant-language-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the dominant language detection job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :dominant-language-detection-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:dominant-language-detection-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The name that you assigned to the dominant language detection job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned to the dominant language detection job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The current status of the dominant language detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the dominant language detection job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>A description for the status of a job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description for the status of a job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the dominant language detection job was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the dominant language detection job was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the dominant language detection job completed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the dominant language detection job completed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The input data configuration that you supplied when you created the dominant language detection job.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data configuration that you supplied when you created the dominant language detection job.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data configuration that you supplied when you created the dominant language detection job.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data configuration that you supplied when you created the dominant language detection job.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that gives Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your dominant language detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your dominant language detection job. For more information, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`DominantLanguageDetectionJobProperties`](crate::model::DominantLanguageDetectionJobProperties).
        pub fn build(self) -> crate::model::DominantLanguageDetectionJobProperties {
            crate::model::DominantLanguageDetectionJobProperties {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_name: self.job_name,
                job_status: self.job_status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                data_access_role_arn: self.data_access_role_arn,
                volume_kms_key_id: self.volume_kms_key_id,
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl DominantLanguageDetectionJobProperties {
    /// Creates a new builder-style object to manufacture [`DominantLanguageDetectionJobProperties`](crate::model::DominantLanguageDetectionJobProperties).
    pub fn builder() -> crate::model::dominant_language_detection_job_properties::Builder {
        crate::model::dominant_language_detection_job_properties::Builder::default()
    }
}

/// <p>Provides information for filtering a list of dominant language detection jobs. For more information, see the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DominantLanguageDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl DominantLanguageDetectionJobFilter {
    /// <p>Filters on the name of the job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`DominantLanguageDetectionJobFilter`](crate::model::DominantLanguageDetectionJobFilter).
pub mod dominant_language_detection_job_filter {

    /// A builder for [`DominantLanguageDetectionJobFilter`](crate::model::DominantLanguageDetectionJobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filters on the name of the job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>Filters on the name of the job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on job status. Returns only jobs with the specified status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`DominantLanguageDetectionJobFilter`](crate::model::DominantLanguageDetectionJobFilter).
        pub fn build(self) -> crate::model::DominantLanguageDetectionJobFilter {
            crate::model::DominantLanguageDetectionJobFilter {
                job_name: self.job_name,
                job_status: self.job_status,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl DominantLanguageDetectionJobFilter {
    /// Creates a new builder-style object to manufacture [`DominantLanguageDetectionJobFilter`](crate::model::DominantLanguageDetectionJobFilter).
    pub fn builder() -> crate::model::dominant_language_detection_job_filter::Builder {
        crate::model::dominant_language_detection_job_filter::Builder::default()
    }
}

/// <p>Describes information about a document classifier and its versions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentClassifierSummary {
    /// <p>The name that you assigned the document classifier.</p>
    #[doc(hidden)]
    pub document_classifier_name: std::option::Option<std::string::String>,
    /// <p>The number of versions you created.</p>
    #[doc(hidden)]
    pub number_of_versions: std::option::Option<i32>,
    /// <p>The time that the latest document classifier version was submitted for processing.</p>
    #[doc(hidden)]
    pub latest_version_created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The version name you assigned to the latest document classifier version.</p>
    #[doc(hidden)]
    pub latest_version_name: std::option::Option<std::string::String>,
    /// <p>Provides the status of the latest document classifier version.</p>
    #[doc(hidden)]
    pub latest_version_status: std::option::Option<crate::model::ModelStatus>,
}
impl DocumentClassifierSummary {
    /// <p>The name that you assigned the document classifier.</p>
    pub fn document_classifier_name(&self) -> std::option::Option<&str> {
        self.document_classifier_name.as_deref()
    }
    /// <p>The number of versions you created.</p>
    pub fn number_of_versions(&self) -> std::option::Option<i32> {
        self.number_of_versions
    }
    /// <p>The time that the latest document classifier version was submitted for processing.</p>
    pub fn latest_version_created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.latest_version_created_at.as_ref()
    }
    /// <p>The version name you assigned to the latest document classifier version.</p>
    pub fn latest_version_name(&self) -> std::option::Option<&str> {
        self.latest_version_name.as_deref()
    }
    /// <p>Provides the status of the latest document classifier version.</p>
    pub fn latest_version_status(&self) -> std::option::Option<&crate::model::ModelStatus> {
        self.latest_version_status.as_ref()
    }
}
/// See [`DocumentClassifierSummary`](crate::model::DocumentClassifierSummary).
pub mod document_classifier_summary {

    /// A builder for [`DocumentClassifierSummary`](crate::model::DocumentClassifierSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) document_classifier_name: std::option::Option<std::string::String>,
        pub(crate) number_of_versions: std::option::Option<i32>,
        pub(crate) latest_version_created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) latest_version_name: std::option::Option<std::string::String>,
        pub(crate) latest_version_status: std::option::Option<crate::model::ModelStatus>,
    }
    impl Builder {
        /// <p>The name that you assigned the document classifier.</p>
        pub fn document_classifier_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_classifier_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned the document classifier.</p>
        pub fn set_document_classifier_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_classifier_name = input;
            self
        }
        /// <p>The number of versions you created.</p>
        pub fn number_of_versions(mut self, input: i32) -> Self {
            self.number_of_versions = Some(input);
            self
        }
        /// <p>The number of versions you created.</p>
        pub fn set_number_of_versions(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_versions = input;
            self
        }
        /// <p>The time that the latest document classifier version was submitted for processing.</p>
        pub fn latest_version_created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.latest_version_created_at = Some(input);
            self
        }
        /// <p>The time that the latest document classifier version was submitted for processing.</p>
        pub fn set_latest_version_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.latest_version_created_at = input;
            self
        }
        /// <p>The version name you assigned to the latest document classifier version.</p>
        pub fn latest_version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.latest_version_name = Some(input.into());
            self
        }
        /// <p>The version name you assigned to the latest document classifier version.</p>
        pub fn set_latest_version_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_version_name = input;
            self
        }
        /// <p>Provides the status of the latest document classifier version.</p>
        pub fn latest_version_status(mut self, input: crate::model::ModelStatus) -> Self {
            self.latest_version_status = Some(input);
            self
        }
        /// <p>Provides the status of the latest document classifier version.</p>
        pub fn set_latest_version_status(
            mut self,
            input: std::option::Option<crate::model::ModelStatus>,
        ) -> Self {
            self.latest_version_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentClassifierSummary`](crate::model::DocumentClassifierSummary).
        pub fn build(self) -> crate::model::DocumentClassifierSummary {
            crate::model::DocumentClassifierSummary {
                document_classifier_name: self.document_classifier_name,
                number_of_versions: self.number_of_versions,
                latest_version_created_at: self.latest_version_created_at,
                latest_version_name: self.latest_version_name,
                latest_version_status: self.latest_version_status,
            }
        }
    }
}
impl DocumentClassifierSummary {
    /// Creates a new builder-style object to manufacture [`DocumentClassifierSummary`](crate::model::DocumentClassifierSummary).
    pub fn builder() -> crate::model::document_classifier_summary::Builder {
        crate::model::document_classifier_summary::Builder::default()
    }
}

/// <p>Provides information about a document classifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DocumentClassifierProperties {
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
    #[doc(hidden)]
    pub document_classifier_arn: std::option::Option<std::string::String>,
    /// <p>The language code for the language of the documents that the classifier was trained on.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The status of the document classifier. If the status is <code>TRAINED</code> the classifier is ready to use. If the status is <code>FAILED</code> you can see additional information about why the classifier wasn't trained in the <code>Message</code> field.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ModelStatus>,
    /// <p>Additional information about the status of the classifier.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the document classifier was submitted for training.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that training the document classifier completed.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates the time when the training starts on documentation classifiers. You are billed for the time interval between this time and the value of TrainingEndTime. </p>
    #[doc(hidden)]
    pub training_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that training of the document classifier was completed. Indicates the time when the training completes on documentation classifiers. You are billed for the time interval between this time and the value of TrainingStartTime.</p>
    #[doc(hidden)]
    pub training_end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The input data configuration that you supplied when you created the document classifier for training.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::DocumentClassifierInputDataConfig>,
    /// <p> Provides output results configuration parameters for custom classifier jobs.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::DocumentClassifierOutputDataConfig>,
    /// <p>Information about the document classifier, including the number of documents used for training the classifier, the number of documents used for test the classifier, and an accuracy rating.</p>
    #[doc(hidden)]
    pub classifier_metadata: std::option::Option<crate::model::ClassifierMetadata>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your custom classifier. For more information, see <a href="https://docs.aws.amazon.com/vppc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
    /// <p>Indicates the mode in which the specific classifier was trained. This also indicates the format of input documents and the format of the confusion matrix. Each classifier can only be trained in one mode and this cannot be changed once the classifier is trained.</p>
    #[doc(hidden)]
    pub mode: std::option::Option<crate::model::DocumentClassifierMode>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt trained custom models. The ModelKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub model_kms_key_id: std::option::Option<std::string::String>,
    /// <p>The version name that you assigned to the document classifier.</p>
    #[doc(hidden)]
    pub version_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the source model. This model was imported from a different AWS account to create the document classifier model in your AWS account.</p>
    #[doc(hidden)]
    pub source_model_arn: std::option::Option<std::string::String>,
}
impl DocumentClassifierProperties {
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
    pub fn document_classifier_arn(&self) -> std::option::Option<&str> {
        self.document_classifier_arn.as_deref()
    }
    /// <p>The language code for the language of the documents that the classifier was trained on.</p>
    pub fn language_code(&self) -> std::option::Option<&crate::model::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The status of the document classifier. If the status is <code>TRAINED</code> the classifier is ready to use. If the status is <code>FAILED</code> you can see additional information about why the classifier wasn't trained in the <code>Message</code> field.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ModelStatus> {
        self.status.as_ref()
    }
    /// <p>Additional information about the status of the classifier.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the document classifier was submitted for training.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that training the document classifier completed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>Indicates the time when the training starts on documentation classifiers. You are billed for the time interval between this time and the value of TrainingEndTime. </p>
    pub fn training_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.training_start_time.as_ref()
    }
    /// <p>The time that training of the document classifier was completed. Indicates the time when the training completes on documentation classifiers. You are billed for the time interval between this time and the value of TrainingStartTime.</p>
    pub fn training_end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.training_end_time.as_ref()
    }
    /// <p>The input data configuration that you supplied when you created the document classifier for training.</p>
    pub fn input_data_config(
        &self,
    ) -> std::option::Option<&crate::model::DocumentClassifierInputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p> Provides output results configuration parameters for custom classifier jobs.</p>
    pub fn output_data_config(
        &self,
    ) -> std::option::Option<&crate::model::DocumentClassifierOutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>Information about the document classifier, including the number of documents used for training the classifier, the number of documents used for test the classifier, and an accuracy rating.</p>
    pub fn classifier_metadata(&self) -> std::option::Option<&crate::model::ClassifierMetadata> {
        self.classifier_metadata.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your custom classifier. For more information, see <a href="https://docs.aws.amazon.com/vppc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
    /// <p>Indicates the mode in which the specific classifier was trained. This also indicates the format of input documents and the format of the confusion matrix. Each classifier can only be trained in one mode and this cannot be changed once the classifier is trained.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::DocumentClassifierMode> {
        self.mode.as_ref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt trained custom models. The ModelKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn model_kms_key_id(&self) -> std::option::Option<&str> {
        self.model_kms_key_id.as_deref()
    }
    /// <p>The version name that you assigned to the document classifier.</p>
    pub fn version_name(&self) -> std::option::Option<&str> {
        self.version_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the source model. This model was imported from a different AWS account to create the document classifier model in your AWS account.</p>
    pub fn source_model_arn(&self) -> std::option::Option<&str> {
        self.source_model_arn.as_deref()
    }
}
impl std::fmt::Debug for DocumentClassifierProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DocumentClassifierProperties");
        formatter.field("document_classifier_arn", &self.document_classifier_arn);
        formatter.field("language_code", &self.language_code);
        formatter.field("status", &self.status);
        formatter.field("message", &self.message);
        formatter.field("submit_time", &self.submit_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("training_start_time", &self.training_start_time);
        formatter.field("training_end_time", &self.training_end_time);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("classifier_metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
        formatter.field("vpc_config", &self.vpc_config);
        formatter.field("mode", &self.mode);
        formatter.field("model_kms_key_id", &self.model_kms_key_id);
        formatter.field("version_name", &self.version_name);
        formatter.field("source_model_arn", &self.source_model_arn);
        formatter.finish()
    }
}
/// See [`DocumentClassifierProperties`](crate::model::DocumentClassifierProperties).
pub mod document_classifier_properties {

    /// A builder for [`DocumentClassifierProperties`](crate::model::DocumentClassifierProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) document_classifier_arn: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) status: std::option::Option<crate::model::ModelStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) training_end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) input_data_config:
            std::option::Option<crate::model::DocumentClassifierInputDataConfig>,
        pub(crate) output_data_config:
            std::option::Option<crate::model::DocumentClassifierOutputDataConfig>,
        pub(crate) classifier_metadata: std::option::Option<crate::model::ClassifierMetadata>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
        pub(crate) mode: std::option::Option<crate::model::DocumentClassifierMode>,
        pub(crate) model_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) version_name: std::option::Option<std::string::String>,
        pub(crate) source_model_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
        pub fn document_classifier_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_classifier_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the document classifier.</p>
        pub fn set_document_classifier_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_classifier_arn = input;
            self
        }
        /// <p>The language code for the language of the documents that the classifier was trained on.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code for the language of the documents that the classifier was trained on.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The status of the document classifier. If the status is <code>TRAINED</code> the classifier is ready to use. If the status is <code>FAILED</code> you can see additional information about why the classifier wasn't trained in the <code>Message</code> field.</p>
        pub fn status(mut self, input: crate::model::ModelStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the document classifier. If the status is <code>TRAINED</code> the classifier is ready to use. If the status is <code>FAILED</code> you can see additional information about why the classifier wasn't trained in the <code>Message</code> field.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ModelStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Additional information about the status of the classifier.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Additional information about the status of the classifier.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the document classifier was submitted for training.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the document classifier was submitted for training.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that training the document classifier completed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that training the document classifier completed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Indicates the time when the training starts on documentation classifiers. You are billed for the time interval between this time and the value of TrainingEndTime. </p>
        pub fn training_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.training_start_time = Some(input);
            self
        }
        /// <p>Indicates the time when the training starts on documentation classifiers. You are billed for the time interval between this time and the value of TrainingEndTime. </p>
        pub fn set_training_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.training_start_time = input;
            self
        }
        /// <p>The time that training of the document classifier was completed. Indicates the time when the training completes on documentation classifiers. You are billed for the time interval between this time and the value of TrainingStartTime.</p>
        pub fn training_end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.training_end_time = Some(input);
            self
        }
        /// <p>The time that training of the document classifier was completed. Indicates the time when the training completes on documentation classifiers. You are billed for the time interval between this time and the value of TrainingStartTime.</p>
        pub fn set_training_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.training_end_time = input;
            self
        }
        /// <p>The input data configuration that you supplied when you created the document classifier for training.</p>
        pub fn input_data_config(
            mut self,
            input: crate::model::DocumentClassifierInputDataConfig,
        ) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data configuration that you supplied when you created the document classifier for training.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::DocumentClassifierInputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p> Provides output results configuration parameters for custom classifier jobs.</p>
        pub fn output_data_config(
            mut self,
            input: crate::model::DocumentClassifierOutputDataConfig,
        ) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p> Provides output results configuration parameters for custom classifier jobs.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::DocumentClassifierOutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>Information about the document classifier, including the number of documents used for training the classifier, the number of documents used for test the classifier, and an accuracy rating.</p>
        pub fn classifier_metadata(mut self, input: crate::model::ClassifierMetadata) -> Self {
            self.classifier_metadata = Some(input);
            self
        }
        /// <p>Information about the document classifier, including the number of documents used for training the classifier, the number of documents used for test the classifier, and an accuracy rating.</p>
        pub fn set_classifier_metadata(
            mut self,
            input: std::option::Option<crate::model::ClassifierMetadata>,
        ) -> Self {
            self.classifier_metadata = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your custom classifier. For more information, see <a href="https://docs.aws.amazon.com/vppc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your custom classifier. For more information, see <a href="https://docs.aws.amazon.com/vppc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// <p>Indicates the mode in which the specific classifier was trained. This also indicates the format of input documents and the format of the confusion matrix. Each classifier can only be trained in one mode and this cannot be changed once the classifier is trained.</p>
        pub fn mode(mut self, input: crate::model::DocumentClassifierMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>Indicates the mode in which the specific classifier was trained. This also indicates the format of input documents and the format of the confusion matrix. Each classifier can only be trained in one mode and this cannot be changed once the classifier is trained.</p>
        pub fn set_mode(
            mut self,
            input: std::option::Option<crate::model::DocumentClassifierMode>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt trained custom models. The ModelKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn model_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt trained custom models. The ModelKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_model_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_kms_key_id = input;
            self
        }
        /// <p>The version name that you assigned to the document classifier.</p>
        pub fn version_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.version_name = Some(input.into());
            self
        }
        /// <p>The version name that you assigned to the document classifier.</p>
        pub fn set_version_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source model. This model was imported from a different AWS account to create the document classifier model in your AWS account.</p>
        pub fn source_model_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_model_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the source model. This model was imported from a different AWS account to create the document classifier model in your AWS account.</p>
        pub fn set_source_model_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_model_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentClassifierProperties`](crate::model::DocumentClassifierProperties).
        pub fn build(self) -> crate::model::DocumentClassifierProperties {
            crate::model::DocumentClassifierProperties {
                document_classifier_arn: self.document_classifier_arn,
                language_code: self.language_code,
                status: self.status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                training_start_time: self.training_start_time,
                training_end_time: self.training_end_time,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                classifier_metadata: self.classifier_metadata,
                data_access_role_arn: self.data_access_role_arn,
                volume_kms_key_id: self.volume_kms_key_id,
                vpc_config: self.vpc_config,
                mode: self.mode,
                model_kms_key_id: self.model_kms_key_id,
                version_name: self.version_name,
                source_model_arn: self.source_model_arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("document_classifier_arn", &self.document_classifier_arn);
            formatter.field("language_code", &self.language_code);
            formatter.field("status", &self.status);
            formatter.field("message", &self.message);
            formatter.field("submit_time", &self.submit_time);
            formatter.field("end_time", &self.end_time);
            formatter.field("training_start_time", &self.training_start_time);
            formatter.field("training_end_time", &self.training_end_time);
            formatter.field("input_data_config", &self.input_data_config);
            formatter.field("output_data_config", &self.output_data_config);
            formatter.field("classifier_metadata", &"*** Sensitive Data Redacted ***");
            formatter.field("data_access_role_arn", &self.data_access_role_arn);
            formatter.field("volume_kms_key_id", &self.volume_kms_key_id);
            formatter.field("vpc_config", &self.vpc_config);
            formatter.field("mode", &self.mode);
            formatter.field("model_kms_key_id", &self.model_kms_key_id);
            formatter.field("version_name", &self.version_name);
            formatter.field("source_model_arn", &self.source_model_arn);
            formatter.finish()
        }
    }
}
impl DocumentClassifierProperties {
    /// Creates a new builder-style object to manufacture [`DocumentClassifierProperties`](crate::model::DocumentClassifierProperties).
    pub fn builder() -> crate::model::document_classifier_properties::Builder {
        crate::model::document_classifier_properties::Builder::default()
    }
}

/// When writing a match expression against `DocumentClassifierMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let documentclassifiermode = unimplemented!();
/// match documentclassifiermode {
///     DocumentClassifierMode::MultiClass => { /* ... */ },
///     DocumentClassifierMode::MultiLabel => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `documentclassifiermode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DocumentClassifierMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DocumentClassifierMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DocumentClassifierMode::NewFeature` is defined.
/// Specifically, when `documentclassifiermode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DocumentClassifierMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentClassifierMode {
    #[allow(missing_docs)] // documentation missing in model
    MultiClass,
    #[allow(missing_docs)] // documentation missing in model
    MultiLabel,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DocumentClassifierMode {
    fn from(s: &str) -> Self {
        match s {
            "MULTI_CLASS" => DocumentClassifierMode::MultiClass,
            "MULTI_LABEL" => DocumentClassifierMode::MultiLabel,
            other => {
                DocumentClassifierMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DocumentClassifierMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DocumentClassifierMode::from(s))
    }
}
impl DocumentClassifierMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DocumentClassifierMode::MultiClass => "MULTI_CLASS",
            DocumentClassifierMode::MultiLabel => "MULTI_LABEL",
            DocumentClassifierMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MULTI_CLASS", "MULTI_LABEL"]
    }
}
impl AsRef<str> for DocumentClassifierMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about a document classifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClassifierMetadata {
    /// <p>The number of labels in the input data. </p>
    #[doc(hidden)]
    pub number_of_labels: std::option::Option<i32>,
    /// <p>The number of documents in the input data that were used to train the classifier. Typically this is 80 to 90 percent of the input documents.</p>
    #[doc(hidden)]
    pub number_of_trained_documents: std::option::Option<i32>,
    /// <p>The number of documents in the input data that were used to test the classifier. Typically this is 10 to 20 percent of the input documents, up to 10,000 documents.</p>
    #[doc(hidden)]
    pub number_of_test_documents: std::option::Option<i32>,
    /// <p> Describes the result metrics for the test data associated with an documentation classifier.</p>
    #[doc(hidden)]
    pub evaluation_metrics: std::option::Option<crate::model::ClassifierEvaluationMetrics>,
}
impl ClassifierMetadata {
    /// <p>The number of labels in the input data. </p>
    pub fn number_of_labels(&self) -> std::option::Option<i32> {
        self.number_of_labels
    }
    /// <p>The number of documents in the input data that were used to train the classifier. Typically this is 80 to 90 percent of the input documents.</p>
    pub fn number_of_trained_documents(&self) -> std::option::Option<i32> {
        self.number_of_trained_documents
    }
    /// <p>The number of documents in the input data that were used to test the classifier. Typically this is 10 to 20 percent of the input documents, up to 10,000 documents.</p>
    pub fn number_of_test_documents(&self) -> std::option::Option<i32> {
        self.number_of_test_documents
    }
    /// <p> Describes the result metrics for the test data associated with an documentation classifier.</p>
    pub fn evaluation_metrics(
        &self,
    ) -> std::option::Option<&crate::model::ClassifierEvaluationMetrics> {
        self.evaluation_metrics.as_ref()
    }
}
impl std::fmt::Debug for ClassifierMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClassifierMetadata");
        formatter.field("number_of_labels", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "number_of_trained_documents",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field(
            "number_of_test_documents",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("evaluation_metrics", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ClassifierMetadata`](crate::model::ClassifierMetadata).
pub mod classifier_metadata {

    /// A builder for [`ClassifierMetadata`](crate::model::ClassifierMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) number_of_labels: std::option::Option<i32>,
        pub(crate) number_of_trained_documents: std::option::Option<i32>,
        pub(crate) number_of_test_documents: std::option::Option<i32>,
        pub(crate) evaluation_metrics:
            std::option::Option<crate::model::ClassifierEvaluationMetrics>,
    }
    impl Builder {
        /// <p>The number of labels in the input data. </p>
        pub fn number_of_labels(mut self, input: i32) -> Self {
            self.number_of_labels = Some(input);
            self
        }
        /// <p>The number of labels in the input data. </p>
        pub fn set_number_of_labels(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_labels = input;
            self
        }
        /// <p>The number of documents in the input data that were used to train the classifier. Typically this is 80 to 90 percent of the input documents.</p>
        pub fn number_of_trained_documents(mut self, input: i32) -> Self {
            self.number_of_trained_documents = Some(input);
            self
        }
        /// <p>The number of documents in the input data that were used to train the classifier. Typically this is 80 to 90 percent of the input documents.</p>
        pub fn set_number_of_trained_documents(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_trained_documents = input;
            self
        }
        /// <p>The number of documents in the input data that were used to test the classifier. Typically this is 10 to 20 percent of the input documents, up to 10,000 documents.</p>
        pub fn number_of_test_documents(mut self, input: i32) -> Self {
            self.number_of_test_documents = Some(input);
            self
        }
        /// <p>The number of documents in the input data that were used to test the classifier. Typically this is 10 to 20 percent of the input documents, up to 10,000 documents.</p>
        pub fn set_number_of_test_documents(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_test_documents = input;
            self
        }
        /// <p> Describes the result metrics for the test data associated with an documentation classifier.</p>
        pub fn evaluation_metrics(
            mut self,
            input: crate::model::ClassifierEvaluationMetrics,
        ) -> Self {
            self.evaluation_metrics = Some(input);
            self
        }
        /// <p> Describes the result metrics for the test data associated with an documentation classifier.</p>
        pub fn set_evaluation_metrics(
            mut self,
            input: std::option::Option<crate::model::ClassifierEvaluationMetrics>,
        ) -> Self {
            self.evaluation_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassifierMetadata`](crate::model::ClassifierMetadata).
        pub fn build(self) -> crate::model::ClassifierMetadata {
            crate::model::ClassifierMetadata {
                number_of_labels: self.number_of_labels,
                number_of_trained_documents: self.number_of_trained_documents,
                number_of_test_documents: self.number_of_test_documents,
                evaluation_metrics: self.evaluation_metrics,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("number_of_labels", &"*** Sensitive Data Redacted ***");
            formatter.field(
                "number_of_trained_documents",
                &"*** Sensitive Data Redacted ***",
            );
            formatter.field(
                "number_of_test_documents",
                &"*** Sensitive Data Redacted ***",
            );
            formatter.field("evaluation_metrics", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl ClassifierMetadata {
    /// Creates a new builder-style object to manufacture [`ClassifierMetadata`](crate::model::ClassifierMetadata).
    pub fn builder() -> crate::model::classifier_metadata::Builder {
        crate::model::classifier_metadata::Builder::default()
    }
}

/// <p>Describes the result metrics for the test data associated with an documentation classifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClassifierEvaluationMetrics {
    /// <p>The fraction of the labels that were correct recognized. It is computed by dividing the number of labels in the test documents that were correctly recognized by the total number of labels in the test documents.</p>
    #[doc(hidden)]
    pub accuracy: std::option::Option<f64>,
    /// <p>A measure of the usefulness of the classifier results in the test data. High precision means that the classifier returned substantially more relevant results than irrelevant ones.</p>
    #[doc(hidden)]
    pub precision: std::option::Option<f64>,
    /// <p>A measure of how complete the classifier results are for the test data. High recall means that the classifier returned most of the relevant results. </p>
    #[doc(hidden)]
    pub recall: std::option::Option<f64>,
    /// <p>A measure of how accurate the classifier results are for the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
    #[doc(hidden)]
    pub f1_score: std::option::Option<f64>,
    /// <p>A measure of the usefulness of the recognizer results in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. Unlike the Precision metric which comes from averaging the precision of all available labels, this is based on the overall score of all precision scores added together.</p>
    #[doc(hidden)]
    pub micro_precision: std::option::Option<f64>,
    /// <p>A measure of how complete the classifier results are for the test data. High recall means that the classifier returned most of the relevant results. Specifically, this indicates how many of the correct categories in the text that the model can predict. It is a percentage of correct categories in the text that can found. Instead of averaging the recall scores of all labels (as with Recall), micro Recall is based on the overall score of all recall scores added together.</p>
    #[doc(hidden)]
    pub micro_recall: std::option::Option<f64>,
    /// <p>A measure of how accurate the classifier results are for the test data. It is a combination of the <code>Micro Precision</code> and <code>Micro Recall</code> values. The <code>Micro F1Score</code> is the harmonic mean of the two scores. The highest score is 1, and the worst score is 0.</p>
    #[doc(hidden)]
    pub micro_f1_score: std::option::Option<f64>,
    /// <p>Indicates the fraction of labels that are incorrectly predicted. Also seen as the fraction of wrong labels compared to the total number of labels. Scores closer to zero are better.</p>
    #[doc(hidden)]
    pub hamming_loss: std::option::Option<f64>,
}
impl ClassifierEvaluationMetrics {
    /// <p>The fraction of the labels that were correct recognized. It is computed by dividing the number of labels in the test documents that were correctly recognized by the total number of labels in the test documents.</p>
    pub fn accuracy(&self) -> std::option::Option<f64> {
        self.accuracy
    }
    /// <p>A measure of the usefulness of the classifier results in the test data. High precision means that the classifier returned substantially more relevant results than irrelevant ones.</p>
    pub fn precision(&self) -> std::option::Option<f64> {
        self.precision
    }
    /// <p>A measure of how complete the classifier results are for the test data. High recall means that the classifier returned most of the relevant results. </p>
    pub fn recall(&self) -> std::option::Option<f64> {
        self.recall
    }
    /// <p>A measure of how accurate the classifier results are for the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
    pub fn f1_score(&self) -> std::option::Option<f64> {
        self.f1_score
    }
    /// <p>A measure of the usefulness of the recognizer results in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. Unlike the Precision metric which comes from averaging the precision of all available labels, this is based on the overall score of all precision scores added together.</p>
    pub fn micro_precision(&self) -> std::option::Option<f64> {
        self.micro_precision
    }
    /// <p>A measure of how complete the classifier results are for the test data. High recall means that the classifier returned most of the relevant results. Specifically, this indicates how many of the correct categories in the text that the model can predict. It is a percentage of correct categories in the text that can found. Instead of averaging the recall scores of all labels (as with Recall), micro Recall is based on the overall score of all recall scores added together.</p>
    pub fn micro_recall(&self) -> std::option::Option<f64> {
        self.micro_recall
    }
    /// <p>A measure of how accurate the classifier results are for the test data. It is a combination of the <code>Micro Precision</code> and <code>Micro Recall</code> values. The <code>Micro F1Score</code> is the harmonic mean of the two scores. The highest score is 1, and the worst score is 0.</p>
    pub fn micro_f1_score(&self) -> std::option::Option<f64> {
        self.micro_f1_score
    }
    /// <p>Indicates the fraction of labels that are incorrectly predicted. Also seen as the fraction of wrong labels compared to the total number of labels. Scores closer to zero are better.</p>
    pub fn hamming_loss(&self) -> std::option::Option<f64> {
        self.hamming_loss
    }
}
/// See [`ClassifierEvaluationMetrics`](crate::model::ClassifierEvaluationMetrics).
pub mod classifier_evaluation_metrics {

    /// A builder for [`ClassifierEvaluationMetrics`](crate::model::ClassifierEvaluationMetrics).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accuracy: std::option::Option<f64>,
        pub(crate) precision: std::option::Option<f64>,
        pub(crate) recall: std::option::Option<f64>,
        pub(crate) f1_score: std::option::Option<f64>,
        pub(crate) micro_precision: std::option::Option<f64>,
        pub(crate) micro_recall: std::option::Option<f64>,
        pub(crate) micro_f1_score: std::option::Option<f64>,
        pub(crate) hamming_loss: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The fraction of the labels that were correct recognized. It is computed by dividing the number of labels in the test documents that were correctly recognized by the total number of labels in the test documents.</p>
        pub fn accuracy(mut self, input: f64) -> Self {
            self.accuracy = Some(input);
            self
        }
        /// <p>The fraction of the labels that were correct recognized. It is computed by dividing the number of labels in the test documents that were correctly recognized by the total number of labels in the test documents.</p>
        pub fn set_accuracy(mut self, input: std::option::Option<f64>) -> Self {
            self.accuracy = input;
            self
        }
        /// <p>A measure of the usefulness of the classifier results in the test data. High precision means that the classifier returned substantially more relevant results than irrelevant ones.</p>
        pub fn precision(mut self, input: f64) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p>A measure of the usefulness of the classifier results in the test data. High precision means that the classifier returned substantially more relevant results than irrelevant ones.</p>
        pub fn set_precision(mut self, input: std::option::Option<f64>) -> Self {
            self.precision = input;
            self
        }
        /// <p>A measure of how complete the classifier results are for the test data. High recall means that the classifier returned most of the relevant results. </p>
        pub fn recall(mut self, input: f64) -> Self {
            self.recall = Some(input);
            self
        }
        /// <p>A measure of how complete the classifier results are for the test data. High recall means that the classifier returned most of the relevant results. </p>
        pub fn set_recall(mut self, input: std::option::Option<f64>) -> Self {
            self.recall = input;
            self
        }
        /// <p>A measure of how accurate the classifier results are for the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
        pub fn f1_score(mut self, input: f64) -> Self {
            self.f1_score = Some(input);
            self
        }
        /// <p>A measure of how accurate the classifier results are for the test data. It is derived from the <code>Precision</code> and <code>Recall</code> values. The <code>F1Score</code> is the harmonic average of the two scores. The highest score is 1, and the worst score is 0. </p>
        pub fn set_f1_score(mut self, input: std::option::Option<f64>) -> Self {
            self.f1_score = input;
            self
        }
        /// <p>A measure of the usefulness of the recognizer results in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. Unlike the Precision metric which comes from averaging the precision of all available labels, this is based on the overall score of all precision scores added together.</p>
        pub fn micro_precision(mut self, input: f64) -> Self {
            self.micro_precision = Some(input);
            self
        }
        /// <p>A measure of the usefulness of the recognizer results in the test data. High precision means that the recognizer returned substantially more relevant results than irrelevant ones. Unlike the Precision metric which comes from averaging the precision of all available labels, this is based on the overall score of all precision scores added together.</p>
        pub fn set_micro_precision(mut self, input: std::option::Option<f64>) -> Self {
            self.micro_precision = input;
            self
        }
        /// <p>A measure of how complete the classifier results are for the test data. High recall means that the classifier returned most of the relevant results. Specifically, this indicates how many of the correct categories in the text that the model can predict. It is a percentage of correct categories in the text that can found. Instead of averaging the recall scores of all labels (as with Recall), micro Recall is based on the overall score of all recall scores added together.</p>
        pub fn micro_recall(mut self, input: f64) -> Self {
            self.micro_recall = Some(input);
            self
        }
        /// <p>A measure of how complete the classifier results are for the test data. High recall means that the classifier returned most of the relevant results. Specifically, this indicates how many of the correct categories in the text that the model can predict. It is a percentage of correct categories in the text that can found. Instead of averaging the recall scores of all labels (as with Recall), micro Recall is based on the overall score of all recall scores added together.</p>
        pub fn set_micro_recall(mut self, input: std::option::Option<f64>) -> Self {
            self.micro_recall = input;
            self
        }
        /// <p>A measure of how accurate the classifier results are for the test data. It is a combination of the <code>Micro Precision</code> and <code>Micro Recall</code> values. The <code>Micro F1Score</code> is the harmonic mean of the two scores. The highest score is 1, and the worst score is 0.</p>
        pub fn micro_f1_score(mut self, input: f64) -> Self {
            self.micro_f1_score = Some(input);
            self
        }
        /// <p>A measure of how accurate the classifier results are for the test data. It is a combination of the <code>Micro Precision</code> and <code>Micro Recall</code> values. The <code>Micro F1Score</code> is the harmonic mean of the two scores. The highest score is 1, and the worst score is 0.</p>
        pub fn set_micro_f1_score(mut self, input: std::option::Option<f64>) -> Self {
            self.micro_f1_score = input;
            self
        }
        /// <p>Indicates the fraction of labels that are incorrectly predicted. Also seen as the fraction of wrong labels compared to the total number of labels. Scores closer to zero are better.</p>
        pub fn hamming_loss(mut self, input: f64) -> Self {
            self.hamming_loss = Some(input);
            self
        }
        /// <p>Indicates the fraction of labels that are incorrectly predicted. Also seen as the fraction of wrong labels compared to the total number of labels. Scores closer to zero are better.</p>
        pub fn set_hamming_loss(mut self, input: std::option::Option<f64>) -> Self {
            self.hamming_loss = input;
            self
        }
        /// Consumes the builder and constructs a [`ClassifierEvaluationMetrics`](crate::model::ClassifierEvaluationMetrics).
        pub fn build(self) -> crate::model::ClassifierEvaluationMetrics {
            crate::model::ClassifierEvaluationMetrics {
                accuracy: self.accuracy,
                precision: self.precision,
                recall: self.recall,
                f1_score: self.f1_score,
                micro_precision: self.micro_precision,
                micro_recall: self.micro_recall,
                micro_f1_score: self.micro_f1_score,
                hamming_loss: self.hamming_loss,
            }
        }
    }
}
impl ClassifierEvaluationMetrics {
    /// Creates a new builder-style object to manufacture [`ClassifierEvaluationMetrics`](crate::model::ClassifierEvaluationMetrics).
    pub fn builder() -> crate::model::classifier_evaluation_metrics::Builder {
        crate::model::classifier_evaluation_metrics::Builder::default()
    }
}

/// <p>Provides output results configuration parameters for custom classifier jobs. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentClassifierOutputDataConfig {
    /// <p>When you use the <code>OutputDataConfig</code> object while creating a custom classifier, you specify the Amazon S3 location where you want to write the confusion matrix. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of this output file.</p>
    /// <p>When the custom classifier job is finished, the service creates the output file in a directory specific to the job. The <code>S3Uri</code> field contains the location of the output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the confusion matrix.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>KMS Key Alias: <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>ARN of a KMS Key Alias: <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl DocumentClassifierOutputDataConfig {
    /// <p>When you use the <code>OutputDataConfig</code> object while creating a custom classifier, you specify the Amazon S3 location where you want to write the confusion matrix. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of this output file.</p>
    /// <p>When the custom classifier job is finished, the service creates the output file in a directory specific to the job. The <code>S3Uri</code> field contains the location of the output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the confusion matrix.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>KMS Key Alias: <code>"alias/ExampleAlias"</code> </p> </li>
    /// <li> <p>ARN of a KMS Key Alias: <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
    /// </ul>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
/// See [`DocumentClassifierOutputDataConfig`](crate::model::DocumentClassifierOutputDataConfig).
pub mod document_classifier_output_data_config {

    /// A builder for [`DocumentClassifierOutputDataConfig`](crate::model::DocumentClassifierOutputDataConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>When you use the <code>OutputDataConfig</code> object while creating a custom classifier, you specify the Amazon S3 location where you want to write the confusion matrix. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of this output file.</p>
        /// <p>When the custom classifier job is finished, the service creates the output file in a directory specific to the job. The <code>S3Uri</code> field contains the location of the output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the confusion matrix.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>When you use the <code>OutputDataConfig</code> object while creating a custom classifier, you specify the Amazon S3 location where you want to write the confusion matrix. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of this output file.</p>
        /// <p>When the custom classifier job is finished, the service creates the output file in a directory specific to the job. The <code>S3Uri</code> field contains the location of the output file, called <code>output.tar.gz</code>. It is a compressed archive that contains the confusion matrix.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>KMS Key Alias: <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>ARN of a KMS Key Alias: <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
        /// </ul>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt the output results from an analysis job. The KmsKeyId can be one of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>KMS Key Alias: <code>"alias/ExampleAlias"</code> </p> </li>
        /// <li> <p>ARN of a KMS Key Alias: <code>"arn:aws:kms:us-west-2:111122223333:alias/ExampleAlias"</code> </p> </li>
        /// </ul>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentClassifierOutputDataConfig`](crate::model::DocumentClassifierOutputDataConfig).
        pub fn build(self) -> crate::model::DocumentClassifierOutputDataConfig {
            crate::model::DocumentClassifierOutputDataConfig {
                s3_uri: self.s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl DocumentClassifierOutputDataConfig {
    /// Creates a new builder-style object to manufacture [`DocumentClassifierOutputDataConfig`](crate::model::DocumentClassifierOutputDataConfig).
    pub fn builder() -> crate::model::document_classifier_output_data_config::Builder {
        crate::model::document_classifier_output_data_config::Builder::default()
    }
}

/// <p>The input properties for training a document classifier. </p>
/// <p>For more information on how the input file is formatted, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/prep-classifier-data.html">Preparing training data</a> in the Comprehend Developer Guide. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentClassifierInputDataConfig {
    /// <p>The format of your training data:</p>
    /// <ul>
    /// <li> <p> <code>COMPREHEND_CSV</code>: A two-column CSV file, where labels are provided in the first column, and documents are provided in the second. If you use this value, you must provide the <code>S3Uri</code> parameter in your request.</p> </li>
    /// <li> <p> <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON object that contains a training document and its associated labels. </p> <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter in your request.</p> </li>
    /// </ul>
    /// <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the default.</p>
    #[doc(hidden)]
    pub data_format: std::option::Option<crate::model::DocumentClassifierDataFormat>,
    /// <p>The Amazon S3 URI for the input data. The S3 bucket must be in the same region as the API endpoint that you are calling. The URI can point to a single input file or it can provide the prefix for a collection of input files.</p>
    /// <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a single file, Amazon Comprehend uses that file as input. If more than one file begins with the prefix, Amazon Comprehend uses all of them as input.</p>
    /// <p>This parameter is required if you set <code>DataFormat</code> to <code>COMPREHEND_CSV</code>.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>This specifies the Amazon S3 location where the test annotations for an entity recognizer are located. The URI must be in the same AWS Region as the API endpoint that you are calling. </p>
    #[doc(hidden)]
    pub test_s3_uri: std::option::Option<std::string::String>,
    /// <p>Indicates the delimiter used to separate each label for training a multi-label classifier. The default delimiter between labels is a pipe (|). You can use a different character as a delimiter (if it's an allowed character) by specifying it under Delimiter for labels. If the training documents use a delimiter other than the default or the delimiter you specify, the labels on that line will be combined to make a single unique label, such as LABELLABELLABEL.</p>
    #[doc(hidden)]
    pub label_delimiter: std::option::Option<std::string::String>,
    /// <p>A list of augmented manifest files that provide training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
    /// <p>This parameter is required if you set <code>DataFormat</code> to <code>AUGMENTED_MANIFEST</code>.</p>
    #[doc(hidden)]
    pub augmented_manifests:
        std::option::Option<std::vec::Vec<crate::model::AugmentedManifestsListItem>>,
}
impl DocumentClassifierInputDataConfig {
    /// <p>The format of your training data:</p>
    /// <ul>
    /// <li> <p> <code>COMPREHEND_CSV</code>: A two-column CSV file, where labels are provided in the first column, and documents are provided in the second. If you use this value, you must provide the <code>S3Uri</code> parameter in your request.</p> </li>
    /// <li> <p> <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON object that contains a training document and its associated labels. </p> <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter in your request.</p> </li>
    /// </ul>
    /// <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the default.</p>
    pub fn data_format(&self) -> std::option::Option<&crate::model::DocumentClassifierDataFormat> {
        self.data_format.as_ref()
    }
    /// <p>The Amazon S3 URI for the input data. The S3 bucket must be in the same region as the API endpoint that you are calling. The URI can point to a single input file or it can provide the prefix for a collection of input files.</p>
    /// <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a single file, Amazon Comprehend uses that file as input. If more than one file begins with the prefix, Amazon Comprehend uses all of them as input.</p>
    /// <p>This parameter is required if you set <code>DataFormat</code> to <code>COMPREHEND_CSV</code>.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>This specifies the Amazon S3 location where the test annotations for an entity recognizer are located. The URI must be in the same AWS Region as the API endpoint that you are calling. </p>
    pub fn test_s3_uri(&self) -> std::option::Option<&str> {
        self.test_s3_uri.as_deref()
    }
    /// <p>Indicates the delimiter used to separate each label for training a multi-label classifier. The default delimiter between labels is a pipe (|). You can use a different character as a delimiter (if it's an allowed character) by specifying it under Delimiter for labels. If the training documents use a delimiter other than the default or the delimiter you specify, the labels on that line will be combined to make a single unique label, such as LABELLABELLABEL.</p>
    pub fn label_delimiter(&self) -> std::option::Option<&str> {
        self.label_delimiter.as_deref()
    }
    /// <p>A list of augmented manifest files that provide training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
    /// <p>This parameter is required if you set <code>DataFormat</code> to <code>AUGMENTED_MANIFEST</code>.</p>
    pub fn augmented_manifests(
        &self,
    ) -> std::option::Option<&[crate::model::AugmentedManifestsListItem]> {
        self.augmented_manifests.as_deref()
    }
}
/// See [`DocumentClassifierInputDataConfig`](crate::model::DocumentClassifierInputDataConfig).
pub mod document_classifier_input_data_config {

    /// A builder for [`DocumentClassifierInputDataConfig`](crate::model::DocumentClassifierInputDataConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_format: std::option::Option<crate::model::DocumentClassifierDataFormat>,
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) test_s3_uri: std::option::Option<std::string::String>,
        pub(crate) label_delimiter: std::option::Option<std::string::String>,
        pub(crate) augmented_manifests:
            std::option::Option<std::vec::Vec<crate::model::AugmentedManifestsListItem>>,
    }
    impl Builder {
        /// <p>The format of your training data:</p>
        /// <ul>
        /// <li> <p> <code>COMPREHEND_CSV</code>: A two-column CSV file, where labels are provided in the first column, and documents are provided in the second. If you use this value, you must provide the <code>S3Uri</code> parameter in your request.</p> </li>
        /// <li> <p> <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON object that contains a training document and its associated labels. </p> <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter in your request.</p> </li>
        /// </ul>
        /// <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the default.</p>
        pub fn data_format(mut self, input: crate::model::DocumentClassifierDataFormat) -> Self {
            self.data_format = Some(input);
            self
        }
        /// <p>The format of your training data:</p>
        /// <ul>
        /// <li> <p> <code>COMPREHEND_CSV</code>: A two-column CSV file, where labels are provided in the first column, and documents are provided in the second. If you use this value, you must provide the <code>S3Uri</code> parameter in your request.</p> </li>
        /// <li> <p> <code>AUGMENTED_MANIFEST</code>: A labeled dataset that is produced by Amazon SageMaker Ground Truth. This file is in JSON lines format. Each line is a complete JSON object that contains a training document and its associated labels. </p> <p>If you use this value, you must provide the <code>AugmentedManifests</code> parameter in your request.</p> </li>
        /// </ul>
        /// <p>If you don't specify a value, Amazon Comprehend uses <code>COMPREHEND_CSV</code> as the default.</p>
        pub fn set_data_format(
            mut self,
            input: std::option::Option<crate::model::DocumentClassifierDataFormat>,
        ) -> Self {
            self.data_format = input;
            self
        }
        /// <p>The Amazon S3 URI for the input data. The S3 bucket must be in the same region as the API endpoint that you are calling. The URI can point to a single input file or it can provide the prefix for a collection of input files.</p>
        /// <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a single file, Amazon Comprehend uses that file as input. If more than one file begins with the prefix, Amazon Comprehend uses all of them as input.</p>
        /// <p>This parameter is required if you set <code>DataFormat</code> to <code>COMPREHEND_CSV</code>.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 URI for the input data. The S3 bucket must be in the same region as the API endpoint that you are calling. The URI can point to a single input file or it can provide the prefix for a collection of input files.</p>
        /// <p>For example, if you use the URI <code>S3://bucketName/prefix</code>, if the prefix is a single file, Amazon Comprehend uses that file as input. If more than one file begins with the prefix, Amazon Comprehend uses all of them as input.</p>
        /// <p>This parameter is required if you set <code>DataFormat</code> to <code>COMPREHEND_CSV</code>.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>This specifies the Amazon S3 location where the test annotations for an entity recognizer are located. The URI must be in the same AWS Region as the API endpoint that you are calling. </p>
        pub fn test_s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.test_s3_uri = Some(input.into());
            self
        }
        /// <p>This specifies the Amazon S3 location where the test annotations for an entity recognizer are located. The URI must be in the same AWS Region as the API endpoint that you are calling. </p>
        pub fn set_test_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.test_s3_uri = input;
            self
        }
        /// <p>Indicates the delimiter used to separate each label for training a multi-label classifier. The default delimiter between labels is a pipe (|). You can use a different character as a delimiter (if it's an allowed character) by specifying it under Delimiter for labels. If the training documents use a delimiter other than the default or the delimiter you specify, the labels on that line will be combined to make a single unique label, such as LABELLABELLABEL.</p>
        pub fn label_delimiter(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_delimiter = Some(input.into());
            self
        }
        /// <p>Indicates the delimiter used to separate each label for training a multi-label classifier. The default delimiter between labels is a pipe (|). You can use a different character as a delimiter (if it's an allowed character) by specifying it under Delimiter for labels. If the training documents use a delimiter other than the default or the delimiter you specify, the labels on that line will be combined to make a single unique label, such as LABELLABELLABEL.</p>
        pub fn set_label_delimiter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.label_delimiter = input;
            self
        }
        /// Appends an item to `augmented_manifests`.
        ///
        /// To override the contents of this collection use [`set_augmented_manifests`](Self::set_augmented_manifests).
        ///
        /// <p>A list of augmented manifest files that provide training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
        /// <p>This parameter is required if you set <code>DataFormat</code> to <code>AUGMENTED_MANIFEST</code>.</p>
        pub fn augmented_manifests(
            mut self,
            input: crate::model::AugmentedManifestsListItem,
        ) -> Self {
            let mut v = self.augmented_manifests.unwrap_or_default();
            v.push(input);
            self.augmented_manifests = Some(v);
            self
        }
        /// <p>A list of augmented manifest files that provide training data for your custom model. An augmented manifest file is a labeled dataset that is produced by Amazon SageMaker Ground Truth.</p>
        /// <p>This parameter is required if you set <code>DataFormat</code> to <code>AUGMENTED_MANIFEST</code>.</p>
        pub fn set_augmented_manifests(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AugmentedManifestsListItem>>,
        ) -> Self {
            self.augmented_manifests = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentClassifierInputDataConfig`](crate::model::DocumentClassifierInputDataConfig).
        pub fn build(self) -> crate::model::DocumentClassifierInputDataConfig {
            crate::model::DocumentClassifierInputDataConfig {
                data_format: self.data_format,
                s3_uri: self.s3_uri,
                test_s3_uri: self.test_s3_uri,
                label_delimiter: self.label_delimiter,
                augmented_manifests: self.augmented_manifests,
            }
        }
    }
}
impl DocumentClassifierInputDataConfig {
    /// Creates a new builder-style object to manufacture [`DocumentClassifierInputDataConfig`](crate::model::DocumentClassifierInputDataConfig).
    pub fn builder() -> crate::model::document_classifier_input_data_config::Builder {
        crate::model::document_classifier_input_data_config::Builder::default()
    }
}

/// When writing a match expression against `DocumentClassifierDataFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let documentclassifierdataformat = unimplemented!();
/// match documentclassifierdataformat {
///     DocumentClassifierDataFormat::AugmentedManifest => { /* ... */ },
///     DocumentClassifierDataFormat::ComprehendCsv => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `documentclassifierdataformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DocumentClassifierDataFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DocumentClassifierDataFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DocumentClassifierDataFormat::NewFeature` is defined.
/// Specifically, when `documentclassifierdataformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DocumentClassifierDataFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentClassifierDataFormat {
    #[allow(missing_docs)] // documentation missing in model
    AugmentedManifest,
    #[allow(missing_docs)] // documentation missing in model
    ComprehendCsv,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DocumentClassifierDataFormat {
    fn from(s: &str) -> Self {
        match s {
            "AUGMENTED_MANIFEST" => DocumentClassifierDataFormat::AugmentedManifest,
            "COMPREHEND_CSV" => DocumentClassifierDataFormat::ComprehendCsv,
            other => DocumentClassifierDataFormat::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DocumentClassifierDataFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DocumentClassifierDataFormat::from(s))
    }
}
impl DocumentClassifierDataFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DocumentClassifierDataFormat::AugmentedManifest => "AUGMENTED_MANIFEST",
            DocumentClassifierDataFormat::ComprehendCsv => "COMPREHEND_CSV",
            DocumentClassifierDataFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUGMENTED_MANIFEST", "COMPREHEND_CSV"]
    }
}
impl AsRef<str> for DocumentClassifierDataFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information for filtering a list of document classifiers. You can only specify one filtering parameter in a request. For more information, see the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentClassifierFilter {
    /// <p>Filters the list of classifiers based on status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ModelStatus>,
    /// <p>The name that you assigned to the document classifier</p>
    #[doc(hidden)]
    pub document_classifier_name: std::option::Option<std::string::String>,
    /// <p>Filters the list of classifiers based on the time that the classifier was submitted for processing. Returns only classifiers submitted before the specified time. Classifiers are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of classifiers based on the time that the classifier was submitted for processing. Returns only classifiers submitted after the specified time. Classifiers are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl DocumentClassifierFilter {
    /// <p>Filters the list of classifiers based on status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ModelStatus> {
        self.status.as_ref()
    }
    /// <p>The name that you assigned to the document classifier</p>
    pub fn document_classifier_name(&self) -> std::option::Option<&str> {
        self.document_classifier_name.as_deref()
    }
    /// <p>Filters the list of classifiers based on the time that the classifier was submitted for processing. Returns only classifiers submitted before the specified time. Classifiers are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of classifiers based on the time that the classifier was submitted for processing. Returns only classifiers submitted after the specified time. Classifiers are returned in descending order, newest to oldest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`DocumentClassifierFilter`](crate::model::DocumentClassifierFilter).
pub mod document_classifier_filter {

    /// A builder for [`DocumentClassifierFilter`](crate::model::DocumentClassifierFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ModelStatus>,
        pub(crate) document_classifier_name: std::option::Option<std::string::String>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filters the list of classifiers based on status.</p>
        pub fn status(mut self, input: crate::model::ModelStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Filters the list of classifiers based on status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ModelStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The name that you assigned to the document classifier</p>
        pub fn document_classifier_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_classifier_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned to the document classifier</p>
        pub fn set_document_classifier_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_classifier_name = input;
            self
        }
        /// <p>Filters the list of classifiers based on the time that the classifier was submitted for processing. Returns only classifiers submitted before the specified time. Classifiers are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of classifiers based on the time that the classifier was submitted for processing. Returns only classifiers submitted before the specified time. Classifiers are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of classifiers based on the time that the classifier was submitted for processing. Returns only classifiers submitted after the specified time. Classifiers are returned in descending order, newest to oldest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of classifiers based on the time that the classifier was submitted for processing. Returns only classifiers submitted after the specified time. Classifiers are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentClassifierFilter`](crate::model::DocumentClassifierFilter).
        pub fn build(self) -> crate::model::DocumentClassifierFilter {
            crate::model::DocumentClassifierFilter {
                status: self.status,
                document_classifier_name: self.document_classifier_name,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl DocumentClassifierFilter {
    /// Creates a new builder-style object to manufacture [`DocumentClassifierFilter`](crate::model::DocumentClassifierFilter).
    pub fn builder() -> crate::model::document_classifier_filter::Builder {
        crate::model::document_classifier_filter::Builder::default()
    }
}

/// <p>Provides information about a document classification job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentClassificationJobProperties {
    /// <p>The identifier assigned to the document classification job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :document-classification-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    #[doc(hidden)]
    pub job_arn: std::option::Option<std::string::String>,
    /// <p>The name that you assigned to the document classification job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The current status of the document classification job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>A description of the status of the job.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the document classification job was submitted for processing.</p>
    #[doc(hidden)]
    pub submit_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time that the document classification job completed.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier. </p>
    #[doc(hidden)]
    pub document_classifier_arn: std::option::Option<std::string::String>,
    /// <p>The input data configuration that you supplied when you created the document classification job.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data configuration that you supplied when you created the document classification job.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub volume_kms_key_id: std::option::Option<std::string::String>,
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your document classification job. For more information, see <a href="https://docs.aws.amazon.com/vppc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    #[doc(hidden)]
    pub vpc_config: std::option::Option<crate::model::VpcConfig>,
}
impl DocumentClassificationJobProperties {
    /// <p>The identifier assigned to the document classification job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
    /// <p> <code>arn:
    /// <partition>
    /// :comprehend:
    /// <region>
    /// :
    /// <account-id>
    /// :document-classification-job/
    /// <job-id></job-id>
    /// </account-id>
    /// </region>
    /// </partition></code> </p>
    /// <p>The following is an example job ARN:</p>
    /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
    pub fn job_arn(&self) -> std::option::Option<&str> {
        self.job_arn.as_deref()
    }
    /// <p>The name that you assigned to the document classification job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The current status of the document classification job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>A description of the status of the job.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The time that the document classification job was submitted for processing.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time.as_ref()
    }
    /// <p>The time that the document classification job completed.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that identifies the document classifier. </p>
    pub fn document_classifier_arn(&self) -> std::option::Option<&str> {
        self.document_classifier_arn.as_deref()
    }
    /// <p>The input data configuration that you supplied when you created the document classification job.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data configuration that you supplied when you created the document classification job.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
    /// <ul>
    /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
    /// </ul>
    pub fn volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.volume_kms_key_id.as_deref()
    }
    /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your document classification job. For more information, see <a href="https://docs.aws.amazon.com/vppc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
    pub fn vpc_config(&self) -> std::option::Option<&crate::model::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
/// See [`DocumentClassificationJobProperties`](crate::model::DocumentClassificationJobProperties).
pub mod document_classification_job_properties {

    /// A builder for [`DocumentClassificationJobProperties`](crate::model::DocumentClassificationJobProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_arn: std::option::Option<std::string::String>,
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) document_classifier_arn: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) volume_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) vpc_config: std::option::Option<crate::model::VpcConfig>,
    }
    impl Builder {
        /// <p>The identifier assigned to the document classification job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier assigned to the document classification job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :document-classification-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn job_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the document classification job. It is a unique, fully qualified identifier for the job. It includes the AWS account, Region, and the job ID. The format of the ARN is as follows:</p>
        /// <p> <code>arn:
        /// <partition>
        /// :comprehend:
        /// <region>
        /// :
        /// <account-id>
        /// :document-classification-job/
        /// <job-id></job-id>
        /// </account-id>
        /// </region>
        /// </partition></code> </p>
        /// <p>The following is an example job ARN:</p>
        /// <p> <code>arn:aws:comprehend:us-west-2:111122223333:document-classification-job/1234abcd12ab34cd56ef1234567890ab</code> </p>
        pub fn set_job_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_arn = input;
            self
        }
        /// <p>The name that you assigned to the document classification job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The name that you assigned to the document classification job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The current status of the document classification job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the document classification job. If the status is <code>FAILED</code>, the <code>Message</code> field shows the reason for the failure.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>A description of the status of the job.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the status of the job.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the document classification job was submitted for processing.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The time that the document classification job was submitted for processing.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p>The time that the document classification job completed.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time that the document classification job completed.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the document classifier. </p>
        pub fn document_classifier_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_classifier_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the document classifier. </p>
        pub fn set_document_classifier_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.document_classifier_arn = input;
            self
        }
        /// <p>The input data configuration that you supplied when you created the document classification job.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data configuration that you supplied when you created the document classification job.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data configuration that you supplied when you created the document classification job.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data configuration that you supplied when you created the document classification job.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS identity and Access Management (IAM) role that grants Amazon Comprehend read access to your input data.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>ID for the AWS Key Management Service (KMS) key that Amazon Comprehend uses to encrypt data on the storage volume attached to the ML compute instance(s) that process the analysis job. The VolumeKmsKeyId can be either of the following formats:</p>
        /// <ul>
        /// <li> <p>KMS Key ID: <code>"1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// <li> <p>Amazon Resource Name (ARN) of a KMS Key: <code>"arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"</code> </p> </li>
        /// </ul>
        pub fn set_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_kms_key_id = input;
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your document classification job. For more information, see <a href="https://docs.aws.amazon.com/vppc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn vpc_config(mut self, input: crate::model::VpcConfig) -> Self {
            self.vpc_config = Some(input);
            self
        }
        /// <p> Configuration parameters for a private Virtual Private Cloud (VPC) containing the resources you are using for your document classification job. For more information, see <a href="https://docs.aws.amazon.com/vppc/latest/userguide/what-is-amazon-vpc.html">Amazon VPC</a>. </p>
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfig>,
        ) -> Self {
            self.vpc_config = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentClassificationJobProperties`](crate::model::DocumentClassificationJobProperties).
        pub fn build(self) -> crate::model::DocumentClassificationJobProperties {
            crate::model::DocumentClassificationJobProperties {
                job_id: self.job_id,
                job_arn: self.job_arn,
                job_name: self.job_name,
                job_status: self.job_status,
                message: self.message,
                submit_time: self.submit_time,
                end_time: self.end_time,
                document_classifier_arn: self.document_classifier_arn,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                data_access_role_arn: self.data_access_role_arn,
                volume_kms_key_id: self.volume_kms_key_id,
                vpc_config: self.vpc_config,
            }
        }
    }
}
impl DocumentClassificationJobProperties {
    /// Creates a new builder-style object to manufacture [`DocumentClassificationJobProperties`](crate::model::DocumentClassificationJobProperties).
    pub fn builder() -> crate::model::document_classification_job_properties::Builder {
        crate::model::document_classification_job_properties::Builder::default()
    }
}

/// <p>Provides information for filtering a list of document classification jobs. For more information, see the operation. You can provide only one filter parameter in each request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentClassificationJobFilter {
    /// <p>Filters on the name of the job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>Filters the list based on job status. Returns only jobs with the specified status.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    #[doc(hidden)]
    pub submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    #[doc(hidden)]
    pub submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl DocumentClassificationJobFilter {
    /// <p>Filters on the name of the job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>Filters the list based on job status. Returns only jobs with the specified status.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.job_status.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
    pub fn submit_time_before(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_before.as_ref()
    }
    /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
    pub fn submit_time_after(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.submit_time_after.as_ref()
    }
}
/// See [`DocumentClassificationJobFilter`](crate::model::DocumentClassificationJobFilter).
pub mod document_classification_job_filter {

    /// A builder for [`DocumentClassificationJobFilter`](crate::model::DocumentClassificationJobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) submit_time_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) submit_time_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Filters on the name of the job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>Filters on the name of the job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>Filters the list based on job status. Returns only jobs with the specified status.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>Filters the list based on job status. Returns only jobs with the specified status.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn submit_time_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_before = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.</p>
        pub fn set_submit_time_before(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_before = input;
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn submit_time_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.submit_time_after = Some(input);
            self
        }
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.</p>
        pub fn set_submit_time_after(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.submit_time_after = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentClassificationJobFilter`](crate::model::DocumentClassificationJobFilter).
        pub fn build(self) -> crate::model::DocumentClassificationJobFilter {
            crate::model::DocumentClassificationJobFilter {
                job_name: self.job_name,
                job_status: self.job_status,
                submit_time_before: self.submit_time_before,
                submit_time_after: self.submit_time_after,
            }
        }
    }
}
impl DocumentClassificationJobFilter {
    /// Creates a new builder-style object to manufacture [`DocumentClassificationJobFilter`](crate::model::DocumentClassificationJobFilter).
    pub fn builder() -> crate::model::document_classification_job_filter::Builder {
        crate::model::document_classification_job_filter::Builder::default()
    }
}

/// <p>Information about one of the entities found by targeted sentiment analysis.</p>
/// <p>For more information about targeted sentiment, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html">Targeted sentiment</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TargetedSentimentEntity {
    /// <p>One or more index into the Mentions array that provides the best name for the entity group.</p>
    #[doc(hidden)]
    pub descriptive_mention_index: std::option::Option<std::vec::Vec<i32>>,
    /// <p>An array of mentions of the entity in the document. The array represents a co-reference group. See <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html#how-targeted-sentiment-values"> Co-reference group</a> for an example. </p>
    #[doc(hidden)]
    pub mentions: std::option::Option<std::vec::Vec<crate::model::TargetedSentimentMention>>,
}
impl TargetedSentimentEntity {
    /// <p>One or more index into the Mentions array that provides the best name for the entity group.</p>
    pub fn descriptive_mention_index(&self) -> std::option::Option<&[i32]> {
        self.descriptive_mention_index.as_deref()
    }
    /// <p>An array of mentions of the entity in the document. The array represents a co-reference group. See <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html#how-targeted-sentiment-values"> Co-reference group</a> for an example. </p>
    pub fn mentions(&self) -> std::option::Option<&[crate::model::TargetedSentimentMention]> {
        self.mentions.as_deref()
    }
}
/// See [`TargetedSentimentEntity`](crate::model::TargetedSentimentEntity).
pub mod targeted_sentiment_entity {

    /// A builder for [`TargetedSentimentEntity`](crate::model::TargetedSentimentEntity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) descriptive_mention_index: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) mentions:
            std::option::Option<std::vec::Vec<crate::model::TargetedSentimentMention>>,
    }
    impl Builder {
        /// Appends an item to `descriptive_mention_index`.
        ///
        /// To override the contents of this collection use [`set_descriptive_mention_index`](Self::set_descriptive_mention_index).
        ///
        /// <p>One or more index into the Mentions array that provides the best name for the entity group.</p>
        pub fn descriptive_mention_index(mut self, input: i32) -> Self {
            let mut v = self.descriptive_mention_index.unwrap_or_default();
            v.push(input);
            self.descriptive_mention_index = Some(v);
            self
        }
        /// <p>One or more index into the Mentions array that provides the best name for the entity group.</p>
        pub fn set_descriptive_mention_index(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.descriptive_mention_index = input;
            self
        }
        /// Appends an item to `mentions`.
        ///
        /// To override the contents of this collection use [`set_mentions`](Self::set_mentions).
        ///
        /// <p>An array of mentions of the entity in the document. The array represents a co-reference group. See <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html#how-targeted-sentiment-values"> Co-reference group</a> for an example. </p>
        pub fn mentions(mut self, input: crate::model::TargetedSentimentMention) -> Self {
            let mut v = self.mentions.unwrap_or_default();
            v.push(input);
            self.mentions = Some(v);
            self
        }
        /// <p>An array of mentions of the entity in the document. The array represents a co-reference group. See <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html#how-targeted-sentiment-values"> Co-reference group</a> for an example. </p>
        pub fn set_mentions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetedSentimentMention>>,
        ) -> Self {
            self.mentions = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetedSentimentEntity`](crate::model::TargetedSentimentEntity).
        pub fn build(self) -> crate::model::TargetedSentimentEntity {
            crate::model::TargetedSentimentEntity {
                descriptive_mention_index: self.descriptive_mention_index,
                mentions: self.mentions,
            }
        }
    }
}
impl TargetedSentimentEntity {
    /// Creates a new builder-style object to manufacture [`TargetedSentimentEntity`](crate::model::TargetedSentimentEntity).
    pub fn builder() -> crate::model::targeted_sentiment_entity::Builder {
        crate::model::targeted_sentiment_entity::Builder::default()
    }
}

/// <p>Information about one mention of an entity. The mention information includes the location of the mention in the text and the sentiment of the mention.</p>
/// <p>For more information about targeted sentiment, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html">Targeted sentiment</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TargetedSentimentMention {
    /// <p>Model confidence that the entity is relevant. Value range is zero to one, where one is highest confidence.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f32>,
    /// <p>The confidence that all the entities mentioned in the group relate to the same entity.</p>
    #[doc(hidden)]
    pub group_score: std::option::Option<f32>,
    /// <p>The text in the document that identifies the entity.</p>
    #[doc(hidden)]
    pub text: std::option::Option<std::string::String>,
    /// <p>The type of the entity. Amazon Comprehend supports a variety of <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html#how-targeted-sentiment-entities">entity types</a>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::TargetedSentimentEntityType>,
    /// <p>Contains the sentiment and sentiment score for the mention.</p>
    #[doc(hidden)]
    pub mention_sentiment: std::option::Option<crate::model::MentionSentiment>,
    /// <p>The offset into the document text where the mention begins.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>The offset into the document text where the mention ends.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
}
impl TargetedSentimentMention {
    /// <p>Model confidence that the entity is relevant. Value range is zero to one, where one is highest confidence.</p>
    pub fn score(&self) -> std::option::Option<f32> {
        self.score
    }
    /// <p>The confidence that all the entities mentioned in the group relate to the same entity.</p>
    pub fn group_score(&self) -> std::option::Option<f32> {
        self.group_score
    }
    /// <p>The text in the document that identifies the entity.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The type of the entity. Amazon Comprehend supports a variety of <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html#how-targeted-sentiment-entities">entity types</a>.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TargetedSentimentEntityType> {
        self.r#type.as_ref()
    }
    /// <p>Contains the sentiment and sentiment score for the mention.</p>
    pub fn mention_sentiment(&self) -> std::option::Option<&crate::model::MentionSentiment> {
        self.mention_sentiment.as_ref()
    }
    /// <p>The offset into the document text where the mention begins.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The offset into the document text where the mention ends.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
}
/// See [`TargetedSentimentMention`](crate::model::TargetedSentimentMention).
pub mod targeted_sentiment_mention {

    /// A builder for [`TargetedSentimentMention`](crate::model::TargetedSentimentMention).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) score: std::option::Option<f32>,
        pub(crate) group_score: std::option::Option<f32>,
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::TargetedSentimentEntityType>,
        pub(crate) mention_sentiment: std::option::Option<crate::model::MentionSentiment>,
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Model confidence that the entity is relevant. Value range is zero to one, where one is highest confidence.</p>
        pub fn score(mut self, input: f32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>Model confidence that the entity is relevant. Value range is zero to one, where one is highest confidence.</p>
        pub fn set_score(mut self, input: std::option::Option<f32>) -> Self {
            self.score = input;
            self
        }
        /// <p>The confidence that all the entities mentioned in the group relate to the same entity.</p>
        pub fn group_score(mut self, input: f32) -> Self {
            self.group_score = Some(input);
            self
        }
        /// <p>The confidence that all the entities mentioned in the group relate to the same entity.</p>
        pub fn set_group_score(mut self, input: std::option::Option<f32>) -> Self {
            self.group_score = input;
            self
        }
        /// <p>The text in the document that identifies the entity.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The text in the document that identifies the entity.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>The type of the entity. Amazon Comprehend supports a variety of <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html#how-targeted-sentiment-entities">entity types</a>.</p>
        pub fn r#type(mut self, input: crate::model::TargetedSentimentEntityType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the entity. Amazon Comprehend supports a variety of <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html#how-targeted-sentiment-entities">entity types</a>.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TargetedSentimentEntityType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Contains the sentiment and sentiment score for the mention.</p>
        pub fn mention_sentiment(mut self, input: crate::model::MentionSentiment) -> Self {
            self.mention_sentiment = Some(input);
            self
        }
        /// <p>Contains the sentiment and sentiment score for the mention.</p>
        pub fn set_mention_sentiment(
            mut self,
            input: std::option::Option<crate::model::MentionSentiment>,
        ) -> Self {
            self.mention_sentiment = input;
            self
        }
        /// <p>The offset into the document text where the mention begins.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>The offset into the document text where the mention begins.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>The offset into the document text where the mention ends.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>The offset into the document text where the mention ends.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetedSentimentMention`](crate::model::TargetedSentimentMention).
        pub fn build(self) -> crate::model::TargetedSentimentMention {
            crate::model::TargetedSentimentMention {
                score: self.score,
                group_score: self.group_score,
                text: self.text,
                r#type: self.r#type,
                mention_sentiment: self.mention_sentiment,
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
            }
        }
    }
}
impl TargetedSentimentMention {
    /// Creates a new builder-style object to manufacture [`TargetedSentimentMention`](crate::model::TargetedSentimentMention).
    pub fn builder() -> crate::model::targeted_sentiment_mention::Builder {
        crate::model::targeted_sentiment_mention::Builder::default()
    }
}

/// <p>Contains the sentiment and sentiment score for one mention of an entity.</p>
/// <p>For more information about targeted sentiment, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-targeted-sentiment.html">Targeted sentiment</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MentionSentiment {
    /// <p>The sentiment of the mention. </p>
    #[doc(hidden)]
    pub sentiment: std::option::Option<crate::model::SentimentType>,
    /// <p>Describes the level of confidence that Amazon Comprehend has in the accuracy of its detection of sentiments.</p>
    #[doc(hidden)]
    pub sentiment_score: std::option::Option<crate::model::SentimentScore>,
}
impl MentionSentiment {
    /// <p>The sentiment of the mention. </p>
    pub fn sentiment(&self) -> std::option::Option<&crate::model::SentimentType> {
        self.sentiment.as_ref()
    }
    /// <p>Describes the level of confidence that Amazon Comprehend has in the accuracy of its detection of sentiments.</p>
    pub fn sentiment_score(&self) -> std::option::Option<&crate::model::SentimentScore> {
        self.sentiment_score.as_ref()
    }
}
/// See [`MentionSentiment`](crate::model::MentionSentiment).
pub mod mention_sentiment {

    /// A builder for [`MentionSentiment`](crate::model::MentionSentiment).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sentiment: std::option::Option<crate::model::SentimentType>,
        pub(crate) sentiment_score: std::option::Option<crate::model::SentimentScore>,
    }
    impl Builder {
        /// <p>The sentiment of the mention. </p>
        pub fn sentiment(mut self, input: crate::model::SentimentType) -> Self {
            self.sentiment = Some(input);
            self
        }
        /// <p>The sentiment of the mention. </p>
        pub fn set_sentiment(
            mut self,
            input: std::option::Option<crate::model::SentimentType>,
        ) -> Self {
            self.sentiment = input;
            self
        }
        /// <p>Describes the level of confidence that Amazon Comprehend has in the accuracy of its detection of sentiments.</p>
        pub fn sentiment_score(mut self, input: crate::model::SentimentScore) -> Self {
            self.sentiment_score = Some(input);
            self
        }
        /// <p>Describes the level of confidence that Amazon Comprehend has in the accuracy of its detection of sentiments.</p>
        pub fn set_sentiment_score(
            mut self,
            input: std::option::Option<crate::model::SentimentScore>,
        ) -> Self {
            self.sentiment_score = input;
            self
        }
        /// Consumes the builder and constructs a [`MentionSentiment`](crate::model::MentionSentiment).
        pub fn build(self) -> crate::model::MentionSentiment {
            crate::model::MentionSentiment {
                sentiment: self.sentiment,
                sentiment_score: self.sentiment_score,
            }
        }
    }
}
impl MentionSentiment {
    /// Creates a new builder-style object to manufacture [`MentionSentiment`](crate::model::MentionSentiment).
    pub fn builder() -> crate::model::mention_sentiment::Builder {
        crate::model::mention_sentiment::Builder::default()
    }
}

/// <p>Describes the level of confidence that Amazon Comprehend has in the accuracy of its detection of sentiments.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SentimentScore {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>POSITIVE</code> sentiment.</p>
    #[doc(hidden)]
    pub positive: std::option::Option<f32>,
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>NEGATIVE</code> sentiment.</p>
    #[doc(hidden)]
    pub negative: std::option::Option<f32>,
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>NEUTRAL</code> sentiment.</p>
    #[doc(hidden)]
    pub neutral: std::option::Option<f32>,
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>MIXED</code> sentiment.</p>
    #[doc(hidden)]
    pub mixed: std::option::Option<f32>,
}
impl SentimentScore {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>POSITIVE</code> sentiment.</p>
    pub fn positive(&self) -> std::option::Option<f32> {
        self.positive
    }
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>NEGATIVE</code> sentiment.</p>
    pub fn negative(&self) -> std::option::Option<f32> {
        self.negative
    }
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>NEUTRAL</code> sentiment.</p>
    pub fn neutral(&self) -> std::option::Option<f32> {
        self.neutral
    }
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>MIXED</code> sentiment.</p>
    pub fn mixed(&self) -> std::option::Option<f32> {
        self.mixed
    }
}
/// See [`SentimentScore`](crate::model::SentimentScore).
pub mod sentiment_score {

    /// A builder for [`SentimentScore`](crate::model::SentimentScore).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) positive: std::option::Option<f32>,
        pub(crate) negative: std::option::Option<f32>,
        pub(crate) neutral: std::option::Option<f32>,
        pub(crate) mixed: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>POSITIVE</code> sentiment.</p>
        pub fn positive(mut self, input: f32) -> Self {
            self.positive = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>POSITIVE</code> sentiment.</p>
        pub fn set_positive(mut self, input: std::option::Option<f32>) -> Self {
            self.positive = input;
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>NEGATIVE</code> sentiment.</p>
        pub fn negative(mut self, input: f32) -> Self {
            self.negative = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>NEGATIVE</code> sentiment.</p>
        pub fn set_negative(mut self, input: std::option::Option<f32>) -> Self {
            self.negative = input;
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>NEUTRAL</code> sentiment.</p>
        pub fn neutral(mut self, input: f32) -> Self {
            self.neutral = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>NEUTRAL</code> sentiment.</p>
        pub fn set_neutral(mut self, input: std::option::Option<f32>) -> Self {
            self.neutral = input;
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>MIXED</code> sentiment.</p>
        pub fn mixed(mut self, input: f32) -> Self {
            self.mixed = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its detection of the <code>MIXED</code> sentiment.</p>
        pub fn set_mixed(mut self, input: std::option::Option<f32>) -> Self {
            self.mixed = input;
            self
        }
        /// Consumes the builder and constructs a [`SentimentScore`](crate::model::SentimentScore).
        pub fn build(self) -> crate::model::SentimentScore {
            crate::model::SentimentScore {
                positive: self.positive,
                negative: self.negative,
                neutral: self.neutral,
                mixed: self.mixed,
            }
        }
    }
}
impl SentimentScore {
    /// Creates a new builder-style object to manufacture [`SentimentScore`](crate::model::SentimentScore).
    pub fn builder() -> crate::model::sentiment_score::Builder {
        crate::model::sentiment_score::Builder::default()
    }
}

/// When writing a match expression against `SentimentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sentimenttype = unimplemented!();
/// match sentimenttype {
///     SentimentType::Mixed => { /* ... */ },
///     SentimentType::Negative => { /* ... */ },
///     SentimentType::Neutral => { /* ... */ },
///     SentimentType::Positive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sentimenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SentimentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SentimentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SentimentType::NewFeature` is defined.
/// Specifically, when `sentimenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SentimentType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SentimentType {
    #[allow(missing_docs)] // documentation missing in model
    Mixed,
    #[allow(missing_docs)] // documentation missing in model
    Negative,
    #[allow(missing_docs)] // documentation missing in model
    Neutral,
    #[allow(missing_docs)] // documentation missing in model
    Positive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SentimentType {
    fn from(s: &str) -> Self {
        match s {
            "MIXED" => SentimentType::Mixed,
            "NEGATIVE" => SentimentType::Negative,
            "NEUTRAL" => SentimentType::Neutral,
            "POSITIVE" => SentimentType::Positive,
            other => SentimentType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SentimentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SentimentType::from(s))
    }
}
impl SentimentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SentimentType::Mixed => "MIXED",
            SentimentType::Negative => "NEGATIVE",
            SentimentType::Neutral => "NEUTRAL",
            SentimentType::Positive => "POSITIVE",
            SentimentType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MIXED", "NEGATIVE", "NEUTRAL", "POSITIVE"]
    }
}
impl AsRef<str> for SentimentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TargetedSentimentEntityType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetedsentimententitytype = unimplemented!();
/// match targetedsentimententitytype {
///     TargetedSentimentEntityType::Attribute => { /* ... */ },
///     TargetedSentimentEntityType::Book => { /* ... */ },
///     TargetedSentimentEntityType::Brand => { /* ... */ },
///     TargetedSentimentEntityType::CommercialItem => { /* ... */ },
///     TargetedSentimentEntityType::Date => { /* ... */ },
///     TargetedSentimentEntityType::Event => { /* ... */ },
///     TargetedSentimentEntityType::Facility => { /* ... */ },
///     TargetedSentimentEntityType::Game => { /* ... */ },
///     TargetedSentimentEntityType::Location => { /* ... */ },
///     TargetedSentimentEntityType::Movie => { /* ... */ },
///     TargetedSentimentEntityType::Music => { /* ... */ },
///     TargetedSentimentEntityType::Organization => { /* ... */ },
///     TargetedSentimentEntityType::Other => { /* ... */ },
///     TargetedSentimentEntityType::Person => { /* ... */ },
///     TargetedSentimentEntityType::PersonalTitle => { /* ... */ },
///     TargetedSentimentEntityType::Quantity => { /* ... */ },
///     TargetedSentimentEntityType::Software => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetedsentimententitytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetedSentimentEntityType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetedSentimentEntityType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetedSentimentEntityType::NewFeature` is defined.
/// Specifically, when `targetedsentimententitytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetedSentimentEntityType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetedSentimentEntityType {
    #[allow(missing_docs)] // documentation missing in model
    Attribute,
    #[allow(missing_docs)] // documentation missing in model
    Book,
    #[allow(missing_docs)] // documentation missing in model
    Brand,
    #[allow(missing_docs)] // documentation missing in model
    CommercialItem,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    Facility,
    #[allow(missing_docs)] // documentation missing in model
    Game,
    #[allow(missing_docs)] // documentation missing in model
    Location,
    #[allow(missing_docs)] // documentation missing in model
    Movie,
    #[allow(missing_docs)] // documentation missing in model
    Music,
    #[allow(missing_docs)] // documentation missing in model
    Organization,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    Person,
    #[allow(missing_docs)] // documentation missing in model
    PersonalTitle,
    #[allow(missing_docs)] // documentation missing in model
    Quantity,
    #[allow(missing_docs)] // documentation missing in model
    Software,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetedSentimentEntityType {
    fn from(s: &str) -> Self {
        match s {
            "ATTRIBUTE" => TargetedSentimentEntityType::Attribute,
            "BOOK" => TargetedSentimentEntityType::Book,
            "BRAND" => TargetedSentimentEntityType::Brand,
            "COMMERCIAL_ITEM" => TargetedSentimentEntityType::CommercialItem,
            "DATE" => TargetedSentimentEntityType::Date,
            "EVENT" => TargetedSentimentEntityType::Event,
            "FACILITY" => TargetedSentimentEntityType::Facility,
            "GAME" => TargetedSentimentEntityType::Game,
            "LOCATION" => TargetedSentimentEntityType::Location,
            "MOVIE" => TargetedSentimentEntityType::Movie,
            "MUSIC" => TargetedSentimentEntityType::Music,
            "ORGANIZATION" => TargetedSentimentEntityType::Organization,
            "OTHER" => TargetedSentimentEntityType::Other,
            "PERSON" => TargetedSentimentEntityType::Person,
            "PERSONAL_TITLE" => TargetedSentimentEntityType::PersonalTitle,
            "QUANTITY" => TargetedSentimentEntityType::Quantity,
            "SOFTWARE" => TargetedSentimentEntityType::Software,
            other => TargetedSentimentEntityType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for TargetedSentimentEntityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetedSentimentEntityType::from(s))
    }
}
impl TargetedSentimentEntityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetedSentimentEntityType::Attribute => "ATTRIBUTE",
            TargetedSentimentEntityType::Book => "BOOK",
            TargetedSentimentEntityType::Brand => "BRAND",
            TargetedSentimentEntityType::CommercialItem => "COMMERCIAL_ITEM",
            TargetedSentimentEntityType::Date => "DATE",
            TargetedSentimentEntityType::Event => "EVENT",
            TargetedSentimentEntityType::Facility => "FACILITY",
            TargetedSentimentEntityType::Game => "GAME",
            TargetedSentimentEntityType::Location => "LOCATION",
            TargetedSentimentEntityType::Movie => "MOVIE",
            TargetedSentimentEntityType::Music => "MUSIC",
            TargetedSentimentEntityType::Organization => "ORGANIZATION",
            TargetedSentimentEntityType::Other => "OTHER",
            TargetedSentimentEntityType::Person => "PERSON",
            TargetedSentimentEntityType::PersonalTitle => "PERSONAL_TITLE",
            TargetedSentimentEntityType::Quantity => "QUANTITY",
            TargetedSentimentEntityType::Software => "SOFTWARE",
            TargetedSentimentEntityType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ATTRIBUTE",
            "BOOK",
            "BRAND",
            "COMMERCIAL_ITEM",
            "DATE",
            "EVENT",
            "FACILITY",
            "GAME",
            "LOCATION",
            "MOVIE",
            "MUSIC",
            "ORGANIZATION",
            "OTHER",
            "PERSON",
            "PERSONAL_TITLE",
            "QUANTITY",
            "SOFTWARE",
        ]
    }
}
impl AsRef<str> for TargetedSentimentEntityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a work in the input text that was recognized and assigned a part of speech. There is one syntax token record for each word in the source text.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyntaxToken {
    /// <p>A unique identifier for a token.</p>
    #[doc(hidden)]
    pub token_id: std::option::Option<i32>,
    /// <p>The word that was recognized in the source text.</p>
    #[doc(hidden)]
    pub text: std::option::Option<std::string::String>,
    /// <p>The zero-based offset from the beginning of the source text to the first character in the word.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>The zero-based offset from the beginning of the source text to the last character in the word.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
    /// <p>Provides the part of speech label and the confidence level that Amazon Comprehend has that the part of speech was correctly identified. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide. </p>
    #[doc(hidden)]
    pub part_of_speech: std::option::Option<crate::model::PartOfSpeechTag>,
}
impl SyntaxToken {
    /// <p>A unique identifier for a token.</p>
    pub fn token_id(&self) -> std::option::Option<i32> {
        self.token_id
    }
    /// <p>The word that was recognized in the source text.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The zero-based offset from the beginning of the source text to the first character in the word.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The zero-based offset from the beginning of the source text to the last character in the word.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
    /// <p>Provides the part of speech label and the confidence level that Amazon Comprehend has that the part of speech was correctly identified. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide. </p>
    pub fn part_of_speech(&self) -> std::option::Option<&crate::model::PartOfSpeechTag> {
        self.part_of_speech.as_ref()
    }
}
/// See [`SyntaxToken`](crate::model::SyntaxToken).
pub mod syntax_token {

    /// A builder for [`SyntaxToken`](crate::model::SyntaxToken).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) token_id: std::option::Option<i32>,
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
        pub(crate) part_of_speech: std::option::Option<crate::model::PartOfSpeechTag>,
    }
    impl Builder {
        /// <p>A unique identifier for a token.</p>
        pub fn token_id(mut self, input: i32) -> Self {
            self.token_id = Some(input);
            self
        }
        /// <p>A unique identifier for a token.</p>
        pub fn set_token_id(mut self, input: std::option::Option<i32>) -> Self {
            self.token_id = input;
            self
        }
        /// <p>The word that was recognized in the source text.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The word that was recognized in the source text.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the first character in the word.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the first character in the word.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the last character in the word.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the last character in the word.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// <p>Provides the part of speech label and the confidence level that Amazon Comprehend has that the part of speech was correctly identified. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide. </p>
        pub fn part_of_speech(mut self, input: crate::model::PartOfSpeechTag) -> Self {
            self.part_of_speech = Some(input);
            self
        }
        /// <p>Provides the part of speech label and the confidence level that Amazon Comprehend has that the part of speech was correctly identified. For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide. </p>
        pub fn set_part_of_speech(
            mut self,
            input: std::option::Option<crate::model::PartOfSpeechTag>,
        ) -> Self {
            self.part_of_speech = input;
            self
        }
        /// Consumes the builder and constructs a [`SyntaxToken`](crate::model::SyntaxToken).
        pub fn build(self) -> crate::model::SyntaxToken {
            crate::model::SyntaxToken {
                token_id: self.token_id,
                text: self.text,
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
                part_of_speech: self.part_of_speech,
            }
        }
    }
}
impl SyntaxToken {
    /// Creates a new builder-style object to manufacture [`SyntaxToken`](crate::model::SyntaxToken).
    pub fn builder() -> crate::model::syntax_token::Builder {
        crate::model::syntax_token::Builder::default()
    }
}

/// <p>Identifies the part of speech represented by the token and gives the confidence that Amazon Comprehend has that the part of speech was correctly identified. For more information about the parts of speech that Amazon Comprehend can identify, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-syntax.html">Syntax</a> in the Comprehend Developer Guide. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PartOfSpeechTag {
    /// <p>Identifies the part of speech that the token represents.</p>
    #[doc(hidden)]
    pub tag: std::option::Option<crate::model::PartOfSpeechTagType>,
    /// <p>The confidence that Amazon Comprehend has that the part of speech was correctly identified.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f32>,
}
impl PartOfSpeechTag {
    /// <p>Identifies the part of speech that the token represents.</p>
    pub fn tag(&self) -> std::option::Option<&crate::model::PartOfSpeechTagType> {
        self.tag.as_ref()
    }
    /// <p>The confidence that Amazon Comprehend has that the part of speech was correctly identified.</p>
    pub fn score(&self) -> std::option::Option<f32> {
        self.score
    }
}
/// See [`PartOfSpeechTag`](crate::model::PartOfSpeechTag).
pub mod part_of_speech_tag {

    /// A builder for [`PartOfSpeechTag`](crate::model::PartOfSpeechTag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag: std::option::Option<crate::model::PartOfSpeechTagType>,
        pub(crate) score: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>Identifies the part of speech that the token represents.</p>
        pub fn tag(mut self, input: crate::model::PartOfSpeechTagType) -> Self {
            self.tag = Some(input);
            self
        }
        /// <p>Identifies the part of speech that the token represents.</p>
        pub fn set_tag(
            mut self,
            input: std::option::Option<crate::model::PartOfSpeechTagType>,
        ) -> Self {
            self.tag = input;
            self
        }
        /// <p>The confidence that Amazon Comprehend has that the part of speech was correctly identified.</p>
        pub fn score(mut self, input: f32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The confidence that Amazon Comprehend has that the part of speech was correctly identified.</p>
        pub fn set_score(mut self, input: std::option::Option<f32>) -> Self {
            self.score = input;
            self
        }
        /// Consumes the builder and constructs a [`PartOfSpeechTag`](crate::model::PartOfSpeechTag).
        pub fn build(self) -> crate::model::PartOfSpeechTag {
            crate::model::PartOfSpeechTag {
                tag: self.tag,
                score: self.score,
            }
        }
    }
}
impl PartOfSpeechTag {
    /// Creates a new builder-style object to manufacture [`PartOfSpeechTag`](crate::model::PartOfSpeechTag).
    pub fn builder() -> crate::model::part_of_speech_tag::Builder {
        crate::model::part_of_speech_tag::Builder::default()
    }
}

/// When writing a match expression against `PartOfSpeechTagType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let partofspeechtagtype = unimplemented!();
/// match partofspeechtagtype {
///     PartOfSpeechTagType::Adj => { /* ... */ },
///     PartOfSpeechTagType::Adp => { /* ... */ },
///     PartOfSpeechTagType::Adv => { /* ... */ },
///     PartOfSpeechTagType::Aux => { /* ... */ },
///     PartOfSpeechTagType::Cconj => { /* ... */ },
///     PartOfSpeechTagType::Conj => { /* ... */ },
///     PartOfSpeechTagType::Det => { /* ... */ },
///     PartOfSpeechTagType::Intj => { /* ... */ },
///     PartOfSpeechTagType::Noun => { /* ... */ },
///     PartOfSpeechTagType::Num => { /* ... */ },
///     PartOfSpeechTagType::O => { /* ... */ },
///     PartOfSpeechTagType::Part => { /* ... */ },
///     PartOfSpeechTagType::Pron => { /* ... */ },
///     PartOfSpeechTagType::Propn => { /* ... */ },
///     PartOfSpeechTagType::Punct => { /* ... */ },
///     PartOfSpeechTagType::Sconj => { /* ... */ },
///     PartOfSpeechTagType::Sym => { /* ... */ },
///     PartOfSpeechTagType::Verb => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `partofspeechtagtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PartOfSpeechTagType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PartOfSpeechTagType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PartOfSpeechTagType::NewFeature` is defined.
/// Specifically, when `partofspeechtagtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PartOfSpeechTagType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PartOfSpeechTagType {
    #[allow(missing_docs)] // documentation missing in model
    Adj,
    #[allow(missing_docs)] // documentation missing in model
    Adp,
    #[allow(missing_docs)] // documentation missing in model
    Adv,
    #[allow(missing_docs)] // documentation missing in model
    Aux,
    #[allow(missing_docs)] // documentation missing in model
    Cconj,
    #[allow(missing_docs)] // documentation missing in model
    Conj,
    #[allow(missing_docs)] // documentation missing in model
    Det,
    #[allow(missing_docs)] // documentation missing in model
    Intj,
    #[allow(missing_docs)] // documentation missing in model
    Noun,
    #[allow(missing_docs)] // documentation missing in model
    Num,
    #[allow(missing_docs)] // documentation missing in model
    O,
    #[allow(missing_docs)] // documentation missing in model
    Part,
    #[allow(missing_docs)] // documentation missing in model
    Pron,
    #[allow(missing_docs)] // documentation missing in model
    Propn,
    #[allow(missing_docs)] // documentation missing in model
    Punct,
    #[allow(missing_docs)] // documentation missing in model
    Sconj,
    #[allow(missing_docs)] // documentation missing in model
    Sym,
    #[allow(missing_docs)] // documentation missing in model
    Verb,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PartOfSpeechTagType {
    fn from(s: &str) -> Self {
        match s {
            "ADJ" => PartOfSpeechTagType::Adj,
            "ADP" => PartOfSpeechTagType::Adp,
            "ADV" => PartOfSpeechTagType::Adv,
            "AUX" => PartOfSpeechTagType::Aux,
            "CCONJ" => PartOfSpeechTagType::Cconj,
            "CONJ" => PartOfSpeechTagType::Conj,
            "DET" => PartOfSpeechTagType::Det,
            "INTJ" => PartOfSpeechTagType::Intj,
            "NOUN" => PartOfSpeechTagType::Noun,
            "NUM" => PartOfSpeechTagType::Num,
            "O" => PartOfSpeechTagType::O,
            "PART" => PartOfSpeechTagType::Part,
            "PRON" => PartOfSpeechTagType::Pron,
            "PROPN" => PartOfSpeechTagType::Propn,
            "PUNCT" => PartOfSpeechTagType::Punct,
            "SCONJ" => PartOfSpeechTagType::Sconj,
            "SYM" => PartOfSpeechTagType::Sym,
            "VERB" => PartOfSpeechTagType::Verb,
            other => {
                PartOfSpeechTagType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PartOfSpeechTagType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PartOfSpeechTagType::from(s))
    }
}
impl PartOfSpeechTagType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PartOfSpeechTagType::Adj => "ADJ",
            PartOfSpeechTagType::Adp => "ADP",
            PartOfSpeechTagType::Adv => "ADV",
            PartOfSpeechTagType::Aux => "AUX",
            PartOfSpeechTagType::Cconj => "CCONJ",
            PartOfSpeechTagType::Conj => "CONJ",
            PartOfSpeechTagType::Det => "DET",
            PartOfSpeechTagType::Intj => "INTJ",
            PartOfSpeechTagType::Noun => "NOUN",
            PartOfSpeechTagType::Num => "NUM",
            PartOfSpeechTagType::O => "O",
            PartOfSpeechTagType::Part => "PART",
            PartOfSpeechTagType::Pron => "PRON",
            PartOfSpeechTagType::Propn => "PROPN",
            PartOfSpeechTagType::Punct => "PUNCT",
            PartOfSpeechTagType::Sconj => "SCONJ",
            PartOfSpeechTagType::Sym => "SYM",
            PartOfSpeechTagType::Verb => "VERB",
            PartOfSpeechTagType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ADJ", "ADP", "ADV", "AUX", "CCONJ", "CONJ", "DET", "INTJ", "NOUN", "NUM", "O", "PART",
            "PRON", "PROPN", "PUNCT", "SCONJ", "SYM", "VERB",
        ]
    }
}
impl AsRef<str> for PartOfSpeechTagType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SyntaxLanguageCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let syntaxlanguagecode = unimplemented!();
/// match syntaxlanguagecode {
///     SyntaxLanguageCode::De => { /* ... */ },
///     SyntaxLanguageCode::En => { /* ... */ },
///     SyntaxLanguageCode::Es => { /* ... */ },
///     SyntaxLanguageCode::Fr => { /* ... */ },
///     SyntaxLanguageCode::It => { /* ... */ },
///     SyntaxLanguageCode::Pt => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `syntaxlanguagecode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SyntaxLanguageCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SyntaxLanguageCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SyntaxLanguageCode::NewFeature` is defined.
/// Specifically, when `syntaxlanguagecode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SyntaxLanguageCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SyntaxLanguageCode {
    #[allow(missing_docs)] // documentation missing in model
    De,
    #[allow(missing_docs)] // documentation missing in model
    En,
    #[allow(missing_docs)] // documentation missing in model
    Es,
    #[allow(missing_docs)] // documentation missing in model
    Fr,
    #[allow(missing_docs)] // documentation missing in model
    It,
    #[allow(missing_docs)] // documentation missing in model
    Pt,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SyntaxLanguageCode {
    fn from(s: &str) -> Self {
        match s {
            "de" => SyntaxLanguageCode::De,
            "en" => SyntaxLanguageCode::En,
            "es" => SyntaxLanguageCode::Es,
            "fr" => SyntaxLanguageCode::Fr,
            "it" => SyntaxLanguageCode::It,
            "pt" => SyntaxLanguageCode::Pt,
            other => {
                SyntaxLanguageCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SyntaxLanguageCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SyntaxLanguageCode::from(s))
    }
}
impl SyntaxLanguageCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SyntaxLanguageCode::De => "de",
            SyntaxLanguageCode::En => "en",
            SyntaxLanguageCode::Es => "es",
            SyntaxLanguageCode::Fr => "fr",
            SyntaxLanguageCode::It => "it",
            SyntaxLanguageCode::Pt => "pt",
            SyntaxLanguageCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["de", "en", "es", "fr", "it", "pt"]
    }
}
impl AsRef<str> for SyntaxLanguageCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about a PII entity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PiiEntity {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f32>,
    /// <p>The entity's type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PiiEntityType>,
    /// <p>The zero-based offset from the beginning of the source text to the first character in the entity.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>The zero-based offset from the beginning of the source text to the last character in the entity.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
}
impl PiiEntity {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    pub fn score(&self) -> std::option::Option<f32> {
        self.score
    }
    /// <p>The entity's type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PiiEntityType> {
        self.r#type.as_ref()
    }
    /// <p>The zero-based offset from the beginning of the source text to the first character in the entity.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The zero-based offset from the beginning of the source text to the last character in the entity.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
}
/// See [`PiiEntity`](crate::model::PiiEntity).
pub mod pii_entity {

    /// A builder for [`PiiEntity`](crate::model::PiiEntity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) score: std::option::Option<f32>,
        pub(crate) r#type: std::option::Option<crate::model::PiiEntityType>,
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn score(mut self, input: f32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn set_score(mut self, input: std::option::Option<f32>) -> Self {
            self.score = input;
            self
        }
        /// <p>The entity's type.</p>
        pub fn r#type(mut self, input: crate::model::PiiEntityType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The entity's type.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::PiiEntityType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the first character in the entity.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the first character in the entity.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the last character in the entity.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the last character in the entity.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`PiiEntity`](crate::model::PiiEntity).
        pub fn build(self) -> crate::model::PiiEntity {
            crate::model::PiiEntity {
                score: self.score,
                r#type: self.r#type,
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
            }
        }
    }
}
impl PiiEntity {
    /// Creates a new builder-style object to manufacture [`PiiEntity`](crate::model::PiiEntity).
    pub fn builder() -> crate::model::pii_entity::Builder {
        crate::model::pii_entity::Builder::default()
    }
}

/// <p>Describes a key noun phrase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KeyPhrase {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f32>,
    /// <p>The text of a key noun phrase.</p>
    #[doc(hidden)]
    pub text: std::option::Option<std::string::String>,
    /// <p>The zero-based offset from the beginning of the source text to the first character in the key phrase.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>The zero-based offset from the beginning of the source text to the last character in the key phrase.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
}
impl KeyPhrase {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    pub fn score(&self) -> std::option::Option<f32> {
        self.score
    }
    /// <p>The text of a key noun phrase.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The zero-based offset from the beginning of the source text to the first character in the key phrase.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The zero-based offset from the beginning of the source text to the last character in the key phrase.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
}
/// See [`KeyPhrase`](crate::model::KeyPhrase).
pub mod key_phrase {

    /// A builder for [`KeyPhrase`](crate::model::KeyPhrase).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) score: std::option::Option<f32>,
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn score(mut self, input: f32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn set_score(mut self, input: std::option::Option<f32>) -> Self {
            self.score = input;
            self
        }
        /// <p>The text of a key noun phrase.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The text of a key noun phrase.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the first character in the key phrase.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the first character in the key phrase.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the last character in the key phrase.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the last character in the key phrase.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`KeyPhrase`](crate::model::KeyPhrase).
        pub fn build(self) -> crate::model::KeyPhrase {
            crate::model::KeyPhrase {
                score: self.score,
                text: self.text,
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
            }
        }
    }
}
impl KeyPhrase {
    /// Creates a new builder-style object to manufacture [`KeyPhrase`](crate::model::KeyPhrase).
    pub fn builder() -> crate::model::key_phrase::Builder {
        crate::model::key_phrase::Builder::default()
    }
}

/// <p>Text extraction encountered one or more page-level errors in the input document.</p>
/// <p>The <code>ErrorCode</code> contains one of the following values:</p>
/// <ul>
/// <li> <p>TEXTRACT_BAD_PAGE - Amazon Textract cannot read the page. For more information about page limits in Amazon Textract, see <a href="https://docs.aws.amazon.com/textract/latest/dg/limits-document.html"> Page Quotas in Amazon Textract</a>.</p> </li>
/// <li> <p>TEXTRACT_PROVISIONED_THROUGHPUT_EXCEEDED - The number of requests exceeded your throughput limit. For more information about throughput quotas in Amazon Textract, see <a href="https://docs.aws.amazon.com/textract/latest/dg/limits-quotas-explained.html"> Default quotas in Amazon Textract</a>.</p> </li>
/// <li> <p>PAGE_CHARACTERS_EXCEEDED - Too many text characters on the page (10,000 characters maximum).</p> </li>
/// <li> <p>PAGE_SIZE_EXCEEDED - The maximum page size is 10 MB.</p> </li>
/// <li> <p>INTERNAL_SERVER_ERROR - The request encountered a service issue. Try the API request again.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorsListItem {
    /// <p>Page number where the error occurred.</p>
    #[doc(hidden)]
    pub page: std::option::Option<i32>,
    /// <p>Error code for the cause of the error.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::PageBasedErrorCode>,
    /// <p>Text message explaining the reason for the error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl ErrorsListItem {
    /// <p>Page number where the error occurred.</p>
    pub fn page(&self) -> std::option::Option<i32> {
        self.page
    }
    /// <p>Error code for the cause of the error.</p>
    pub fn error_code(&self) -> std::option::Option<&crate::model::PageBasedErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>Text message explaining the reason for the error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`ErrorsListItem`](crate::model::ErrorsListItem).
pub mod errors_list_item {

    /// A builder for [`ErrorsListItem`](crate::model::ErrorsListItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page: std::option::Option<i32>,
        pub(crate) error_code: std::option::Option<crate::model::PageBasedErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Page number where the error occurred.</p>
        pub fn page(mut self, input: i32) -> Self {
            self.page = Some(input);
            self
        }
        /// <p>Page number where the error occurred.</p>
        pub fn set_page(mut self, input: std::option::Option<i32>) -> Self {
            self.page = input;
            self
        }
        /// <p>Error code for the cause of the error.</p>
        pub fn error_code(mut self, input: crate::model::PageBasedErrorCode) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>Error code for the cause of the error.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::PageBasedErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>Text message explaining the reason for the error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Text message explaining the reason for the error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorsListItem`](crate::model::ErrorsListItem).
        pub fn build(self) -> crate::model::ErrorsListItem {
            crate::model::ErrorsListItem {
                page: self.page,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl ErrorsListItem {
    /// Creates a new builder-style object to manufacture [`ErrorsListItem`](crate::model::ErrorsListItem).
    pub fn builder() -> crate::model::errors_list_item::Builder {
        crate::model::errors_list_item::Builder::default()
    }
}

/// When writing a match expression against `PageBasedErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pagebasederrorcode = unimplemented!();
/// match pagebasederrorcode {
///     PageBasedErrorCode::InternalServerError => { /* ... */ },
///     PageBasedErrorCode::PageCharactersExceeded => { /* ... */ },
///     PageBasedErrorCode::PageSizeExceeded => { /* ... */ },
///     PageBasedErrorCode::TextractBadPage => { /* ... */ },
///     PageBasedErrorCode::TextractProvisionedThroughputExceeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pagebasederrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PageBasedErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PageBasedErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PageBasedErrorCode::NewFeature` is defined.
/// Specifically, when `pagebasederrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PageBasedErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PageBasedErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalServerError,
    #[allow(missing_docs)] // documentation missing in model
    PageCharactersExceeded,
    #[allow(missing_docs)] // documentation missing in model
    PageSizeExceeded,
    #[allow(missing_docs)] // documentation missing in model
    TextractBadPage,
    #[allow(missing_docs)] // documentation missing in model
    TextractProvisionedThroughputExceeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PageBasedErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_SERVER_ERROR" => PageBasedErrorCode::InternalServerError,
            "PAGE_CHARACTERS_EXCEEDED" => PageBasedErrorCode::PageCharactersExceeded,
            "PAGE_SIZE_EXCEEDED" => PageBasedErrorCode::PageSizeExceeded,
            "TEXTRACT_BAD_PAGE" => PageBasedErrorCode::TextractBadPage,
            "TEXTRACT_PROVISIONED_THROUGHPUT_EXCEEDED" => {
                PageBasedErrorCode::TextractProvisionedThroughputExceeded
            }
            other => {
                PageBasedErrorCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PageBasedErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PageBasedErrorCode::from(s))
    }
}
impl PageBasedErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PageBasedErrorCode::InternalServerError => "INTERNAL_SERVER_ERROR",
            PageBasedErrorCode::PageCharactersExceeded => "PAGE_CHARACTERS_EXCEEDED",
            PageBasedErrorCode::PageSizeExceeded => "PAGE_SIZE_EXCEEDED",
            PageBasedErrorCode::TextractBadPage => "TEXTRACT_BAD_PAGE",
            PageBasedErrorCode::TextractProvisionedThroughputExceeded => {
                "TEXTRACT_PROVISIONED_THROUGHPUT_EXCEEDED"
            }
            PageBasedErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "INTERNAL_SERVER_ERROR",
            "PAGE_CHARACTERS_EXCEEDED",
            "PAGE_SIZE_EXCEEDED",
            "TEXTRACT_BAD_PAGE",
            "TEXTRACT_PROVISIONED_THROUGHPUT_EXCEEDED",
        ]
    }
}
impl AsRef<str> for PageBasedErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about each word or line of text in the input document.</p>
/// <p>For additional information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/API_Block.html">Block</a> in the Amazon Textract API reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Block {
    /// <p>Unique identifier for the block.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The block represents a line of text or one word of text.</p>
    /// <ul>
    /// <li> <p>WORD - A word that's detected on a document page. A word is one or more ISO basic Latin script characters that aren't separated by spaces.</p> </li>
    /// <li> <p>LINE - A string of tab-delimited, contiguous words that are detected on a document page</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub block_type: std::option::Option<crate::model::BlockType>,
    /// <p>The word or line of text extracted from the block.</p>
    #[doc(hidden)]
    pub text: std::option::Option<std::string::String>,
    /// <p>Page number where the block appears.</p>
    #[doc(hidden)]
    pub page: std::option::Option<i32>,
    /// <p>Co-ordinates of the rectangle or polygon that contains the text.</p>
    #[doc(hidden)]
    pub geometry: std::option::Option<crate::model::Geometry>,
    /// <p>A list of child blocks of the current block. For example, a LINE object has child blocks for each WORD block that's part of the line of text. </p>
    #[doc(hidden)]
    pub relationships: std::option::Option<std::vec::Vec<crate::model::RelationshipsListItem>>,
}
impl Block {
    /// <p>Unique identifier for the block.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The block represents a line of text or one word of text.</p>
    /// <ul>
    /// <li> <p>WORD - A word that's detected on a document page. A word is one or more ISO basic Latin script characters that aren't separated by spaces.</p> </li>
    /// <li> <p>LINE - A string of tab-delimited, contiguous words that are detected on a document page</p> </li>
    /// </ul>
    pub fn block_type(&self) -> std::option::Option<&crate::model::BlockType> {
        self.block_type.as_ref()
    }
    /// <p>The word or line of text extracted from the block.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>Page number where the block appears.</p>
    pub fn page(&self) -> std::option::Option<i32> {
        self.page
    }
    /// <p>Co-ordinates of the rectangle or polygon that contains the text.</p>
    pub fn geometry(&self) -> std::option::Option<&crate::model::Geometry> {
        self.geometry.as_ref()
    }
    /// <p>A list of child blocks of the current block. For example, a LINE object has child blocks for each WORD block that's part of the line of text. </p>
    pub fn relationships(&self) -> std::option::Option<&[crate::model::RelationshipsListItem]> {
        self.relationships.as_deref()
    }
}
/// See [`Block`](crate::model::Block).
pub mod block {

    /// A builder for [`Block`](crate::model::Block).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) block_type: std::option::Option<crate::model::BlockType>,
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) page: std::option::Option<i32>,
        pub(crate) geometry: std::option::Option<crate::model::Geometry>,
        pub(crate) relationships:
            std::option::Option<std::vec::Vec<crate::model::RelationshipsListItem>>,
    }
    impl Builder {
        /// <p>Unique identifier for the block.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>Unique identifier for the block.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The block represents a line of text or one word of text.</p>
        /// <ul>
        /// <li> <p>WORD - A word that's detected on a document page. A word is one or more ISO basic Latin script characters that aren't separated by spaces.</p> </li>
        /// <li> <p>LINE - A string of tab-delimited, contiguous words that are detected on a document page</p> </li>
        /// </ul>
        pub fn block_type(mut self, input: crate::model::BlockType) -> Self {
            self.block_type = Some(input);
            self
        }
        /// <p>The block represents a line of text or one word of text.</p>
        /// <ul>
        /// <li> <p>WORD - A word that's detected on a document page. A word is one or more ISO basic Latin script characters that aren't separated by spaces.</p> </li>
        /// <li> <p>LINE - A string of tab-delimited, contiguous words that are detected on a document page</p> </li>
        /// </ul>
        pub fn set_block_type(
            mut self,
            input: std::option::Option<crate::model::BlockType>,
        ) -> Self {
            self.block_type = input;
            self
        }
        /// <p>The word or line of text extracted from the block.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The word or line of text extracted from the block.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>Page number where the block appears.</p>
        pub fn page(mut self, input: i32) -> Self {
            self.page = Some(input);
            self
        }
        /// <p>Page number where the block appears.</p>
        pub fn set_page(mut self, input: std::option::Option<i32>) -> Self {
            self.page = input;
            self
        }
        /// <p>Co-ordinates of the rectangle or polygon that contains the text.</p>
        pub fn geometry(mut self, input: crate::model::Geometry) -> Self {
            self.geometry = Some(input);
            self
        }
        /// <p>Co-ordinates of the rectangle or polygon that contains the text.</p>
        pub fn set_geometry(mut self, input: std::option::Option<crate::model::Geometry>) -> Self {
            self.geometry = input;
            self
        }
        /// Appends an item to `relationships`.
        ///
        /// To override the contents of this collection use [`set_relationships`](Self::set_relationships).
        ///
        /// <p>A list of child blocks of the current block. For example, a LINE object has child blocks for each WORD block that's part of the line of text. </p>
        pub fn relationships(mut self, input: crate::model::RelationshipsListItem) -> Self {
            let mut v = self.relationships.unwrap_or_default();
            v.push(input);
            self.relationships = Some(v);
            self
        }
        /// <p>A list of child blocks of the current block. For example, a LINE object has child blocks for each WORD block that's part of the line of text. </p>
        pub fn set_relationships(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelationshipsListItem>>,
        ) -> Self {
            self.relationships = input;
            self
        }
        /// Consumes the builder and constructs a [`Block`](crate::model::Block).
        pub fn build(self) -> crate::model::Block {
            crate::model::Block {
                id: self.id,
                block_type: self.block_type,
                text: self.text,
                page: self.page,
                geometry: self.geometry,
                relationships: self.relationships,
            }
        }
    }
}
impl Block {
    /// Creates a new builder-style object to manufacture [`Block`](crate::model::Block).
    pub fn builder() -> crate::model::block::Builder {
        crate::model::block::Builder::default()
    }
}

/// <p>List of child blocks for the current block.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelationshipsListItem {
    /// <p>Identifers of the child blocks.</p>
    #[doc(hidden)]
    pub ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Only supported relationship is a child relationship.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::RelationshipType>,
}
impl RelationshipsListItem {
    /// <p>Identifers of the child blocks.</p>
    pub fn ids(&self) -> std::option::Option<&[std::string::String]> {
        self.ids.as_deref()
    }
    /// <p>Only supported relationship is a child relationship.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::RelationshipType> {
        self.r#type.as_ref()
    }
}
/// See [`RelationshipsListItem`](crate::model::RelationshipsListItem).
pub mod relationships_list_item {

    /// A builder for [`RelationshipsListItem`](crate::model::RelationshipsListItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) r#type: std::option::Option<crate::model::RelationshipType>,
    }
    impl Builder {
        /// Appends an item to `ids`.
        ///
        /// To override the contents of this collection use [`set_ids`](Self::set_ids).
        ///
        /// <p>Identifers of the child blocks.</p>
        pub fn ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ids.unwrap_or_default();
            v.push(input.into());
            self.ids = Some(v);
            self
        }
        /// <p>Identifers of the child blocks.</p>
        pub fn set_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ids = input;
            self
        }
        /// <p>Only supported relationship is a child relationship.</p>
        pub fn r#type(mut self, input: crate::model::RelationshipType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Only supported relationship is a child relationship.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::RelationshipType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`RelationshipsListItem`](crate::model::RelationshipsListItem).
        pub fn build(self) -> crate::model::RelationshipsListItem {
            crate::model::RelationshipsListItem {
                ids: self.ids,
                r#type: self.r#type,
            }
        }
    }
}
impl RelationshipsListItem {
    /// Creates a new builder-style object to manufacture [`RelationshipsListItem`](crate::model::RelationshipsListItem).
    pub fn builder() -> crate::model::relationships_list_item::Builder {
        crate::model::relationships_list_item::Builder::default()
    }
}

/// When writing a match expression against `RelationshipType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let relationshiptype = unimplemented!();
/// match relationshiptype {
///     RelationshipType::Child => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `relationshiptype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RelationshipType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RelationshipType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RelationshipType::NewFeature` is defined.
/// Specifically, when `relationshiptype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RelationshipType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RelationshipType {
    #[allow(missing_docs)] // documentation missing in model
    Child,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RelationshipType {
    fn from(s: &str) -> Self {
        match s {
            "CHILD" => RelationshipType::Child,
            other => RelationshipType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RelationshipType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RelationshipType::from(s))
    }
}
impl RelationshipType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RelationshipType::Child => "CHILD",
            RelationshipType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CHILD"]
    }
}
impl AsRef<str> for RelationshipType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the location of items on a document page.</p>
/// <p>For additional information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/API_Geometry.html">Geometry</a> in the Amazon Textract API reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Geometry {
    /// <p>An axis-aligned coarse representation of the location of the recognized item on the document page.</p>
    #[doc(hidden)]
    pub bounding_box: std::option::Option<crate::model::BoundingBox>,
    /// <p>Within the bounding box, a fine-grained polygon around the recognized item.</p>
    #[doc(hidden)]
    pub polygon: std::option::Option<std::vec::Vec<crate::model::Point>>,
}
impl Geometry {
    /// <p>An axis-aligned coarse representation of the location of the recognized item on the document page.</p>
    pub fn bounding_box(&self) -> std::option::Option<&crate::model::BoundingBox> {
        self.bounding_box.as_ref()
    }
    /// <p>Within the bounding box, a fine-grained polygon around the recognized item.</p>
    pub fn polygon(&self) -> std::option::Option<&[crate::model::Point]> {
        self.polygon.as_deref()
    }
}
/// See [`Geometry`](crate::model::Geometry).
pub mod geometry {

    /// A builder for [`Geometry`](crate::model::Geometry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bounding_box: std::option::Option<crate::model::BoundingBox>,
        pub(crate) polygon: std::option::Option<std::vec::Vec<crate::model::Point>>,
    }
    impl Builder {
        /// <p>An axis-aligned coarse representation of the location of the recognized item on the document page.</p>
        pub fn bounding_box(mut self, input: crate::model::BoundingBox) -> Self {
            self.bounding_box = Some(input);
            self
        }
        /// <p>An axis-aligned coarse representation of the location of the recognized item on the document page.</p>
        pub fn set_bounding_box(
            mut self,
            input: std::option::Option<crate::model::BoundingBox>,
        ) -> Self {
            self.bounding_box = input;
            self
        }
        /// Appends an item to `polygon`.
        ///
        /// To override the contents of this collection use [`set_polygon`](Self::set_polygon).
        ///
        /// <p>Within the bounding box, a fine-grained polygon around the recognized item.</p>
        pub fn polygon(mut self, input: crate::model::Point) -> Self {
            let mut v = self.polygon.unwrap_or_default();
            v.push(input);
            self.polygon = Some(v);
            self
        }
        /// <p>Within the bounding box, a fine-grained polygon around the recognized item.</p>
        pub fn set_polygon(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Point>>,
        ) -> Self {
            self.polygon = input;
            self
        }
        /// Consumes the builder and constructs a [`Geometry`](crate::model::Geometry).
        pub fn build(self) -> crate::model::Geometry {
            crate::model::Geometry {
                bounding_box: self.bounding_box,
                polygon: self.polygon,
            }
        }
    }
}
impl Geometry {
    /// Creates a new builder-style object to manufacture [`Geometry`](crate::model::Geometry).
    pub fn builder() -> crate::model::geometry::Builder {
        crate::model::geometry::Builder::default()
    }
}

/// <p>The X and Y coordinates of a point on a document page.</p>
/// <p>For additional information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/API_Point.html">Point</a> in the Amazon Textract API reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Point {
    /// <p>The value of the X coordinate for a point on a polygon</p>
    #[doc(hidden)]
    pub x: std::option::Option<f32>,
    /// <p>The value of the Y coordinate for a point on a polygon</p>
    #[doc(hidden)]
    pub y: std::option::Option<f32>,
}
impl Point {
    /// <p>The value of the X coordinate for a point on a polygon</p>
    pub fn x(&self) -> std::option::Option<f32> {
        self.x
    }
    /// <p>The value of the Y coordinate for a point on a polygon</p>
    pub fn y(&self) -> std::option::Option<f32> {
        self.y
    }
}
/// See [`Point`](crate::model::Point).
pub mod point {

    /// A builder for [`Point`](crate::model::Point).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) x: std::option::Option<f32>,
        pub(crate) y: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The value of the X coordinate for a point on a polygon</p>
        pub fn x(mut self, input: f32) -> Self {
            self.x = Some(input);
            self
        }
        /// <p>The value of the X coordinate for a point on a polygon</p>
        pub fn set_x(mut self, input: std::option::Option<f32>) -> Self {
            self.x = input;
            self
        }
        /// <p>The value of the Y coordinate for a point on a polygon</p>
        pub fn y(mut self, input: f32) -> Self {
            self.y = Some(input);
            self
        }
        /// <p>The value of the Y coordinate for a point on a polygon</p>
        pub fn set_y(mut self, input: std::option::Option<f32>) -> Self {
            self.y = input;
            self
        }
        /// Consumes the builder and constructs a [`Point`](crate::model::Point).
        pub fn build(self) -> crate::model::Point {
            crate::model::Point {
                x: self.x,
                y: self.y,
            }
        }
    }
}
impl Point {
    /// Creates a new builder-style object to manufacture [`Point`](crate::model::Point).
    pub fn builder() -> crate::model::point::Builder {
        crate::model::point::Builder::default()
    }
}

/// <p>The bounding box around the detected page or around an element on a document page. The left (x-coordinate) and top (y-coordinate) are coordinates that represent the top and left sides of the bounding box. Note that the upper-left corner of the image is the origin (0,0). </p>
/// <p>For additional information, see <a href="https://docs.aws.amazon.com/textract/latest/dg/API_BoundingBox.html">BoundingBox</a> in the Amazon Textract API reference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BoundingBox {
    /// <p>The height of the bounding box as a ratio of the overall document page height.</p>
    #[doc(hidden)]
    pub height: std::option::Option<f32>,
    /// <p>The left coordinate of the bounding box as a ratio of overall document page width.</p>
    #[doc(hidden)]
    pub left: std::option::Option<f32>,
    /// <p>The top coordinate of the bounding box as a ratio of overall document page height.</p>
    #[doc(hidden)]
    pub top: std::option::Option<f32>,
    /// <p>The width of the bounding box as a ratio of the overall document page width.</p>
    #[doc(hidden)]
    pub width: std::option::Option<f32>,
}
impl BoundingBox {
    /// <p>The height of the bounding box as a ratio of the overall document page height.</p>
    pub fn height(&self) -> std::option::Option<f32> {
        self.height
    }
    /// <p>The left coordinate of the bounding box as a ratio of overall document page width.</p>
    pub fn left(&self) -> std::option::Option<f32> {
        self.left
    }
    /// <p>The top coordinate of the bounding box as a ratio of overall document page height.</p>
    pub fn top(&self) -> std::option::Option<f32> {
        self.top
    }
    /// <p>The width of the bounding box as a ratio of the overall document page width.</p>
    pub fn width(&self) -> std::option::Option<f32> {
        self.width
    }
}
/// See [`BoundingBox`](crate::model::BoundingBox).
pub mod bounding_box {

    /// A builder for [`BoundingBox`](crate::model::BoundingBox).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) height: std::option::Option<f32>,
        pub(crate) left: std::option::Option<f32>,
        pub(crate) top: std::option::Option<f32>,
        pub(crate) width: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The height of the bounding box as a ratio of the overall document page height.</p>
        pub fn height(mut self, input: f32) -> Self {
            self.height = Some(input);
            self
        }
        /// <p>The height of the bounding box as a ratio of the overall document page height.</p>
        pub fn set_height(mut self, input: std::option::Option<f32>) -> Self {
            self.height = input;
            self
        }
        /// <p>The left coordinate of the bounding box as a ratio of overall document page width.</p>
        pub fn left(mut self, input: f32) -> Self {
            self.left = Some(input);
            self
        }
        /// <p>The left coordinate of the bounding box as a ratio of overall document page width.</p>
        pub fn set_left(mut self, input: std::option::Option<f32>) -> Self {
            self.left = input;
            self
        }
        /// <p>The top coordinate of the bounding box as a ratio of overall document page height.</p>
        pub fn top(mut self, input: f32) -> Self {
            self.top = Some(input);
            self
        }
        /// <p>The top coordinate of the bounding box as a ratio of overall document page height.</p>
        pub fn set_top(mut self, input: std::option::Option<f32>) -> Self {
            self.top = input;
            self
        }
        /// <p>The width of the bounding box as a ratio of the overall document page width.</p>
        pub fn width(mut self, input: f32) -> Self {
            self.width = Some(input);
            self
        }
        /// <p>The width of the bounding box as a ratio of the overall document page width.</p>
        pub fn set_width(mut self, input: std::option::Option<f32>) -> Self {
            self.width = input;
            self
        }
        /// Consumes the builder and constructs a [`BoundingBox`](crate::model::BoundingBox).
        pub fn build(self) -> crate::model::BoundingBox {
            crate::model::BoundingBox {
                height: self.height,
                left: self.left,
                top: self.top,
                width: self.width,
            }
        }
    }
}
impl BoundingBox {
    /// Creates a new builder-style object to manufacture [`BoundingBox`](crate::model::BoundingBox).
    pub fn builder() -> crate::model::bounding_box::Builder {
        crate::model::bounding_box::Builder::default()
    }
}

/// When writing a match expression against `BlockType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let blocktype = unimplemented!();
/// match blocktype {
///     BlockType::Line => { /* ... */ },
///     BlockType::Word => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `blocktype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BlockType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BlockType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BlockType::NewFeature` is defined.
/// Specifically, when `blocktype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BlockType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BlockType {
    #[allow(missing_docs)] // documentation missing in model
    Line,
    #[allow(missing_docs)] // documentation missing in model
    Word,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BlockType {
    fn from(s: &str) -> Self {
        match s {
            "LINE" => BlockType::Line,
            "WORD" => BlockType::Word,
            other => BlockType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BlockType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BlockType::from(s))
    }
}
impl BlockType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BlockType::Line => "LINE",
            BlockType::Word => "WORD",
            BlockType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LINE", "WORD"]
    }
}
impl AsRef<str> for BlockType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Document type for each page in the document.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentTypeListItem {
    /// <p>Page number.</p>
    #[doc(hidden)]
    pub page: std::option::Option<i32>,
    /// <p>Document type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DocumentType>,
}
impl DocumentTypeListItem {
    /// <p>Page number.</p>
    pub fn page(&self) -> std::option::Option<i32> {
        self.page
    }
    /// <p>Document type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DocumentType> {
        self.r#type.as_ref()
    }
}
/// See [`DocumentTypeListItem`](crate::model::DocumentTypeListItem).
pub mod document_type_list_item {

    /// A builder for [`DocumentTypeListItem`](crate::model::DocumentTypeListItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<crate::model::DocumentType>,
    }
    impl Builder {
        /// <p>Page number.</p>
        pub fn page(mut self, input: i32) -> Self {
            self.page = Some(input);
            self
        }
        /// <p>Page number.</p>
        pub fn set_page(mut self, input: std::option::Option<i32>) -> Self {
            self.page = input;
            self
        }
        /// <p>Document type.</p>
        pub fn r#type(mut self, input: crate::model::DocumentType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Document type.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::DocumentType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentTypeListItem`](crate::model::DocumentTypeListItem).
        pub fn build(self) -> crate::model::DocumentTypeListItem {
            crate::model::DocumentTypeListItem {
                page: self.page,
                r#type: self.r#type,
            }
        }
    }
}
impl DocumentTypeListItem {
    /// Creates a new builder-style object to manufacture [`DocumentTypeListItem`](crate::model::DocumentTypeListItem).
    pub fn builder() -> crate::model::document_type_list_item::Builder {
        crate::model::document_type_list_item::Builder::default()
    }
}

/// When writing a match expression against `DocumentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let documenttype = unimplemented!();
/// match documenttype {
///     DocumentType::Image => { /* ... */ },
///     DocumentType::MsWord => { /* ... */ },
///     DocumentType::NativePdf => { /* ... */ },
///     DocumentType::PlainText => { /* ... */ },
///     DocumentType::ScannedPdf => { /* ... */ },
///     DocumentType::TextractAnalyzeDocumentJson => { /* ... */ },
///     DocumentType::TextractDetectDocumentTextJson => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `documenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DocumentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DocumentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DocumentType::NewFeature` is defined.
/// Specifically, when `documenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DocumentType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DocumentType {
    #[allow(missing_docs)] // documentation missing in model
    Image,
    #[allow(missing_docs)] // documentation missing in model
    MsWord,
    #[allow(missing_docs)] // documentation missing in model
    NativePdf,
    #[allow(missing_docs)] // documentation missing in model
    PlainText,
    #[allow(missing_docs)] // documentation missing in model
    ScannedPdf,
    #[allow(missing_docs)] // documentation missing in model
    TextractAnalyzeDocumentJson,
    #[allow(missing_docs)] // documentation missing in model
    TextractDetectDocumentTextJson,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DocumentType {
    fn from(s: &str) -> Self {
        match s {
            "IMAGE" => DocumentType::Image,
            "MS_WORD" => DocumentType::MsWord,
            "NATIVE_PDF" => DocumentType::NativePdf,
            "PLAIN_TEXT" => DocumentType::PlainText,
            "SCANNED_PDF" => DocumentType::ScannedPdf,
            "TEXTRACT_ANALYZE_DOCUMENT_JSON" => DocumentType::TextractAnalyzeDocumentJson,
            "TEXTRACT_DETECT_DOCUMENT_TEXT_JSON" => DocumentType::TextractDetectDocumentTextJson,
            other => DocumentType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DocumentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DocumentType::from(s))
    }
}
impl DocumentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DocumentType::Image => "IMAGE",
            DocumentType::MsWord => "MS_WORD",
            DocumentType::NativePdf => "NATIVE_PDF",
            DocumentType::PlainText => "PLAIN_TEXT",
            DocumentType::ScannedPdf => "SCANNED_PDF",
            DocumentType::TextractAnalyzeDocumentJson => "TEXTRACT_ANALYZE_DOCUMENT_JSON",
            DocumentType::TextractDetectDocumentTextJson => "TEXTRACT_DETECT_DOCUMENT_TEXT_JSON",
            DocumentType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "IMAGE",
            "MS_WORD",
            "NATIVE_PDF",
            "PLAIN_TEXT",
            "SCANNED_PDF",
            "TEXTRACT_ANALYZE_DOCUMENT_JSON",
            "TEXTRACT_DETECT_DOCUMENT_TEXT_JSON",
        ]
    }
}
impl AsRef<str> for DocumentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the document, discovered during text extraction.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentMetadata {
    /// <p>Number of pages in the document.</p>
    #[doc(hidden)]
    pub pages: std::option::Option<i32>,
    /// <p>List of pages in the document, with the number of characters extracted from each page.</p>
    #[doc(hidden)]
    pub extracted_characters:
        std::option::Option<std::vec::Vec<crate::model::ExtractedCharactersListItem>>,
}
impl DocumentMetadata {
    /// <p>Number of pages in the document.</p>
    pub fn pages(&self) -> std::option::Option<i32> {
        self.pages
    }
    /// <p>List of pages in the document, with the number of characters extracted from each page.</p>
    pub fn extracted_characters(
        &self,
    ) -> std::option::Option<&[crate::model::ExtractedCharactersListItem]> {
        self.extracted_characters.as_deref()
    }
}
/// See [`DocumentMetadata`](crate::model::DocumentMetadata).
pub mod document_metadata {

    /// A builder for [`DocumentMetadata`](crate::model::DocumentMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pages: std::option::Option<i32>,
        pub(crate) extracted_characters:
            std::option::Option<std::vec::Vec<crate::model::ExtractedCharactersListItem>>,
    }
    impl Builder {
        /// <p>Number of pages in the document.</p>
        pub fn pages(mut self, input: i32) -> Self {
            self.pages = Some(input);
            self
        }
        /// <p>Number of pages in the document.</p>
        pub fn set_pages(mut self, input: std::option::Option<i32>) -> Self {
            self.pages = input;
            self
        }
        /// Appends an item to `extracted_characters`.
        ///
        /// To override the contents of this collection use [`set_extracted_characters`](Self::set_extracted_characters).
        ///
        /// <p>List of pages in the document, with the number of characters extracted from each page.</p>
        pub fn extracted_characters(
            mut self,
            input: crate::model::ExtractedCharactersListItem,
        ) -> Self {
            let mut v = self.extracted_characters.unwrap_or_default();
            v.push(input);
            self.extracted_characters = Some(v);
            self
        }
        /// <p>List of pages in the document, with the number of characters extracted from each page.</p>
        pub fn set_extracted_characters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ExtractedCharactersListItem>>,
        ) -> Self {
            self.extracted_characters = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentMetadata`](crate::model::DocumentMetadata).
        pub fn build(self) -> crate::model::DocumentMetadata {
            crate::model::DocumentMetadata {
                pages: self.pages,
                extracted_characters: self.extracted_characters,
            }
        }
    }
}
impl DocumentMetadata {
    /// Creates a new builder-style object to manufacture [`DocumentMetadata`](crate::model::DocumentMetadata).
    pub fn builder() -> crate::model::document_metadata::Builder {
        crate::model::document_metadata::Builder::default()
    }
}

/// <p>Array of the number of characters extracted from each page.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExtractedCharactersListItem {
    /// <p>Page number.</p>
    #[doc(hidden)]
    pub page: std::option::Option<i32>,
    /// <p>Number of characters extracted from each page.</p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
}
impl ExtractedCharactersListItem {
    /// <p>Page number.</p>
    pub fn page(&self) -> std::option::Option<i32> {
        self.page
    }
    /// <p>Number of characters extracted from each page.</p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
/// See [`ExtractedCharactersListItem`](crate::model::ExtractedCharactersListItem).
pub mod extracted_characters_list_item {

    /// A builder for [`ExtractedCharactersListItem`](crate::model::ExtractedCharactersListItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page: std::option::Option<i32>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Page number.</p>
        pub fn page(mut self, input: i32) -> Self {
            self.page = Some(input);
            self
        }
        /// <p>Page number.</p>
        pub fn set_page(mut self, input: std::option::Option<i32>) -> Self {
            self.page = input;
            self
        }
        /// <p>Number of characters extracted from each page.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>Number of characters extracted from each page.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// Consumes the builder and constructs a [`ExtractedCharactersListItem`](crate::model::ExtractedCharactersListItem).
        pub fn build(self) -> crate::model::ExtractedCharactersListItem {
            crate::model::ExtractedCharactersListItem {
                page: self.page,
                count: self.count,
            }
        }
    }
}
impl ExtractedCharactersListItem {
    /// Creates a new builder-style object to manufacture [`ExtractedCharactersListItem`](crate::model::ExtractedCharactersListItem).
    pub fn builder() -> crate::model::extracted_characters_list_item::Builder {
        crate::model::extracted_characters_list_item::Builder::default()
    }
}

/// <p>Provides information about an entity. </p>
/// <p> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Entity {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f32>,
    /// <p>The entity type. For entity detection using the built-in model, this field contains one of the standard entity types listed below.</p>
    /// <p>For custom entity detection, this field contains one of the entity types that you specified when you trained your custom model.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::EntityType>,
    /// <p>The text of the entity.</p>
    #[doc(hidden)]
    pub text: std::option::Option<std::string::String>,
    /// <p>The zero-based offset from the beginning of the source text to the first character in the entity.</p>
    /// <p>This field is empty for non-text input.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>The zero-based offset from the beginning of the source text to the last character in the entity.</p>
    /// <p>This field is empty for non-text input.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
    /// <p>A reference to each block for this entity. This field is empty for plain-text input.</p>
    #[doc(hidden)]
    pub block_references: std::option::Option<std::vec::Vec<crate::model::BlockReference>>,
}
impl Entity {
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    pub fn score(&self) -> std::option::Option<f32> {
        self.score
    }
    /// <p>The entity type. For entity detection using the built-in model, this field contains one of the standard entity types listed below.</p>
    /// <p>For custom entity detection, this field contains one of the entity types that you specified when you trained your custom model.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::EntityType> {
        self.r#type.as_ref()
    }
    /// <p>The text of the entity.</p>
    pub fn text(&self) -> std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The zero-based offset from the beginning of the source text to the first character in the entity.</p>
    /// <p>This field is empty for non-text input.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The zero-based offset from the beginning of the source text to the last character in the entity.</p>
    /// <p>This field is empty for non-text input.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
    /// <p>A reference to each block for this entity. This field is empty for plain-text input.</p>
    pub fn block_references(&self) -> std::option::Option<&[crate::model::BlockReference]> {
        self.block_references.as_deref()
    }
}
/// See [`Entity`](crate::model::Entity).
pub mod entity {

    /// A builder for [`Entity`](crate::model::Entity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) score: std::option::Option<f32>,
        pub(crate) r#type: std::option::Option<crate::model::EntityType>,
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
        pub(crate) block_references:
            std::option::Option<std::vec::Vec<crate::model::BlockReference>>,
    }
    impl Builder {
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn score(mut self, input: f32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn set_score(mut self, input: std::option::Option<f32>) -> Self {
            self.score = input;
            self
        }
        /// <p>The entity type. For entity detection using the built-in model, this field contains one of the standard entity types listed below.</p>
        /// <p>For custom entity detection, this field contains one of the entity types that you specified when you trained your custom model.</p>
        pub fn r#type(mut self, input: crate::model::EntityType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The entity type. For entity detection using the built-in model, this field contains one of the standard entity types listed below.</p>
        /// <p>For custom entity detection, this field contains one of the entity types that you specified when you trained your custom model.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::EntityType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The text of the entity.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>The text of the entity.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the first character in the entity.</p>
        /// <p>This field is empty for non-text input.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the first character in the entity.</p>
        /// <p>This field is empty for non-text input.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the last character in the entity.</p>
        /// <p>This field is empty for non-text input.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>The zero-based offset from the beginning of the source text to the last character in the entity.</p>
        /// <p>This field is empty for non-text input.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// Appends an item to `block_references`.
        ///
        /// To override the contents of this collection use [`set_block_references`](Self::set_block_references).
        ///
        /// <p>A reference to each block for this entity. This field is empty for plain-text input.</p>
        pub fn block_references(mut self, input: crate::model::BlockReference) -> Self {
            let mut v = self.block_references.unwrap_or_default();
            v.push(input);
            self.block_references = Some(v);
            self
        }
        /// <p>A reference to each block for this entity. This field is empty for plain-text input.</p>
        pub fn set_block_references(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockReference>>,
        ) -> Self {
            self.block_references = input;
            self
        }
        /// Consumes the builder and constructs a [`Entity`](crate::model::Entity).
        pub fn build(self) -> crate::model::Entity {
            crate::model::Entity {
                score: self.score,
                r#type: self.r#type,
                text: self.text,
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
                block_references: self.block_references,
            }
        }
    }
}
impl Entity {
    /// Creates a new builder-style object to manufacture [`Entity`](crate::model::Entity).
    pub fn builder() -> crate::model::entity::Builder {
        crate::model::entity::Builder::default()
    }
}

/// <p>A reference to a block. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BlockReference {
    /// <p>Unique identifier for the block.</p>
    #[doc(hidden)]
    pub block_id: std::option::Option<std::string::String>,
    /// <p>Offset of the start of the block within its parent block.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>Offset of the end of the block within its parent block.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
    /// <p>List of child blocks within this block.</p>
    #[doc(hidden)]
    pub child_blocks: std::option::Option<std::vec::Vec<crate::model::ChildBlock>>,
}
impl BlockReference {
    /// <p>Unique identifier for the block.</p>
    pub fn block_id(&self) -> std::option::Option<&str> {
        self.block_id.as_deref()
    }
    /// <p>Offset of the start of the block within its parent block.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>Offset of the end of the block within its parent block.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
    /// <p>List of child blocks within this block.</p>
    pub fn child_blocks(&self) -> std::option::Option<&[crate::model::ChildBlock]> {
        self.child_blocks.as_deref()
    }
}
/// See [`BlockReference`](crate::model::BlockReference).
pub mod block_reference {

    /// A builder for [`BlockReference`](crate::model::BlockReference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) block_id: std::option::Option<std::string::String>,
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
        pub(crate) child_blocks: std::option::Option<std::vec::Vec<crate::model::ChildBlock>>,
    }
    impl Builder {
        /// <p>Unique identifier for the block.</p>
        pub fn block_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.block_id = Some(input.into());
            self
        }
        /// <p>Unique identifier for the block.</p>
        pub fn set_block_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.block_id = input;
            self
        }
        /// <p>Offset of the start of the block within its parent block.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>Offset of the start of the block within its parent block.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>Offset of the end of the block within its parent block.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>Offset of the end of the block within its parent block.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// Appends an item to `child_blocks`.
        ///
        /// To override the contents of this collection use [`set_child_blocks`](Self::set_child_blocks).
        ///
        /// <p>List of child blocks within this block.</p>
        pub fn child_blocks(mut self, input: crate::model::ChildBlock) -> Self {
            let mut v = self.child_blocks.unwrap_or_default();
            v.push(input);
            self.child_blocks = Some(v);
            self
        }
        /// <p>List of child blocks within this block.</p>
        pub fn set_child_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ChildBlock>>,
        ) -> Self {
            self.child_blocks = input;
            self
        }
        /// Consumes the builder and constructs a [`BlockReference`](crate::model::BlockReference).
        pub fn build(self) -> crate::model::BlockReference {
            crate::model::BlockReference {
                block_id: self.block_id,
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
                child_blocks: self.child_blocks,
            }
        }
    }
}
impl BlockReference {
    /// Creates a new builder-style object to manufacture [`BlockReference`](crate::model::BlockReference).
    pub fn builder() -> crate::model::block_reference::Builder {
        crate::model::block_reference::Builder::default()
    }
}

/// <p>Nested block contained within a block.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChildBlock {
    /// <p>Unique identifier for the child block.</p>
    #[doc(hidden)]
    pub child_block_id: std::option::Option<std::string::String>,
    /// <p>Offset of the start of the child block within its parent block.</p>
    #[doc(hidden)]
    pub begin_offset: std::option::Option<i32>,
    /// <p>Offset of the end of the child block within its parent block.</p>
    #[doc(hidden)]
    pub end_offset: std::option::Option<i32>,
}
impl ChildBlock {
    /// <p>Unique identifier for the child block.</p>
    pub fn child_block_id(&self) -> std::option::Option<&str> {
        self.child_block_id.as_deref()
    }
    /// <p>Offset of the start of the child block within its parent block.</p>
    pub fn begin_offset(&self) -> std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>Offset of the end of the child block within its parent block.</p>
    pub fn end_offset(&self) -> std::option::Option<i32> {
        self.end_offset
    }
}
/// See [`ChildBlock`](crate::model::ChildBlock).
pub mod child_block {

    /// A builder for [`ChildBlock`](crate::model::ChildBlock).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) child_block_id: std::option::Option<std::string::String>,
        pub(crate) begin_offset: std::option::Option<i32>,
        pub(crate) end_offset: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Unique identifier for the child block.</p>
        pub fn child_block_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.child_block_id = Some(input.into());
            self
        }
        /// <p>Unique identifier for the child block.</p>
        pub fn set_child_block_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.child_block_id = input;
            self
        }
        /// <p>Offset of the start of the child block within its parent block.</p>
        pub fn begin_offset(mut self, input: i32) -> Self {
            self.begin_offset = Some(input);
            self
        }
        /// <p>Offset of the start of the child block within its parent block.</p>
        pub fn set_begin_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.begin_offset = input;
            self
        }
        /// <p>Offset of the end of the child block within its parent block.</p>
        pub fn end_offset(mut self, input: i32) -> Self {
            self.end_offset = Some(input);
            self
        }
        /// <p>Offset of the end of the child block within its parent block.</p>
        pub fn set_end_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`ChildBlock`](crate::model::ChildBlock).
        pub fn build(self) -> crate::model::ChildBlock {
            crate::model::ChildBlock {
                child_block_id: self.child_block_id,
                begin_offset: self.begin_offset,
                end_offset: self.end_offset,
            }
        }
    }
}
impl ChildBlock {
    /// Creates a new builder-style object to manufacture [`ChildBlock`](crate::model::ChildBlock).
    pub fn builder() -> crate::model::child_block::Builder {
        crate::model::child_block::Builder::default()
    }
}

/// When writing a match expression against `EntityType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let entitytype = unimplemented!();
/// match entitytype {
///     EntityType::CommercialItem => { /* ... */ },
///     EntityType::Date => { /* ... */ },
///     EntityType::Event => { /* ... */ },
///     EntityType::Location => { /* ... */ },
///     EntityType::Organization => { /* ... */ },
///     EntityType::Other => { /* ... */ },
///     EntityType::Person => { /* ... */ },
///     EntityType::Quantity => { /* ... */ },
///     EntityType::Title => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `entitytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EntityType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EntityType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EntityType::NewFeature` is defined.
/// Specifically, when `entitytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EntityType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EntityType {
    #[allow(missing_docs)] // documentation missing in model
    CommercialItem,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    Location,
    #[allow(missing_docs)] // documentation missing in model
    Organization,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    Person,
    #[allow(missing_docs)] // documentation missing in model
    Quantity,
    #[allow(missing_docs)] // documentation missing in model
    Title,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EntityType {
    fn from(s: &str) -> Self {
        match s {
            "COMMERCIAL_ITEM" => EntityType::CommercialItem,
            "DATE" => EntityType::Date,
            "EVENT" => EntityType::Event,
            "LOCATION" => EntityType::Location,
            "ORGANIZATION" => EntityType::Organization,
            "OTHER" => EntityType::Other,
            "PERSON" => EntityType::Person,
            "QUANTITY" => EntityType::Quantity,
            "TITLE" => EntityType::Title,
            other => EntityType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EntityType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EntityType::from(s))
    }
}
impl EntityType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EntityType::CommercialItem => "COMMERCIAL_ITEM",
            EntityType::Date => "DATE",
            EntityType::Event => "EVENT",
            EntityType::Location => "LOCATION",
            EntityType::Organization => "ORGANIZATION",
            EntityType::Other => "OTHER",
            EntityType::Person => "PERSON",
            EntityType::Quantity => "QUANTITY",
            EntityType::Title => "TITLE",
            EntityType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMMERCIAL_ITEM",
            "DATE",
            "EVENT",
            "LOCATION",
            "ORGANIZATION",
            "OTHER",
            "PERSON",
            "QUANTITY",
            "TITLE",
        ]
    }
}
impl AsRef<str> for EntityType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns the code for the dominant language in the input text and the level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DominantLanguage {
    /// <p>The RFC 5646 language code for the dominant language. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the <i>IETF Tools</i> web site.</p>
    #[doc(hidden)]
    pub language_code: std::option::Option<std::string::String>,
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f32>,
}
impl DominantLanguage {
    /// <p>The RFC 5646 language code for the dominant language. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the <i>IETF Tools</i> web site.</p>
    pub fn language_code(&self) -> std::option::Option<&str> {
        self.language_code.as_deref()
    }
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    pub fn score(&self) -> std::option::Option<f32> {
        self.score
    }
}
/// See [`DominantLanguage`](crate::model::DominantLanguage).
pub mod dominant_language {

    /// A builder for [`DominantLanguage`](crate::model::DominantLanguage).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) language_code: std::option::Option<std::string::String>,
        pub(crate) score: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The RFC 5646 language code for the dominant language. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the <i>IETF Tools</i> web site.</p>
        pub fn language_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_code = Some(input.into());
            self
        }
        /// <p>The RFC 5646 language code for the dominant language. For more information about RFC 5646, see <a href="https://tools.ietf.org/html/rfc5646">Tags for Identifying Languages</a> on the <i>IETF Tools</i> web site.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn score(mut self, input: f32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn set_score(mut self, input: std::option::Option<f32>) -> Self {
            self.score = input;
            self
        }
        /// Consumes the builder and constructs a [`DominantLanguage`](crate::model::DominantLanguage).
        pub fn build(self) -> crate::model::DominantLanguage {
            crate::model::DominantLanguage {
                language_code: self.language_code,
                score: self.score,
            }
        }
    }
}
impl DominantLanguage {
    /// Creates a new builder-style object to manufacture [`DominantLanguage`](crate::model::DominantLanguage).
    pub fn builder() -> crate::model::dominant_language::Builder {
        crate::model::dominant_language::Builder::default()
    }
}

/// <p>Specifies one of the label or labels that categorize the personally identifiable information (PII) entity being analyzed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityLabel {
    /// <p>The name of the label.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::PiiEntityType>,
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f32>,
}
impl EntityLabel {
    /// <p>The name of the label.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::PiiEntityType> {
        self.name.as_ref()
    }
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
    pub fn score(&self) -> std::option::Option<f32> {
        self.score
    }
}
/// See [`EntityLabel`](crate::model::EntityLabel).
pub mod entity_label {

    /// A builder for [`EntityLabel`](crate::model::EntityLabel).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::PiiEntityType>,
        pub(crate) score: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The name of the label.</p>
        pub fn name(mut self, input: crate::model::PiiEntityType) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the label.</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::PiiEntityType>) -> Self {
            self.name = input;
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn score(mut self, input: f32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of the detection.</p>
        pub fn set_score(mut self, input: std::option::Option<f32>) -> Self {
            self.score = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityLabel`](crate::model::EntityLabel).
        pub fn build(self) -> crate::model::EntityLabel {
            crate::model::EntityLabel {
                name: self.name,
                score: self.score,
            }
        }
    }
}
impl EntityLabel {
    /// Creates a new builder-style object to manufacture [`EntityLabel`](crate::model::EntityLabel).
    pub fn builder() -> crate::model::entity_label::Builder {
        crate::model::entity_label::Builder::default()
    }
}

/// <p>Specifies one of the label or labels that categorize the document being analyzed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentLabel {
    /// <p>The name of the label.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The confidence score that Amazon Comprehend has this label correctly attributed.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f32>,
    /// <p>Page number where the label occurs. This field is present in the response only if your request includes the <code>Byte</code> parameter. </p>
    #[doc(hidden)]
    pub page: std::option::Option<i32>,
}
impl DocumentLabel {
    /// <p>The name of the label.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The confidence score that Amazon Comprehend has this label correctly attributed.</p>
    pub fn score(&self) -> std::option::Option<f32> {
        self.score
    }
    /// <p>Page number where the label occurs. This field is present in the response only if your request includes the <code>Byte</code> parameter. </p>
    pub fn page(&self) -> std::option::Option<i32> {
        self.page
    }
}
/// See [`DocumentLabel`](crate::model::DocumentLabel).
pub mod document_label {

    /// A builder for [`DocumentLabel`](crate::model::DocumentLabel).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) score: std::option::Option<f32>,
        pub(crate) page: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the label.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the label.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The confidence score that Amazon Comprehend has this label correctly attributed.</p>
        pub fn score(mut self, input: f32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The confidence score that Amazon Comprehend has this label correctly attributed.</p>
        pub fn set_score(mut self, input: std::option::Option<f32>) -> Self {
            self.score = input;
            self
        }
        /// <p>Page number where the label occurs. This field is present in the response only if your request includes the <code>Byte</code> parameter. </p>
        pub fn page(mut self, input: i32) -> Self {
            self.page = Some(input);
            self
        }
        /// <p>Page number where the label occurs. This field is present in the response only if your request includes the <code>Byte</code> parameter. </p>
        pub fn set_page(mut self, input: std::option::Option<i32>) -> Self {
            self.page = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentLabel`](crate::model::DocumentLabel).
        pub fn build(self) -> crate::model::DocumentLabel {
            crate::model::DocumentLabel {
                name: self.name,
                score: self.score,
                page: self.page,
            }
        }
    }
}
impl DocumentLabel {
    /// Creates a new builder-style object to manufacture [`DocumentLabel`](crate::model::DocumentLabel).
    pub fn builder() -> crate::model::document_label::Builder {
        crate::model::document_label::Builder::default()
    }
}

/// <p>Specifies the class that categorizes the document being analyzed</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentClass {
    /// <p>The name of the class.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The confidence score that Amazon Comprehend has this class correctly attributed.</p>
    #[doc(hidden)]
    pub score: std::option::Option<f32>,
    /// <p>Page number in the input document. This field is present in the response only if your request includes the <code>Byte</code> parameter. </p>
    #[doc(hidden)]
    pub page: std::option::Option<i32>,
}
impl DocumentClass {
    /// <p>The name of the class.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The confidence score that Amazon Comprehend has this class correctly attributed.</p>
    pub fn score(&self) -> std::option::Option<f32> {
        self.score
    }
    /// <p>Page number in the input document. This field is present in the response only if your request includes the <code>Byte</code> parameter. </p>
    pub fn page(&self) -> std::option::Option<i32> {
        self.page
    }
}
/// See [`DocumentClass`](crate::model::DocumentClass).
pub mod document_class {

    /// A builder for [`DocumentClass`](crate::model::DocumentClass).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) score: std::option::Option<f32>,
        pub(crate) page: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the class.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the class.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The confidence score that Amazon Comprehend has this class correctly attributed.</p>
        pub fn score(mut self, input: f32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The confidence score that Amazon Comprehend has this class correctly attributed.</p>
        pub fn set_score(mut self, input: std::option::Option<f32>) -> Self {
            self.score = input;
            self
        }
        /// <p>Page number in the input document. This field is present in the response only if your request includes the <code>Byte</code> parameter. </p>
        pub fn page(mut self, input: i32) -> Self {
            self.page = Some(input);
            self
        }
        /// <p>Page number in the input document. This field is present in the response only if your request includes the <code>Byte</code> parameter. </p>
        pub fn set_page(mut self, input: std::option::Option<i32>) -> Self {
            self.page = input;
            self
        }
        /// Consumes the builder and constructs a [`DocumentClass`](crate::model::DocumentClass).
        pub fn build(self) -> crate::model::DocumentClass {
            crate::model::DocumentClass {
                name: self.name,
                score: self.score,
                page: self.page,
            }
        }
    }
}
impl DocumentClass {
    /// Creates a new builder-style object to manufacture [`DocumentClass`](crate::model::DocumentClass).
    pub fn builder() -> crate::model::document_class::Builder {
        crate::model::document_class::Builder::default()
    }
}

/// <p>Describes an error that occurred while processing a document in a batch. The operation returns on <code>BatchItemError</code> object for each document that contained an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchItemError {
    /// <p>The zero-based index of the document in the input list.</p>
    #[doc(hidden)]
    pub index: std::option::Option<i32>,
    /// <p>The numeric error code of the error.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>A text description of the error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl BatchItemError {
    /// <p>The zero-based index of the document in the input list.</p>
    pub fn index(&self) -> std::option::Option<i32> {
        self.index
    }
    /// <p>The numeric error code of the error.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>A text description of the error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`BatchItemError`](crate::model::BatchItemError).
pub mod batch_item_error {

    /// A builder for [`BatchItemError`](crate::model::BatchItemError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index: std::option::Option<i32>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn index(mut self, input: i32) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn set_index(mut self, input: std::option::Option<i32>) -> Self {
            self.index = input;
            self
        }
        /// <p>The numeric error code of the error.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The numeric error code of the error.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>A text description of the error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A text description of the error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchItemError`](crate::model::BatchItemError).
        pub fn build(self) -> crate::model::BatchItemError {
            crate::model::BatchItemError {
                index: self.index,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl BatchItemError {
    /// Creates a new builder-style object to manufacture [`BatchItemError`](crate::model::BatchItemError).
    pub fn builder() -> crate::model::batch_item_error::Builder {
        crate::model::batch_item_error::Builder::default()
    }
}

/// <p>Analysis results for one of the documents in the batch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDetectTargetedSentimentItemResult {
    /// <p>The zero-based index of this result in the input list.</p>
    #[doc(hidden)]
    pub index: std::option::Option<i32>,
    /// <p>An array of targeted sentiment entities.</p>
    #[doc(hidden)]
    pub entities: std::option::Option<std::vec::Vec<crate::model::TargetedSentimentEntity>>,
}
impl BatchDetectTargetedSentimentItemResult {
    /// <p>The zero-based index of this result in the input list.</p>
    pub fn index(&self) -> std::option::Option<i32> {
        self.index
    }
    /// <p>An array of targeted sentiment entities.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::TargetedSentimentEntity]> {
        self.entities.as_deref()
    }
}
/// See [`BatchDetectTargetedSentimentItemResult`](crate::model::BatchDetectTargetedSentimentItemResult).
pub mod batch_detect_targeted_sentiment_item_result {

    /// A builder for [`BatchDetectTargetedSentimentItemResult`](crate::model::BatchDetectTargetedSentimentItemResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index: std::option::Option<i32>,
        pub(crate) entities:
            std::option::Option<std::vec::Vec<crate::model::TargetedSentimentEntity>>,
    }
    impl Builder {
        /// <p>The zero-based index of this result in the input list.</p>
        pub fn index(mut self, input: i32) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The zero-based index of this result in the input list.</p>
        pub fn set_index(mut self, input: std::option::Option<i32>) -> Self {
            self.index = input;
            self
        }
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>An array of targeted sentiment entities.</p>
        pub fn entities(mut self, input: crate::model::TargetedSentimentEntity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>An array of targeted sentiment entities.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetedSentimentEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectTargetedSentimentItemResult`](crate::model::BatchDetectTargetedSentimentItemResult).
        pub fn build(self) -> crate::model::BatchDetectTargetedSentimentItemResult {
            crate::model::BatchDetectTargetedSentimentItemResult {
                index: self.index,
                entities: self.entities,
            }
        }
    }
}
impl BatchDetectTargetedSentimentItemResult {
    /// Creates a new builder-style object to manufacture [`BatchDetectTargetedSentimentItemResult`](crate::model::BatchDetectTargetedSentimentItemResult).
    pub fn builder() -> crate::model::batch_detect_targeted_sentiment_item_result::Builder {
        crate::model::batch_detect_targeted_sentiment_item_result::Builder::default()
    }
}

/// <p>The result of calling the operation. The operation returns one object that is successfully processed by the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDetectSyntaxItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    #[doc(hidden)]
    pub index: std::option::Option<i32>,
    /// <p>The syntax tokens for the words in the document, one token for each word.</p>
    #[doc(hidden)]
    pub syntax_tokens: std::option::Option<std::vec::Vec<crate::model::SyntaxToken>>,
}
impl BatchDetectSyntaxItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    pub fn index(&self) -> std::option::Option<i32> {
        self.index
    }
    /// <p>The syntax tokens for the words in the document, one token for each word.</p>
    pub fn syntax_tokens(&self) -> std::option::Option<&[crate::model::SyntaxToken]> {
        self.syntax_tokens.as_deref()
    }
}
/// See [`BatchDetectSyntaxItemResult`](crate::model::BatchDetectSyntaxItemResult).
pub mod batch_detect_syntax_item_result {

    /// A builder for [`BatchDetectSyntaxItemResult`](crate::model::BatchDetectSyntaxItemResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index: std::option::Option<i32>,
        pub(crate) syntax_tokens: std::option::Option<std::vec::Vec<crate::model::SyntaxToken>>,
    }
    impl Builder {
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn index(mut self, input: i32) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn set_index(mut self, input: std::option::Option<i32>) -> Self {
            self.index = input;
            self
        }
        /// Appends an item to `syntax_tokens`.
        ///
        /// To override the contents of this collection use [`set_syntax_tokens`](Self::set_syntax_tokens).
        ///
        /// <p>The syntax tokens for the words in the document, one token for each word.</p>
        pub fn syntax_tokens(mut self, input: crate::model::SyntaxToken) -> Self {
            let mut v = self.syntax_tokens.unwrap_or_default();
            v.push(input);
            self.syntax_tokens = Some(v);
            self
        }
        /// <p>The syntax tokens for the words in the document, one token for each word.</p>
        pub fn set_syntax_tokens(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SyntaxToken>>,
        ) -> Self {
            self.syntax_tokens = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectSyntaxItemResult`](crate::model::BatchDetectSyntaxItemResult).
        pub fn build(self) -> crate::model::BatchDetectSyntaxItemResult {
            crate::model::BatchDetectSyntaxItemResult {
                index: self.index,
                syntax_tokens: self.syntax_tokens,
            }
        }
    }
}
impl BatchDetectSyntaxItemResult {
    /// Creates a new builder-style object to manufacture [`BatchDetectSyntaxItemResult`](crate::model::BatchDetectSyntaxItemResult).
    pub fn builder() -> crate::model::batch_detect_syntax_item_result::Builder {
        crate::model::batch_detect_syntax_item_result::Builder::default()
    }
}

/// <p>The result of calling the operation. The operation returns one object for each document that is successfully processed by the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDetectSentimentItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    #[doc(hidden)]
    pub index: std::option::Option<i32>,
    /// <p>The sentiment detected in the document.</p>
    #[doc(hidden)]
    pub sentiment: std::option::Option<crate::model::SentimentType>,
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its sentiment detection.</p>
    #[doc(hidden)]
    pub sentiment_score: std::option::Option<crate::model::SentimentScore>,
}
impl BatchDetectSentimentItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    pub fn index(&self) -> std::option::Option<i32> {
        self.index
    }
    /// <p>The sentiment detected in the document.</p>
    pub fn sentiment(&self) -> std::option::Option<&crate::model::SentimentType> {
        self.sentiment.as_ref()
    }
    /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its sentiment detection.</p>
    pub fn sentiment_score(&self) -> std::option::Option<&crate::model::SentimentScore> {
        self.sentiment_score.as_ref()
    }
}
/// See [`BatchDetectSentimentItemResult`](crate::model::BatchDetectSentimentItemResult).
pub mod batch_detect_sentiment_item_result {

    /// A builder for [`BatchDetectSentimentItemResult`](crate::model::BatchDetectSentimentItemResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index: std::option::Option<i32>,
        pub(crate) sentiment: std::option::Option<crate::model::SentimentType>,
        pub(crate) sentiment_score: std::option::Option<crate::model::SentimentScore>,
    }
    impl Builder {
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn index(mut self, input: i32) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn set_index(mut self, input: std::option::Option<i32>) -> Self {
            self.index = input;
            self
        }
        /// <p>The sentiment detected in the document.</p>
        pub fn sentiment(mut self, input: crate::model::SentimentType) -> Self {
            self.sentiment = Some(input);
            self
        }
        /// <p>The sentiment detected in the document.</p>
        pub fn set_sentiment(
            mut self,
            input: std::option::Option<crate::model::SentimentType>,
        ) -> Self {
            self.sentiment = input;
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its sentiment detection.</p>
        pub fn sentiment_score(mut self, input: crate::model::SentimentScore) -> Self {
            self.sentiment_score = Some(input);
            self
        }
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy of its sentiment detection.</p>
        pub fn set_sentiment_score(
            mut self,
            input: std::option::Option<crate::model::SentimentScore>,
        ) -> Self {
            self.sentiment_score = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectSentimentItemResult`](crate::model::BatchDetectSentimentItemResult).
        pub fn build(self) -> crate::model::BatchDetectSentimentItemResult {
            crate::model::BatchDetectSentimentItemResult {
                index: self.index,
                sentiment: self.sentiment,
                sentiment_score: self.sentiment_score,
            }
        }
    }
}
impl BatchDetectSentimentItemResult {
    /// Creates a new builder-style object to manufacture [`BatchDetectSentimentItemResult`](crate::model::BatchDetectSentimentItemResult).
    pub fn builder() -> crate::model::batch_detect_sentiment_item_result::Builder {
        crate::model::batch_detect_sentiment_item_result::Builder::default()
    }
}

/// <p>The result of calling the operation. The operation returns one object for each document that is successfully processed by the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDetectKeyPhrasesItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    #[doc(hidden)]
    pub index: std::option::Option<i32>,
    /// <p>One or more <code>KeyPhrase</code> objects, one for each key phrase detected in the document.</p>
    #[doc(hidden)]
    pub key_phrases: std::option::Option<std::vec::Vec<crate::model::KeyPhrase>>,
}
impl BatchDetectKeyPhrasesItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    pub fn index(&self) -> std::option::Option<i32> {
        self.index
    }
    /// <p>One or more <code>KeyPhrase</code> objects, one for each key phrase detected in the document.</p>
    pub fn key_phrases(&self) -> std::option::Option<&[crate::model::KeyPhrase]> {
        self.key_phrases.as_deref()
    }
}
/// See [`BatchDetectKeyPhrasesItemResult`](crate::model::BatchDetectKeyPhrasesItemResult).
pub mod batch_detect_key_phrases_item_result {

    /// A builder for [`BatchDetectKeyPhrasesItemResult`](crate::model::BatchDetectKeyPhrasesItemResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index: std::option::Option<i32>,
        pub(crate) key_phrases: std::option::Option<std::vec::Vec<crate::model::KeyPhrase>>,
    }
    impl Builder {
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn index(mut self, input: i32) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn set_index(mut self, input: std::option::Option<i32>) -> Self {
            self.index = input;
            self
        }
        /// Appends an item to `key_phrases`.
        ///
        /// To override the contents of this collection use [`set_key_phrases`](Self::set_key_phrases).
        ///
        /// <p>One or more <code>KeyPhrase</code> objects, one for each key phrase detected in the document.</p>
        pub fn key_phrases(mut self, input: crate::model::KeyPhrase) -> Self {
            let mut v = self.key_phrases.unwrap_or_default();
            v.push(input);
            self.key_phrases = Some(v);
            self
        }
        /// <p>One or more <code>KeyPhrase</code> objects, one for each key phrase detected in the document.</p>
        pub fn set_key_phrases(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::KeyPhrase>>,
        ) -> Self {
            self.key_phrases = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectKeyPhrasesItemResult`](crate::model::BatchDetectKeyPhrasesItemResult).
        pub fn build(self) -> crate::model::BatchDetectKeyPhrasesItemResult {
            crate::model::BatchDetectKeyPhrasesItemResult {
                index: self.index,
                key_phrases: self.key_phrases,
            }
        }
    }
}
impl BatchDetectKeyPhrasesItemResult {
    /// Creates a new builder-style object to manufacture [`BatchDetectKeyPhrasesItemResult`](crate::model::BatchDetectKeyPhrasesItemResult).
    pub fn builder() -> crate::model::batch_detect_key_phrases_item_result::Builder {
        crate::model::batch_detect_key_phrases_item_result::Builder::default()
    }
}

/// <p>The result of calling the operation. The operation returns one object for each document that is successfully processed by the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDetectEntitiesItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    #[doc(hidden)]
    pub index: std::option::Option<i32>,
    /// <p>One or more <code>Entity</code> objects, one for each entity detected in the document.</p>
    #[doc(hidden)]
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
}
impl BatchDetectEntitiesItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    pub fn index(&self) -> std::option::Option<i32> {
        self.index
    }
    /// <p>One or more <code>Entity</code> objects, one for each entity detected in the document.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.entities.as_deref()
    }
}
/// See [`BatchDetectEntitiesItemResult`](crate::model::BatchDetectEntitiesItemResult).
pub mod batch_detect_entities_item_result {

    /// A builder for [`BatchDetectEntitiesItemResult`](crate::model::BatchDetectEntitiesItemResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index: std::option::Option<i32>,
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    }
    impl Builder {
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn index(mut self, input: i32) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn set_index(mut self, input: std::option::Option<i32>) -> Self {
            self.index = input;
            self
        }
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>One or more <code>Entity</code> objects, one for each entity detected in the document.</p>
        pub fn entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>One or more <code>Entity</code> objects, one for each entity detected in the document.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectEntitiesItemResult`](crate::model::BatchDetectEntitiesItemResult).
        pub fn build(self) -> crate::model::BatchDetectEntitiesItemResult {
            crate::model::BatchDetectEntitiesItemResult {
                index: self.index,
                entities: self.entities,
            }
        }
    }
}
impl BatchDetectEntitiesItemResult {
    /// Creates a new builder-style object to manufacture [`BatchDetectEntitiesItemResult`](crate::model::BatchDetectEntitiesItemResult).
    pub fn builder() -> crate::model::batch_detect_entities_item_result::Builder {
        crate::model::batch_detect_entities_item_result::Builder::default()
    }
}

/// <p>The result of calling the operation. The operation returns one object for each document that is successfully processed by the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDetectDominantLanguageItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    #[doc(hidden)]
    pub index: std::option::Option<i32>,
    /// <p>One or more <code>DominantLanguage</code> objects describing the dominant languages in the document.</p>
    #[doc(hidden)]
    pub languages: std::option::Option<std::vec::Vec<crate::model::DominantLanguage>>,
}
impl BatchDetectDominantLanguageItemResult {
    /// <p>The zero-based index of the document in the input list.</p>
    pub fn index(&self) -> std::option::Option<i32> {
        self.index
    }
    /// <p>One or more <code>DominantLanguage</code> objects describing the dominant languages in the document.</p>
    pub fn languages(&self) -> std::option::Option<&[crate::model::DominantLanguage]> {
        self.languages.as_deref()
    }
}
/// See [`BatchDetectDominantLanguageItemResult`](crate::model::BatchDetectDominantLanguageItemResult).
pub mod batch_detect_dominant_language_item_result {

    /// A builder for [`BatchDetectDominantLanguageItemResult`](crate::model::BatchDetectDominantLanguageItemResult).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index: std::option::Option<i32>,
        pub(crate) languages: std::option::Option<std::vec::Vec<crate::model::DominantLanguage>>,
    }
    impl Builder {
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn index(mut self, input: i32) -> Self {
            self.index = Some(input);
            self
        }
        /// <p>The zero-based index of the document in the input list.</p>
        pub fn set_index(mut self, input: std::option::Option<i32>) -> Self {
            self.index = input;
            self
        }
        /// Appends an item to `languages`.
        ///
        /// To override the contents of this collection use [`set_languages`](Self::set_languages).
        ///
        /// <p>One or more <code>DominantLanguage</code> objects describing the dominant languages in the document.</p>
        pub fn languages(mut self, input: crate::model::DominantLanguage) -> Self {
            let mut v = self.languages.unwrap_or_default();
            v.push(input);
            self.languages = Some(v);
            self
        }
        /// <p>One or more <code>DominantLanguage</code> objects describing the dominant languages in the document.</p>
        pub fn set_languages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DominantLanguage>>,
        ) -> Self {
            self.languages = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDetectDominantLanguageItemResult`](crate::model::BatchDetectDominantLanguageItemResult).
        pub fn build(self) -> crate::model::BatchDetectDominantLanguageItemResult {
            crate::model::BatchDetectDominantLanguageItemResult {
                index: self.index,
                languages: self.languages,
            }
        }
    }
}
impl BatchDetectDominantLanguageItemResult {
    /// Creates a new builder-style object to manufacture [`BatchDetectDominantLanguageItemResult`](crate::model::BatchDetectDominantLanguageItemResult).
    pub fn builder() -> crate::model::batch_detect_dominant_language_item_result::Builder {
        crate::model::batch_detect_dominant_language_item_result::Builder::default()
    }
}
