// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An object that represents the details of the consumer you registered. This type of object is returned by <code>RegisterStreamConsumer</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Consumer {
    /// <p>The name of the consumer is something you choose when you register the consumer.</p>
    #[doc(hidden)]
    pub consumer_name: std::option::Option<std::string::String>,
    /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need this ARN to be able to call <code>SubscribeToShard</code>.</p>
    /// <p>If you delete a consumer and then create a new one with the same name, it won't have the same ARN. That's because consumer ARNs contain the creation timestamp. This is important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
    #[doc(hidden)]
    pub consumer_arn: std::option::Option<std::string::String>,
    /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code> states.</p>
    #[doc(hidden)]
    pub consumer_status: std::option::Option<crate::types::ConsumerStatus>,
    /// <p></p>
    #[doc(hidden)]
    pub consumer_creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl Consumer {
    /// <p>The name of the consumer is something you choose when you register the consumer.</p>
    pub fn consumer_name(&self) -> std::option::Option<&str> {
        self.consumer_name.as_deref()
    }
    /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need this ARN to be able to call <code>SubscribeToShard</code>.</p>
    /// <p>If you delete a consumer and then create a new one with the same name, it won't have the same ARN. That's because consumer ARNs contain the creation timestamp. This is important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
    pub fn consumer_arn(&self) -> std::option::Option<&str> {
        self.consumer_arn.as_deref()
    }
    /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code> states.</p>
    pub fn consumer_status(&self) -> std::option::Option<&crate::types::ConsumerStatus> {
        self.consumer_status.as_ref()
    }
    /// <p></p>
    pub fn consumer_creation_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.consumer_creation_timestamp.as_ref()
    }
}
impl Consumer {
    /// Creates a new builder-style object to manufacture [`Consumer`](crate::types::Consumer).
    pub fn builder() -> crate::types::builders::ConsumerBuilder {
        crate::types::builders::ConsumerBuilder::default()
    }
}

/// A builder for [`Consumer`](crate::types::Consumer).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ConsumerBuilder {
    pub(crate) consumer_name: std::option::Option<std::string::String>,
    pub(crate) consumer_arn: std::option::Option<std::string::String>,
    pub(crate) consumer_status: std::option::Option<crate::types::ConsumerStatus>,
    pub(crate) consumer_creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConsumerBuilder {
    /// <p>The name of the consumer is something you choose when you register the consumer.</p>
    pub fn consumer_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.consumer_name = Some(input.into());
        self
    }
    /// <p>The name of the consumer is something you choose when you register the consumer.</p>
    pub fn set_consumer_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.consumer_name = input;
        self
    }
    /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need this ARN to be able to call <code>SubscribeToShard</code>.</p>
    /// <p>If you delete a consumer and then create a new one with the same name, it won't have the same ARN. That's because consumer ARNs contain the creation timestamp. This is important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
    pub fn consumer_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.consumer_arn = Some(input.into());
        self
    }
    /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need this ARN to be able to call <code>SubscribeToShard</code>.</p>
    /// <p>If you delete a consumer and then create a new one with the same name, it won't have the same ARN. That's because consumer ARNs contain the creation timestamp. This is important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
    pub fn set_consumer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.consumer_arn = input;
        self
    }
    /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code> states.</p>
    pub fn consumer_status(mut self, input: crate::types::ConsumerStatus) -> Self {
        self.consumer_status = Some(input);
        self
    }
    /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code> states.</p>
    pub fn set_consumer_status(
        mut self,
        input: std::option::Option<crate::types::ConsumerStatus>,
    ) -> Self {
        self.consumer_status = input;
        self
    }
    /// <p></p>
    pub fn consumer_creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.consumer_creation_timestamp = Some(input);
        self
    }
    /// <p></p>
    pub fn set_consumer_creation_timestamp(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.consumer_creation_timestamp = input;
        self
    }
    /// Consumes the builder and constructs a [`Consumer`](crate::types::Consumer).
    pub fn build(self) -> crate::types::Consumer {
        crate::types::Consumer {
            consumer_name: self.consumer_name,
            consumer_arn: self.consumer_arn,
            consumer_status: self.consumer_status,
            consumer_creation_timestamp: self.consumer_creation_timestamp,
        }
    }
}
