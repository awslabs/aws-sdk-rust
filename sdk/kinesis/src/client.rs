// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_tags_to_stream(&self) -> fluent_builders::AddTagsToStream<C> {
        fluent_builders::AddTagsToStream::new(self.handle.clone())
    }
    pub fn create_stream(&self) -> fluent_builders::CreateStream<C> {
        fluent_builders::CreateStream::new(self.handle.clone())
    }
    pub fn decrease_stream_retention_period(
        &self,
    ) -> fluent_builders::DecreaseStreamRetentionPeriod<C> {
        fluent_builders::DecreaseStreamRetentionPeriod::new(self.handle.clone())
    }
    pub fn delete_stream(&self) -> fluent_builders::DeleteStream<C> {
        fluent_builders::DeleteStream::new(self.handle.clone())
    }
    pub fn deregister_stream_consumer(&self) -> fluent_builders::DeregisterStreamConsumer<C> {
        fluent_builders::DeregisterStreamConsumer::new(self.handle.clone())
    }
    pub fn describe_limits(&self) -> fluent_builders::DescribeLimits<C> {
        fluent_builders::DescribeLimits::new(self.handle.clone())
    }
    pub fn describe_stream(&self) -> fluent_builders::DescribeStream<C> {
        fluent_builders::DescribeStream::new(self.handle.clone())
    }
    pub fn describe_stream_consumer(&self) -> fluent_builders::DescribeStreamConsumer<C> {
        fluent_builders::DescribeStreamConsumer::new(self.handle.clone())
    }
    pub fn describe_stream_summary(&self) -> fluent_builders::DescribeStreamSummary<C> {
        fluent_builders::DescribeStreamSummary::new(self.handle.clone())
    }
    pub fn disable_enhanced_monitoring(&self) -> fluent_builders::DisableEnhancedMonitoring<C> {
        fluent_builders::DisableEnhancedMonitoring::new(self.handle.clone())
    }
    pub fn enable_enhanced_monitoring(&self) -> fluent_builders::EnableEnhancedMonitoring<C> {
        fluent_builders::EnableEnhancedMonitoring::new(self.handle.clone())
    }
    pub fn get_records(&self) -> fluent_builders::GetRecords<C> {
        fluent_builders::GetRecords::new(self.handle.clone())
    }
    pub fn get_shard_iterator(&self) -> fluent_builders::GetShardIterator<C> {
        fluent_builders::GetShardIterator::new(self.handle.clone())
    }
    pub fn increase_stream_retention_period(
        &self,
    ) -> fluent_builders::IncreaseStreamRetentionPeriod<C> {
        fluent_builders::IncreaseStreamRetentionPeriod::new(self.handle.clone())
    }
    pub fn list_shards(&self) -> fluent_builders::ListShards<C> {
        fluent_builders::ListShards::new(self.handle.clone())
    }
    pub fn list_stream_consumers(&self) -> fluent_builders::ListStreamConsumers<C> {
        fluent_builders::ListStreamConsumers::new(self.handle.clone())
    }
    pub fn list_streams(&self) -> fluent_builders::ListStreams<C> {
        fluent_builders::ListStreams::new(self.handle.clone())
    }
    pub fn list_tags_for_stream(&self) -> fluent_builders::ListTagsForStream<C> {
        fluent_builders::ListTagsForStream::new(self.handle.clone())
    }
    pub fn merge_shards(&self) -> fluent_builders::MergeShards<C> {
        fluent_builders::MergeShards::new(self.handle.clone())
    }
    pub fn put_record(&self) -> fluent_builders::PutRecord<C> {
        fluent_builders::PutRecord::new(self.handle.clone())
    }
    pub fn put_records(&self) -> fluent_builders::PutRecords<C> {
        fluent_builders::PutRecords::new(self.handle.clone())
    }
    pub fn register_stream_consumer(&self) -> fluent_builders::RegisterStreamConsumer<C> {
        fluent_builders::RegisterStreamConsumer::new(self.handle.clone())
    }
    pub fn remove_tags_from_stream(&self) -> fluent_builders::RemoveTagsFromStream<C> {
        fluent_builders::RemoveTagsFromStream::new(self.handle.clone())
    }
    pub fn split_shard(&self) -> fluent_builders::SplitShard<C> {
        fluent_builders::SplitShard::new(self.handle.clone())
    }
    pub fn start_stream_encryption(&self) -> fluent_builders::StartStreamEncryption<C> {
        fluent_builders::StartStreamEncryption::new(self.handle.clone())
    }
    pub fn stop_stream_encryption(&self) -> fluent_builders::StopStreamEncryption<C> {
        fluent_builders::StopStreamEncryption::new(self.handle.clone())
    }
    pub fn update_shard_count(&self) -> fluent_builders::UpdateShardCount<C> {
        fluent_builders::UpdateShardCount::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddTagsToStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_tags_to_stream_input::Builder,
    }
    impl<C> AddTagsToStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsToStreamOutput,
            smithy_http::result::SdkError<crate::error::AddTagsToStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>A set of up to 10 key-value pairs to use to create the tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_stream_input::Builder,
    }
    impl<C> CreateStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name to identify the stream. The stream name is scoped to the AWS account used by
        /// the application that creates the stream. It is also scoped by AWS Region. That is, two
        /// streams in two different AWS accounts can have the same name. Two streams in the same
        /// AWS account but in two different Regions can also have the same name.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The number of shards that the stream will use. The throughput of the stream is a
        /// function of the number of shards; more shards are required for greater provisioned
        /// throughput.</p>
        pub fn shard_count(mut self, input: i32) -> Self {
            self.inner = self.inner.shard_count(input);
            self
        }
        pub fn set_shard_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_shard_count(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DecreaseStreamRetentionPeriod<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::decrease_stream_retention_period_input::Builder,
    }
    impl<C> DecreaseStreamRetentionPeriod<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DecreaseStreamRetentionPeriodOutput,
            smithy_http::result::SdkError<crate::error::DecreaseStreamRetentionPeriodError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream to modify.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The new retention period of the stream, in hours. Must be less than the current
        /// retention period.</p>
        pub fn retention_period_hours(mut self, input: i32) -> Self {
            self.inner = self.inner.retention_period_hours(input);
            self
        }
        pub fn set_retention_period_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_retention_period_hours(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_stream_input::Builder,
    }
    impl<C> DeleteStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStreamOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream to delete.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>If this parameter is unset (<code>null</code>) or if you set it to <code>false</code>,
        /// and the stream has registered consumers, the call to <code>DeleteStream</code> fails
        /// with a <code>ResourceInUseException</code>. </p>
        pub fn enforce_consumer_deletion(mut self, input: bool) -> Self {
            self.inner = self.inner.enforce_consumer_deletion(input);
            self
        }
        pub fn set_enforce_consumer_deletion(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enforce_consumer_deletion(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterStreamConsumer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_stream_consumer_input::Builder,
    }
    impl<C> DeregisterStreamConsumer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterStreamConsumerOutput,
            smithy_http::result::SdkError<crate::error::DeregisterStreamConsumerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
        /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(input);
            self
        }
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(input);
            self
        }
        /// <p>The name that you gave to the consumer.</p>
        pub fn consumer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_name(input);
            self
        }
        pub fn set_consumer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_consumer_name(input);
            self
        }
        /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer. If you
        /// don't know the ARN of the consumer that you want to deregister, you can use the
        /// ListStreamConsumers operation to get a list of the descriptions of all the consumers
        /// that are currently registered with a given data stream. The description of a consumer
        /// contains its ARN.</p>
        pub fn consumer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_arn(input);
            self
        }
        pub fn set_consumer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLimits<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_limits_input::Builder,
    }
    impl<C> DescribeLimits<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLimitsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLimitsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_stream_input::Builder,
    }
    impl<C> DescribeStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeStreamOutput,
            smithy_http::result::SdkError<crate::error::DescribeStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream to describe.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The maximum number of shards to return in a single call. The default value is 100.
        /// If you specify a value greater than 100, at most 100 shards are returned.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>The shard ID of the shard to start with.</p>
        pub fn exclusive_start_shard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclusive_start_shard_id(input);
            self
        }
        pub fn set_exclusive_start_shard_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_shard_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeStreamConsumer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_stream_consumer_input::Builder,
    }
    impl<C> DescribeStreamConsumer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeStreamConsumerOutput,
            smithy_http::result::SdkError<crate::error::DescribeStreamConsumerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
        /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(input);
            self
        }
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(input);
            self
        }
        /// <p>The name that you gave to the consumer.</p>
        pub fn consumer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_name(input);
            self
        }
        pub fn set_consumer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_consumer_name(input);
            self
        }
        /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer.</p>
        pub fn consumer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_arn(input);
            self
        }
        pub fn set_consumer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeStreamSummary<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_stream_summary_input::Builder,
    }
    impl<C> DescribeStreamSummary<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeStreamSummaryOutput,
            smithy_http::result::SdkError<crate::error::DescribeStreamSummaryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream to describe.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableEnhancedMonitoring<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_enhanced_monitoring_input::Builder,
    }
    impl<C> DisableEnhancedMonitoring<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableEnhancedMonitoringOutput,
            smithy_http::result::SdkError<crate::error::DisableEnhancedMonitoringError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Kinesis data stream for which to disable enhanced
        /// monitoring.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>List of shard-level metrics to disable.</p>
        /// <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
        /// disables every metric.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>IncomingBytes</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IncomingRecords</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OutgoingBytes</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OutgoingRecords</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WriteProvisionedThroughputExceeded</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReadProvisionedThroughputExceeded</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IteratorAgeMilliseconds</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALL</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
        /// Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
        /// Kinesis Data Streams Developer Guide</i>.</p>
        pub fn shard_level_metrics(mut self, inp: impl Into<crate::model::MetricsName>) -> Self {
            self.inner = self.inner.shard_level_metrics(inp);
            self
        }
        pub fn set_shard_level_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
        ) -> Self {
            self.inner = self.inner.set_shard_level_metrics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableEnhancedMonitoring<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_enhanced_monitoring_input::Builder,
    }
    impl<C> EnableEnhancedMonitoring<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableEnhancedMonitoringOutput,
            smithy_http::result::SdkError<crate::error::EnableEnhancedMonitoringError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream for which to enable enhanced monitoring.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>List of shard-level metrics to enable.</p>
        /// <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
        /// enables every metric.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>IncomingBytes</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IncomingRecords</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OutgoingBytes</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OutgoingRecords</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WriteProvisionedThroughputExceeded</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReadProvisionedThroughputExceeded</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IteratorAgeMilliseconds</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALL</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
        /// Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
        /// Kinesis Data Streams Developer Guide</i>.</p>
        pub fn shard_level_metrics(mut self, inp: impl Into<crate::model::MetricsName>) -> Self {
            self.inner = self.inner.shard_level_metrics(inp);
            self
        }
        pub fn set_shard_level_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
        ) -> Self {
            self.inner = self.inner.set_shard_level_metrics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRecords<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_records_input::Builder,
    }
    impl<C> GetRecords<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRecordsOutput,
            smithy_http::result::SdkError<crate::error::GetRecordsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The position in the shard from which you want to start sequentially reading data
        /// records. A shard iterator specifies this position using the sequence number of a data
        /// record in the shard.</p>
        pub fn shard_iterator(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shard_iterator(input);
            self
        }
        pub fn set_shard_iterator(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_shard_iterator(input);
            self
        }
        /// <p>The maximum number of records to return. Specify a value of up to 10,000. If you
        /// specify a value that is greater than 10,000, <a>GetRecords</a> throws
        /// <code>InvalidArgumentException</code>. The default value is 10,000.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetShardIterator<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_shard_iterator_input::Builder,
    }
    impl<C> GetShardIterator<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetShardIteratorOutput,
            smithy_http::result::SdkError<crate::error::GetShardIteratorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon Kinesis data stream.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The shard ID of the Kinesis Data Streams shard to get the iterator for.</p>
        pub fn shard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shard_id(input);
            self
        }
        pub fn set_shard_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_shard_id(input);
            self
        }
        /// <p>Determines how the shard iterator is used to start reading data records from the
        /// shard.</p>
        /// <p>The following are the valid Amazon Kinesis shard iterator types:</p>
        /// <ul>
        /// <li>
        /// <p>AT_SEQUENCE_NUMBER - Start reading from the position denoted by a specific
        /// sequence number, provided in the value
        /// <code>StartingSequenceNumber</code>.</p>
        /// </li>
        /// <li>
        /// <p>AFTER_SEQUENCE_NUMBER - Start reading right after the position denoted by a
        /// specific sequence number, provided in the value
        /// <code>StartingSequenceNumber</code>.</p>
        /// </li>
        /// <li>
        /// <p>AT_TIMESTAMP - Start reading from the position denoted by a specific time
        /// stamp, provided in the value <code>Timestamp</code>.</p>
        /// </li>
        /// <li>
        /// <p>TRIM_HORIZON - Start reading at the last untrimmed record in the shard in
        /// the system, which is the oldest data record in the shard.</p>
        /// </li>
        /// <li>
        /// <p>LATEST - Start reading just after the most recent record in the shard, so
        /// that you always read the most recent data in the shard.</p>
        /// </li>
        /// </ul>
        pub fn shard_iterator_type(mut self, input: crate::model::ShardIteratorType) -> Self {
            self.inner = self.inner.shard_iterator_type(input);
            self
        }
        pub fn set_shard_iterator_type(
            mut self,
            input: std::option::Option<crate::model::ShardIteratorType>,
        ) -> Self {
            self.inner = self.inner.set_shard_iterator_type(input);
            self
        }
        /// <p>The sequence number of the data record in the shard from which to start reading.
        /// Used with shard iterator type AT_SEQUENCE_NUMBER and AFTER_SEQUENCE_NUMBER.</p>
        pub fn starting_sequence_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.starting_sequence_number(input);
            self
        }
        pub fn set_starting_sequence_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_starting_sequence_number(input);
            self
        }
        /// <p>The time stamp of the data record from which to start reading. Used with shard
        /// iterator type AT_TIMESTAMP. A time stamp is the Unix epoch date with precision in
        /// milliseconds. For example, <code>2016-04-04T19:58:46.480-00:00</code> or
        /// <code>1459799926.480</code>. If a record with this exact time stamp does not exist,
        /// the iterator returned is for the next (later) record. If the time stamp is older than
        /// the current trim horizon, the iterator returned is for the oldest untrimmed data record
        /// (TRIM_HORIZON).</p>
        pub fn timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.timestamp(input);
            self
        }
        pub fn set_timestamp(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_timestamp(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct IncreaseStreamRetentionPeriod<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::increase_stream_retention_period_input::Builder,
    }
    impl<C> IncreaseStreamRetentionPeriod<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::IncreaseStreamRetentionPeriodOutput,
            smithy_http::result::SdkError<crate::error::IncreaseStreamRetentionPeriodError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream to modify.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The new retention period of the stream, in hours. Must be more than the current
        /// retention period.</p>
        pub fn retention_period_hours(mut self, input: i32) -> Self {
            self.inner = self.inner.retention_period_hours(input);
            self
        }
        pub fn set_retention_period_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_retention_period_hours(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListShards<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_shards_input::Builder,
    }
    impl<C> ListShards<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListShardsOutput,
            smithy_http::result::SdkError<crate::error::ListShardsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the data stream whose shards you want to list. </p>
        /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
        /// parameter.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>When the number of shards in the data stream is greater than the default value for
        /// the <code>MaxResults</code> parameter, or if you explicitly specify a value for
        /// <code>MaxResults</code> that is less than the number of shards in the data stream,
        /// the response includes a pagination token named <code>NextToken</code>. You can specify
        /// this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
        /// list the next set of shards.</p>
        /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if
        /// you specify <code>NextToken</code> because the latter unambiguously identifies the
        /// stream.</p>
        /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when
        /// you specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that
        /// is less than the number of shards that the operation returns if you don't specify
        /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
        /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
        /// <code>ListShards</code> operation.</p>
        /// <important>
        /// <p>Tokens expire after 300 seconds. When you obtain a value for
        /// <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
        /// have 300 seconds to use that value. If you specify an expired token in a call to
        /// <code>ListShards</code>, you get
        /// <code>ExpiredNextTokenException</code>.</p>
        /// </important>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specify this parameter to indicate that you want to list the shards starting with
        /// the shard whose ID immediately follows <code>ExclusiveStartShardId</code>.</p>
        /// <p>If you don't specify this parameter, the default behavior is for
        /// <code>ListShards</code> to list the shards starting with the first one in the
        /// stream.</p>
        /// <p>You cannot specify this parameter if you specify <code>NextToken</code>.</p>
        pub fn exclusive_start_shard_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclusive_start_shard_id(input);
            self
        }
        pub fn set_exclusive_start_shard_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_shard_id(input);
            self
        }
        /// <p>The maximum number of shards to return in a single call to <code>ListShards</code>.
        /// The minimum value you can specify for this parameter is 1, and the maximum is 10,000,
        /// which is also the default.</p>
        /// <p>When the number of shards to be listed is greater than the value of
        /// <code>MaxResults</code>, the response contains a <code>NextToken</code> value that
        /// you can use in a subsequent call to <code>ListShards</code> to list the next set of
        /// shards.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Specify this input parameter to distinguish data streams that have the same name.
        /// For example, if you create a data stream and then delete it, and you later create
        /// another data stream with the same name, you can use this input parameter to specify
        /// which of the two streams you want to list the shards for.</p>
        /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
        /// parameter.</p>
        pub fn stream_creation_timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.stream_creation_timestamp(input);
            self
        }
        pub fn set_stream_creation_timestamp(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_stream_creation_timestamp(input);
            self
        }
        pub fn shard_filter(mut self, input: crate::model::ShardFilter) -> Self {
            self.inner = self.inner.shard_filter(input);
            self
        }
        pub fn set_shard_filter(
            mut self,
            input: std::option::Option<crate::model::ShardFilter>,
        ) -> Self {
            self.inner = self.inner.set_shard_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreamConsumers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_stream_consumers_input::Builder,
    }
    impl<C> ListStreamConsumers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamConsumersOutput,
            smithy_http::result::SdkError<crate::error::ListStreamConsumersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Kinesis data stream for which you want to list the registered
        /// consumers. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(input);
            self
        }
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(input);
            self
        }
        /// <p>When the number of consumers that are registered with the data stream is greater than
        /// the default value for the <code>MaxResults</code> parameter, or if you explicitly
        /// specify a value for <code>MaxResults</code> that is less than the number of consumers
        /// that are registered with the data stream, the response includes a pagination token named
        /// <code>NextToken</code>. You can specify this <code>NextToken</code> value in a
        /// subsequent call to <code>ListStreamConsumers</code> to list the next set of registered
        /// consumers.</p>
        /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if you
        /// specify <code>NextToken</code> because the latter unambiguously identifies the
        /// stream.</p>
        /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when you
        /// specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that is
        /// less than the number of consumers that the operation returns if you don't specify
        /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
        /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
        /// <code>ListStreamConsumers</code> operation to list the next set of consumers.</p>
        /// <important>
        /// <p>Tokens expire after 300 seconds. When you obtain a value for
        /// <code>NextToken</code> in the response to a call to
        /// <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
        /// specify an expired token in a call to <code>ListStreamConsumers</code>, you get
        /// <code>ExpiredNextTokenException</code>.</p>
        /// </important>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of consumers that you want a single call of
        /// <code>ListStreamConsumers</code> to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Specify this input parameter to distinguish data streams that have the same name. For
        /// example, if you create a data stream and then delete it, and you later create another
        /// data stream with the same name, you can use this input parameter to specify which of the
        /// two streams you want to list the consumers for. </p>
        /// <p>You can't specify this parameter if you specify the NextToken parameter. </p>
        pub fn stream_creation_timestamp(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.stream_creation_timestamp(input);
            self
        }
        pub fn set_stream_creation_timestamp(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_stream_creation_timestamp(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreams<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_streams_input::Builder,
    }
    impl<C> ListStreams<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamsOutput,
            smithy_http::result::SdkError<crate::error::ListStreamsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of streams to list.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>The name of the stream to start the list with.</p>
        pub fn exclusive_start_stream_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.exclusive_start_stream_name(input);
            self
        }
        pub fn set_exclusive_start_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_stream_input::Builder,
    }
    impl<C> ListTagsForStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForStreamOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The key to use as the starting point for the list of tags. If this parameter is
        /// set, <code>ListTagsForStream</code> gets all tags that occur after
        /// <code>ExclusiveStartTagKey</code>. </p>
        pub fn exclusive_start_tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclusive_start_tag_key(input);
            self
        }
        pub fn set_exclusive_start_tag_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_tag_key(input);
            self
        }
        /// <p>The number of tags to return. If this number is less than the total number of tags
        /// associated with the stream, <code>HasMoreTags</code> is set to <code>true</code>. To
        /// list additional tags, set <code>ExclusiveStartTagKey</code> to the last key in the
        /// response.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MergeShards<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::merge_shards_input::Builder,
    }
    impl<C> MergeShards<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MergeShardsOutput,
            smithy_http::result::SdkError<crate::error::MergeShardsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream for the merge.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The shard ID of the shard to combine with the adjacent shard for the
        /// merge.</p>
        pub fn shard_to_merge(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shard_to_merge(input);
            self
        }
        pub fn set_shard_to_merge(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_shard_to_merge(input);
            self
        }
        /// <p>The shard ID of the adjacent shard for the merge.</p>
        pub fn adjacent_shard_to_merge(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.adjacent_shard_to_merge(input);
            self
        }
        pub fn set_adjacent_shard_to_merge(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_adjacent_shard_to_merge(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRecord<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_record_input::Builder,
    }
    impl<C> PutRecord<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRecordOutput,
            smithy_http::result::SdkError<crate::error::PutRecordError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream to put the data record into.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The data blob to put into the record, which is base64-encoded when the blob is
        /// serialized. When the data blob (the payload before base64-encoding) is added to the
        /// partition key size, the total size must not exceed the maximum record size (1
        /// MiB).</p>
        pub fn data(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.data(input);
            self
        }
        pub fn set_data(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_data(input);
            self
        }
        /// <p>Determines which shard in the stream the data record is assigned to. Partition keys
        /// are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
        /// Kinesis Data Streams uses the partition key as input to a hash function that maps the
        /// partition key and associated data to a specific shard. Specifically, an MD5 hash
        /// function is used to map partition keys to 128-bit integer values and to map associated
        /// data records to shards. As a result of this hashing mechanism, all data records with the
        /// same partition key map to the same shard within the stream.</p>
        pub fn partition_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.partition_key(input);
            self
        }
        pub fn set_partition_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_partition_key(input);
            self
        }
        /// <p>The hash value used to explicitly determine the shard the data record is assigned
        /// to by overriding the partition key hash.</p>
        pub fn explicit_hash_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.explicit_hash_key(input);
            self
        }
        pub fn set_explicit_hash_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_explicit_hash_key(input);
            self
        }
        /// <p>Guarantees strictly increasing sequence numbers, for puts from the same client and
        /// to the same partition key. Usage: set the <code>SequenceNumberForOrdering</code> of
        /// record <i>n</i> to the sequence number of record <i>n-1</i>
        /// (as returned in the result when putting record <i>n-1</i>). If this
        /// parameter is not set, records are coarsely ordered based on arrival time.</p>
        pub fn sequence_number_for_ordering(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.sequence_number_for_ordering(input);
            self
        }
        pub fn set_sequence_number_for_ordering(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sequence_number_for_ordering(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRecords<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_records_input::Builder,
    }
    impl<C> PutRecords<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRecordsOutput,
            smithy_http::result::SdkError<crate::error::PutRecordsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The records associated with the request.</p>
        pub fn records(mut self, inp: impl Into<crate::model::PutRecordsRequestEntry>) -> Self {
            self.inner = self.inner.records(inp);
            self
        }
        pub fn set_records(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PutRecordsRequestEntry>>,
        ) -> Self {
            self.inner = self.inner.set_records(input);
            self
        }
        /// <p>The stream name associated with the request.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterStreamConsumer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_stream_consumer_input::Builder,
    }
    impl<C> RegisterStreamConsumer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterStreamConsumerOutput,
            smithy_http::result::SdkError<crate::error::RegisterStreamConsumerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Kinesis data stream that you want to register the consumer with. For
        /// more info, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(input);
            self
        }
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(input);
            self
        }
        /// <p>For a given Kinesis data stream, each consumer must have a unique name. However,
        /// consumer names don't have to be unique across data streams.</p>
        pub fn consumer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_name(input);
            self
        }
        pub fn set_consumer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_consumer_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTagsFromStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_tags_from_stream_input::Builder,
    }
    impl<C> RemoveTagsFromStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsFromStreamOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsFromStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>A list of tag keys. Each corresponding tag is removed from the stream.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SplitShard<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::split_shard_input::Builder,
    }
    impl<C> SplitShard<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SplitShardOutput,
            smithy_http::result::SdkError<crate::error::SplitShardError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream for the shard split.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The shard ID of the shard to split.</p>
        pub fn shard_to_split(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shard_to_split(input);
            self
        }
        pub fn set_shard_to_split(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_shard_to_split(input);
            self
        }
        /// <p>A hash key value for the starting hash key of one of the child shards created by
        /// the split. The hash key range for a given shard constitutes a set of ordered contiguous
        /// positive integers. The value for <code>NewStartingHashKey</code> must be in the range of
        /// hash keys being mapped into the shard. The <code>NewStartingHashKey</code> hash key
        /// value and all higher hash key values in hash key range are distributed to one of the
        /// child shards. All the lower hash key values in the range are distributed to the other
        /// child shard.</p>
        pub fn new_starting_hash_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_starting_hash_key(input);
            self
        }
        pub fn set_new_starting_hash_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_new_starting_hash_key(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartStreamEncryption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_stream_encryption_input::Builder,
    }
    impl<C> StartStreamEncryption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartStreamEncryptionOutput,
            smithy_http::result::SdkError<crate::error::StartStreamEncryptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream for which to start encrypting records.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The encryption type to use. The only valid value is <code>KMS</code>.</p>
        pub fn encryption_type(mut self, input: crate::model::EncryptionType) -> Self {
            self.inner = self.inner.encryption_type(input);
            self
        }
        pub fn set_encryption_type(
            mut self,
            input: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.inner = self.inner.set_encryption_type(input);
            self
        }
        /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
        /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
        /// owned by Kinesis Data Streams by specifying the alias
        /// <code>aws/kinesis</code>.</p>
        /// <ul>
        /// <li>
        /// <p>Key ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Globally unique key ID example:
        /// <code>12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name example: <code>alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Master key owned by Kinesis Data Streams:
        /// <code>alias/aws/kinesis</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_id(input);
            self
        }
        pub fn set_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopStreamEncryption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_stream_encryption_input::Builder,
    }
    impl<C> StopStreamEncryption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopStreamEncryptionOutput,
            smithy_http::result::SdkError<crate::error::StopStreamEncryptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream on which to stop encrypting records.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The encryption type. The only valid value is <code>KMS</code>.</p>
        pub fn encryption_type(mut self, input: crate::model::EncryptionType) -> Self {
            self.inner = self.inner.encryption_type(input);
            self
        }
        pub fn set_encryption_type(
            mut self,
            input: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.inner = self.inner.set_encryption_type(input);
            self
        }
        /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
        /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
        /// owned by Kinesis Data Streams by specifying the alias
        /// <code>aws/kinesis</code>.</p>
        /// <ul>
        /// <li>
        /// <p>Key ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Globally unique key ID example:
        /// <code>12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name example: <code>alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Master key owned by Kinesis Data Streams:
        /// <code>alias/aws/kinesis</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_id(input);
            self
        }
        pub fn set_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateShardCount<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_shard_count_input::Builder,
    }
    impl<C> UpdateShardCount<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateShardCountOutput,
            smithy_http::result::SdkError<crate::error::UpdateShardCountError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(input);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The new number of shards. This value has the following default limits. By default,
        /// you cannot do the following: </p>
        /// <ul>
        /// <li>
        /// <p>Set this value to more than double your current shard count for a
        /// stream.</p>
        /// </li>
        /// <li>
        /// <p>Set this value below half your current shard count for a stream.</p>
        /// </li>
        /// <li>
        /// <p>Set this value to more than 500 shards in a stream (the default limit for
        /// shard count per stream is 500 per account per region), unless you request a
        /// limit increase.</p>
        /// </li>
        /// <li>
        /// <p>Scale a stream with more than 500 shards down unless you set this value to
        /// less than 500 shards.</p>
        /// </li>
        /// </ul>
        pub fn target_shard_count(mut self, input: i32) -> Self {
            self.inner = self.inner.target_shard_count(input);
            self
        }
        pub fn set_target_shard_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_target_shard_count(input);
            self
        }
        /// <p>The scaling type. Uniform scaling creates shards of equal size.</p>
        pub fn scaling_type(mut self, input: crate::model::ScalingType) -> Self {
            self.inner = self.inner.scaling_type(input);
            self
        }
        pub fn set_scaling_type(
            mut self,
            input: std::option::Option<crate::model::ScalingType>,
        ) -> Self {
            self.inner = self.inner.set_scaling_type(input);
            self
        }
    }
}
