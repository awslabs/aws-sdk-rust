// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

#[derive(std::fmt::Debug)]
pub(crate) struct Handle {
    client: aws_hyper::Client<aws_hyper::conn::Standard>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client {
    handle: std::sync::Arc<Handle>,
}

impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf_conn(
            crate::Config::builder().build(),
            aws_hyper::conn::Standard::https(),
        )
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        Self::from_conf_conn(conf, aws_hyper::conn::Standard::https())
    }

    pub fn from_conf_conn(conf: crate::Config, conn: aws_hyper::conn::Standard) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }

    pub fn add_tags_to_stream(&self) -> fluent_builders::AddTagsToStream {
        fluent_builders::AddTagsToStream::new(self.handle.clone())
    }

    pub fn create_stream(&self) -> fluent_builders::CreateStream {
        fluent_builders::CreateStream::new(self.handle.clone())
    }

    pub fn decrease_stream_retention_period(
        &self,
    ) -> fluent_builders::DecreaseStreamRetentionPeriod {
        fluent_builders::DecreaseStreamRetentionPeriod::new(self.handle.clone())
    }

    pub fn delete_stream(&self) -> fluent_builders::DeleteStream {
        fluent_builders::DeleteStream::new(self.handle.clone())
    }

    pub fn deregister_stream_consumer(&self) -> fluent_builders::DeregisterStreamConsumer {
        fluent_builders::DeregisterStreamConsumer::new(self.handle.clone())
    }

    pub fn describe_limits(&self) -> fluent_builders::DescribeLimits {
        fluent_builders::DescribeLimits::new(self.handle.clone())
    }

    pub fn describe_stream(&self) -> fluent_builders::DescribeStream {
        fluent_builders::DescribeStream::new(self.handle.clone())
    }

    pub fn describe_stream_consumer(&self) -> fluent_builders::DescribeStreamConsumer {
        fluent_builders::DescribeStreamConsumer::new(self.handle.clone())
    }

    pub fn describe_stream_summary(&self) -> fluent_builders::DescribeStreamSummary {
        fluent_builders::DescribeStreamSummary::new(self.handle.clone())
    }

    pub fn disable_enhanced_monitoring(&self) -> fluent_builders::DisableEnhancedMonitoring {
        fluent_builders::DisableEnhancedMonitoring::new(self.handle.clone())
    }

    pub fn enable_enhanced_monitoring(&self) -> fluent_builders::EnableEnhancedMonitoring {
        fluent_builders::EnableEnhancedMonitoring::new(self.handle.clone())
    }

    pub fn get_records(&self) -> fluent_builders::GetRecords {
        fluent_builders::GetRecords::new(self.handle.clone())
    }

    pub fn get_shard_iterator(&self) -> fluent_builders::GetShardIterator {
        fluent_builders::GetShardIterator::new(self.handle.clone())
    }

    pub fn increase_stream_retention_period(
        &self,
    ) -> fluent_builders::IncreaseStreamRetentionPeriod {
        fluent_builders::IncreaseStreamRetentionPeriod::new(self.handle.clone())
    }

    pub fn list_shards(&self) -> fluent_builders::ListShards {
        fluent_builders::ListShards::new(self.handle.clone())
    }

    pub fn list_stream_consumers(&self) -> fluent_builders::ListStreamConsumers {
        fluent_builders::ListStreamConsumers::new(self.handle.clone())
    }

    pub fn list_streams(&self) -> fluent_builders::ListStreams {
        fluent_builders::ListStreams::new(self.handle.clone())
    }

    pub fn list_tags_for_stream(&self) -> fluent_builders::ListTagsForStream {
        fluent_builders::ListTagsForStream::new(self.handle.clone())
    }

    pub fn merge_shards(&self) -> fluent_builders::MergeShards {
        fluent_builders::MergeShards::new(self.handle.clone())
    }

    pub fn put_record(&self) -> fluent_builders::PutRecord {
        fluent_builders::PutRecord::new(self.handle.clone())
    }

    pub fn put_records(&self) -> fluent_builders::PutRecords {
        fluent_builders::PutRecords::new(self.handle.clone())
    }

    pub fn register_stream_consumer(&self) -> fluent_builders::RegisterStreamConsumer {
        fluent_builders::RegisterStreamConsumer::new(self.handle.clone())
    }

    pub fn remove_tags_from_stream(&self) -> fluent_builders::RemoveTagsFromStream {
        fluent_builders::RemoveTagsFromStream::new(self.handle.clone())
    }

    pub fn split_shard(&self) -> fluent_builders::SplitShard {
        fluent_builders::SplitShard::new(self.handle.clone())
    }

    pub fn start_stream_encryption(&self) -> fluent_builders::StartStreamEncryption {
        fluent_builders::StartStreamEncryption::new(self.handle.clone())
    }

    pub fn stop_stream_encryption(&self) -> fluent_builders::StopStreamEncryption {
        fluent_builders::StopStreamEncryption::new(self.handle.clone())
    }

    pub fn update_shard_count(&self) -> fluent_builders::UpdateShardCount {
        fluent_builders::UpdateShardCount::new(self.handle.clone())
    }
}
pub mod fluent_builders {

    #[derive(std::fmt::Debug)]
    pub struct AddTagsToStream {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::add_tags_to_stream_input::Builder,
    }
    impl AddTagsToStream {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AddTagsToStreamOutput,
            smithy_http::result::SdkError<crate::error::AddTagsToStreamError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A set of up to 10 key-value pairs to use to create the tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateStream {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_stream_input::Builder,
    }
    impl CreateStream {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateStreamOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A name to identify the stream. The stream name is scoped to the AWS account used by
        /// the application that creates the stream. It is also scoped by AWS Region. That is, two
        /// streams in two different AWS accounts can have the same name. Two streams in the same
        /// AWS account but in two different Regions can also have the same name.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
        /// <p>The number of shards that the stream will use. The throughput of the stream is a
        /// function of the number of shards; more shards are required for greater provisioned
        /// throughput.</p>
        pub fn shard_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.shard_count(inp);
            self
        }
        pub fn set_shard_count(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_shard_count(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DecreaseStreamRetentionPeriod {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::decrease_stream_retention_period_input::Builder,
    }
    impl DecreaseStreamRetentionPeriod {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DecreaseStreamRetentionPeriodOutput,
            smithy_http::result::SdkError<crate::error::DecreaseStreamRetentionPeriodError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The new retention period of the stream, in hours. Must be less than the current
        /// retention period.</p>
        pub fn retention_period_hours(mut self, inp: i32) -> Self {
            self.inner = self.inner.retention_period_hours(inp);
            self
        }
        pub fn set_retention_period_hours(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_retention_period_hours(inp);
            self
        }
        /// <p>The name of the stream to modify.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteStream {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_stream_input::Builder,
    }
    impl DeleteStream {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteStreamOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the stream to delete.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
        /// <p>If this parameter is unset (<code>null</code>) or if you set it to <code>false</code>,
        /// and the stream has registered consumers, the call to <code>DeleteStream</code> fails
        /// with a <code>ResourceInUseException</code>. </p>
        pub fn enforce_consumer_deletion(mut self, inp: bool) -> Self {
            self.inner = self.inner.enforce_consumer_deletion(inp);
            self
        }
        pub fn set_enforce_consumer_deletion(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enforce_consumer_deletion(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeregisterStreamConsumer {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::deregister_stream_consumer_input::Builder,
    }
    impl DeregisterStreamConsumer {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeregisterStreamConsumerOutput,
            smithy_http::result::SdkError<crate::error::DeregisterStreamConsumerError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
        /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(inp);
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(inp);
            self
        }
        /// <p>The name that you gave to the consumer.</p>
        pub fn consumer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_name(inp);
            self
        }
        pub fn set_consumer_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_name(inp);
            self
        }
        /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer. If you
        /// don't know the ARN of the consumer that you want to deregister, you can use the
        /// ListStreamConsumers operation to get a list of the descriptions of all the consumers
        /// that are currently registered with a given data stream. The description of a consumer
        /// contains its ARN.</p>
        pub fn consumer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_arn(inp);
            self
        }
        pub fn set_consumer_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_arn(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeLimits {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_limits_input::Builder,
    }
    impl DescribeLimits {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeLimitsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLimitsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeStream {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_stream_input::Builder,
    }
    impl DescribeStream {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeStreamOutput,
            smithy_http::result::SdkError<crate::error::DescribeStreamError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the stream to describe.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
        /// <p>The shard ID of the shard to start with.</p>
        pub fn exclusive_start_shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclusive_start_shard_id(inp);
            self
        }
        pub fn set_exclusive_start_shard_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_shard_id(inp);
            self
        }
        /// <p>The maximum number of shards to return in a single call. The default value is 100.
        /// If you specify a value greater than 100, at most 100 shards are returned.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeStreamConsumer {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_stream_consumer_input::Builder,
    }
    impl DescribeStreamConsumer {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeStreamConsumerOutput,
            smithy_http::result::SdkError<crate::error::DescribeStreamConsumerError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
        /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(inp);
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(inp);
            self
        }
        /// <p>The name that you gave to the consumer.</p>
        pub fn consumer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_name(inp);
            self
        }
        pub fn set_consumer_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_name(inp);
            self
        }
        /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer.</p>
        pub fn consumer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_arn(inp);
            self
        }
        pub fn set_consumer_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_arn(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeStreamSummary {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_stream_summary_input::Builder,
    }
    impl DescribeStreamSummary {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeStreamSummaryOutput,
            smithy_http::result::SdkError<crate::error::DescribeStreamSummaryError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the stream to describe.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DisableEnhancedMonitoring {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::disable_enhanced_monitoring_input::Builder,
    }
    impl DisableEnhancedMonitoring {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DisableEnhancedMonitoringOutput,
            smithy_http::result::SdkError<crate::error::DisableEnhancedMonitoringError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>List of shard-level metrics to disable.</p>
        /// <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
        /// disables every metric.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>IncomingBytes</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IncomingRecords</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OutgoingBytes</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OutgoingRecords</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WriteProvisionedThroughputExceeded</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReadProvisionedThroughputExceeded</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IteratorAgeMilliseconds</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALL</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
        /// Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
        /// Kinesis Data Streams Developer Guide</i>.</p>
        pub fn shard_level_metrics(mut self, inp: impl Into<crate::model::MetricsName>) -> Self {
            self.inner = self.inner.shard_level_metrics(inp);
            self
        }
        pub fn set_shard_level_metrics(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
        ) -> Self {
            self.inner = self.inner.set_shard_level_metrics(inp);
            self
        }
        /// <p>The name of the Kinesis data stream for which to disable enhanced
        /// monitoring.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct EnableEnhancedMonitoring {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::enable_enhanced_monitoring_input::Builder,
    }
    impl EnableEnhancedMonitoring {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::EnableEnhancedMonitoringOutput,
            smithy_http::result::SdkError<crate::error::EnableEnhancedMonitoringError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the stream for which to enable enhanced monitoring.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
        /// <p>List of shard-level metrics to enable.</p>
        /// <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
        /// enables every metric.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>IncomingBytes</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IncomingRecords</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OutgoingBytes</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OutgoingRecords</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WriteProvisionedThroughputExceeded</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReadProvisionedThroughputExceeded</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IteratorAgeMilliseconds</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALL</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
        /// Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
        /// Kinesis Data Streams Developer Guide</i>.</p>
        pub fn shard_level_metrics(mut self, inp: impl Into<crate::model::MetricsName>) -> Self {
            self.inner = self.inner.shard_level_metrics(inp);
            self
        }
        pub fn set_shard_level_metrics(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
        ) -> Self {
            self.inner = self.inner.set_shard_level_metrics(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetRecords {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_records_input::Builder,
    }
    impl GetRecords {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetRecordsOutput,
            smithy_http::result::SdkError<crate::error::GetRecordsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The position in the shard from which you want to start sequentially reading data
        /// records. A shard iterator specifies this position using the sequence number of a data
        /// record in the shard.</p>
        pub fn shard_iterator(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shard_iterator(inp);
            self
        }
        pub fn set_shard_iterator(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_shard_iterator(inp);
            self
        }
        /// <p>The maximum number of records to return. Specify a value of up to 10,000. If you
        /// specify a value that is greater than 10,000, <a>GetRecords</a> throws
        /// <code>InvalidArgumentException</code>. The default value is 10,000.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetShardIterator {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_shard_iterator_input::Builder,
    }
    impl GetShardIterator {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetShardIteratorOutput,
            smithy_http::result::SdkError<crate::error::GetShardIteratorError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Determines how the shard iterator is used to start reading data records from the
        /// shard.</p>
        /// <p>The following are the valid Amazon Kinesis shard iterator types:</p>
        /// <ul>
        /// <li>
        /// <p>AT_SEQUENCE_NUMBER - Start reading from the position denoted by a specific
        /// sequence number, provided in the value
        /// <code>StartingSequenceNumber</code>.</p>
        /// </li>
        /// <li>
        /// <p>AFTER_SEQUENCE_NUMBER - Start reading right after the position denoted by a
        /// specific sequence number, provided in the value
        /// <code>StartingSequenceNumber</code>.</p>
        /// </li>
        /// <li>
        /// <p>AT_TIMESTAMP - Start reading from the position denoted by a specific time
        /// stamp, provided in the value <code>Timestamp</code>.</p>
        /// </li>
        /// <li>
        /// <p>TRIM_HORIZON - Start reading at the last untrimmed record in the shard in
        /// the system, which is the oldest data record in the shard.</p>
        /// </li>
        /// <li>
        /// <p>LATEST - Start reading just after the most recent record in the shard, so
        /// that you always read the most recent data in the shard.</p>
        /// </li>
        /// </ul>
        pub fn shard_iterator_type(mut self, inp: crate::model::ShardIteratorType) -> Self {
            self.inner = self.inner.shard_iterator_type(inp);
            self
        }
        pub fn set_shard_iterator_type(
            mut self,
            inp: std::option::Option<crate::model::ShardIteratorType>,
        ) -> Self {
            self.inner = self.inner.set_shard_iterator_type(inp);
            self
        }
        /// <p>The shard ID of the Kinesis Data Streams shard to get the iterator for.</p>
        pub fn shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shard_id(inp);
            self
        }
        pub fn set_shard_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_shard_id(inp);
            self
        }
        /// <p>The sequence number of the data record in the shard from which to start reading.
        /// Used with shard iterator type AT_SEQUENCE_NUMBER and AFTER_SEQUENCE_NUMBER.</p>
        pub fn starting_sequence_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.starting_sequence_number(inp);
            self
        }
        pub fn set_starting_sequence_number(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_starting_sequence_number(inp);
            self
        }
        /// <p>The time stamp of the data record from which to start reading. Used with shard
        /// iterator type AT_TIMESTAMP. A time stamp is the Unix epoch date with precision in
        /// milliseconds. For example, <code>2016-04-04T19:58:46.480-00:00</code> or
        /// <code>1459799926.480</code>. If a record with this exact time stamp does not exist,
        /// the iterator returned is for the next (later) record. If the time stamp is older than
        /// the current trim horizon, the iterator returned is for the oldest untrimmed data record
        /// (TRIM_HORIZON).</p>
        pub fn timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.timestamp(inp);
            self
        }
        pub fn set_timestamp(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_timestamp(inp);
            self
        }
        /// <p>The name of the Amazon Kinesis data stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct IncreaseStreamRetentionPeriod {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::increase_stream_retention_period_input::Builder,
    }
    impl IncreaseStreamRetentionPeriod {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::IncreaseStreamRetentionPeriodOutput,
            smithy_http::result::SdkError<crate::error::IncreaseStreamRetentionPeriodError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The new retention period of the stream, in hours. Must be more than the current
        /// retention period.</p>
        pub fn retention_period_hours(mut self, inp: i32) -> Self {
            self.inner = self.inner.retention_period_hours(inp);
            self
        }
        pub fn set_retention_period_hours(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_retention_period_hours(inp);
            self
        }
        /// <p>The name of the stream to modify.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListShards {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_shards_input::Builder,
    }
    impl ListShards {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListShardsOutput,
            smithy_http::result::SdkError<crate::error::ListShardsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The maximum number of shards to return in a single call to <code>ListShards</code>.
        /// The minimum value you can specify for this parameter is 1, and the maximum is 10,000,
        /// which is also the default.</p>
        /// <p>When the number of shards to be listed is greater than the value of
        /// <code>MaxResults</code>, the response contains a <code>NextToken</code> value that
        /// you can use in a subsequent call to <code>ListShards</code> to list the next set of
        /// shards.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>Specify this input parameter to distinguish data streams that have the same name.
        /// For example, if you create a data stream and then delete it, and you later create
        /// another data stream with the same name, you can use this input parameter to specify
        /// which of the two streams you want to list the shards for.</p>
        /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
        /// parameter.</p>
        pub fn stream_creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.stream_creation_timestamp(inp);
            self
        }
        pub fn set_stream_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_stream_creation_timestamp(inp);
            self
        }
        /// <p>When the number of shards in the data stream is greater than the default value for
        /// the <code>MaxResults</code> parameter, or if you explicitly specify a value for
        /// <code>MaxResults</code> that is less than the number of shards in the data stream,
        /// the response includes a pagination token named <code>NextToken</code>. You can specify
        /// this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
        /// list the next set of shards.</p>
        /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if
        /// you specify <code>NextToken</code> because the latter unambiguously identifies the
        /// stream.</p>
        /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when
        /// you specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that
        /// is less than the number of shards that the operation returns if you don't specify
        /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
        /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
        /// <code>ListShards</code> operation.</p>
        /// <important>
        /// <p>Tokens expire after 300 seconds. When you obtain a value for
        /// <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
        /// have 300 seconds to use that value. If you specify an expired token in a call to
        /// <code>ListShards</code>, you get
        /// <code>ExpiredNextTokenException</code>.</p>
        /// </important>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>Specify this parameter to indicate that you want to list the shards starting with
        /// the shard whose ID immediately follows <code>ExclusiveStartShardId</code>.</p>
        /// <p>If you don't specify this parameter, the default behavior is for
        /// <code>ListShards</code> to list the shards starting with the first one in the
        /// stream.</p>
        /// <p>You cannot specify this parameter if you specify <code>NextToken</code>.</p>
        pub fn exclusive_start_shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclusive_start_shard_id(inp);
            self
        }
        pub fn set_exclusive_start_shard_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_shard_id(inp);
            self
        }
        pub fn shard_filter(mut self, inp: crate::model::ShardFilter) -> Self {
            self.inner = self.inner.shard_filter(inp);
            self
        }
        pub fn set_shard_filter(
            mut self,
            inp: std::option::Option<crate::model::ShardFilter>,
        ) -> Self {
            self.inner = self.inner.set_shard_filter(inp);
            self
        }
        /// <p>The name of the data stream whose shards you want to list. </p>
        /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
        /// parameter.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListStreamConsumers {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_stream_consumers_input::Builder,
    }
    impl ListStreamConsumers {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListStreamConsumersOutput,
            smithy_http::result::SdkError<crate::error::ListStreamConsumersError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>When the number of consumers that are registered with the data stream is greater than
        /// the default value for the <code>MaxResults</code> parameter, or if you explicitly
        /// specify a value for <code>MaxResults</code> that is less than the number of consumers
        /// that are registered with the data stream, the response includes a pagination token named
        /// <code>NextToken</code>. You can specify this <code>NextToken</code> value in a
        /// subsequent call to <code>ListStreamConsumers</code> to list the next set of registered
        /// consumers.</p>
        /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if you
        /// specify <code>NextToken</code> because the latter unambiguously identifies the
        /// stream.</p>
        /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when you
        /// specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that is
        /// less than the number of consumers that the operation returns if you don't specify
        /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
        /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
        /// <code>ListStreamConsumers</code> operation to list the next set of consumers.</p>
        /// <important>
        /// <p>Tokens expire after 300 seconds. When you obtain a value for
        /// <code>NextToken</code> in the response to a call to
        /// <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
        /// specify an expired token in a call to <code>ListStreamConsumers</code>, you get
        /// <code>ExpiredNextTokenException</code>.</p>
        /// </important>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>Specify this input parameter to distinguish data streams that have the same name. For
        /// example, if you create a data stream and then delete it, and you later create another
        /// data stream with the same name, you can use this input parameter to specify which of the
        /// two streams you want to list the consumers for. </p>
        /// <p>You can't specify this parameter if you specify the NextToken parameter. </p>
        pub fn stream_creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.inner = self.inner.stream_creation_timestamp(inp);
            self
        }
        pub fn set_stream_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_stream_creation_timestamp(inp);
            self
        }
        /// <p>The ARN of the Kinesis data stream for which you want to list the registered
        /// consumers. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(inp);
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(inp);
            self
        }
        /// <p>The maximum number of consumers that you want a single call of
        /// <code>ListStreamConsumers</code> to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListStreams {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_streams_input::Builder,
    }
    impl ListStreams {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListStreamsOutput,
            smithy_http::result::SdkError<crate::error::ListStreamsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The maximum number of streams to list.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(inp);
            self
        }
        /// <p>The name of the stream to start the list with.</p>
        pub fn exclusive_start_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclusive_start_stream_name(inp);
            self
        }
        pub fn set_exclusive_start_stream_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListTagsForStream {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_tags_for_stream_input::Builder,
    }
    impl ListTagsForStream {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListTagsForStreamOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForStreamError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The number of tags to return. If this number is less than the total number of tags
        /// associated with the stream, <code>HasMoreTags</code> is set to <code>true</code>. To
        /// list additional tags, set <code>ExclusiveStartTagKey</code> to the last key in the
        /// response.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(inp);
            self
        }
        /// <p>The key to use as the starting point for the list of tags. If this parameter is
        /// set, <code>ListTagsForStream</code> gets all tags that occur after
        /// <code>ExclusiveStartTagKey</code>. </p>
        pub fn exclusive_start_tag_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclusive_start_tag_key(inp);
            self
        }
        pub fn set_exclusive_start_tag_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclusive_start_tag_key(inp);
            self
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct MergeShards {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::merge_shards_input::Builder,
    }
    impl MergeShards {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::MergeShardsOutput,
            smithy_http::result::SdkError<crate::error::MergeShardsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The shard ID of the adjacent shard for the merge.</p>
        pub fn adjacent_shard_to_merge(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.adjacent_shard_to_merge(inp);
            self
        }
        pub fn set_adjacent_shard_to_merge(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_adjacent_shard_to_merge(inp);
            self
        }
        /// <p>The name of the stream for the merge.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
        /// <p>The shard ID of the shard to combine with the adjacent shard for the
        /// merge.</p>
        pub fn shard_to_merge(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shard_to_merge(inp);
            self
        }
        pub fn set_shard_to_merge(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_shard_to_merge(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct PutRecord {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_record_input::Builder,
    }
    impl PutRecord {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutRecordOutput,
            smithy_http::result::SdkError<crate::error::PutRecordError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the stream to put the data record into.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
        /// <p>The hash value used to explicitly determine the shard the data record is assigned
        /// to by overriding the partition key hash.</p>
        pub fn explicit_hash_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.explicit_hash_key(inp);
            self
        }
        pub fn set_explicit_hash_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_explicit_hash_key(inp);
            self
        }
        /// <p>Guarantees strictly increasing sequence numbers, for puts from the same client and
        /// to the same partition key. Usage: set the <code>SequenceNumberForOrdering</code> of
        /// record <i>n</i> to the sequence number of record <i>n-1</i>
        /// (as returned in the result when putting record <i>n-1</i>). If this
        /// parameter is not set, records are coarsely ordered based on arrival time.</p>
        pub fn sequence_number_for_ordering(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sequence_number_for_ordering(inp);
            self
        }
        pub fn set_sequence_number_for_ordering(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sequence_number_for_ordering(inp);
            self
        }
        /// <p>Determines which shard in the stream the data record is assigned to. Partition keys
        /// are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
        /// Kinesis Data Streams uses the partition key as input to a hash function that maps the
        /// partition key and associated data to a specific shard. Specifically, an MD5 hash
        /// function is used to map partition keys to 128-bit integer values and to map associated
        /// data records to shards. As a result of this hashing mechanism, all data records with the
        /// same partition key map to the same shard within the stream.</p>
        pub fn partition_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.partition_key(inp);
            self
        }
        pub fn set_partition_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_partition_key(inp);
            self
        }
        /// <p>The data blob to put into the record, which is base64-encoded when the blob is
        /// serialized. When the data blob (the payload before base64-encoding) is added to the
        /// partition key size, the total size must not exceed the maximum record size (1
        /// MiB).</p>
        pub fn data(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.data(inp);
            self
        }
        pub fn set_data(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_data(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct PutRecords {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_records_input::Builder,
    }
    impl PutRecords {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutRecordsOutput,
            smithy_http::result::SdkError<crate::error::PutRecordsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The records associated with the request.</p>
        pub fn records(mut self, inp: impl Into<crate::model::PutRecordsRequestEntry>) -> Self {
            self.inner = self.inner.records(inp);
            self
        }
        pub fn set_records(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PutRecordsRequestEntry>>,
        ) -> Self {
            self.inner = self.inner.set_records(inp);
            self
        }
        /// <p>The stream name associated with the request.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct RegisterStreamConsumer {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::register_stream_consumer_input::Builder,
    }
    impl RegisterStreamConsumer {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RegisterStreamConsumerOutput,
            smithy_http::result::SdkError<crate::error::RegisterStreamConsumerError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>For a given Kinesis data stream, each consumer must have a unique name. However,
        /// consumer names don't have to be unique across data streams.</p>
        pub fn consumer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.consumer_name(inp);
            self
        }
        pub fn set_consumer_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_consumer_name(inp);
            self
        }
        /// <p>The ARN of the Kinesis data stream that you want to register the consumer with. For
        /// more info, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(inp);
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct RemoveTagsFromStream {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::remove_tags_from_stream_input::Builder,
    }
    impl RemoveTagsFromStream {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RemoveTagsFromStreamOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsFromStreamError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A list of tag keys. Each corresponding tag is removed from the stream.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct SplitShard {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::split_shard_input::Builder,
    }
    impl SplitShard {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::SplitShardOutput,
            smithy_http::result::SdkError<crate::error::SplitShardError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The shard ID of the shard to split.</p>
        pub fn shard_to_split(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.shard_to_split(inp);
            self
        }
        pub fn set_shard_to_split(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_shard_to_split(inp);
            self
        }
        /// <p>A hash key value for the starting hash key of one of the child shards created by
        /// the split. The hash key range for a given shard constitutes a set of ordered contiguous
        /// positive integers. The value for <code>NewStartingHashKey</code> must be in the range of
        /// hash keys being mapped into the shard. The <code>NewStartingHashKey</code> hash key
        /// value and all higher hash key values in hash key range are distributed to one of the
        /// child shards. All the lower hash key values in the range are distributed to the other
        /// child shard.</p>
        pub fn new_starting_hash_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_starting_hash_key(inp);
            self
        }
        pub fn set_new_starting_hash_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_new_starting_hash_key(inp);
            self
        }
        /// <p>The name of the stream for the shard split.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct StartStreamEncryption {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::start_stream_encryption_input::Builder,
    }
    impl StartStreamEncryption {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StartStreamEncryptionOutput,
            smithy_http::result::SdkError<crate::error::StartStreamEncryptionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the stream for which to start encrypting records.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
        /// <p>The encryption type to use. The only valid value is <code>KMS</code>.</p>
        pub fn encryption_type(mut self, inp: crate::model::EncryptionType) -> Self {
            self.inner = self.inner.encryption_type(inp);
            self
        }
        pub fn set_encryption_type(
            mut self,
            inp: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.inner = self.inner.set_encryption_type(inp);
            self
        }
        /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
        /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
        /// owned by Kinesis Data Streams by specifying the alias
        /// <code>aws/kinesis</code>.</p>
        /// <ul>
        /// <li>
        /// <p>Key ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Globally unique key ID example:
        /// <code>12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name example: <code>alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Master key owned by Kinesis Data Streams:
        /// <code>alias/aws/kinesis</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_id(inp);
            self
        }
        pub fn set_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct StopStreamEncryption {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::stop_stream_encryption_input::Builder,
    }
    impl StopStreamEncryption {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::StopStreamEncryptionOutput,
            smithy_http::result::SdkError<crate::error::StopStreamEncryptionError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The name of the stream on which to stop encrypting records.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
        /// <p>The encryption type. The only valid value is <code>KMS</code>.</p>
        pub fn encryption_type(mut self, inp: crate::model::EncryptionType) -> Self {
            self.inner = self.inner.encryption_type(inp);
            self
        }
        pub fn set_encryption_type(
            mut self,
            inp: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.inner = self.inner.set_encryption_type(inp);
            self
        }
        /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
        /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
        /// owned by Kinesis Data Streams by specifying the alias
        /// <code>aws/kinesis</code>.</p>
        /// <ul>
        /// <li>
        /// <p>Key ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Globally unique key ID example:
        /// <code>12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name example: <code>alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Master key owned by Kinesis Data Streams:
        /// <code>alias/aws/kinesis</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_id(inp);
            self
        }
        pub fn set_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateShardCount {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_shard_count_input::Builder,
    }
    impl UpdateShardCount {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateShardCountOutput,
            smithy_http::result::SdkError<crate::error::UpdateShardCountError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The scaling type. Uniform scaling creates shards of equal size.</p>
        pub fn scaling_type(mut self, inp: crate::model::ScalingType) -> Self {
            self.inner = self.inner.scaling_type(inp);
            self
        }
        pub fn set_scaling_type(
            mut self,
            inp: std::option::Option<crate::model::ScalingType>,
        ) -> Self {
            self.inner = self.inner.set_scaling_type(inp);
            self
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(inp);
            self
        }
        /// <p>The new number of shards. This value has the following default limits. By default,
        /// you cannot do the following: </p>
        /// <ul>
        /// <li>
        /// <p>Set this value to more than double your current shard count for a
        /// stream.</p>
        /// </li>
        /// <li>
        /// <p>Set this value below half your current shard count for a stream.</p>
        /// </li>
        /// <li>
        /// <p>Set this value to more than 500 shards in a stream (the default limit for
        /// shard count per stream is 500 per account per region), unless you request a
        /// limit increase.</p>
        /// </li>
        /// <li>
        /// <p>Scale a stream with more than 500 shards down unless you set this value to
        /// less than 500 shards.</p>
        /// </li>
        /// </ul>
        pub fn target_shard_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.target_shard_count(inp);
            self
        }
        pub fn set_target_shard_count(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_target_shard_count(inp);
            self
        }
    }
}
