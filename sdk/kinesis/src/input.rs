// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// See [`AddTagsToStreamInput`](crate::input::AddTagsToStreamInput)
pub mod add_tags_to_stream_input {
    /// A builder for [`AddTagsToStreamInput`](crate::input::AddTagsToStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`AddTagsToStreamInput`](crate::input::AddTagsToStreamInput)
        pub fn build(
            self,
        ) -> Result<crate::input::AddTagsToStreamInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::AddTagsToStreamInput {
                tags: self.tags,
                stream_name: self.stream_name,
            })
        }
    }
}
impl AddTagsToStreamInput {
    /// Consumes the builder and constructs an Operation<[`AddTagsToStream`](crate::operation::AddTagsToStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::AddTagsToStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AddTagsToStream::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AddTagsToStream",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.AddTagsToStream"))
    }
    fn body(&self) -> crate::serializer::AddTagsToStreamInputBody {
        crate::serializer::AddTagsToStreamInputBody {
            tags: &self.tags,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`AddTagsToStreamInput`](crate::input::AddTagsToStreamInput)
    pub fn builder() -> crate::input::add_tags_to_stream_input::Builder {
        crate::input::add_tags_to_stream_input::Builder::default()
    }
}

/// See [`CreateStreamInput`](crate::input::CreateStreamInput)
pub mod create_stream_input {
    /// A builder for [`CreateStreamInput`](crate::input::CreateStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_name: std::option::Option<std::string::String>,
        shard_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A name to identify the stream. The stream name is scoped to the AWS account used by
        /// the application that creates the stream. It is also scoped by AWS Region. That is, two
        /// streams in two different AWS accounts can have the same name. Two streams in the same
        /// AWS account but in two different Regions can also have the same name.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>The number of shards that the stream will use. The throughput of the stream is a
        /// function of the number of shards; more shards are required for greater provisioned
        /// throughput.</p>
        pub fn shard_count(mut self, inp: i32) -> Self {
            self.shard_count = Some(inp);
            self
        }
        pub fn set_shard_count(mut self, inp: std::option::Option<i32>) -> Self {
            self.shard_count = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateStreamInput`](crate::input::CreateStreamInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateStreamInput, smithy_http::operation::BuildError> {
            Ok(crate::input::CreateStreamInput {
                stream_name: self.stream_name,
                shard_count: self.shard_count,
            })
        }
    }
}
impl CreateStreamInput {
    /// Consumes the builder and constructs an Operation<[`CreateStream`](crate::operation::CreateStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateStream::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateStream",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.CreateStream"))
    }
    fn body(&self) -> crate::serializer::CreateStreamInputBody {
        crate::serializer::CreateStreamInputBody {
            stream_name: &self.stream_name,
            shard_count: &self.shard_count,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`CreateStreamInput`](crate::input::CreateStreamInput)
    pub fn builder() -> crate::input::create_stream_input::Builder {
        crate::input::create_stream_input::Builder::default()
    }
}

/// See [`DecreaseStreamRetentionPeriodInput`](crate::input::DecreaseStreamRetentionPeriodInput)
pub mod decrease_stream_retention_period_input {
    /// A builder for [`DecreaseStreamRetentionPeriodInput`](crate::input::DecreaseStreamRetentionPeriodInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        retention_period_hours: std::option::Option<i32>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The new retention period of the stream, in hours. Must be less than the current
        /// retention period.</p>
        pub fn retention_period_hours(mut self, inp: i32) -> Self {
            self.retention_period_hours = Some(inp);
            self
        }
        pub fn set_retention_period_hours(mut self, inp: std::option::Option<i32>) -> Self {
            self.retention_period_hours = inp;
            self
        }
        /// <p>The name of the stream to modify.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DecreaseStreamRetentionPeriodInput`](crate::input::DecreaseStreamRetentionPeriodInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::DecreaseStreamRetentionPeriodInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DecreaseStreamRetentionPeriodInput {
                retention_period_hours: self.retention_period_hours,
                stream_name: self.stream_name,
            })
        }
    }
}
impl DecreaseStreamRetentionPeriodInput {
    /// Consumes the builder and constructs an Operation<[`DecreaseStreamRetentionPeriod`](crate::operation::DecreaseStreamRetentionPeriod)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DecreaseStreamRetentionPeriod,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DecreaseStreamRetentionPeriod::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DecreaseStreamRetentionPeriod",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header(
                "X-Amz-Target",
                "Kinesis_20131202.DecreaseStreamRetentionPeriod",
            ))
    }
    fn body(&self) -> crate::serializer::DecreaseStreamRetentionPeriodInputBody {
        crate::serializer::DecreaseStreamRetentionPeriodInputBody {
            retention_period_hours: &self.retention_period_hours,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DecreaseStreamRetentionPeriodInput`](crate::input::DecreaseStreamRetentionPeriodInput)
    pub fn builder() -> crate::input::decrease_stream_retention_period_input::Builder {
        crate::input::decrease_stream_retention_period_input::Builder::default()
    }
}

/// See [`DeleteStreamInput`](crate::input::DeleteStreamInput)
pub mod delete_stream_input {
    /// A builder for [`DeleteStreamInput`](crate::input::DeleteStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_name: std::option::Option<std::string::String>,
        enforce_consumer_deletion: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the stream to delete.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>If this parameter is unset (<code>null</code>) or if you set it to <code>false</code>,
        /// and the stream has registered consumers, the call to <code>DeleteStream</code> fails
        /// with a <code>ResourceInUseException</code>. </p>
        pub fn enforce_consumer_deletion(mut self, inp: bool) -> Self {
            self.enforce_consumer_deletion = Some(inp);
            self
        }
        pub fn set_enforce_consumer_deletion(mut self, inp: std::option::Option<bool>) -> Self {
            self.enforce_consumer_deletion = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteStreamInput`](crate::input::DeleteStreamInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteStreamInput, smithy_http::operation::BuildError> {
            Ok(crate::input::DeleteStreamInput {
                stream_name: self.stream_name,
                enforce_consumer_deletion: self.enforce_consumer_deletion,
            })
        }
    }
}
impl DeleteStreamInput {
    /// Consumes the builder and constructs an Operation<[`DeleteStream`](crate::operation::DeleteStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteStream::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteStream",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.DeleteStream"))
    }
    fn body(&self) -> crate::serializer::DeleteStreamInputBody {
        crate::serializer::DeleteStreamInputBody {
            stream_name: &self.stream_name,
            enforce_consumer_deletion: &self.enforce_consumer_deletion,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DeleteStreamInput`](crate::input::DeleteStreamInput)
    pub fn builder() -> crate::input::delete_stream_input::Builder {
        crate::input::delete_stream_input::Builder::default()
    }
}

/// See [`DeregisterStreamConsumerInput`](crate::input::DeregisterStreamConsumerInput)
pub mod deregister_stream_consumer_input {
    /// A builder for [`DeregisterStreamConsumerInput`](crate::input::DeregisterStreamConsumerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_arn: std::option::Option<std::string::String>,
        consumer_name: std::option::Option<std::string::String>,
        consumer_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
        /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(inp.into());
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = inp;
            self
        }
        /// <p>The name that you gave to the consumer.</p>
        pub fn consumer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.consumer_name = Some(inp.into());
            self
        }
        pub fn set_consumer_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.consumer_name = inp;
            self
        }
        /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer. If you
        /// don't know the ARN of the consumer that you want to deregister, you can use the
        /// ListStreamConsumers operation to get a list of the descriptions of all the consumers
        /// that are currently registered with a given data stream. The description of a consumer
        /// contains its ARN.</p>
        pub fn consumer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.consumer_arn = Some(inp.into());
            self
        }
        pub fn set_consumer_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.consumer_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeregisterStreamConsumerInput`](crate::input::DeregisterStreamConsumerInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeregisterStreamConsumerInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeregisterStreamConsumerInput {
                stream_arn: self.stream_arn,
                consumer_name: self.consumer_name,
                consumer_arn: self.consumer_arn,
            })
        }
    }
}
impl DeregisterStreamConsumerInput {
    /// Consumes the builder and constructs an Operation<[`DeregisterStreamConsumer`](crate::operation::DeregisterStreamConsumer)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeregisterStreamConsumer,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeregisterStreamConsumer::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeregisterStreamConsumer",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.DeregisterStreamConsumer"))
    }
    fn body(&self) -> crate::serializer::DeregisterStreamConsumerInputBody {
        crate::serializer::DeregisterStreamConsumerInputBody {
            stream_arn: &self.stream_arn,
            consumer_name: &self.consumer_name,
            consumer_arn: &self.consumer_arn,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DeregisterStreamConsumerInput`](crate::input::DeregisterStreamConsumerInput)
    pub fn builder() -> crate::input::deregister_stream_consumer_input::Builder {
        crate::input::deregister_stream_consumer_input::Builder::default()
    }
}

/// See [`DescribeLimitsInput`](crate::input::DescribeLimitsInput)
pub mod describe_limits_input {
    /// A builder for [`DescribeLimitsInput`](crate::input::DescribeLimitsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DescribeLimitsInput`](crate::input::DescribeLimitsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeLimitsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::DescribeLimitsInput {})
        }
    }
}
impl DescribeLimitsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeLimits`](crate::operation::DescribeLimits)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeLimits,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeLimits::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeLimits",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.DescribeLimits"))
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        "{}".to_string().into()
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DescribeLimitsInput`](crate::input::DescribeLimitsInput)
    pub fn builder() -> crate::input::describe_limits_input::Builder {
        crate::input::describe_limits_input::Builder::default()
    }
}

/// See [`DescribeStreamInput`](crate::input::DescribeStreamInput)
pub mod describe_stream_input {
    /// A builder for [`DescribeStreamInput`](crate::input::DescribeStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_name: std::option::Option<std::string::String>,
        exclusive_start_shard_id: std::option::Option<std::string::String>,
        limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the stream to describe.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>The shard ID of the shard to start with.</p>
        pub fn exclusive_start_shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.exclusive_start_shard_id = Some(inp.into());
            self
        }
        pub fn set_exclusive_start_shard_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.exclusive_start_shard_id = inp;
            self
        }
        /// <p>The maximum number of shards to return in a single call. The default value is 100.
        /// If you specify a value greater than 100, at most 100 shards are returned.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.limit = Some(inp);
            self
        }
        pub fn set_limit(mut self, inp: std::option::Option<i32>) -> Self {
            self.limit = inp;
            self
        }
        /// Consumes the builder and constructs a [`DescribeStreamInput`](crate::input::DescribeStreamInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeStreamInput, smithy_http::operation::BuildError> {
            Ok(crate::input::DescribeStreamInput {
                stream_name: self.stream_name,
                exclusive_start_shard_id: self.exclusive_start_shard_id,
                limit: self.limit,
            })
        }
    }
}
impl DescribeStreamInput {
    /// Consumes the builder and constructs an Operation<[`DescribeStream`](crate::operation::DescribeStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeStream::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeStream",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.DescribeStream"))
    }
    fn body(&self) -> crate::serializer::DescribeStreamInputBody {
        crate::serializer::DescribeStreamInputBody {
            stream_name: &self.stream_name,
            exclusive_start_shard_id: &self.exclusive_start_shard_id,
            limit: &self.limit,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DescribeStreamInput`](crate::input::DescribeStreamInput)
    pub fn builder() -> crate::input::describe_stream_input::Builder {
        crate::input::describe_stream_input::Builder::default()
    }
}

/// See [`DescribeStreamConsumerInput`](crate::input::DescribeStreamConsumerInput)
pub mod describe_stream_consumer_input {
    /// A builder for [`DescribeStreamConsumerInput`](crate::input::DescribeStreamConsumerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_arn: std::option::Option<std::string::String>,
        consumer_name: std::option::Option<std::string::String>,
        consumer_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
        /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(inp.into());
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = inp;
            self
        }
        /// <p>The name that you gave to the consumer.</p>
        pub fn consumer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.consumer_name = Some(inp.into());
            self
        }
        pub fn set_consumer_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.consumer_name = inp;
            self
        }
        /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer.</p>
        pub fn consumer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.consumer_arn = Some(inp.into());
            self
        }
        pub fn set_consumer_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.consumer_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`DescribeStreamConsumerInput`](crate::input::DescribeStreamConsumerInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeStreamConsumerInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DescribeStreamConsumerInput {
                stream_arn: self.stream_arn,
                consumer_name: self.consumer_name,
                consumer_arn: self.consumer_arn,
            })
        }
    }
}
impl DescribeStreamConsumerInput {
    /// Consumes the builder and constructs an Operation<[`DescribeStreamConsumer`](crate::operation::DescribeStreamConsumer)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeStreamConsumer,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeStreamConsumer::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeStreamConsumer",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.DescribeStreamConsumer"))
    }
    fn body(&self) -> crate::serializer::DescribeStreamConsumerInputBody {
        crate::serializer::DescribeStreamConsumerInputBody {
            stream_arn: &self.stream_arn,
            consumer_name: &self.consumer_name,
            consumer_arn: &self.consumer_arn,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DescribeStreamConsumerInput`](crate::input::DescribeStreamConsumerInput)
    pub fn builder() -> crate::input::describe_stream_consumer_input::Builder {
        crate::input::describe_stream_consumer_input::Builder::default()
    }
}

/// See [`DescribeStreamSummaryInput`](crate::input::DescribeStreamSummaryInput)
pub mod describe_stream_summary_input {
    /// A builder for [`DescribeStreamSummaryInput`](crate::input::DescribeStreamSummaryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the stream to describe.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DescribeStreamSummaryInput`](crate::input::DescribeStreamSummaryInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeStreamSummaryInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DescribeStreamSummaryInput {
                stream_name: self.stream_name,
            })
        }
    }
}
impl DescribeStreamSummaryInput {
    /// Consumes the builder and constructs an Operation<[`DescribeStreamSummary`](crate::operation::DescribeStreamSummary)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeStreamSummary,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeStreamSummary::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeStreamSummary",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.DescribeStreamSummary"))
    }
    fn body(&self) -> crate::serializer::DescribeStreamSummaryInputBody {
        crate::serializer::DescribeStreamSummaryInputBody {
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DescribeStreamSummaryInput`](crate::input::DescribeStreamSummaryInput)
    pub fn builder() -> crate::input::describe_stream_summary_input::Builder {
        crate::input::describe_stream_summary_input::Builder::default()
    }
}

/// See [`DisableEnhancedMonitoringInput`](crate::input::DisableEnhancedMonitoringInput)
pub mod disable_enhanced_monitoring_input {
    /// A builder for [`DisableEnhancedMonitoringInput`](crate::input::DisableEnhancedMonitoringInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn shard_level_metrics(mut self, inp: impl Into<crate::model::MetricsName>) -> Self {
            let mut v = self.shard_level_metrics.unwrap_or_default();
            v.push(inp.into());
            self.shard_level_metrics = Some(v);
            self
        }
        pub fn set_shard_level_metrics(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
        ) -> Self {
            self.shard_level_metrics = inp;
            self
        }
        /// <p>The name of the Kinesis data stream for which to disable enhanced
        /// monitoring.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DisableEnhancedMonitoringInput`](crate::input::DisableEnhancedMonitoringInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DisableEnhancedMonitoringInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DisableEnhancedMonitoringInput {
                shard_level_metrics: self.shard_level_metrics,
                stream_name: self.stream_name,
            })
        }
    }
}
impl DisableEnhancedMonitoringInput {
    /// Consumes the builder and constructs an Operation<[`DisableEnhancedMonitoring`](crate::operation::DisableEnhancedMonitoring)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DisableEnhancedMonitoring,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DisableEnhancedMonitoring::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DisableEnhancedMonitoring",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.DisableEnhancedMonitoring"))
    }
    fn body(&self) -> crate::serializer::DisableEnhancedMonitoringInputBody {
        crate::serializer::DisableEnhancedMonitoringInputBody {
            shard_level_metrics: &self.shard_level_metrics,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DisableEnhancedMonitoringInput`](crate::input::DisableEnhancedMonitoringInput)
    pub fn builder() -> crate::input::disable_enhanced_monitoring_input::Builder {
        crate::input::disable_enhanced_monitoring_input::Builder::default()
    }
}

/// See [`EnableEnhancedMonitoringInput`](crate::input::EnableEnhancedMonitoringInput)
pub mod enable_enhanced_monitoring_input {
    /// A builder for [`EnableEnhancedMonitoringInput`](crate::input::EnableEnhancedMonitoringInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_name: std::option::Option<std::string::String>,
        shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
    }
    impl Builder {
        /// <p>The name of the stream for which to enable enhanced monitoring.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        pub fn shard_level_metrics(mut self, inp: impl Into<crate::model::MetricsName>) -> Self {
            let mut v = self.shard_level_metrics.unwrap_or_default();
            v.push(inp.into());
            self.shard_level_metrics = Some(v);
            self
        }
        pub fn set_shard_level_metrics(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
        ) -> Self {
            self.shard_level_metrics = inp;
            self
        }
        /// Consumes the builder and constructs a [`EnableEnhancedMonitoringInput`](crate::input::EnableEnhancedMonitoringInput)
        pub fn build(
            self,
        ) -> Result<crate::input::EnableEnhancedMonitoringInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::EnableEnhancedMonitoringInput {
                stream_name: self.stream_name,
                shard_level_metrics: self.shard_level_metrics,
            })
        }
    }
}
impl EnableEnhancedMonitoringInput {
    /// Consumes the builder and constructs an Operation<[`EnableEnhancedMonitoring`](crate::operation::EnableEnhancedMonitoring)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::EnableEnhancedMonitoring,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::EnableEnhancedMonitoring::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "EnableEnhancedMonitoring",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.EnableEnhancedMonitoring"))
    }
    fn body(&self) -> crate::serializer::EnableEnhancedMonitoringInputBody {
        crate::serializer::EnableEnhancedMonitoringInputBody {
            stream_name: &self.stream_name,
            shard_level_metrics: &self.shard_level_metrics,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`EnableEnhancedMonitoringInput`](crate::input::EnableEnhancedMonitoringInput)
    pub fn builder() -> crate::input::enable_enhanced_monitoring_input::Builder {
        crate::input::enable_enhanced_monitoring_input::Builder::default()
    }
}

/// See [`GetRecordsInput`](crate::input::GetRecordsInput)
pub mod get_records_input {
    /// A builder for [`GetRecordsInput`](crate::input::GetRecordsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        shard_iterator: std::option::Option<std::string::String>,
        limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The position in the shard from which you want to start sequentially reading data
        /// records. A shard iterator specifies this position using the sequence number of a data
        /// record in the shard.</p>
        pub fn shard_iterator(mut self, inp: impl Into<std::string::String>) -> Self {
            self.shard_iterator = Some(inp.into());
            self
        }
        pub fn set_shard_iterator(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.shard_iterator = inp;
            self
        }
        /// <p>The maximum number of records to return. Specify a value of up to 10,000. If you
        /// specify a value that is greater than 10,000, <a>GetRecords</a> throws
        /// <code>InvalidArgumentException</code>. The default value is 10,000.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.limit = Some(inp);
            self
        }
        pub fn set_limit(mut self, inp: std::option::Option<i32>) -> Self {
            self.limit = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetRecordsInput`](crate::input::GetRecordsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetRecordsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::GetRecordsInput {
                shard_iterator: self.shard_iterator,
                limit: self.limit,
            })
        }
    }
}
impl GetRecordsInput {
    /// Consumes the builder and constructs an Operation<[`GetRecords`](crate::operation::GetRecords)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetRecords,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetRecords::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetRecords",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.GetRecords"))
    }
    fn body(&self) -> crate::serializer::GetRecordsInputBody {
        crate::serializer::GetRecordsInputBody {
            shard_iterator: &self.shard_iterator,
            limit: &self.limit,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`GetRecordsInput`](crate::input::GetRecordsInput)
    pub fn builder() -> crate::input::get_records_input::Builder {
        crate::input::get_records_input::Builder::default()
    }
}

/// See [`GetShardIteratorInput`](crate::input::GetShardIteratorInput)
pub mod get_shard_iterator_input {
    /// A builder for [`GetShardIteratorInput`](crate::input::GetShardIteratorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        shard_iterator_type: std::option::Option<crate::model::ShardIteratorType>,
        shard_id: std::option::Option<std::string::String>,
        starting_sequence_number: std::option::Option<std::string::String>,
        timestamp: std::option::Option<smithy_types::Instant>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Determines how the shard iterator is used to start reading data records from the
        /// shard.</p>
        /// <p>The following are the valid Amazon Kinesis shard iterator types:</p>
        /// <ul>
        /// <li>
        /// <p>AT_SEQUENCE_NUMBER - Start reading from the position denoted by a specific
        /// sequence number, provided in the value
        /// <code>StartingSequenceNumber</code>.</p>
        /// </li>
        /// <li>
        /// <p>AFTER_SEQUENCE_NUMBER - Start reading right after the position denoted by a
        /// specific sequence number, provided in the value
        /// <code>StartingSequenceNumber</code>.</p>
        /// </li>
        /// <li>
        /// <p>AT_TIMESTAMP - Start reading from the position denoted by a specific time
        /// stamp, provided in the value <code>Timestamp</code>.</p>
        /// </li>
        /// <li>
        /// <p>TRIM_HORIZON - Start reading at the last untrimmed record in the shard in
        /// the system, which is the oldest data record in the shard.</p>
        /// </li>
        /// <li>
        /// <p>LATEST - Start reading just after the most recent record in the shard, so
        /// that you always read the most recent data in the shard.</p>
        /// </li>
        /// </ul>
        pub fn shard_iterator_type(mut self, inp: crate::model::ShardIteratorType) -> Self {
            self.shard_iterator_type = Some(inp);
            self
        }
        pub fn set_shard_iterator_type(
            mut self,
            inp: std::option::Option<crate::model::ShardIteratorType>,
        ) -> Self {
            self.shard_iterator_type = inp;
            self
        }
        /// <p>The shard ID of the Kinesis Data Streams shard to get the iterator for.</p>
        pub fn shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.shard_id = Some(inp.into());
            self
        }
        pub fn set_shard_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.shard_id = inp;
            self
        }
        /// <p>The sequence number of the data record in the shard from which to start reading.
        /// Used with shard iterator type AT_SEQUENCE_NUMBER and AFTER_SEQUENCE_NUMBER.</p>
        pub fn starting_sequence_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.starting_sequence_number = Some(inp.into());
            self
        }
        pub fn set_starting_sequence_number(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.starting_sequence_number = inp;
            self
        }
        /// <p>The time stamp of the data record from which to start reading. Used with shard
        /// iterator type AT_TIMESTAMP. A time stamp is the Unix epoch date with precision in
        /// milliseconds. For example, <code>2016-04-04T19:58:46.480-00:00</code> or
        /// <code>1459799926.480</code>. If a record with this exact time stamp does not exist,
        /// the iterator returned is for the next (later) record. If the time stamp is older than
        /// the current trim horizon, the iterator returned is for the oldest untrimmed data record
        /// (TRIM_HORIZON).</p>
        pub fn timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        pub fn set_timestamp(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = inp;
            self
        }
        /// <p>The name of the Amazon Kinesis data stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetShardIteratorInput`](crate::input::GetShardIteratorInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetShardIteratorInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetShardIteratorInput {
                shard_iterator_type: self.shard_iterator_type,
                shard_id: self.shard_id,
                starting_sequence_number: self.starting_sequence_number,
                timestamp: self.timestamp,
                stream_name: self.stream_name,
            })
        }
    }
}
impl GetShardIteratorInput {
    /// Consumes the builder and constructs an Operation<[`GetShardIterator`](crate::operation::GetShardIterator)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetShardIterator,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetShardIterator::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetShardIterator",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.GetShardIterator"))
    }
    fn body(&self) -> crate::serializer::GetShardIteratorInputBody {
        crate::serializer::GetShardIteratorInputBody {
            shard_iterator_type: &self.shard_iterator_type,
            shard_id: &self.shard_id,
            starting_sequence_number: &self.starting_sequence_number,
            timestamp: &self.timestamp,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`GetShardIteratorInput`](crate::input::GetShardIteratorInput)
    pub fn builder() -> crate::input::get_shard_iterator_input::Builder {
        crate::input::get_shard_iterator_input::Builder::default()
    }
}

/// See [`IncreaseStreamRetentionPeriodInput`](crate::input::IncreaseStreamRetentionPeriodInput)
pub mod increase_stream_retention_period_input {
    /// A builder for [`IncreaseStreamRetentionPeriodInput`](crate::input::IncreaseStreamRetentionPeriodInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        retention_period_hours: std::option::Option<i32>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The new retention period of the stream, in hours. Must be more than the current
        /// retention period.</p>
        pub fn retention_period_hours(mut self, inp: i32) -> Self {
            self.retention_period_hours = Some(inp);
            self
        }
        pub fn set_retention_period_hours(mut self, inp: std::option::Option<i32>) -> Self {
            self.retention_period_hours = inp;
            self
        }
        /// <p>The name of the stream to modify.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`IncreaseStreamRetentionPeriodInput`](crate::input::IncreaseStreamRetentionPeriodInput)
        pub fn build(
            self,
        ) -> Result<
            crate::input::IncreaseStreamRetentionPeriodInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::IncreaseStreamRetentionPeriodInput {
                retention_period_hours: self.retention_period_hours,
                stream_name: self.stream_name,
            })
        }
    }
}
impl IncreaseStreamRetentionPeriodInput {
    /// Consumes the builder and constructs an Operation<[`IncreaseStreamRetentionPeriod`](crate::operation::IncreaseStreamRetentionPeriod)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::IncreaseStreamRetentionPeriod,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::IncreaseStreamRetentionPeriod::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "IncreaseStreamRetentionPeriod",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header(
                "X-Amz-Target",
                "Kinesis_20131202.IncreaseStreamRetentionPeriod",
            ))
    }
    fn body(&self) -> crate::serializer::IncreaseStreamRetentionPeriodInputBody {
        crate::serializer::IncreaseStreamRetentionPeriodInputBody {
            retention_period_hours: &self.retention_period_hours,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`IncreaseStreamRetentionPeriodInput`](crate::input::IncreaseStreamRetentionPeriodInput)
    pub fn builder() -> crate::input::increase_stream_retention_period_input::Builder {
        crate::input::increase_stream_retention_period_input::Builder::default()
    }
}

/// See [`ListShardsInput`](crate::input::ListShardsInput)
pub mod list_shards_input {
    /// A builder for [`ListShardsInput`](crate::input::ListShardsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        max_results: std::option::Option<i32>,
        stream_creation_timestamp: std::option::Option<smithy_types::Instant>,
        next_token: std::option::Option<std::string::String>,
        exclusive_start_shard_id: std::option::Option<std::string::String>,
        shard_filter: std::option::Option<crate::model::ShardFilter>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of shards to return in a single call to <code>ListShards</code>.
        /// The minimum value you can specify for this parameter is 1, and the maximum is 10,000,
        /// which is also the default.</p>
        /// <p>When the number of shards to be listed is greater than the value of
        /// <code>MaxResults</code>, the response contains a <code>NextToken</code> value that
        /// you can use in a subsequent call to <code>ListShards</code> to list the next set of
        /// shards.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.max_results = Some(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_results = inp;
            self
        }
        /// <p>Specify this input parameter to distinguish data streams that have the same name.
        /// For example, if you create a data stream and then delete it, and you later create
        /// another data stream with the same name, you can use this input parameter to specify
        /// which of the two streams you want to list the shards for.</p>
        /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
        /// parameter.</p>
        pub fn stream_creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.stream_creation_timestamp = Some(inp);
            self
        }
        pub fn set_stream_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.stream_creation_timestamp = inp;
            self
        }
        /// <p>When the number of shards in the data stream is greater than the default value for
        /// the <code>MaxResults</code> parameter, or if you explicitly specify a value for
        /// <code>MaxResults</code> that is less than the number of shards in the data stream,
        /// the response includes a pagination token named <code>NextToken</code>. You can specify
        /// this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
        /// list the next set of shards.</p>
        /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if
        /// you specify <code>NextToken</code> because the latter unambiguously identifies the
        /// stream.</p>
        /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when
        /// you specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that
        /// is less than the number of shards that the operation returns if you don't specify
        /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
        /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
        /// <code>ListShards</code> operation.</p>
        /// <important>
        /// <p>Tokens expire after 300 seconds. When you obtain a value for
        /// <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
        /// have 300 seconds to use that value. If you specify an expired token in a call to
        /// <code>ListShards</code>, you get
        /// <code>ExpiredNextTokenException</code>.</p>
        /// </important>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.next_token = Some(inp.into());
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.next_token = inp;
            self
        }
        /// <p>Specify this parameter to indicate that you want to list the shards starting with
        /// the shard whose ID immediately follows <code>ExclusiveStartShardId</code>.</p>
        /// <p>If you don't specify this parameter, the default behavior is for
        /// <code>ListShards</code> to list the shards starting with the first one in the
        /// stream.</p>
        /// <p>You cannot specify this parameter if you specify <code>NextToken</code>.</p>
        pub fn exclusive_start_shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.exclusive_start_shard_id = Some(inp.into());
            self
        }
        pub fn set_exclusive_start_shard_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.exclusive_start_shard_id = inp;
            self
        }
        pub fn shard_filter(mut self, inp: crate::model::ShardFilter) -> Self {
            self.shard_filter = Some(inp);
            self
        }
        pub fn set_shard_filter(
            mut self,
            inp: std::option::Option<crate::model::ShardFilter>,
        ) -> Self {
            self.shard_filter = inp;
            self
        }
        /// <p>The name of the data stream whose shards you want to list. </p>
        /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
        /// parameter.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListShardsInput`](crate::input::ListShardsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListShardsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListShardsInput {
                max_results: self.max_results,
                stream_creation_timestamp: self.stream_creation_timestamp,
                next_token: self.next_token,
                exclusive_start_shard_id: self.exclusive_start_shard_id,
                shard_filter: self.shard_filter,
                stream_name: self.stream_name,
            })
        }
    }
}
impl ListShardsInput {
    /// Consumes the builder and constructs an Operation<[`ListShards`](crate::operation::ListShards)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListShards,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListShards::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListShards",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.ListShards"))
    }
    fn body(&self) -> crate::serializer::ListShardsInputBody {
        crate::serializer::ListShardsInputBody {
            max_results: &self.max_results,
            stream_creation_timestamp: &self.stream_creation_timestamp,
            next_token: &self.next_token,
            exclusive_start_shard_id: &self.exclusive_start_shard_id,
            shard_filter: &self.shard_filter,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ListShardsInput`](crate::input::ListShardsInput)
    pub fn builder() -> crate::input::list_shards_input::Builder {
        crate::input::list_shards_input::Builder::default()
    }
}

/// See [`ListStreamConsumersInput`](crate::input::ListStreamConsumersInput)
pub mod list_stream_consumers_input {
    /// A builder for [`ListStreamConsumersInput`](crate::input::ListStreamConsumersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        next_token: std::option::Option<std::string::String>,
        stream_creation_timestamp: std::option::Option<smithy_types::Instant>,
        stream_arn: std::option::Option<std::string::String>,
        max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>When the number of consumers that are registered with the data stream is greater than
        /// the default value for the <code>MaxResults</code> parameter, or if you explicitly
        /// specify a value for <code>MaxResults</code> that is less than the number of consumers
        /// that are registered with the data stream, the response includes a pagination token named
        /// <code>NextToken</code>. You can specify this <code>NextToken</code> value in a
        /// subsequent call to <code>ListStreamConsumers</code> to list the next set of registered
        /// consumers.</p>
        /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if you
        /// specify <code>NextToken</code> because the latter unambiguously identifies the
        /// stream.</p>
        /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when you
        /// specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that is
        /// less than the number of consumers that the operation returns if you don't specify
        /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
        /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
        /// <code>ListStreamConsumers</code> operation to list the next set of consumers.</p>
        /// <important>
        /// <p>Tokens expire after 300 seconds. When you obtain a value for
        /// <code>NextToken</code> in the response to a call to
        /// <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
        /// specify an expired token in a call to <code>ListStreamConsumers</code>, you get
        /// <code>ExpiredNextTokenException</code>.</p>
        /// </important>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.next_token = Some(inp.into());
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.next_token = inp;
            self
        }
        /// <p>Specify this input parameter to distinguish data streams that have the same name. For
        /// example, if you create a data stream and then delete it, and you later create another
        /// data stream with the same name, you can use this input parameter to specify which of the
        /// two streams you want to list the consumers for. </p>
        /// <p>You can't specify this parameter if you specify the NextToken parameter. </p>
        pub fn stream_creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.stream_creation_timestamp = Some(inp);
            self
        }
        pub fn set_stream_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.stream_creation_timestamp = inp;
            self
        }
        /// <p>The ARN of the Kinesis data stream for which you want to list the registered
        /// consumers. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(inp.into());
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = inp;
            self
        }
        /// <p>The maximum number of consumers that you want a single call of
        /// <code>ListStreamConsumers</code> to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.max_results = Some(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_results = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListStreamConsumersInput`](crate::input::ListStreamConsumersInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListStreamConsumersInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListStreamConsumersInput {
                next_token: self.next_token,
                stream_creation_timestamp: self.stream_creation_timestamp,
                stream_arn: self.stream_arn,
                max_results: self.max_results,
            })
        }
    }
}
impl ListStreamConsumersInput {
    /// Consumes the builder and constructs an Operation<[`ListStreamConsumers`](crate::operation::ListStreamConsumers)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListStreamConsumers,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListStreamConsumers::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListStreamConsumers",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.ListStreamConsumers"))
    }
    fn body(&self) -> crate::serializer::ListStreamConsumersInputBody {
        crate::serializer::ListStreamConsumersInputBody {
            next_token: &self.next_token,
            stream_creation_timestamp: &self.stream_creation_timestamp,
            stream_arn: &self.stream_arn,
            max_results: &self.max_results,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ListStreamConsumersInput`](crate::input::ListStreamConsumersInput)
    pub fn builder() -> crate::input::list_stream_consumers_input::Builder {
        crate::input::list_stream_consumers_input::Builder::default()
    }
}

/// See [`ListStreamsInput`](crate::input::ListStreamsInput)
pub mod list_streams_input {
    /// A builder for [`ListStreamsInput`](crate::input::ListStreamsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        limit: std::option::Option<i32>,
        exclusive_start_stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of streams to list.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.limit = Some(inp);
            self
        }
        pub fn set_limit(mut self, inp: std::option::Option<i32>) -> Self {
            self.limit = inp;
            self
        }
        /// <p>The name of the stream to start the list with.</p>
        pub fn exclusive_start_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.exclusive_start_stream_name = Some(inp.into());
            self
        }
        pub fn set_exclusive_start_stream_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.exclusive_start_stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListStreamsInput`](crate::input::ListStreamsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListStreamsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListStreamsInput {
                limit: self.limit,
                exclusive_start_stream_name: self.exclusive_start_stream_name,
            })
        }
    }
}
impl ListStreamsInput {
    /// Consumes the builder and constructs an Operation<[`ListStreams`](crate::operation::ListStreams)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListStreams,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListStreams::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListStreams",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.ListStreams"))
    }
    fn body(&self) -> crate::serializer::ListStreamsInputBody {
        crate::serializer::ListStreamsInputBody {
            limit: &self.limit,
            exclusive_start_stream_name: &self.exclusive_start_stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ListStreamsInput`](crate::input::ListStreamsInput)
    pub fn builder() -> crate::input::list_streams_input::Builder {
        crate::input::list_streams_input::Builder::default()
    }
}

/// See [`ListTagsForStreamInput`](crate::input::ListTagsForStreamInput)
pub mod list_tags_for_stream_input {
    /// A builder for [`ListTagsForStreamInput`](crate::input::ListTagsForStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        limit: std::option::Option<i32>,
        exclusive_start_tag_key: std::option::Option<std::string::String>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of tags to return. If this number is less than the total number of tags
        /// associated with the stream, <code>HasMoreTags</code> is set to <code>true</code>. To
        /// list additional tags, set <code>ExclusiveStartTagKey</code> to the last key in the
        /// response.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.limit = Some(inp);
            self
        }
        pub fn set_limit(mut self, inp: std::option::Option<i32>) -> Self {
            self.limit = inp;
            self
        }
        /// <p>The key to use as the starting point for the list of tags. If this parameter is
        /// set, <code>ListTagsForStream</code> gets all tags that occur after
        /// <code>ExclusiveStartTagKey</code>. </p>
        pub fn exclusive_start_tag_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.exclusive_start_tag_key = Some(inp.into());
            self
        }
        pub fn set_exclusive_start_tag_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.exclusive_start_tag_key = inp;
            self
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForStreamInput`](crate::input::ListTagsForStreamInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListTagsForStreamInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListTagsForStreamInput {
                limit: self.limit,
                exclusive_start_tag_key: self.exclusive_start_tag_key,
                stream_name: self.stream_name,
            })
        }
    }
}
impl ListTagsForStreamInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForStream`](crate::operation::ListTagsForStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListTagsForStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListTagsForStream::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListTagsForStream",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.ListTagsForStream"))
    }
    fn body(&self) -> crate::serializer::ListTagsForStreamInputBody {
        crate::serializer::ListTagsForStreamInputBody {
            limit: &self.limit,
            exclusive_start_tag_key: &self.exclusive_start_tag_key,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForStreamInput`](crate::input::ListTagsForStreamInput)
    pub fn builder() -> crate::input::list_tags_for_stream_input::Builder {
        crate::input::list_tags_for_stream_input::Builder::default()
    }
}

/// See [`MergeShardsInput`](crate::input::MergeShardsInput)
pub mod merge_shards_input {
    /// A builder for [`MergeShardsInput`](crate::input::MergeShardsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        adjacent_shard_to_merge: std::option::Option<std::string::String>,
        stream_name: std::option::Option<std::string::String>,
        shard_to_merge: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The shard ID of the adjacent shard for the merge.</p>
        pub fn adjacent_shard_to_merge(mut self, inp: impl Into<std::string::String>) -> Self {
            self.adjacent_shard_to_merge = Some(inp.into());
            self
        }
        pub fn set_adjacent_shard_to_merge(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.adjacent_shard_to_merge = inp;
            self
        }
        /// <p>The name of the stream for the merge.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>The shard ID of the shard to combine with the adjacent shard for the
        /// merge.</p>
        pub fn shard_to_merge(mut self, inp: impl Into<std::string::String>) -> Self {
            self.shard_to_merge = Some(inp.into());
            self
        }
        pub fn set_shard_to_merge(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.shard_to_merge = inp;
            self
        }
        /// Consumes the builder and constructs a [`MergeShardsInput`](crate::input::MergeShardsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::MergeShardsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::MergeShardsInput {
                adjacent_shard_to_merge: self.adjacent_shard_to_merge,
                stream_name: self.stream_name,
                shard_to_merge: self.shard_to_merge,
            })
        }
    }
}
impl MergeShardsInput {
    /// Consumes the builder and constructs an Operation<[`MergeShards`](crate::operation::MergeShards)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::MergeShards,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::MergeShards::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "MergeShards",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.MergeShards"))
    }
    fn body(&self) -> crate::serializer::MergeShardsInputBody {
        crate::serializer::MergeShardsInputBody {
            adjacent_shard_to_merge: &self.adjacent_shard_to_merge,
            stream_name: &self.stream_name,
            shard_to_merge: &self.shard_to_merge,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`MergeShardsInput`](crate::input::MergeShardsInput)
    pub fn builder() -> crate::input::merge_shards_input::Builder {
        crate::input::merge_shards_input::Builder::default()
    }
}

/// See [`PutRecordInput`](crate::input::PutRecordInput)
pub mod put_record_input {
    /// A builder for [`PutRecordInput`](crate::input::PutRecordInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_name: std::option::Option<std::string::String>,
        explicit_hash_key: std::option::Option<std::string::String>,
        sequence_number_for_ordering: std::option::Option<std::string::String>,
        partition_key: std::option::Option<std::string::String>,
        data: std::option::Option<smithy_types::Blob>,
    }
    impl Builder {
        /// <p>The name of the stream to put the data record into.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>The hash value used to explicitly determine the shard the data record is assigned
        /// to by overriding the partition key hash.</p>
        pub fn explicit_hash_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.explicit_hash_key = Some(inp.into());
            self
        }
        pub fn set_explicit_hash_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.explicit_hash_key = inp;
            self
        }
        /// <p>Guarantees strictly increasing sequence numbers, for puts from the same client and
        /// to the same partition key. Usage: set the <code>SequenceNumberForOrdering</code> of
        /// record <i>n</i> to the sequence number of record <i>n-1</i>
        /// (as returned in the result when putting record <i>n-1</i>). If this
        /// parameter is not set, records are coarsely ordered based on arrival time.</p>
        pub fn sequence_number_for_ordering(mut self, inp: impl Into<std::string::String>) -> Self {
            self.sequence_number_for_ordering = Some(inp.into());
            self
        }
        pub fn set_sequence_number_for_ordering(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.sequence_number_for_ordering = inp;
            self
        }
        /// <p>Determines which shard in the stream the data record is assigned to. Partition keys
        /// are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
        /// Kinesis Data Streams uses the partition key as input to a hash function that maps the
        /// partition key and associated data to a specific shard. Specifically, an MD5 hash
        /// function is used to map partition keys to 128-bit integer values and to map associated
        /// data records to shards. As a result of this hashing mechanism, all data records with the
        /// same partition key map to the same shard within the stream.</p>
        pub fn partition_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.partition_key = Some(inp.into());
            self
        }
        pub fn set_partition_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.partition_key = inp;
            self
        }
        /// <p>The data blob to put into the record, which is base64-encoded when the blob is
        /// serialized. When the data blob (the payload before base64-encoding) is added to the
        /// partition key size, the total size must not exceed the maximum record size (1
        /// MiB).</p>
        pub fn data(mut self, inp: smithy_types::Blob) -> Self {
            self.data = Some(inp);
            self
        }
        pub fn set_data(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.data = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutRecordInput`](crate::input::PutRecordInput)
        pub fn build(
            self,
        ) -> Result<crate::input::PutRecordInput, smithy_http::operation::BuildError> {
            Ok(crate::input::PutRecordInput {
                stream_name: self.stream_name,
                explicit_hash_key: self.explicit_hash_key,
                sequence_number_for_ordering: self.sequence_number_for_ordering,
                partition_key: self.partition_key,
                data: self.data,
            })
        }
    }
}
impl PutRecordInput {
    /// Consumes the builder and constructs an Operation<[`PutRecord`](crate::operation::PutRecord)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::PutRecord,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op =
                smithy_http::operation::Operation::new(request, crate::operation::PutRecord::new())
                    .with_metadata(smithy_http::operation::Metadata::new(
                        "PutRecord",
                        "kinesis",
                    ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.PutRecord"))
    }
    fn body(&self) -> crate::serializer::PutRecordInputBody {
        crate::serializer::PutRecordInputBody {
            stream_name: &self.stream_name,
            explicit_hash_key: &self.explicit_hash_key,
            sequence_number_for_ordering: &self.sequence_number_for_ordering,
            partition_key: &self.partition_key,
            data: &self.data,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`PutRecordInput`](crate::input::PutRecordInput)
    pub fn builder() -> crate::input::put_record_input::Builder {
        crate::input::put_record_input::Builder::default()
    }
}

/// See [`PutRecordsInput`](crate::input::PutRecordsInput)
pub mod put_records_input {
    /// A builder for [`PutRecordsInput`](crate::input::PutRecordsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        records: std::option::Option<std::vec::Vec<crate::model::PutRecordsRequestEntry>>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn records(mut self, inp: impl Into<crate::model::PutRecordsRequestEntry>) -> Self {
            let mut v = self.records.unwrap_or_default();
            v.push(inp.into());
            self.records = Some(v);
            self
        }
        pub fn set_records(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PutRecordsRequestEntry>>,
        ) -> Self {
            self.records = inp;
            self
        }
        /// <p>The stream name associated with the request.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutRecordsInput`](crate::input::PutRecordsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::PutRecordsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::PutRecordsInput {
                records: self.records,
                stream_name: self.stream_name,
            })
        }
    }
}
impl PutRecordsInput {
    /// Consumes the builder and constructs an Operation<[`PutRecords`](crate::operation::PutRecords)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::PutRecords,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutRecords::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutRecords",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.PutRecords"))
    }
    fn body(&self) -> crate::serializer::PutRecordsInputBody {
        crate::serializer::PutRecordsInputBody {
            records: &self.records,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`PutRecordsInput`](crate::input::PutRecordsInput)
    pub fn builder() -> crate::input::put_records_input::Builder {
        crate::input::put_records_input::Builder::default()
    }
}

/// See [`RegisterStreamConsumerInput`](crate::input::RegisterStreamConsumerInput)
pub mod register_stream_consumer_input {
    /// A builder for [`RegisterStreamConsumerInput`](crate::input::RegisterStreamConsumerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        consumer_name: std::option::Option<std::string::String>,
        stream_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>For a given Kinesis data stream, each consumer must have a unique name. However,
        /// consumer names don't have to be unique across data streams.</p>
        pub fn consumer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.consumer_name = Some(inp.into());
            self
        }
        pub fn set_consumer_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.consumer_name = inp;
            self
        }
        /// <p>The ARN of the Kinesis data stream that you want to register the consumer with. For
        /// more info, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(inp.into());
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`RegisterStreamConsumerInput`](crate::input::RegisterStreamConsumerInput)
        pub fn build(
            self,
        ) -> Result<crate::input::RegisterStreamConsumerInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::RegisterStreamConsumerInput {
                consumer_name: self.consumer_name,
                stream_arn: self.stream_arn,
            })
        }
    }
}
impl RegisterStreamConsumerInput {
    /// Consumes the builder and constructs an Operation<[`RegisterStreamConsumer`](crate::operation::RegisterStreamConsumer)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::RegisterStreamConsumer,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::RegisterStreamConsumer::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "RegisterStreamConsumer",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.RegisterStreamConsumer"))
    }
    fn body(&self) -> crate::serializer::RegisterStreamConsumerInputBody {
        crate::serializer::RegisterStreamConsumerInputBody {
            consumer_name: &self.consumer_name,
            stream_arn: &self.stream_arn,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`RegisterStreamConsumerInput`](crate::input::RegisterStreamConsumerInput)
    pub fn builder() -> crate::input::register_stream_consumer_input::Builder {
        crate::input::register_stream_consumer_input::Builder::default()
    }
}

/// See [`RemoveTagsFromStreamInput`](crate::input::RemoveTagsFromStreamInput)
pub mod remove_tags_from_stream_input {
    /// A builder for [`RemoveTagsFromStreamInput`](crate::input::RemoveTagsFromStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`RemoveTagsFromStreamInput`](crate::input::RemoveTagsFromStreamInput)
        pub fn build(
            self,
        ) -> Result<crate::input::RemoveTagsFromStreamInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::RemoveTagsFromStreamInput {
                tag_keys: self.tag_keys,
                stream_name: self.stream_name,
            })
        }
    }
}
impl RemoveTagsFromStreamInput {
    /// Consumes the builder and constructs an Operation<[`RemoveTagsFromStream`](crate::operation::RemoveTagsFromStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::RemoveTagsFromStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::RemoveTagsFromStream::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "RemoveTagsFromStream",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.RemoveTagsFromStream"))
    }
    fn body(&self) -> crate::serializer::RemoveTagsFromStreamInputBody {
        crate::serializer::RemoveTagsFromStreamInputBody {
            tag_keys: &self.tag_keys,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`RemoveTagsFromStreamInput`](crate::input::RemoveTagsFromStreamInput)
    pub fn builder() -> crate::input::remove_tags_from_stream_input::Builder {
        crate::input::remove_tags_from_stream_input::Builder::default()
    }
}

/// See [`SplitShardInput`](crate::input::SplitShardInput)
pub mod split_shard_input {
    /// A builder for [`SplitShardInput`](crate::input::SplitShardInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        shard_to_split: std::option::Option<std::string::String>,
        new_starting_hash_key: std::option::Option<std::string::String>,
        stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The shard ID of the shard to split.</p>
        pub fn shard_to_split(mut self, inp: impl Into<std::string::String>) -> Self {
            self.shard_to_split = Some(inp.into());
            self
        }
        pub fn set_shard_to_split(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.shard_to_split = inp;
            self
        }
        /// <p>A hash key value for the starting hash key of one of the child shards created by
        /// the split. The hash key range for a given shard constitutes a set of ordered contiguous
        /// positive integers. The value for <code>NewStartingHashKey</code> must be in the range of
        /// hash keys being mapped into the shard. The <code>NewStartingHashKey</code> hash key
        /// value and all higher hash key values in hash key range are distributed to one of the
        /// child shards. All the lower hash key values in the range are distributed to the other
        /// child shard.</p>
        pub fn new_starting_hash_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.new_starting_hash_key = Some(inp.into());
            self
        }
        pub fn set_new_starting_hash_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.new_starting_hash_key = inp;
            self
        }
        /// <p>The name of the stream for the shard split.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`SplitShardInput`](crate::input::SplitShardInput)
        pub fn build(
            self,
        ) -> Result<crate::input::SplitShardInput, smithy_http::operation::BuildError> {
            Ok(crate::input::SplitShardInput {
                shard_to_split: self.shard_to_split,
                new_starting_hash_key: self.new_starting_hash_key,
                stream_name: self.stream_name,
            })
        }
    }
}
impl SplitShardInput {
    /// Consumes the builder and constructs an Operation<[`SplitShard`](crate::operation::SplitShard)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::SplitShard,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::SplitShard::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "SplitShard",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.SplitShard"))
    }
    fn body(&self) -> crate::serializer::SplitShardInputBody {
        crate::serializer::SplitShardInputBody {
            shard_to_split: &self.shard_to_split,
            new_starting_hash_key: &self.new_starting_hash_key,
            stream_name: &self.stream_name,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`SplitShardInput`](crate::input::SplitShardInput)
    pub fn builder() -> crate::input::split_shard_input::Builder {
        crate::input::split_shard_input::Builder::default()
    }
}

/// See [`StartStreamEncryptionInput`](crate::input::StartStreamEncryptionInput)
pub mod start_stream_encryption_input {
    /// A builder for [`StartStreamEncryptionInput`](crate::input::StartStreamEncryptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_name: std::option::Option<std::string::String>,
        encryption_type: std::option::Option<crate::model::EncryptionType>,
        key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the stream for which to start encrypting records.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>The encryption type to use. The only valid value is <code>KMS</code>.</p>
        pub fn encryption_type(mut self, inp: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(inp);
            self
        }
        pub fn set_encryption_type(
            mut self,
            inp: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.encryption_type = inp;
            self
        }
        /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
        /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
        /// owned by Kinesis Data Streams by specifying the alias
        /// <code>aws/kinesis</code>.</p>
        /// <ul>
        /// <li>
        /// <p>Key ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Globally unique key ID example:
        /// <code>12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name example: <code>alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Master key owned by Kinesis Data Streams:
        /// <code>alias/aws/kinesis</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.key_id = Some(inp.into());
            self
        }
        pub fn set_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.key_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`StartStreamEncryptionInput`](crate::input::StartStreamEncryptionInput)
        pub fn build(
            self,
        ) -> Result<crate::input::StartStreamEncryptionInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::StartStreamEncryptionInput {
                stream_name: self.stream_name,
                encryption_type: self.encryption_type,
                key_id: self.key_id,
            })
        }
    }
}
impl StartStreamEncryptionInput {
    /// Consumes the builder and constructs an Operation<[`StartStreamEncryption`](crate::operation::StartStreamEncryption)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::StartStreamEncryption,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StartStreamEncryption::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StartStreamEncryption",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.StartStreamEncryption"))
    }
    fn body(&self) -> crate::serializer::StartStreamEncryptionInputBody {
        crate::serializer::StartStreamEncryptionInputBody {
            stream_name: &self.stream_name,
            encryption_type: &self.encryption_type,
            key_id: &self.key_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`StartStreamEncryptionInput`](crate::input::StartStreamEncryptionInput)
    pub fn builder() -> crate::input::start_stream_encryption_input::Builder {
        crate::input::start_stream_encryption_input::Builder::default()
    }
}

/// See [`StopStreamEncryptionInput`](crate::input::StopStreamEncryptionInput)
pub mod stop_stream_encryption_input {
    /// A builder for [`StopStreamEncryptionInput`](crate::input::StopStreamEncryptionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        stream_name: std::option::Option<std::string::String>,
        encryption_type: std::option::Option<crate::model::EncryptionType>,
        key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the stream on which to stop encrypting records.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>The encryption type. The only valid value is <code>KMS</code>.</p>
        pub fn encryption_type(mut self, inp: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(inp);
            self
        }
        pub fn set_encryption_type(
            mut self,
            inp: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.encryption_type = inp;
            self
        }
        /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
        /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
        /// owned by Kinesis Data Streams by specifying the alias
        /// <code>aws/kinesis</code>.</p>
        /// <ul>
        /// <li>
        /// <p>Key ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Globally unique key ID example:
        /// <code>12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name example: <code>alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Master key owned by Kinesis Data Streams:
        /// <code>alias/aws/kinesis</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.key_id = Some(inp.into());
            self
        }
        pub fn set_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.key_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`StopStreamEncryptionInput`](crate::input::StopStreamEncryptionInput)
        pub fn build(
            self,
        ) -> Result<crate::input::StopStreamEncryptionInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::StopStreamEncryptionInput {
                stream_name: self.stream_name,
                encryption_type: self.encryption_type,
                key_id: self.key_id,
            })
        }
    }
}
impl StopStreamEncryptionInput {
    /// Consumes the builder and constructs an Operation<[`StopStreamEncryption`](crate::operation::StopStreamEncryption)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::StopStreamEncryption,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StopStreamEncryption::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StopStreamEncryption",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.StopStreamEncryption"))
    }
    fn body(&self) -> crate::serializer::StopStreamEncryptionInputBody {
        crate::serializer::StopStreamEncryptionInputBody {
            stream_name: &self.stream_name,
            encryption_type: &self.encryption_type,
            key_id: &self.key_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`StopStreamEncryptionInput`](crate::input::StopStreamEncryptionInput)
    pub fn builder() -> crate::input::stop_stream_encryption_input::Builder {
        crate::input::stop_stream_encryption_input::Builder::default()
    }
}

/// See [`UpdateShardCountInput`](crate::input::UpdateShardCountInput)
pub mod update_shard_count_input {
    /// A builder for [`UpdateShardCountInput`](crate::input::UpdateShardCountInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        scaling_type: std::option::Option<crate::model::ScalingType>,
        stream_name: std::option::Option<std::string::String>,
        target_shard_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The scaling type. Uniform scaling creates shards of equal size.</p>
        pub fn scaling_type(mut self, inp: crate::model::ScalingType) -> Self {
            self.scaling_type = Some(inp);
            self
        }
        pub fn set_scaling_type(
            mut self,
            inp: std::option::Option<crate::model::ScalingType>,
        ) -> Self {
            self.scaling_type = inp;
            self
        }
        /// <p>The name of the stream.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>The new number of shards. This value has the following default limits. By default,
        /// you cannot do the following: </p>
        /// <ul>
        /// <li>
        /// <p>Set this value to more than double your current shard count for a
        /// stream.</p>
        /// </li>
        /// <li>
        /// <p>Set this value below half your current shard count for a stream.</p>
        /// </li>
        /// <li>
        /// <p>Set this value to more than 500 shards in a stream (the default limit for
        /// shard count per stream is 500 per account per region), unless you request a
        /// limit increase.</p>
        /// </li>
        /// <li>
        /// <p>Scale a stream with more than 500 shards down unless you set this value to
        /// less than 500 shards.</p>
        /// </li>
        /// </ul>
        pub fn target_shard_count(mut self, inp: i32) -> Self {
            self.target_shard_count = Some(inp);
            self
        }
        pub fn set_target_shard_count(mut self, inp: std::option::Option<i32>) -> Self {
            self.target_shard_count = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateShardCountInput`](crate::input::UpdateShardCountInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateShardCountInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateShardCountInput {
                scaling_type: self.scaling_type,
                stream_name: self.stream_name,
                target_shard_count: self.target_shard_count,
            })
        }
    }
}
impl UpdateShardCountInput {
    /// Consumes the builder and constructs an Operation<[`UpdateShardCount`](crate::operation::UpdateShardCount)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateShardCount,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateShardCount::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateShardCount",
                "kinesis",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Kinesis_20131202.UpdateShardCount"))
    }
    fn body(&self) -> crate::serializer::UpdateShardCountInputBody {
        crate::serializer::UpdateShardCountInputBody {
            scaling_type: &self.scaling_type,
            stream_name: &self.stream_name,
            target_shard_count: &self.target_shard_count,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`UpdateShardCountInput`](crate::input::UpdateShardCountInput)
    pub fn builder() -> crate::input::update_shard_count_input::Builder {
        crate::input::update_shard_count_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateShardCountInput {
    /// <p>The scaling type. Uniform scaling creates shards of equal size.</p>
    pub scaling_type: std::option::Option<crate::model::ScalingType>,
    /// <p>The name of the stream.</p>
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The new number of shards. This value has the following default limits. By default,
    /// you cannot do the following: </p>
    /// <ul>
    /// <li>
    /// <p>Set this value to more than double your current shard count for a
    /// stream.</p>
    /// </li>
    /// <li>
    /// <p>Set this value below half your current shard count for a stream.</p>
    /// </li>
    /// <li>
    /// <p>Set this value to more than 500 shards in a stream (the default limit for
    /// shard count per stream is 500 per account per region), unless you request a
    /// limit increase.</p>
    /// </li>
    /// <li>
    /// <p>Scale a stream with more than 500 shards down unless you set this value to
    /// less than 500 shards.</p>
    /// </li>
    /// </ul>
    pub target_shard_count: std::option::Option<i32>,
}
impl std::fmt::Debug for UpdateShardCountInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateShardCountInput");
        formatter.field("scaling_type", &self.scaling_type);
        formatter.field("stream_name", &self.stream_name);
        formatter.field("target_shard_count", &self.target_shard_count);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopStreamEncryptionInput {
    /// <p>The name of the stream on which to stop encrypting records.</p>
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The encryption type. The only valid value is <code>KMS</code>.</p>
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
    /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
    /// owned by Kinesis Data Streams by specifying the alias
    /// <code>aws/kinesis</code>.</p>
    /// <ul>
    /// <li>
    /// <p>Key ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Globally unique key ID example:
    /// <code>12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name example: <code>alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Master key owned by Kinesis Data Streams:
    /// <code>alias/aws/kinesis</code>
    /// </p>
    /// </li>
    /// </ul>
    pub key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopStreamEncryptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopStreamEncryptionInput");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("key_id", &self.key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartStreamEncryptionInput {
    /// <p>The name of the stream for which to start encrypting records.</p>
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The encryption type to use. The only valid value is <code>KMS</code>.</p>
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
    /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
    /// owned by Kinesis Data Streams by specifying the alias
    /// <code>aws/kinesis</code>.</p>
    /// <ul>
    /// <li>
    /// <p>Key ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Globally unique key ID example:
    /// <code>12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name example: <code>alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Master key owned by Kinesis Data Streams:
    /// <code>alias/aws/kinesis</code>
    /// </p>
    /// </li>
    /// </ul>
    pub key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartStreamEncryptionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartStreamEncryptionInput");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("key_id", &self.key_id);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>SplitShard</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SplitShardInput {
    /// <p>The shard ID of the shard to split.</p>
    pub shard_to_split: std::option::Option<std::string::String>,
    /// <p>A hash key value for the starting hash key of one of the child shards created by
    /// the split. The hash key range for a given shard constitutes a set of ordered contiguous
    /// positive integers. The value for <code>NewStartingHashKey</code> must be in the range of
    /// hash keys being mapped into the shard. The <code>NewStartingHashKey</code> hash key
    /// value and all higher hash key values in hash key range are distributed to one of the
    /// child shards. All the lower hash key values in the range are distributed to the other
    /// child shard.</p>
    pub new_starting_hash_key: std::option::Option<std::string::String>,
    /// <p>The name of the stream for the shard split.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SplitShardInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SplitShardInput");
        formatter.field("shard_to_split", &self.shard_to_split);
        formatter.field("new_starting_hash_key", &self.new_starting_hash_key);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>RemoveTagsFromStream</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveTagsFromStreamInput {
    /// <p>A list of tag keys. Each corresponding tag is removed from the stream.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the stream.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RemoveTagsFromStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveTagsFromStreamInput");
        formatter.field("tag_keys", &self.tag_keys);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterStreamConsumerInput {
    /// <p>For a given Kinesis data stream, each consumer must have a unique name. However,
    /// consumer names don't have to be unique across data streams.</p>
    pub consumer_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the Kinesis data stream that you want to register the consumer with. For
    /// more info, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    pub stream_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RegisterStreamConsumerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterStreamConsumerInput");
        formatter.field("consumer_name", &self.consumer_name);
        formatter.field("stream_arn", &self.stream_arn);
        formatter.finish()
    }
}

/// <p>A <code>PutRecords</code> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRecordsInput {
    /// <p>The records associated with the request.</p>
    pub records: std::option::Option<std::vec::Vec<crate::model::PutRecordsRequestEntry>>,
    /// <p>The stream name associated with the request.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutRecordsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRecordsInput");
        formatter.field("records", &self.records);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>PutRecord</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRecordInput {
    /// <p>The name of the stream to put the data record into.</p>
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The hash value used to explicitly determine the shard the data record is assigned
    /// to by overriding the partition key hash.</p>
    pub explicit_hash_key: std::option::Option<std::string::String>,
    /// <p>Guarantees strictly increasing sequence numbers, for puts from the same client and
    /// to the same partition key. Usage: set the <code>SequenceNumberForOrdering</code> of
    /// record <i>n</i> to the sequence number of record <i>n-1</i>
    /// (as returned in the result when putting record <i>n-1</i>). If this
    /// parameter is not set, records are coarsely ordered based on arrival time.</p>
    pub sequence_number_for_ordering: std::option::Option<std::string::String>,
    /// <p>Determines which shard in the stream the data record is assigned to. Partition keys
    /// are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
    /// Kinesis Data Streams uses the partition key as input to a hash function that maps the
    /// partition key and associated data to a specific shard. Specifically, an MD5 hash
    /// function is used to map partition keys to 128-bit integer values and to map associated
    /// data records to shards. As a result of this hashing mechanism, all data records with the
    /// same partition key map to the same shard within the stream.</p>
    pub partition_key: std::option::Option<std::string::String>,
    /// <p>The data blob to put into the record, which is base64-encoded when the blob is
    /// serialized. When the data blob (the payload before base64-encoding) is added to the
    /// partition key size, the total size must not exceed the maximum record size (1
    /// MiB).</p>
    pub data: std::option::Option<smithy_types::Blob>,
}
impl std::fmt::Debug for PutRecordInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRecordInput");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("explicit_hash_key", &self.explicit_hash_key);
        formatter.field(
            "sequence_number_for_ordering",
            &self.sequence_number_for_ordering,
        );
        formatter.field("partition_key", &self.partition_key);
        formatter.field("data", &self.data);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>MergeShards</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MergeShardsInput {
    /// <p>The shard ID of the adjacent shard for the merge.</p>
    pub adjacent_shard_to_merge: std::option::Option<std::string::String>,
    /// <p>The name of the stream for the merge.</p>
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The shard ID of the shard to combine with the adjacent shard for the
    /// merge.</p>
    pub shard_to_merge: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MergeShardsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MergeShardsInput");
        formatter.field("adjacent_shard_to_merge", &self.adjacent_shard_to_merge);
        formatter.field("stream_name", &self.stream_name);
        formatter.field("shard_to_merge", &self.shard_to_merge);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>ListTagsForStream</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForStreamInput {
    /// <p>The number of tags to return. If this number is less than the total number of tags
    /// associated with the stream, <code>HasMoreTags</code> is set to <code>true</code>. To
    /// list additional tags, set <code>ExclusiveStartTagKey</code> to the last key in the
    /// response.</p>
    pub limit: std::option::Option<i32>,
    /// <p>The key to use as the starting point for the list of tags. If this parameter is
    /// set, <code>ListTagsForStream</code> gets all tags that occur after
    /// <code>ExclusiveStartTagKey</code>. </p>
    pub exclusive_start_tag_key: std::option::Option<std::string::String>,
    /// <p>The name of the stream.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsForStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForStreamInput");
        formatter.field("limit", &self.limit);
        formatter.field("exclusive_start_tag_key", &self.exclusive_start_tag_key);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>ListStreams</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListStreamsInput {
    /// <p>The maximum number of streams to list.</p>
    pub limit: std::option::Option<i32>,
    /// <p>The name of the stream to start the list with.</p>
    pub exclusive_start_stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListStreamsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListStreamsInput");
        formatter.field("limit", &self.limit);
        formatter.field(
            "exclusive_start_stream_name",
            &self.exclusive_start_stream_name,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListStreamConsumersInput {
    /// <p>When the number of consumers that are registered with the data stream is greater than
    /// the default value for the <code>MaxResults</code> parameter, or if you explicitly
    /// specify a value for <code>MaxResults</code> that is less than the number of consumers
    /// that are registered with the data stream, the response includes a pagination token named
    /// <code>NextToken</code>. You can specify this <code>NextToken</code> value in a
    /// subsequent call to <code>ListStreamConsumers</code> to list the next set of registered
    /// consumers.</p>
    /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if you
    /// specify <code>NextToken</code> because the latter unambiguously identifies the
    /// stream.</p>
    /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when you
    /// specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that is
    /// less than the number of consumers that the operation returns if you don't specify
    /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
    /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
    /// <code>ListStreamConsumers</code> operation to list the next set of consumers.</p>
    /// <important>
    /// <p>Tokens expire after 300 seconds. When you obtain a value for
    /// <code>NextToken</code> in the response to a call to
    /// <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
    /// specify an expired token in a call to <code>ListStreamConsumers</code>, you get
    /// <code>ExpiredNextTokenException</code>.</p>
    /// </important>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Specify this input parameter to distinguish data streams that have the same name. For
    /// example, if you create a data stream and then delete it, and you later create another
    /// data stream with the same name, you can use this input parameter to specify which of the
    /// two streams you want to list the consumers for. </p>
    /// <p>You can't specify this parameter if you specify the NextToken parameter. </p>
    pub stream_creation_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The ARN of the Kinesis data stream for which you want to list the registered
    /// consumers. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of consumers that you want a single call of
    /// <code>ListStreamConsumers</code> to return.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListStreamConsumersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListStreamConsumersInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("stream_creation_timestamp", &self.stream_creation_timestamp);
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListShardsInput {
    /// <p>The maximum number of shards to return in a single call to <code>ListShards</code>.
    /// The minimum value you can specify for this parameter is 1, and the maximum is 10,000,
    /// which is also the default.</p>
    /// <p>When the number of shards to be listed is greater than the value of
    /// <code>MaxResults</code>, the response contains a <code>NextToken</code> value that
    /// you can use in a subsequent call to <code>ListShards</code> to list the next set of
    /// shards.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Specify this input parameter to distinguish data streams that have the same name.
    /// For example, if you create a data stream and then delete it, and you later create
    /// another data stream with the same name, you can use this input parameter to specify
    /// which of the two streams you want to list the shards for.</p>
    /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
    /// parameter.</p>
    pub stream_creation_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>When the number of shards in the data stream is greater than the default value for
    /// the <code>MaxResults</code> parameter, or if you explicitly specify a value for
    /// <code>MaxResults</code> that is less than the number of shards in the data stream,
    /// the response includes a pagination token named <code>NextToken</code>. You can specify
    /// this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
    /// list the next set of shards.</p>
    /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if
    /// you specify <code>NextToken</code> because the latter unambiguously identifies the
    /// stream.</p>
    /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when
    /// you specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that
    /// is less than the number of shards that the operation returns if you don't specify
    /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
    /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
    /// <code>ListShards</code> operation.</p>
    /// <important>
    /// <p>Tokens expire after 300 seconds. When you obtain a value for
    /// <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
    /// have 300 seconds to use that value. If you specify an expired token in a call to
    /// <code>ListShards</code>, you get
    /// <code>ExpiredNextTokenException</code>.</p>
    /// </important>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Specify this parameter to indicate that you want to list the shards starting with
    /// the shard whose ID immediately follows <code>ExclusiveStartShardId</code>.</p>
    /// <p>If you don't specify this parameter, the default behavior is for
    /// <code>ListShards</code> to list the shards starting with the first one in the
    /// stream.</p>
    /// <p>You cannot specify this parameter if you specify <code>NextToken</code>.</p>
    pub exclusive_start_shard_id: std::option::Option<std::string::String>,
    pub shard_filter: std::option::Option<crate::model::ShardFilter>,
    /// <p>The name of the data stream whose shards you want to list. </p>
    /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
    /// parameter.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListShardsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListShardsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("stream_creation_timestamp", &self.stream_creation_timestamp);
        formatter.field("next_token", &self.next_token);
        formatter.field("exclusive_start_shard_id", &self.exclusive_start_shard_id);
        formatter.field("shard_filter", &self.shard_filter);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>IncreaseStreamRetentionPeriod</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IncreaseStreamRetentionPeriodInput {
    /// <p>The new retention period of the stream, in hours. Must be more than the current
    /// retention period.</p>
    pub retention_period_hours: std::option::Option<i32>,
    /// <p>The name of the stream to modify.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncreaseStreamRetentionPeriodInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncreaseStreamRetentionPeriodInput");
        formatter.field("retention_period_hours", &self.retention_period_hours);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>GetShardIterator</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetShardIteratorInput {
    /// <p>Determines how the shard iterator is used to start reading data records from the
    /// shard.</p>
    /// <p>The following are the valid Amazon Kinesis shard iterator types:</p>
    /// <ul>
    /// <li>
    /// <p>AT_SEQUENCE_NUMBER - Start reading from the position denoted by a specific
    /// sequence number, provided in the value
    /// <code>StartingSequenceNumber</code>.</p>
    /// </li>
    /// <li>
    /// <p>AFTER_SEQUENCE_NUMBER - Start reading right after the position denoted by a
    /// specific sequence number, provided in the value
    /// <code>StartingSequenceNumber</code>.</p>
    /// </li>
    /// <li>
    /// <p>AT_TIMESTAMP - Start reading from the position denoted by a specific time
    /// stamp, provided in the value <code>Timestamp</code>.</p>
    /// </li>
    /// <li>
    /// <p>TRIM_HORIZON - Start reading at the last untrimmed record in the shard in
    /// the system, which is the oldest data record in the shard.</p>
    /// </li>
    /// <li>
    /// <p>LATEST - Start reading just after the most recent record in the shard, so
    /// that you always read the most recent data in the shard.</p>
    /// </li>
    /// </ul>
    pub shard_iterator_type: std::option::Option<crate::model::ShardIteratorType>,
    /// <p>The shard ID of the Kinesis Data Streams shard to get the iterator for.</p>
    pub shard_id: std::option::Option<std::string::String>,
    /// <p>The sequence number of the data record in the shard from which to start reading.
    /// Used with shard iterator type AT_SEQUENCE_NUMBER and AFTER_SEQUENCE_NUMBER.</p>
    pub starting_sequence_number: std::option::Option<std::string::String>,
    /// <p>The time stamp of the data record from which to start reading. Used with shard
    /// iterator type AT_TIMESTAMP. A time stamp is the Unix epoch date with precision in
    /// milliseconds. For example, <code>2016-04-04T19:58:46.480-00:00</code> or
    /// <code>1459799926.480</code>. If a record with this exact time stamp does not exist,
    /// the iterator returned is for the next (later) record. If the time stamp is older than
    /// the current trim horizon, the iterator returned is for the oldest untrimmed data record
    /// (TRIM_HORIZON).</p>
    pub timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The name of the Amazon Kinesis data stream.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetShardIteratorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetShardIteratorInput");
        formatter.field("shard_iterator_type", &self.shard_iterator_type);
        formatter.field("shard_id", &self.shard_id);
        formatter.field("starting_sequence_number", &self.starting_sequence_number);
        formatter.field("timestamp", &self.timestamp);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>GetRecords</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRecordsInput {
    /// <p>The position in the shard from which you want to start sequentially reading data
    /// records. A shard iterator specifies this position using the sequence number of a data
    /// record in the shard.</p>
    pub shard_iterator: std::option::Option<std::string::String>,
    /// <p>The maximum number of records to return. Specify a value of up to 10,000. If you
    /// specify a value that is greater than 10,000, <a>GetRecords</a> throws
    /// <code>InvalidArgumentException</code>. The default value is 10,000.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for GetRecordsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRecordsInput");
        formatter.field("shard_iterator", &self.shard_iterator);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>EnableEnhancedMonitoring</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableEnhancedMonitoringInput {
    /// <p>The name of the stream for which to enable enhanced monitoring.</p>
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>List of shard-level metrics to enable.</p>
    /// <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
    /// enables every metric.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>IncomingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IncomingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WriteProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ReadProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IteratorAgeMilliseconds</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALL</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    /// Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
    /// Kinesis Data Streams Developer Guide</i>.</p>
    pub shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
}
impl std::fmt::Debug for EnableEnhancedMonitoringInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableEnhancedMonitoringInput");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("shard_level_metrics", &self.shard_level_metrics);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>DisableEnhancedMonitoring</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableEnhancedMonitoringInput {
    /// <p>List of shard-level metrics to disable.</p>
    /// <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
    /// disables every metric.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>IncomingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IncomingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WriteProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ReadProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IteratorAgeMilliseconds</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALL</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    /// Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
    /// Kinesis Data Streams Developer Guide</i>.</p>
    pub shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
    /// <p>The name of the Kinesis data stream for which to disable enhanced
    /// monitoring.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisableEnhancedMonitoringInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableEnhancedMonitoringInput");
        formatter.field("shard_level_metrics", &self.shard_level_metrics);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamSummaryInput {
    /// <p>The name of the stream to describe.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeStreamSummaryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamSummaryInput");
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamConsumerInput {
    /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
    /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The name that you gave to the consumer.</p>
    pub consumer_name: std::option::Option<std::string::String>,
    /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer.</p>
    pub consumer_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeStreamConsumerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamConsumerInput");
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("consumer_name", &self.consumer_name);
        formatter.field("consumer_arn", &self.consumer_arn);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>DescribeStream</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamInput {
    /// <p>The name of the stream to describe.</p>
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The shard ID of the shard to start with.</p>
    pub exclusive_start_shard_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of shards to return in a single call. The default value is 100.
    /// If you specify a value greater than 100, at most 100 shards are returned.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamInput");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("exclusive_start_shard_id", &self.exclusive_start_shard_id);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLimitsInput {}
impl std::fmt::Debug for DescribeLimitsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLimitsInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterStreamConsumerInput {
    /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
    /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The name that you gave to the consumer.</p>
    pub consumer_name: std::option::Option<std::string::String>,
    /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer. If you
    /// don't know the ARN of the consumer that you want to deregister, you can use the
    /// ListStreamConsumers operation to get a list of the descriptions of all the consumers
    /// that are currently registered with a given data stream. The description of a consumer
    /// contains its ARN.</p>
    pub consumer_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeregisterStreamConsumerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterStreamConsumerInput");
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("consumer_name", &self.consumer_name);
        formatter.field("consumer_arn", &self.consumer_arn);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>DeleteStream</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteStreamInput {
    /// <p>The name of the stream to delete.</p>
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>If this parameter is unset (<code>null</code>) or if you set it to <code>false</code>,
    /// and the stream has registered consumers, the call to <code>DeleteStream</code> fails
    /// with a <code>ResourceInUseException</code>. </p>
    pub enforce_consumer_deletion: std::option::Option<bool>,
}
impl std::fmt::Debug for DeleteStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteStreamInput");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("enforce_consumer_deletion", &self.enforce_consumer_deletion);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>DecreaseStreamRetentionPeriod</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DecreaseStreamRetentionPeriodInput {
    /// <p>The new retention period of the stream, in hours. Must be less than the current
    /// retention period.</p>
    pub retention_period_hours: std::option::Option<i32>,
    /// <p>The name of the stream to modify.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DecreaseStreamRetentionPeriodInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DecreaseStreamRetentionPeriodInput");
        formatter.field("retention_period_hours", &self.retention_period_hours);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>CreateStream</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateStreamInput {
    /// <p>A name to identify the stream. The stream name is scoped to the AWS account used by
    /// the application that creates the stream. It is also scoped by AWS Region. That is, two
    /// streams in two different AWS accounts can have the same name. Two streams in the same
    /// AWS account but in two different Regions can also have the same name.</p>
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The number of shards that the stream will use. The throughput of the stream is a
    /// function of the number of shards; more shards are required for greater provisioned
    /// throughput.</p>
    pub shard_count: std::option::Option<i32>,
}
impl std::fmt::Debug for CreateStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateStreamInput");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("shard_count", &self.shard_count);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>AddTagsToStream</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddTagsToStreamInput {
    /// <p>A set of up to 10 key-value pairs to use to create the tags.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The name of the stream.</p>
    pub stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddTagsToStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddTagsToStreamInput");
        formatter.field("tags", &self.tags);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}
