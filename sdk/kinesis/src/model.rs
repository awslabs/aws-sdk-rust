// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalingType {
    UniformScaling,
    Unknown(String),
}
impl std::convert::From<&str> for ScalingType {
    fn from(s: &str) -> Self {
        match s {
            "UNIFORM_SCALING" => ScalingType::UniformScaling,
            other => ScalingType::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for ScalingType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ScalingType::from(s))
    }
}

impl ScalingType {
    pub fn as_str(&self) -> &str {
        match self {
            ScalingType::UniformScaling => "UNIFORM_SCALING",
            ScalingType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ScalingType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for ScalingType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for ScalingType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EncryptionType {
    Kms,
    None,
    Unknown(String),
}
impl std::convert::From<&str> for EncryptionType {
    fn from(s: &str) -> Self {
        match s {
            "KMS" => EncryptionType::Kms,
            "NONE" => EncryptionType::None,
            other => EncryptionType::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for EncryptionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(EncryptionType::from(s))
    }
}

impl EncryptionType {
    pub fn as_str(&self) -> &str {
        match self {
            EncryptionType::Kms => "KMS",
            EncryptionType::None => "NONE",
            EncryptionType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for EncryptionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for EncryptionType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for EncryptionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>An object that represents the details of the consumer you registered. This type of
/// object is returned by <a>RegisterStreamConsumer</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Consumer {
    /// <p>The name of the consumer is something you choose when you register the
    /// consumer.</p>
    #[serde(rename = "ConsumerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub consumer_name: std::option::Option<std::string::String>,
    /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
    /// this ARN to be able to call <a>SubscribeToShard</a>.</p>
    /// <p>If you delete a consumer and then create a new one with the same name, it won't have
    /// the same ARN. That's because consumer ARNs contain the creation timestamp. This is
    /// important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
    #[serde(rename = "ConsumerARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub consumer_arn: std::option::Option<std::string::String>,
    /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code>
    /// states.</p>
    #[serde(rename = "ConsumerStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub consumer_status: std::option::Option<crate::model::ConsumerStatus>,
    /// <p></p>
    #[serde(rename = "ConsumerCreationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub consumer_creation_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for Consumer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Consumer");
        formatter.field("consumer_name", &self.consumer_name);
        formatter.field("consumer_arn", &self.consumer_arn);
        formatter.field("consumer_status", &self.consumer_status);
        formatter.field(
            "consumer_creation_timestamp",
            &self.consumer_creation_timestamp,
        );
        formatter.finish()
    }
}
/// See [`Consumer`](crate::model::Consumer)
pub mod consumer {
    /// A builder for [`Consumer`](crate::model::Consumer)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        consumer_name: std::option::Option<std::string::String>,
        consumer_arn: std::option::Option<std::string::String>,
        consumer_status: std::option::Option<crate::model::ConsumerStatus>,
        consumer_creation_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the consumer is something you choose when you register the
        /// consumer.</p>
        pub fn consumer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.consumer_name = Some(inp.into());
            self
        }
        pub fn set_consumer_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.consumer_name = inp;
            self
        }
        /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
        /// this ARN to be able to call <a>SubscribeToShard</a>.</p>
        /// <p>If you delete a consumer and then create a new one with the same name, it won't have
        /// the same ARN. That's because consumer ARNs contain the creation timestamp. This is
        /// important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
        pub fn consumer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.consumer_arn = Some(inp.into());
            self
        }
        pub fn set_consumer_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.consumer_arn = inp;
            self
        }
        /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code>
        /// states.</p>
        pub fn consumer_status(mut self, inp: crate::model::ConsumerStatus) -> Self {
            self.consumer_status = Some(inp);
            self
        }
        pub fn set_consumer_status(
            mut self,
            inp: std::option::Option<crate::model::ConsumerStatus>,
        ) -> Self {
            self.consumer_status = inp;
            self
        }
        /// <p></p>
        pub fn consumer_creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.consumer_creation_timestamp = Some(inp);
            self
        }
        pub fn set_consumer_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.consumer_creation_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`Consumer`](crate::model::Consumer)
        pub fn build(self) -> crate::model::Consumer {
            crate::model::Consumer {
                consumer_name: self.consumer_name,
                consumer_arn: self.consumer_arn,
                consumer_status: self.consumer_status,
                consumer_creation_timestamp: self.consumer_creation_timestamp,
            }
        }
    }
}
impl Consumer {
    /// Creates a new builder-style object to manufacture [`Consumer`](crate::model::Consumer)
    pub fn builder() -> crate::model::consumer::Builder {
        crate::model::consumer::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConsumerStatus {
    Active,
    Creating,
    Deleting,
    Unknown(String),
}
impl std::convert::From<&str> for ConsumerStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ConsumerStatus::Active,
            "CREATING" => ConsumerStatus::Creating,
            "DELETING" => ConsumerStatus::Deleting,
            other => ConsumerStatus::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for ConsumerStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ConsumerStatus::from(s))
    }
}

impl ConsumerStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ConsumerStatus::Active => "ACTIVE",
            ConsumerStatus::Creating => "CREATING",
            ConsumerStatus::Deleting => "DELETING",
            ConsumerStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ConsumerStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for ConsumerStatus {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for ConsumerStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the result of an individual record from a <code>PutRecords</code>
/// request. A record that is successfully added to a stream includes
/// <code>SequenceNumber</code> and <code>ShardId</code> in the result. A record that
/// fails to be added to the stream includes <code>ErrorCode</code> and
/// <code>ErrorMessage</code> in the result.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRecordsResultEntry {
    /// <p>The error code for an individual record result. <code>ErrorCodes</code> can be
    /// either <code>ProvisionedThroughputExceededException</code> or
    /// <code>InternalFailure</code>.</p>
    #[serde(rename = "ErrorCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The shard ID for an individual record result.</p>
    #[serde(rename = "ShardId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub shard_id: std::option::Option<std::string::String>,
    /// <p>The error message for an individual record result. An <code>ErrorCode</code> value
    /// of <code>ProvisionedThroughputExceededException</code> has an error message that
    /// includes the account ID, stream name, and shard ID. An <code>ErrorCode</code> value of
    /// <code>InternalFailure</code> has the error message <code>"Internal Service
    /// Failure"</code>.</p>
    #[serde(rename = "ErrorMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The sequence number for an individual record result.</p>
    #[serde(rename = "SequenceNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub sequence_number: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutRecordsResultEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRecordsResultEntry");
        formatter.field("error_code", &self.error_code);
        formatter.field("shard_id", &self.shard_id);
        formatter.field("error_message", &self.error_message);
        formatter.field("sequence_number", &self.sequence_number);
        formatter.finish()
    }
}
/// See [`PutRecordsResultEntry`](crate::model::PutRecordsResultEntry)
pub mod put_records_result_entry {
    /// A builder for [`PutRecordsResultEntry`](crate::model::PutRecordsResultEntry)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        error_code: std::option::Option<std::string::String>,
        shard_id: std::option::Option<std::string::String>,
        error_message: std::option::Option<std::string::String>,
        sequence_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code for an individual record result. <code>ErrorCodes</code> can be
        /// either <code>ProvisionedThroughputExceededException</code> or
        /// <code>InternalFailure</code>.</p>
        pub fn error_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.error_code = Some(inp.into());
            self
        }
        pub fn set_error_code(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.error_code = inp;
            self
        }
        /// <p>The shard ID for an individual record result.</p>
        pub fn shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.shard_id = Some(inp.into());
            self
        }
        pub fn set_shard_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.shard_id = inp;
            self
        }
        /// <p>The error message for an individual record result. An <code>ErrorCode</code> value
        /// of <code>ProvisionedThroughputExceededException</code> has an error message that
        /// includes the account ID, stream name, and shard ID. An <code>ErrorCode</code> value of
        /// <code>InternalFailure</code> has the error message <code>"Internal Service
        /// Failure"</code>.</p>
        pub fn error_message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.error_message = Some(inp.into());
            self
        }
        pub fn set_error_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.error_message = inp;
            self
        }
        /// <p>The sequence number for an individual record result.</p>
        pub fn sequence_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.sequence_number = Some(inp.into());
            self
        }
        pub fn set_sequence_number(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.sequence_number = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutRecordsResultEntry`](crate::model::PutRecordsResultEntry)
        pub fn build(self) -> crate::model::PutRecordsResultEntry {
            crate::model::PutRecordsResultEntry {
                error_code: self.error_code,
                shard_id: self.shard_id,
                error_message: self.error_message,
                sequence_number: self.sequence_number,
            }
        }
    }
}
impl PutRecordsResultEntry {
    /// Creates a new builder-style object to manufacture [`PutRecordsResultEntry`](crate::model::PutRecordsResultEntry)
    pub fn builder() -> crate::model::put_records_result_entry::Builder {
        crate::model::put_records_result_entry::Builder::default()
    }
}

/// <p>Represents the output for <code>PutRecords</code>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRecordsRequestEntry {
    /// <p>The data blob to put into the record, which is base64-encoded when the blob is
    /// serialized. When the data blob (the payload before base64-encoding) is added to the
    /// partition key size, the total size must not exceed the maximum record size (1
    /// MiB).</p>
    #[serde(rename = "Data")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::stdoptionoptionsmithytypesblob_ser")]
    #[serde(deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesblob_deser")]
    #[serde(default)]
    pub data: std::option::Option<smithy_types::Blob>,
    /// <p>Determines which shard in the stream the data record is assigned to. Partition keys
    /// are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
    /// Kinesis Data Streams uses the partition key as input to a hash function that maps the
    /// partition key and associated data to a specific shard. Specifically, an MD5 hash
    /// function is used to map partition keys to 128-bit integer values and to map associated
    /// data records to shards. As a result of this hashing mechanism, all data records with the
    /// same partition key map to the same shard within the stream.</p>
    #[serde(rename = "PartitionKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub partition_key: std::option::Option<std::string::String>,
    /// <p>The hash value used to determine explicitly the shard that the data record is
    /// assigned to by overriding the partition key hash.</p>
    #[serde(rename = "ExplicitHashKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub explicit_hash_key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutRecordsRequestEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRecordsRequestEntry");
        formatter.field("data", &self.data);
        formatter.field("partition_key", &self.partition_key);
        formatter.field("explicit_hash_key", &self.explicit_hash_key);
        formatter.finish()
    }
}
/// See [`PutRecordsRequestEntry`](crate::model::PutRecordsRequestEntry)
pub mod put_records_request_entry {
    /// A builder for [`PutRecordsRequestEntry`](crate::model::PutRecordsRequestEntry)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        data: std::option::Option<smithy_types::Blob>,
        partition_key: std::option::Option<std::string::String>,
        explicit_hash_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The data blob to put into the record, which is base64-encoded when the blob is
        /// serialized. When the data blob (the payload before base64-encoding) is added to the
        /// partition key size, the total size must not exceed the maximum record size (1
        /// MiB).</p>
        pub fn data(mut self, inp: smithy_types::Blob) -> Self {
            self.data = Some(inp);
            self
        }
        pub fn set_data(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.data = inp;
            self
        }
        /// <p>Determines which shard in the stream the data record is assigned to. Partition keys
        /// are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
        /// Kinesis Data Streams uses the partition key as input to a hash function that maps the
        /// partition key and associated data to a specific shard. Specifically, an MD5 hash
        /// function is used to map partition keys to 128-bit integer values and to map associated
        /// data records to shards. As a result of this hashing mechanism, all data records with the
        /// same partition key map to the same shard within the stream.</p>
        pub fn partition_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.partition_key = Some(inp.into());
            self
        }
        pub fn set_partition_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.partition_key = inp;
            self
        }
        /// <p>The hash value used to determine explicitly the shard that the data record is
        /// assigned to by overriding the partition key hash.</p>
        pub fn explicit_hash_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.explicit_hash_key = Some(inp.into());
            self
        }
        pub fn set_explicit_hash_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.explicit_hash_key = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutRecordsRequestEntry`](crate::model::PutRecordsRequestEntry)
        pub fn build(self) -> crate::model::PutRecordsRequestEntry {
            crate::model::PutRecordsRequestEntry {
                data: self.data,
                partition_key: self.partition_key,
                explicit_hash_key: self.explicit_hash_key,
            }
        }
    }
}
impl PutRecordsRequestEntry {
    /// Creates a new builder-style object to manufacture [`PutRecordsRequestEntry`](crate::model::PutRecordsRequestEntry)
    pub fn builder() -> crate::model::put_records_request_entry::Builder {
        crate::model::put_records_request_entry::Builder::default()
    }
}

/// <p>Metadata assigned to the stream, consisting of a key-value pair.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>An optional string, typically used to describe or define the tag. Maximum length:
    /// 256 characters. Valid characters: Unicode letters, digits, white space, _ . / = + - %
    /// @</p>
    #[serde(rename = "Value")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the tag. Maximum length: 128 characters. Valid characters:
    /// Unicode letters, digits, white space, _ . / = + - % @</p>
    #[serde(rename = "Key")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("value", &self.value);
        formatter.field("key", &self.key);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        value: std::option::Option<std::string::String>,
        key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An optional string, typically used to describe or define the tag. Maximum length:
        /// 256 characters. Valid characters: Unicode letters, digits, white space, _ . / = + - %
        /// @</p>
        pub fn value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.value = Some(inp.into());
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.value = inp;
            self
        }
        /// <p>A unique identifier for the tag. Maximum length: 128 characters. Valid characters:
        /// Unicode letters, digits, white space, _ . / = + - % @</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.key = Some(inp.into());
            self
        }
        pub fn set_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.key = inp;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                value: self.value,
                key: self.key,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>A uniquely identified group of data records in a Kinesis data stream.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Shard {
    /// <p>The range of possible sequence numbers for the shard.</p>
    #[serde(rename = "SequenceNumberRange")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub sequence_number_range: std::option::Option<crate::model::SequenceNumberRange>,
    /// <p>The unique identifier of the shard within the stream.</p>
    #[serde(rename = "ShardId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub shard_id: std::option::Option<std::string::String>,
    /// <p>The range of possible hash key values for the shard, which is a set of ordered
    /// contiguous positive integers.</p>
    #[serde(rename = "HashKeyRange")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub hash_key_range: std::option::Option<crate::model::HashKeyRange>,
    /// <p>The shard ID of the shard adjacent to the shard's parent.</p>
    #[serde(rename = "AdjacentParentShardId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub adjacent_parent_shard_id: std::option::Option<std::string::String>,
    /// <p>The shard ID of the shard's parent.</p>
    #[serde(rename = "ParentShardId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub parent_shard_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Shard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Shard");
        formatter.field("sequence_number_range", &self.sequence_number_range);
        formatter.field("shard_id", &self.shard_id);
        formatter.field("hash_key_range", &self.hash_key_range);
        formatter.field("adjacent_parent_shard_id", &self.adjacent_parent_shard_id);
        formatter.field("parent_shard_id", &self.parent_shard_id);
        formatter.finish()
    }
}
/// See [`Shard`](crate::model::Shard)
pub mod shard {
    /// A builder for [`Shard`](crate::model::Shard)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        sequence_number_range: std::option::Option<crate::model::SequenceNumberRange>,
        shard_id: std::option::Option<std::string::String>,
        hash_key_range: std::option::Option<crate::model::HashKeyRange>,
        adjacent_parent_shard_id: std::option::Option<std::string::String>,
        parent_shard_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The range of possible sequence numbers for the shard.</p>
        pub fn sequence_number_range(mut self, inp: crate::model::SequenceNumberRange) -> Self {
            self.sequence_number_range = Some(inp);
            self
        }
        pub fn set_sequence_number_range(
            mut self,
            inp: std::option::Option<crate::model::SequenceNumberRange>,
        ) -> Self {
            self.sequence_number_range = inp;
            self
        }
        /// <p>The unique identifier of the shard within the stream.</p>
        pub fn shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.shard_id = Some(inp.into());
            self
        }
        pub fn set_shard_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.shard_id = inp;
            self
        }
        /// <p>The range of possible hash key values for the shard, which is a set of ordered
        /// contiguous positive integers.</p>
        pub fn hash_key_range(mut self, inp: crate::model::HashKeyRange) -> Self {
            self.hash_key_range = Some(inp);
            self
        }
        pub fn set_hash_key_range(
            mut self,
            inp: std::option::Option<crate::model::HashKeyRange>,
        ) -> Self {
            self.hash_key_range = inp;
            self
        }
        /// <p>The shard ID of the shard adjacent to the shard's parent.</p>
        pub fn adjacent_parent_shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.adjacent_parent_shard_id = Some(inp.into());
            self
        }
        pub fn set_adjacent_parent_shard_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.adjacent_parent_shard_id = inp;
            self
        }
        /// <p>The shard ID of the shard's parent.</p>
        pub fn parent_shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.parent_shard_id = Some(inp.into());
            self
        }
        pub fn set_parent_shard_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_shard_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`Shard`](crate::model::Shard)
        pub fn build(self) -> crate::model::Shard {
            crate::model::Shard {
                sequence_number_range: self.sequence_number_range,
                shard_id: self.shard_id,
                hash_key_range: self.hash_key_range,
                adjacent_parent_shard_id: self.adjacent_parent_shard_id,
                parent_shard_id: self.parent_shard_id,
            }
        }
    }
}
impl Shard {
    /// Creates a new builder-style object to manufacture [`Shard`](crate::model::Shard)
    pub fn builder() -> crate::model::shard::Builder {
        crate::model::shard::Builder::default()
    }
}

/// <p>The range of possible hash key values for the shard, which is a set of ordered
/// contiguous positive integers.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct HashKeyRange {
    /// <p>The starting hash key of the hash key range.</p>
    #[serde(rename = "StartingHashKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub starting_hash_key: std::option::Option<std::string::String>,
    /// <p>The ending hash key of the hash key range.</p>
    #[serde(rename = "EndingHashKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub ending_hash_key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HashKeyRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HashKeyRange");
        formatter.field("starting_hash_key", &self.starting_hash_key);
        formatter.field("ending_hash_key", &self.ending_hash_key);
        formatter.finish()
    }
}
/// See [`HashKeyRange`](crate::model::HashKeyRange)
pub mod hash_key_range {
    /// A builder for [`HashKeyRange`](crate::model::HashKeyRange)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        starting_hash_key: std::option::Option<std::string::String>,
        ending_hash_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The starting hash key of the hash key range.</p>
        pub fn starting_hash_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.starting_hash_key = Some(inp.into());
            self
        }
        pub fn set_starting_hash_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.starting_hash_key = inp;
            self
        }
        /// <p>The ending hash key of the hash key range.</p>
        pub fn ending_hash_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ending_hash_key = Some(inp.into());
            self
        }
        pub fn set_ending_hash_key(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.ending_hash_key = inp;
            self
        }
        /// Consumes the builder and constructs a [`HashKeyRange`](crate::model::HashKeyRange)
        pub fn build(self) -> crate::model::HashKeyRange {
            crate::model::HashKeyRange {
                starting_hash_key: self.starting_hash_key,
                ending_hash_key: self.ending_hash_key,
            }
        }
    }
}
impl HashKeyRange {
    /// Creates a new builder-style object to manufacture [`HashKeyRange`](crate::model::HashKeyRange)
    pub fn builder() -> crate::model::hash_key_range::Builder {
        crate::model::hash_key_range::Builder::default()
    }
}

/// <p>The range of possible sequence numbers for the shard.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SequenceNumberRange {
    /// <p>The starting sequence number for the range.</p>
    #[serde(rename = "StartingSequenceNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub starting_sequence_number: std::option::Option<std::string::String>,
    /// <p>The ending sequence number for the range. Shards that are in the OPEN state have an
    /// ending sequence number of <code>null</code>.</p>
    #[serde(rename = "EndingSequenceNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub ending_sequence_number: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SequenceNumberRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SequenceNumberRange");
        formatter.field("starting_sequence_number", &self.starting_sequence_number);
        formatter.field("ending_sequence_number", &self.ending_sequence_number);
        formatter.finish()
    }
}
/// See [`SequenceNumberRange`](crate::model::SequenceNumberRange)
pub mod sequence_number_range {
    /// A builder for [`SequenceNumberRange`](crate::model::SequenceNumberRange)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        starting_sequence_number: std::option::Option<std::string::String>,
        ending_sequence_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The starting sequence number for the range.</p>
        pub fn starting_sequence_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.starting_sequence_number = Some(inp.into());
            self
        }
        pub fn set_starting_sequence_number(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.starting_sequence_number = inp;
            self
        }
        /// <p>The ending sequence number for the range. Shards that are in the OPEN state have an
        /// ending sequence number of <code>null</code>.</p>
        pub fn ending_sequence_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.ending_sequence_number = Some(inp.into());
            self
        }
        pub fn set_ending_sequence_number(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.ending_sequence_number = inp;
            self
        }
        /// Consumes the builder and constructs a [`SequenceNumberRange`](crate::model::SequenceNumberRange)
        pub fn build(self) -> crate::model::SequenceNumberRange {
            crate::model::SequenceNumberRange {
                starting_sequence_number: self.starting_sequence_number,
                ending_sequence_number: self.ending_sequence_number,
            }
        }
    }
}
impl SequenceNumberRange {
    /// Creates a new builder-style object to manufacture [`SequenceNumberRange`](crate::model::SequenceNumberRange)
    pub fn builder() -> crate::model::sequence_number_range::Builder {
        crate::model::sequence_number_range::Builder::default()
    }
}

#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ShardFilter {
    #[serde(rename = "ShardId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub shard_id: std::option::Option<std::string::String>,
    #[serde(rename = "Timestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub timestamp: std::option::Option<smithy_types::Instant>,
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub r#type: std::option::Option<crate::model::ShardFilterType>,
}
impl std::fmt::Debug for ShardFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ShardFilter");
        formatter.field("shard_id", &self.shard_id);
        formatter.field("timestamp", &self.timestamp);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`ShardFilter`](crate::model::ShardFilter)
pub mod shard_filter {
    /// A builder for [`ShardFilter`](crate::model::ShardFilter)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        shard_id: std::option::Option<std::string::String>,
        timestamp: std::option::Option<smithy_types::Instant>,
        r#type: std::option::Option<crate::model::ShardFilterType>,
    }
    impl Builder {
        pub fn shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.shard_id = Some(inp.into());
            self
        }
        pub fn set_shard_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.shard_id = inp;
            self
        }
        pub fn timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        pub fn set_timestamp(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = inp;
            self
        }
        pub fn r#type(mut self, inp: crate::model::ShardFilterType) -> Self {
            self.r#type = Some(inp);
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<crate::model::ShardFilterType>) -> Self {
            self.r#type = inp;
            self
        }
        /// Consumes the builder and constructs a [`ShardFilter`](crate::model::ShardFilter)
        pub fn build(self) -> crate::model::ShardFilter {
            crate::model::ShardFilter {
                shard_id: self.shard_id,
                timestamp: self.timestamp,
                r#type: self.r#type,
            }
        }
    }
}
impl ShardFilter {
    /// Creates a new builder-style object to manufacture [`ShardFilter`](crate::model::ShardFilter)
    pub fn builder() -> crate::model::shard_filter::Builder {
        crate::model::shard_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ShardFilterType {
    AfterShardId,
    AtLatest,
    AtTimestamp,
    AtTrimHorizon,
    FromTimestamp,
    FromTrimHorizon,
    Unknown(String),
}
impl std::convert::From<&str> for ShardFilterType {
    fn from(s: &str) -> Self {
        match s {
            "AFTER_SHARD_ID" => ShardFilterType::AfterShardId,
            "AT_LATEST" => ShardFilterType::AtLatest,
            "AT_TIMESTAMP" => ShardFilterType::AtTimestamp,
            "AT_TRIM_HORIZON" => ShardFilterType::AtTrimHorizon,
            "FROM_TIMESTAMP" => ShardFilterType::FromTimestamp,
            "FROM_TRIM_HORIZON" => ShardFilterType::FromTrimHorizon,
            other => ShardFilterType::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for ShardFilterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ShardFilterType::from(s))
    }
}

impl ShardFilterType {
    pub fn as_str(&self) -> &str {
        match self {
            ShardFilterType::AfterShardId => "AFTER_SHARD_ID",
            ShardFilterType::AtLatest => "AT_LATEST",
            ShardFilterType::AtTimestamp => "AT_TIMESTAMP",
            ShardFilterType::AtTrimHorizon => "AT_TRIM_HORIZON",
            ShardFilterType::FromTimestamp => "FROM_TIMESTAMP",
            ShardFilterType::FromTrimHorizon => "FROM_TRIM_HORIZON",
            ShardFilterType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ShardFilterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for ShardFilterType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for ShardFilterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ShardIteratorType {
    AfterSequenceNumber,
    AtSequenceNumber,
    AtTimestamp,
    Latest,
    TrimHorizon,
    Unknown(String),
}
impl std::convert::From<&str> for ShardIteratorType {
    fn from(s: &str) -> Self {
        match s {
            "AFTER_SEQUENCE_NUMBER" => ShardIteratorType::AfterSequenceNumber,
            "AT_SEQUENCE_NUMBER" => ShardIteratorType::AtSequenceNumber,
            "AT_TIMESTAMP" => ShardIteratorType::AtTimestamp,
            "LATEST" => ShardIteratorType::Latest,
            "TRIM_HORIZON" => ShardIteratorType::TrimHorizon,
            other => ShardIteratorType::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for ShardIteratorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ShardIteratorType::from(s))
    }
}

impl ShardIteratorType {
    pub fn as_str(&self) -> &str {
        match self {
            ShardIteratorType::AfterSequenceNumber => "AFTER_SEQUENCE_NUMBER",
            ShardIteratorType::AtSequenceNumber => "AT_SEQUENCE_NUMBER",
            ShardIteratorType::AtTimestamp => "AT_TIMESTAMP",
            ShardIteratorType::Latest => "LATEST",
            ShardIteratorType::TrimHorizon => "TRIM_HORIZON",
            ShardIteratorType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ShardIteratorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for ShardIteratorType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for ShardIteratorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ChildShard {
    #[serde(rename = "ParentShards")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub parent_shards: std::option::Option<std::vec::Vec<std::string::String>>,
    #[serde(rename = "ShardId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub shard_id: std::option::Option<std::string::String>,
    /// <p>The range of possible hash key values for the shard, which is a set of ordered
    /// contiguous positive integers.</p>
    #[serde(rename = "HashKeyRange")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub hash_key_range: std::option::Option<crate::model::HashKeyRange>,
}
impl std::fmt::Debug for ChildShard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChildShard");
        formatter.field("parent_shards", &self.parent_shards);
        formatter.field("shard_id", &self.shard_id);
        formatter.field("hash_key_range", &self.hash_key_range);
        formatter.finish()
    }
}
/// See [`ChildShard`](crate::model::ChildShard)
pub mod child_shard {
    /// A builder for [`ChildShard`](crate::model::ChildShard)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        parent_shards: std::option::Option<std::vec::Vec<std::string::String>>,
        shard_id: std::option::Option<std::string::String>,
        hash_key_range: std::option::Option<crate::model::HashKeyRange>,
    }
    impl Builder {
        pub fn parent_shards(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.parent_shards.unwrap_or_default();
            v.push(inp.into());
            self.parent_shards = Some(v);
            self
        }
        pub fn set_parent_shards(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.parent_shards = inp;
            self
        }
        pub fn shard_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.shard_id = Some(inp.into());
            self
        }
        pub fn set_shard_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.shard_id = inp;
            self
        }
        /// <p>The range of possible hash key values for the shard, which is a set of ordered
        /// contiguous positive integers.</p>
        pub fn hash_key_range(mut self, inp: crate::model::HashKeyRange) -> Self {
            self.hash_key_range = Some(inp);
            self
        }
        pub fn set_hash_key_range(
            mut self,
            inp: std::option::Option<crate::model::HashKeyRange>,
        ) -> Self {
            self.hash_key_range = inp;
            self
        }
        /// Consumes the builder and constructs a [`ChildShard`](crate::model::ChildShard)
        pub fn build(self) -> crate::model::ChildShard {
            crate::model::ChildShard {
                parent_shards: self.parent_shards,
                shard_id: self.shard_id,
                hash_key_range: self.hash_key_range,
            }
        }
    }
}
impl ChildShard {
    /// Creates a new builder-style object to manufacture [`ChildShard`](crate::model::ChildShard)
    pub fn builder() -> crate::model::child_shard::Builder {
        crate::model::child_shard::Builder::default()
    }
}

/// <p>The unit of data of the Kinesis data stream, which is composed of a sequence
/// number, a partition key, and a data blob.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Record {
    /// <p>The unique identifier of the record within its shard.</p>
    #[serde(rename = "SequenceNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub sequence_number: std::option::Option<std::string::String>,
    /// <p>The encryption type used on the record. This parameter can be one of the following
    /// values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code>: Do not encrypt the records in the stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KMS</code>: Use server-side encryption on the records in the stream
    /// using a customer-managed AWS KMS key.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "EncryptionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>The data blob. The data in the blob is both opaque and immutable to Kinesis Data
    /// Streams, which does not inspect, interpret, or change the data in the blob in any way.
    /// When the data blob (the payload before base64-encoding) is added to the partition key
    /// size, the total size must not exceed the maximum record size (1 MiB).</p>
    #[serde(rename = "Data")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::stdoptionoptionsmithytypesblob_ser")]
    #[serde(deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesblob_deser")]
    #[serde(default)]
    pub data: std::option::Option<smithy_types::Blob>,
    /// <p>The approximate time that the record was inserted into the stream.</p>
    #[serde(rename = "ApproximateArrivalTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub approximate_arrival_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>Identifies which shard in the stream the data record is assigned to.</p>
    #[serde(rename = "PartitionKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub partition_key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Record {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Record");
        formatter.field("sequence_number", &self.sequence_number);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("data", &self.data);
        formatter.field(
            "approximate_arrival_timestamp",
            &self.approximate_arrival_timestamp,
        );
        formatter.field("partition_key", &self.partition_key);
        formatter.finish()
    }
}
/// See [`Record`](crate::model::Record)
pub mod record {
    /// A builder for [`Record`](crate::model::Record)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        sequence_number: std::option::Option<std::string::String>,
        encryption_type: std::option::Option<crate::model::EncryptionType>,
        data: std::option::Option<smithy_types::Blob>,
        approximate_arrival_timestamp: std::option::Option<smithy_types::Instant>,
        partition_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the record within its shard.</p>
        pub fn sequence_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.sequence_number = Some(inp.into());
            self
        }
        pub fn set_sequence_number(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.sequence_number = inp;
            self
        }
        /// <p>The encryption type used on the record. This parameter can be one of the following
        /// values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NONE</code>: Do not encrypt the records in the stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KMS</code>: Use server-side encryption on the records in the stream
        /// using a customer-managed AWS KMS key.</p>
        /// </li>
        /// </ul>
        pub fn encryption_type(mut self, inp: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(inp);
            self
        }
        pub fn set_encryption_type(
            mut self,
            inp: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.encryption_type = inp;
            self
        }
        /// <p>The data blob. The data in the blob is both opaque and immutable to Kinesis Data
        /// Streams, which does not inspect, interpret, or change the data in the blob in any way.
        /// When the data blob (the payload before base64-encoding) is added to the partition key
        /// size, the total size must not exceed the maximum record size (1 MiB).</p>
        pub fn data(mut self, inp: smithy_types::Blob) -> Self {
            self.data = Some(inp);
            self
        }
        pub fn set_data(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.data = inp;
            self
        }
        /// <p>The approximate time that the record was inserted into the stream.</p>
        pub fn approximate_arrival_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.approximate_arrival_timestamp = Some(inp);
            self
        }
        pub fn set_approximate_arrival_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.approximate_arrival_timestamp = inp;
            self
        }
        /// <p>Identifies which shard in the stream the data record is assigned to.</p>
        pub fn partition_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.partition_key = Some(inp.into());
            self
        }
        pub fn set_partition_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.partition_key = inp;
            self
        }
        /// Consumes the builder and constructs a [`Record`](crate::model::Record)
        pub fn build(self) -> crate::model::Record {
            crate::model::Record {
                sequence_number: self.sequence_number,
                encryption_type: self.encryption_type,
                data: self.data,
                approximate_arrival_timestamp: self.approximate_arrival_timestamp,
                partition_key: self.partition_key,
            }
        }
    }
}
impl Record {
    /// Creates a new builder-style object to manufacture [`Record`](crate::model::Record)
    pub fn builder() -> crate::model::record::Builder {
        crate::model::record::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MetricsName {
    All,
    IncomingBytes,
    IncomingRecords,
    IteratorAgeMilliseconds,
    OutgoingBytes,
    OutgoingRecords,
    ReadProvisionedThroughputExceeded,
    WriteProvisionedThroughputExceeded,
    Unknown(String),
}
impl std::convert::From<&str> for MetricsName {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => MetricsName::All,
            "IncomingBytes" => MetricsName::IncomingBytes,
            "IncomingRecords" => MetricsName::IncomingRecords,
            "IteratorAgeMilliseconds" => MetricsName::IteratorAgeMilliseconds,
            "OutgoingBytes" => MetricsName::OutgoingBytes,
            "OutgoingRecords" => MetricsName::OutgoingRecords,
            "ReadProvisionedThroughputExceeded" => MetricsName::ReadProvisionedThroughputExceeded,
            "WriteProvisionedThroughputExceeded" => MetricsName::WriteProvisionedThroughputExceeded,
            other => MetricsName::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for MetricsName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(MetricsName::from(s))
    }
}

impl MetricsName {
    pub fn as_str(&self) -> &str {
        match self {
            MetricsName::All => "ALL",
            MetricsName::IncomingBytes => "IncomingBytes",
            MetricsName::IncomingRecords => "IncomingRecords",
            MetricsName::IteratorAgeMilliseconds => "IteratorAgeMilliseconds",
            MetricsName::OutgoingBytes => "OutgoingBytes",
            MetricsName::OutgoingRecords => "OutgoingRecords",
            MetricsName::ReadProvisionedThroughputExceeded => "ReadProvisionedThroughputExceeded",
            MetricsName::WriteProvisionedThroughputExceeded => "WriteProvisionedThroughputExceeded",
            MetricsName::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for MetricsName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for MetricsName {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for MetricsName {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the output for <a>DescribeStreamSummary</a>
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamDescriptionSummary {
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    /// be a globally unique identifier, a fully specified ARN to either an alias or a key, or
    /// an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data
    /// Streams by specifying the alias <code>aws/kinesis</code>.</p>
    /// <ul>
    /// <li>
    /// <p>Key ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias ARN example: <code>
    /// arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Globally unique key ID example:
    /// <code>12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name example: <code>alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Master key owned by Kinesis Data Streams:
    /// <code>alias/aws/kinesis</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "KeyId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub key_id: std::option::Option<std::string::String>,
    /// <p>The current status of the stream being described. The stream status is one of the
    /// following states:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The stream is being created. Kinesis Data Streams
    /// immediately returns and sets <code>StreamStatus</code> to
    /// <code>CREATING</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The stream is being deleted. The specified stream is in
    /// the <code>DELETING</code> state until Kinesis Data Streams completes the
    /// deletion.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The stream exists and is ready for read and write
    /// operations or deletion. You should perform read and write operations only on an
    /// <code>ACTIVE</code> stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - Shards in the stream are being merged or split. Read and
    /// write operations continue to work while the stream is in the
    /// <code>UPDATING</code> state.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "StreamStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_status: std::option::Option<crate::model::StreamStatus>,
    /// <p>The Amazon Resource Name (ARN) for the stream being described.</p>
    #[serde(rename = "StreamARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The number of enhanced fan-out consumers registered with the stream.</p>
    #[serde(rename = "ConsumerCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub consumer_count: std::option::Option<i32>,
    /// <p>The number of open shards in the stream.</p>
    #[serde(rename = "OpenShardCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub open_shard_count: std::option::Option<i32>,
    /// <p>The approximate time that the stream was created.</p>
    #[serde(rename = "StreamCreationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub stream_creation_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The encryption type used. This value is one of the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>KMS</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NONE</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "EncryptionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>The name of the stream being described.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The current retention period, in hours.</p>
    #[serde(rename = "RetentionPeriodHours")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub retention_period_hours: std::option::Option<i32>,
    /// <p>Represents the current enhanced monitoring settings of the stream.</p>
    #[serde(rename = "EnhancedMonitoring")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub enhanced_monitoring: std::option::Option<std::vec::Vec<crate::model::EnhancedMetrics>>,
}
impl std::fmt::Debug for StreamDescriptionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamDescriptionSummary");
        formatter.field("key_id", &self.key_id);
        formatter.field("stream_status", &self.stream_status);
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("consumer_count", &self.consumer_count);
        formatter.field("open_shard_count", &self.open_shard_count);
        formatter.field("stream_creation_timestamp", &self.stream_creation_timestamp);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("stream_name", &self.stream_name);
        formatter.field("retention_period_hours", &self.retention_period_hours);
        formatter.field("enhanced_monitoring", &self.enhanced_monitoring);
        formatter.finish()
    }
}
/// See [`StreamDescriptionSummary`](crate::model::StreamDescriptionSummary)
pub mod stream_description_summary {
    /// A builder for [`StreamDescriptionSummary`](crate::model::StreamDescriptionSummary)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        key_id: std::option::Option<std::string::String>,
        stream_status: std::option::Option<crate::model::StreamStatus>,
        stream_arn: std::option::Option<std::string::String>,
        consumer_count: std::option::Option<i32>,
        open_shard_count: std::option::Option<i32>,
        stream_creation_timestamp: std::option::Option<smithy_types::Instant>,
        encryption_type: std::option::Option<crate::model::EncryptionType>,
        stream_name: std::option::Option<std::string::String>,
        retention_period_hours: std::option::Option<i32>,
        enhanced_monitoring: std::option::Option<std::vec::Vec<crate::model::EnhancedMetrics>>,
    }
    impl Builder {
        /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        /// be a globally unique identifier, a fully specified ARN to either an alias or a key, or
        /// an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data
        /// Streams by specifying the alias <code>aws/kinesis</code>.</p>
        /// <ul>
        /// <li>
        /// <p>Key ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias ARN example: <code>
        /// arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Globally unique key ID example:
        /// <code>12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name example: <code>alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Master key owned by Kinesis Data Streams:
        /// <code>alias/aws/kinesis</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.key_id = Some(inp.into());
            self
        }
        pub fn set_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.key_id = inp;
            self
        }
        /// <p>The current status of the stream being described. The stream status is one of the
        /// following states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The stream is being created. Kinesis Data Streams
        /// immediately returns and sets <code>StreamStatus</code> to
        /// <code>CREATING</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The stream is being deleted. The specified stream is in
        /// the <code>DELETING</code> state until Kinesis Data Streams completes the
        /// deletion.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The stream exists and is ready for read and write
        /// operations or deletion. You should perform read and write operations only on an
        /// <code>ACTIVE</code> stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - Shards in the stream are being merged or split. Read and
        /// write operations continue to work while the stream is in the
        /// <code>UPDATING</code> state.</p>
        /// </li>
        /// </ul>
        pub fn stream_status(mut self, inp: crate::model::StreamStatus) -> Self {
            self.stream_status = Some(inp);
            self
        }
        pub fn set_stream_status(
            mut self,
            inp: std::option::Option<crate::model::StreamStatus>,
        ) -> Self {
            self.stream_status = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the stream being described.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(inp.into());
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = inp;
            self
        }
        /// <p>The number of enhanced fan-out consumers registered with the stream.</p>
        pub fn consumer_count(mut self, inp: i32) -> Self {
            self.consumer_count = Some(inp);
            self
        }
        pub fn set_consumer_count(mut self, inp: std::option::Option<i32>) -> Self {
            self.consumer_count = inp;
            self
        }
        /// <p>The number of open shards in the stream.</p>
        pub fn open_shard_count(mut self, inp: i32) -> Self {
            self.open_shard_count = Some(inp);
            self
        }
        pub fn set_open_shard_count(mut self, inp: std::option::Option<i32>) -> Self {
            self.open_shard_count = inp;
            self
        }
        /// <p>The approximate time that the stream was created.</p>
        pub fn stream_creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.stream_creation_timestamp = Some(inp);
            self
        }
        pub fn set_stream_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.stream_creation_timestamp = inp;
            self
        }
        /// <p>The encryption type used. This value is one of the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>KMS</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NONE</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn encryption_type(mut self, inp: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(inp);
            self
        }
        pub fn set_encryption_type(
            mut self,
            inp: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.encryption_type = inp;
            self
        }
        /// <p>The name of the stream being described.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>The current retention period, in hours.</p>
        pub fn retention_period_hours(mut self, inp: i32) -> Self {
            self.retention_period_hours = Some(inp);
            self
        }
        pub fn set_retention_period_hours(mut self, inp: std::option::Option<i32>) -> Self {
            self.retention_period_hours = inp;
            self
        }
        pub fn enhanced_monitoring(
            mut self,
            inp: impl Into<crate::model::EnhancedMetrics>,
        ) -> Self {
            let mut v = self.enhanced_monitoring.unwrap_or_default();
            v.push(inp.into());
            self.enhanced_monitoring = Some(v);
            self
        }
        pub fn set_enhanced_monitoring(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::EnhancedMetrics>>,
        ) -> Self {
            self.enhanced_monitoring = inp;
            self
        }
        /// Consumes the builder and constructs a [`StreamDescriptionSummary`](crate::model::StreamDescriptionSummary)
        pub fn build(self) -> crate::model::StreamDescriptionSummary {
            crate::model::StreamDescriptionSummary {
                key_id: self.key_id,
                stream_status: self.stream_status,
                stream_arn: self.stream_arn,
                consumer_count: self.consumer_count,
                open_shard_count: self.open_shard_count,
                stream_creation_timestamp: self.stream_creation_timestamp,
                encryption_type: self.encryption_type,
                stream_name: self.stream_name,
                retention_period_hours: self.retention_period_hours,
                enhanced_monitoring: self.enhanced_monitoring,
            }
        }
    }
}
impl StreamDescriptionSummary {
    /// Creates a new builder-style object to manufacture [`StreamDescriptionSummary`](crate::model::StreamDescriptionSummary)
    pub fn builder() -> crate::model::stream_description_summary::Builder {
        crate::model::stream_description_summary::Builder::default()
    }
}

/// <p>Represents enhanced metrics types.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EnhancedMetrics {
    /// <p>List of shard-level metrics.</p>
    /// <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
    /// enhances every metric.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>IncomingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IncomingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WriteProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ReadProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IteratorAgeMilliseconds</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALL</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    /// Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
    /// Kinesis Data Streams Developer Guide</i>.</p>
    #[serde(rename = "ShardLevelMetrics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
}
impl std::fmt::Debug for EnhancedMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnhancedMetrics");
        formatter.field("shard_level_metrics", &self.shard_level_metrics);
        formatter.finish()
    }
}
/// See [`EnhancedMetrics`](crate::model::EnhancedMetrics)
pub mod enhanced_metrics {
    /// A builder for [`EnhancedMetrics`](crate::model::EnhancedMetrics)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
    }
    impl Builder {
        pub fn shard_level_metrics(mut self, inp: impl Into<crate::model::MetricsName>) -> Self {
            let mut v = self.shard_level_metrics.unwrap_or_default();
            v.push(inp.into());
            self.shard_level_metrics = Some(v);
            self
        }
        pub fn set_shard_level_metrics(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
        ) -> Self {
            self.shard_level_metrics = inp;
            self
        }
        /// Consumes the builder and constructs a [`EnhancedMetrics`](crate::model::EnhancedMetrics)
        pub fn build(self) -> crate::model::EnhancedMetrics {
            crate::model::EnhancedMetrics {
                shard_level_metrics: self.shard_level_metrics,
            }
        }
    }
}
impl EnhancedMetrics {
    /// Creates a new builder-style object to manufacture [`EnhancedMetrics`](crate::model::EnhancedMetrics)
    pub fn builder() -> crate::model::enhanced_metrics::Builder {
        crate::model::enhanced_metrics::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamStatus {
    Active,
    Creating,
    Deleting,
    Updating,
    Unknown(String),
}
impl std::convert::From<&str> for StreamStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => StreamStatus::Active,
            "CREATING" => StreamStatus::Creating,
            "DELETING" => StreamStatus::Deleting,
            "UPDATING" => StreamStatus::Updating,
            other => StreamStatus::Unknown(other.to_owned()),
        }
    }
}

impl std::str::FromStr for StreamStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StreamStatus::from(s))
    }
}

impl StreamStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StreamStatus::Active => "ACTIVE",
            StreamStatus::Creating => "CREATING",
            StreamStatus::Deleting => "DELETING",
            StreamStatus::Updating => "UPDATING",
            StreamStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StreamStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl serde::Serialize for StreamStatus {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::Serializer>::Ok, <S as serde::Serializer>::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> serde::Deserialize<'de> for StreamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>An object that represents the details of a registered consumer. This type of object is
/// returned by <a>DescribeStreamConsumer</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ConsumerDescription {
    /// <p>The ARN of the stream with which you registered the consumer.</p>
    #[serde(rename = "StreamARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The name of the consumer is something you choose when you register the
    /// consumer.</p>
    #[serde(rename = "ConsumerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub consumer_name: std::option::Option<std::string::String>,
    /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
    /// this ARN to be able to call <a>SubscribeToShard</a>.</p>
    /// <p>If you delete a consumer and then create a new one with the same name, it won't have
    /// the same ARN. That's because consumer ARNs contain the creation timestamp. This is
    /// important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
    #[serde(rename = "ConsumerARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub consumer_arn: std::option::Option<std::string::String>,
    /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code>
    /// states.</p>
    #[serde(rename = "ConsumerStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub consumer_status: std::option::Option<crate::model::ConsumerStatus>,
    /// <p></p>
    #[serde(rename = "ConsumerCreationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub consumer_creation_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ConsumerDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConsumerDescription");
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("consumer_name", &self.consumer_name);
        formatter.field("consumer_arn", &self.consumer_arn);
        formatter.field("consumer_status", &self.consumer_status);
        formatter.field(
            "consumer_creation_timestamp",
            &self.consumer_creation_timestamp,
        );
        formatter.finish()
    }
}
/// See [`ConsumerDescription`](crate::model::ConsumerDescription)
pub mod consumer_description {
    /// A builder for [`ConsumerDescription`](crate::model::ConsumerDescription)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        stream_arn: std::option::Option<std::string::String>,
        consumer_name: std::option::Option<std::string::String>,
        consumer_arn: std::option::Option<std::string::String>,
        consumer_status: std::option::Option<crate::model::ConsumerStatus>,
        consumer_creation_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ARN of the stream with which you registered the consumer.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(inp.into());
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = inp;
            self
        }
        /// <p>The name of the consumer is something you choose when you register the
        /// consumer.</p>
        pub fn consumer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.consumer_name = Some(inp.into());
            self
        }
        pub fn set_consumer_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.consumer_name = inp;
            self
        }
        /// <p>When you register a consumer, Kinesis Data Streams generates an ARN for it. You need
        /// this ARN to be able to call <a>SubscribeToShard</a>.</p>
        /// <p>If you delete a consumer and then create a new one with the same name, it won't have
        /// the same ARN. That's because consumer ARNs contain the creation timestamp. This is
        /// important to keep in mind if you have IAM policies that reference consumer ARNs.</p>
        pub fn consumer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.consumer_arn = Some(inp.into());
            self
        }
        pub fn set_consumer_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.consumer_arn = inp;
            self
        }
        /// <p>A consumer can't read data while in the <code>CREATING</code> or <code>DELETING</code>
        /// states.</p>
        pub fn consumer_status(mut self, inp: crate::model::ConsumerStatus) -> Self {
            self.consumer_status = Some(inp);
            self
        }
        pub fn set_consumer_status(
            mut self,
            inp: std::option::Option<crate::model::ConsumerStatus>,
        ) -> Self {
            self.consumer_status = inp;
            self
        }
        /// <p></p>
        pub fn consumer_creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.consumer_creation_timestamp = Some(inp);
            self
        }
        pub fn set_consumer_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.consumer_creation_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`ConsumerDescription`](crate::model::ConsumerDescription)
        pub fn build(self) -> crate::model::ConsumerDescription {
            crate::model::ConsumerDescription {
                stream_arn: self.stream_arn,
                consumer_name: self.consumer_name,
                consumer_arn: self.consumer_arn,
                consumer_status: self.consumer_status,
                consumer_creation_timestamp: self.consumer_creation_timestamp,
            }
        }
    }
}
impl ConsumerDescription {
    /// Creates a new builder-style object to manufacture [`ConsumerDescription`](crate::model::ConsumerDescription)
    pub fn builder() -> crate::model::consumer_description::Builder {
        crate::model::consumer_description::Builder::default()
    }
}

/// <p>Represents the output for <a>DescribeStream</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamDescription {
    /// <p>The server-side encryption type used on the stream. This parameter can be one of
    /// the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code>: Do not encrypt the records in the stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KMS</code>: Use server-side encryption on the records in the stream
    /// using a customer-managed AWS KMS key.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "EncryptionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>Represents the current enhanced monitoring settings of the stream.</p>
    #[serde(rename = "EnhancedMonitoring")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub enhanced_monitoring: std::option::Option<std::vec::Vec<crate::model::EnhancedMetrics>>,
    /// <p>The name of the stream being described.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the stream being described.</p>
    #[serde(rename = "StreamARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The shards that comprise the stream.</p>
    #[serde(rename = "Shards")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub shards: std::option::Option<std::vec::Vec<crate::model::Shard>>,
    /// <p>The current retention period, in hours. Minimum value of 24. Maximum value of
    /// 168.</p>
    #[serde(rename = "RetentionPeriodHours")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub retention_period_hours: std::option::Option<i32>,
    /// <p>If set to <code>true</code>, more shards in the stream are available to
    /// describe.</p>
    #[serde(rename = "HasMoreShards")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub has_more_shards: std::option::Option<bool>,
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    /// be a globally unique identifier, a fully specified ARN to either an alias or a key, or
    /// an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data
    /// Streams by specifying the alias <code>aws/kinesis</code>.</p>
    /// <ul>
    /// <li>
    /// <p>Key ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Globally unique key ID example:
    /// <code>12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name example: <code>alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Master key owned by Kinesis Data Streams:
    /// <code>alias/aws/kinesis</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "KeyId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub key_id: std::option::Option<std::string::String>,
    /// <p>The current status of the stream being described. The stream status is one of the
    /// following states:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The stream is being created. Kinesis Data Streams
    /// immediately returns and sets <code>StreamStatus</code> to
    /// <code>CREATING</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The stream is being deleted. The specified stream is in
    /// the <code>DELETING</code> state until Kinesis Data Streams completes the
    /// deletion.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The stream exists and is ready for read and write
    /// operations or deletion. You should perform read and write operations only on an
    /// <code>ACTIVE</code> stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - Shards in the stream are being merged or split. Read and
    /// write operations continue to work while the stream is in the
    /// <code>UPDATING</code> state.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "StreamStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub stream_status: std::option::Option<crate::model::StreamStatus>,
    /// <p>The approximate time that the stream was created.</p>
    #[serde(rename = "StreamCreationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub stream_creation_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for StreamDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamDescription");
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("enhanced_monitoring", &self.enhanced_monitoring);
        formatter.field("stream_name", &self.stream_name);
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("shards", &self.shards);
        formatter.field("retention_period_hours", &self.retention_period_hours);
        formatter.field("has_more_shards", &self.has_more_shards);
        formatter.field("key_id", &self.key_id);
        formatter.field("stream_status", &self.stream_status);
        formatter.field("stream_creation_timestamp", &self.stream_creation_timestamp);
        formatter.finish()
    }
}
/// See [`StreamDescription`](crate::model::StreamDescription)
pub mod stream_description {
    /// A builder for [`StreamDescription`](crate::model::StreamDescription)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        encryption_type: std::option::Option<crate::model::EncryptionType>,
        enhanced_monitoring: std::option::Option<std::vec::Vec<crate::model::EnhancedMetrics>>,
        stream_name: std::option::Option<std::string::String>,
        stream_arn: std::option::Option<std::string::String>,
        shards: std::option::Option<std::vec::Vec<crate::model::Shard>>,
        retention_period_hours: std::option::Option<i32>,
        has_more_shards: std::option::Option<bool>,
        key_id: std::option::Option<std::string::String>,
        stream_status: std::option::Option<crate::model::StreamStatus>,
        stream_creation_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The server-side encryption type used on the stream. This parameter can be one of
        /// the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NONE</code>: Do not encrypt the records in the stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KMS</code>: Use server-side encryption on the records in the stream
        /// using a customer-managed AWS KMS key.</p>
        /// </li>
        /// </ul>
        pub fn encryption_type(mut self, inp: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(inp);
            self
        }
        pub fn set_encryption_type(
            mut self,
            inp: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.encryption_type = inp;
            self
        }
        pub fn enhanced_monitoring(
            mut self,
            inp: impl Into<crate::model::EnhancedMetrics>,
        ) -> Self {
            let mut v = self.enhanced_monitoring.unwrap_or_default();
            v.push(inp.into());
            self.enhanced_monitoring = Some(v);
            self
        }
        pub fn set_enhanced_monitoring(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::EnhancedMetrics>>,
        ) -> Self {
            self.enhanced_monitoring = inp;
            self
        }
        /// <p>The name of the stream being described.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_name = Some(inp.into());
            self
        }
        pub fn set_stream_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_name = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the stream being described.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(inp.into());
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = inp;
            self
        }
        pub fn shards(mut self, inp: impl Into<crate::model::Shard>) -> Self {
            let mut v = self.shards.unwrap_or_default();
            v.push(inp.into());
            self.shards = Some(v);
            self
        }
        pub fn set_shards(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Shard>>,
        ) -> Self {
            self.shards = inp;
            self
        }
        /// <p>The current retention period, in hours. Minimum value of 24. Maximum value of
        /// 168.</p>
        pub fn retention_period_hours(mut self, inp: i32) -> Self {
            self.retention_period_hours = Some(inp);
            self
        }
        pub fn set_retention_period_hours(mut self, inp: std::option::Option<i32>) -> Self {
            self.retention_period_hours = inp;
            self
        }
        /// <p>If set to <code>true</code>, more shards in the stream are available to
        /// describe.</p>
        pub fn has_more_shards(mut self, inp: bool) -> Self {
            self.has_more_shards = Some(inp);
            self
        }
        pub fn set_has_more_shards(mut self, inp: std::option::Option<bool>) -> Self {
            self.has_more_shards = inp;
            self
        }
        /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
        /// be a globally unique identifier, a fully specified ARN to either an alias or a key, or
        /// an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data
        /// Streams by specifying the alias <code>aws/kinesis</code>.</p>
        /// <ul>
        /// <li>
        /// <p>Key ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias ARN example:
        /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Globally unique key ID example:
        /// <code>12345678-1234-1234-1234-123456789012</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Alias name example: <code>alias/MyAliasName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Master key owned by Kinesis Data Streams:
        /// <code>alias/aws/kinesis</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.key_id = Some(inp.into());
            self
        }
        pub fn set_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.key_id = inp;
            self
        }
        /// <p>The current status of the stream being described. The stream status is one of the
        /// following states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The stream is being created. Kinesis Data Streams
        /// immediately returns and sets <code>StreamStatus</code> to
        /// <code>CREATING</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The stream is being deleted. The specified stream is in
        /// the <code>DELETING</code> state until Kinesis Data Streams completes the
        /// deletion.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The stream exists and is ready for read and write
        /// operations or deletion. You should perform read and write operations only on an
        /// <code>ACTIVE</code> stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - Shards in the stream are being merged or split. Read and
        /// write operations continue to work while the stream is in the
        /// <code>UPDATING</code> state.</p>
        /// </li>
        /// </ul>
        pub fn stream_status(mut self, inp: crate::model::StreamStatus) -> Self {
            self.stream_status = Some(inp);
            self
        }
        pub fn set_stream_status(
            mut self,
            inp: std::option::Option<crate::model::StreamStatus>,
        ) -> Self {
            self.stream_status = inp;
            self
        }
        /// <p>The approximate time that the stream was created.</p>
        pub fn stream_creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.stream_creation_timestamp = Some(inp);
            self
        }
        pub fn set_stream_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.stream_creation_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`StreamDescription`](crate::model::StreamDescription)
        pub fn build(self) -> crate::model::StreamDescription {
            crate::model::StreamDescription {
                encryption_type: self.encryption_type,
                enhanced_monitoring: self.enhanced_monitoring,
                stream_name: self.stream_name,
                stream_arn: self.stream_arn,
                shards: self.shards,
                retention_period_hours: self.retention_period_hours,
                has_more_shards: self.has_more_shards,
                key_id: self.key_id,
                stream_status: self.stream_status,
                stream_creation_timestamp: self.stream_creation_timestamp,
            }
        }
    }
}
impl StreamDescription {
    /// Creates a new builder-style object to manufacture [`StreamDescription`](crate::model::StreamDescription)
    pub fn builder() -> crate::model::stream_description::Builder {
        crate::model::stream_description::Builder::default()
    }
}
