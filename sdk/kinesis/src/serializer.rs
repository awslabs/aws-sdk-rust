// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Represents the input for <code>AddTagsToStream</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AddTagsToStreamInputBody<'a> {
    /// <p>A set of up to 10 key-value pairs to use to create the tags.</p>
    #[serde(rename = "Tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
    /// <p>The name of the stream.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for AddTagsToStreamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddTagsToStreamInputBody");
        formatter.field("tags", &self.tags);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>CreateStream</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateStreamInputBody<'a> {
    /// <p>A name to identify the stream. The stream name is scoped to the AWS account used by
    /// the application that creates the stream. It is also scoped by AWS Region. That is, two
    /// streams in two different AWS accounts can have the same name. Two streams in the same
    /// AWS account but in two different Regions can also have the same name.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
    /// <p>The number of shards that the stream will use. The throughput of the stream is a
    /// function of the number of shards; more shards are required for greater provisioned
    /// throughput.</p>
    #[serde(rename = "ShardCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_count: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for CreateStreamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateStreamInputBody");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("shard_count", &self.shard_count);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>DecreaseStreamRetentionPeriod</a>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DecreaseStreamRetentionPeriodInputBody<'a> {
    /// <p>The new retention period of the stream, in hours. Must be less than the current
    /// retention period.</p>
    #[serde(rename = "RetentionPeriodHours")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention_period_hours: &'a std::option::Option<i32>,
    /// <p>The name of the stream to modify.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DecreaseStreamRetentionPeriodInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DecreaseStreamRetentionPeriodInputBody");
        formatter.field("retention_period_hours", &self.retention_period_hours);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>DeleteStream</a>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteStreamInputBody<'a> {
    /// <p>The name of the stream to delete.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
    /// <p>If this parameter is unset (<code>null</code>) or if you set it to <code>false</code>,
    /// and the stream has registered consumers, the call to <code>DeleteStream</code> fails
    /// with a <code>ResourceInUseException</code>. </p>
    #[serde(rename = "EnforceConsumerDeletion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enforce_consumer_deletion: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for DeleteStreamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteStreamInputBody");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("enforce_consumer_deletion", &self.enforce_consumer_deletion);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterStreamConsumerInputBody<'a> {
    /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
    /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    #[serde(rename = "StreamARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: &'a std::option::Option<std::string::String>,
    /// <p>The name that you gave to the consumer.</p>
    #[serde(rename = "ConsumerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_name: &'a std::option::Option<std::string::String>,
    /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer. If you
    /// don't know the ARN of the consumer that you want to deregister, you can use the
    /// ListStreamConsumers operation to get a list of the descriptions of all the consumers
    /// that are currently registered with a given data stream. The description of a consumer
    /// contains its ARN.</p>
    #[serde(rename = "ConsumerARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeregisterStreamConsumerInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterStreamConsumerInputBody");
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("consumer_name", &self.consumer_name);
        formatter.field("consumer_arn", &self.consumer_arn);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>DescribeStream</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamInputBody<'a> {
    /// <p>The name of the stream to describe.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
    /// <p>The shard ID of the shard to start with.</p>
    #[serde(rename = "ExclusiveStartShardId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exclusive_start_shard_id: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of shards to return in a single call. The default value is 100.
    /// If you specify a value greater than 100, at most 100 shards are returned.</p>
    #[serde(rename = "Limit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeStreamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamInputBody");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("exclusive_start_shard_id", &self.exclusive_start_shard_id);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamConsumerInputBody<'a> {
    /// <p>The ARN of the Kinesis data stream that the consumer is registered with. For more
    /// information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    #[serde(rename = "StreamARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: &'a std::option::Option<std::string::String>,
    /// <p>The name that you gave to the consumer.</p>
    #[serde(rename = "ConsumerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_name: &'a std::option::Option<std::string::String>,
    /// <p>The ARN returned by Kinesis Data Streams when you registered the consumer.</p>
    #[serde(rename = "ConsumerARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeStreamConsumerInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamConsumerInputBody");
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("consumer_name", &self.consumer_name);
        formatter.field("consumer_arn", &self.consumer_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamSummaryInputBody<'a> {
    /// <p>The name of the stream to describe.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeStreamSummaryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamSummaryInputBody");
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>DisableEnhancedMonitoring</a>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableEnhancedMonitoringInputBody<'a> {
    /// <p>List of shard-level metrics to disable.</p>
    /// <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
    /// disables every metric.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>IncomingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IncomingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WriteProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ReadProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IteratorAgeMilliseconds</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALL</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    /// Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
    /// Kinesis Data Streams Developer Guide</i>.</p>
    #[serde(rename = "ShardLevelMetrics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_level_metrics: &'a std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
    /// <p>The name of the Kinesis data stream for which to disable enhanced
    /// monitoring.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DisableEnhancedMonitoringInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableEnhancedMonitoringInputBody");
        formatter.field("shard_level_metrics", &self.shard_level_metrics);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>EnableEnhancedMonitoring</a>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableEnhancedMonitoringInputBody<'a> {
    /// <p>The name of the stream for which to enable enhanced monitoring.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
    /// <p>List of shard-level metrics to enable.</p>
    /// <p>The following are the valid shard-level metrics. The value "<code>ALL</code>"
    /// enables every metric.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>IncomingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IncomingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingBytes</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OutgoingRecords</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WriteProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ReadProvisionedThroughputExceeded</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IteratorAgeMilliseconds</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALL</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/monitoring-with-cloudwatch.html">Monitoring the Amazon
    /// Kinesis Data Streams Service with Amazon CloudWatch</a> in the <i>Amazon
    /// Kinesis Data Streams Developer Guide</i>.</p>
    #[serde(rename = "ShardLevelMetrics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_level_metrics: &'a std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
}
impl<'a> std::fmt::Debug for EnableEnhancedMonitoringInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableEnhancedMonitoringInputBody");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("shard_level_metrics", &self.shard_level_metrics);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>GetRecords</a>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRecordsInputBody<'a> {
    /// <p>The position in the shard from which you want to start sequentially reading data
    /// records. A shard iterator specifies this position using the sequence number of a data
    /// record in the shard.</p>
    #[serde(rename = "ShardIterator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_iterator: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of records to return. Specify a value of up to 10,000. If you
    /// specify a value that is greater than 10,000, <a>GetRecords</a> throws
    /// <code>InvalidArgumentException</code>. The default value is 10,000.</p>
    #[serde(rename = "Limit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for GetRecordsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRecordsInputBody");
        formatter.field("shard_iterator", &self.shard_iterator);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>GetShardIterator</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetShardIteratorInputBody<'a> {
    /// <p>Determines how the shard iterator is used to start reading data records from the
    /// shard.</p>
    /// <p>The following are the valid Amazon Kinesis shard iterator types:</p>
    /// <ul>
    /// <li>
    /// <p>AT_SEQUENCE_NUMBER - Start reading from the position denoted by a specific
    /// sequence number, provided in the value
    /// <code>StartingSequenceNumber</code>.</p>
    /// </li>
    /// <li>
    /// <p>AFTER_SEQUENCE_NUMBER - Start reading right after the position denoted by a
    /// specific sequence number, provided in the value
    /// <code>StartingSequenceNumber</code>.</p>
    /// </li>
    /// <li>
    /// <p>AT_TIMESTAMP - Start reading from the position denoted by a specific time
    /// stamp, provided in the value <code>Timestamp</code>.</p>
    /// </li>
    /// <li>
    /// <p>TRIM_HORIZON - Start reading at the last untrimmed record in the shard in
    /// the system, which is the oldest data record in the shard.</p>
    /// </li>
    /// <li>
    /// <p>LATEST - Start reading just after the most recent record in the shard, so
    /// that you always read the most recent data in the shard.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "ShardIteratorType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_iterator_type: &'a std::option::Option<crate::model::ShardIteratorType>,
    /// <p>The shard ID of the Kinesis Data Streams shard to get the iterator for.</p>
    #[serde(rename = "ShardId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_id: &'a std::option::Option<std::string::String>,
    /// <p>The sequence number of the data record in the shard from which to start reading.
    /// Used with shard iterator type AT_SEQUENCE_NUMBER and AFTER_SEQUENCE_NUMBER.</p>
    #[serde(rename = "StartingSequenceNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starting_sequence_number: &'a std::option::Option<std::string::String>,
    /// <p>The time stamp of the data record from which to start reading. Used with shard
    /// iterator type AT_TIMESTAMP. A time stamp is the Unix epoch date with precision in
    /// milliseconds. For example, <code>2016-04-04T19:58:46.480-00:00</code> or
    /// <code>1459799926.480</code>. If a record with this exact time stamp does not exist,
    /// the iterator returned is for the next (later) record. If the time stamp is older than
    /// the current trim horizon, the iterator returned is for the oldest untrimmed data record
    /// (TRIM_HORIZON).</p>
    #[serde(rename = "Timestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    pub timestamp: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The name of the Amazon Kinesis data stream.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetShardIteratorInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetShardIteratorInputBody");
        formatter.field("shard_iterator_type", &self.shard_iterator_type);
        formatter.field("shard_id", &self.shard_id);
        formatter.field("starting_sequence_number", &self.starting_sequence_number);
        formatter.field("timestamp", &self.timestamp);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <a>IncreaseStreamRetentionPeriod</a>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct IncreaseStreamRetentionPeriodInputBody<'a> {
    /// <p>The new retention period of the stream, in hours. Must be more than the current
    /// retention period.</p>
    #[serde(rename = "RetentionPeriodHours")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention_period_hours: &'a std::option::Option<i32>,
    /// <p>The name of the stream to modify.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for IncreaseStreamRetentionPeriodInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncreaseStreamRetentionPeriodInputBody");
        formatter.field("retention_period_hours", &self.retention_period_hours);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListShardsInputBody<'a> {
    /// <p>The maximum number of shards to return in a single call to <code>ListShards</code>.
    /// The minimum value you can specify for this parameter is 1, and the maximum is 10,000,
    /// which is also the default.</p>
    /// <p>When the number of shards to be listed is greater than the value of
    /// <code>MaxResults</code>, the response contains a <code>NextToken</code> value that
    /// you can use in a subsequent call to <code>ListShards</code> to list the next set of
    /// shards.</p>
    #[serde(rename = "MaxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: &'a std::option::Option<i32>,
    /// <p>Specify this input parameter to distinguish data streams that have the same name.
    /// For example, if you create a data stream and then delete it, and you later create
    /// another data stream with the same name, you can use this input parameter to specify
    /// which of the two streams you want to list the shards for.</p>
    /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
    /// parameter.</p>
    #[serde(rename = "StreamCreationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    pub stream_creation_timestamp: &'a std::option::Option<smithy_types::Instant>,
    /// <p>When the number of shards in the data stream is greater than the default value for
    /// the <code>MaxResults</code> parameter, or if you explicitly specify a value for
    /// <code>MaxResults</code> that is less than the number of shards in the data stream,
    /// the response includes a pagination token named <code>NextToken</code>. You can specify
    /// this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
    /// list the next set of shards.</p>
    /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if
    /// you specify <code>NextToken</code> because the latter unambiguously identifies the
    /// stream.</p>
    /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when
    /// you specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that
    /// is less than the number of shards that the operation returns if you don't specify
    /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
    /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
    /// <code>ListShards</code> operation.</p>
    /// <important>
    /// <p>Tokens expire after 300 seconds. When you obtain a value for
    /// <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
    /// have 300 seconds to use that value. If you specify an expired token in a call to
    /// <code>ListShards</code>, you get
    /// <code>ExpiredNextTokenException</code>.</p>
    /// </important>
    #[serde(rename = "NextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>Specify this parameter to indicate that you want to list the shards starting with
    /// the shard whose ID immediately follows <code>ExclusiveStartShardId</code>.</p>
    /// <p>If you don't specify this parameter, the default behavior is for
    /// <code>ListShards</code> to list the shards starting with the first one in the
    /// stream.</p>
    /// <p>You cannot specify this parameter if you specify <code>NextToken</code>.</p>
    #[serde(rename = "ExclusiveStartShardId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exclusive_start_shard_id: &'a std::option::Option<std::string::String>,
    #[serde(rename = "ShardFilter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_filter: &'a std::option::Option<crate::model::ShardFilter>,
    /// <p>The name of the data stream whose shards you want to list. </p>
    /// <p>You cannot specify this parameter if you specify the <code>NextToken</code>
    /// parameter.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListShardsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListShardsInputBody");
        formatter.field("max_results", &self.max_results);
        formatter.field("stream_creation_timestamp", &self.stream_creation_timestamp);
        formatter.field("next_token", &self.next_token);
        formatter.field("exclusive_start_shard_id", &self.exclusive_start_shard_id);
        formatter.field("shard_filter", &self.shard_filter);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListStreamConsumersInputBody<'a> {
    /// <p>When the number of consumers that are registered with the data stream is greater than
    /// the default value for the <code>MaxResults</code> parameter, or if you explicitly
    /// specify a value for <code>MaxResults</code> that is less than the number of consumers
    /// that are registered with the data stream, the response includes a pagination token named
    /// <code>NextToken</code>. You can specify this <code>NextToken</code> value in a
    /// subsequent call to <code>ListStreamConsumers</code> to list the next set of registered
    /// consumers.</p>
    /// <p>Don't specify <code>StreamName</code> or <code>StreamCreationTimestamp</code> if you
    /// specify <code>NextToken</code> because the latter unambiguously identifies the
    /// stream.</p>
    /// <p>You can optionally specify a value for the <code>MaxResults</code> parameter when you
    /// specify <code>NextToken</code>. If you specify a <code>MaxResults</code> value that is
    /// less than the number of consumers that the operation returns if you don't specify
    /// <code>MaxResults</code>, the response will contain a new <code>NextToken</code>
    /// value. You can use the new <code>NextToken</code> value in a subsequent call to the
    /// <code>ListStreamConsumers</code> operation to list the next set of consumers.</p>
    /// <important>
    /// <p>Tokens expire after 300 seconds. When you obtain a value for
    /// <code>NextToken</code> in the response to a call to
    /// <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
    /// specify an expired token in a call to <code>ListStreamConsumers</code>, you get
    /// <code>ExpiredNextTokenException</code>.</p>
    /// </important>
    #[serde(rename = "NextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>Specify this input parameter to distinguish data streams that have the same name. For
    /// example, if you create a data stream and then delete it, and you later create another
    /// data stream with the same name, you can use this input parameter to specify which of the
    /// two streams you want to list the consumers for. </p>
    /// <p>You can't specify this parameter if you specify the NextToken parameter. </p>
    #[serde(rename = "StreamCreationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(
        serialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_ser"
    )]
    pub stream_creation_timestamp: &'a std::option::Option<smithy_types::Instant>,
    /// <p>The ARN of the Kinesis data stream for which you want to list the registered
    /// consumers. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    #[serde(rename = "StreamARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of consumers that you want a single call of
    /// <code>ListStreamConsumers</code> to return.</p>
    #[serde(rename = "MaxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for ListStreamConsumersInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListStreamConsumersInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("stream_creation_timestamp", &self.stream_creation_timestamp);
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>ListStreams</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListStreamsInputBody<'a> {
    /// <p>The maximum number of streams to list.</p>
    #[serde(rename = "Limit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: &'a std::option::Option<i32>,
    /// <p>The name of the stream to start the list with.</p>
    #[serde(rename = "ExclusiveStartStreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exclusive_start_stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListStreamsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListStreamsInputBody");
        formatter.field("limit", &self.limit);
        formatter.field(
            "exclusive_start_stream_name",
            &self.exclusive_start_stream_name,
        );
        formatter.finish()
    }
}

/// <p>Represents the input for <code>ListTagsForStream</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForStreamInputBody<'a> {
    /// <p>The number of tags to return. If this number is less than the total number of tags
    /// associated with the stream, <code>HasMoreTags</code> is set to <code>true</code>. To
    /// list additional tags, set <code>ExclusiveStartTagKey</code> to the last key in the
    /// response.</p>
    #[serde(rename = "Limit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: &'a std::option::Option<i32>,
    /// <p>The key to use as the starting point for the list of tags. If this parameter is
    /// set, <code>ListTagsForStream</code> gets all tags that occur after
    /// <code>ExclusiveStartTagKey</code>. </p>
    #[serde(rename = "ExclusiveStartTagKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exclusive_start_tag_key: &'a std::option::Option<std::string::String>,
    /// <p>The name of the stream.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListTagsForStreamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForStreamInputBody");
        formatter.field("limit", &self.limit);
        formatter.field("exclusive_start_tag_key", &self.exclusive_start_tag_key);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>MergeShards</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MergeShardsInputBody<'a> {
    /// <p>The shard ID of the adjacent shard for the merge.</p>
    #[serde(rename = "AdjacentShardToMerge")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub adjacent_shard_to_merge: &'a std::option::Option<std::string::String>,
    /// <p>The name of the stream for the merge.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
    /// <p>The shard ID of the shard to combine with the adjacent shard for the
    /// merge.</p>
    #[serde(rename = "ShardToMerge")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_to_merge: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for MergeShardsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MergeShardsInputBody");
        formatter.field("adjacent_shard_to_merge", &self.adjacent_shard_to_merge);
        formatter.field("stream_name", &self.stream_name);
        formatter.field("shard_to_merge", &self.shard_to_merge);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>PutRecord</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRecordInputBody<'a> {
    /// <p>The name of the stream to put the data record into.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
    /// <p>The hash value used to explicitly determine the shard the data record is assigned
    /// to by overriding the partition key hash.</p>
    #[serde(rename = "ExplicitHashKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub explicit_hash_key: &'a std::option::Option<std::string::String>,
    /// <p>Guarantees strictly increasing sequence numbers, for puts from the same client and
    /// to the same partition key. Usage: set the <code>SequenceNumberForOrdering</code> of
    /// record <i>n</i> to the sequence number of record <i>n-1</i>
    /// (as returned in the result when putting record <i>n-1</i>). If this
    /// parameter is not set, records are coarsely ordered based on arrival time.</p>
    #[serde(rename = "SequenceNumberForOrdering")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sequence_number_for_ordering: &'a std::option::Option<std::string::String>,
    /// <p>Determines which shard in the stream the data record is assigned to. Partition keys
    /// are Unicode strings with a maximum length limit of 256 characters for each key. Amazon
    /// Kinesis Data Streams uses the partition key as input to a hash function that maps the
    /// partition key and associated data to a specific shard. Specifically, an MD5 hash
    /// function is used to map partition keys to 128-bit integer values and to map associated
    /// data records to shards. As a result of this hashing mechanism, all data records with the
    /// same partition key map to the same shard within the stream.</p>
    #[serde(rename = "PartitionKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_key: &'a std::option::Option<std::string::String>,
    /// <p>The data blob to put into the record, which is base64-encoded when the blob is
    /// serialized. When the data blob (the payload before base64-encoding) is added to the
    /// partition key size, the total size must not exceed the maximum record size (1
    /// MiB).</p>
    #[serde(rename = "Data")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::stdoptionoptionsmithytypesblob_ser")]
    pub data: &'a std::option::Option<smithy_types::Blob>,
}
impl<'a> std::fmt::Debug for PutRecordInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRecordInputBody");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("explicit_hash_key", &self.explicit_hash_key);
        formatter.field(
            "sequence_number_for_ordering",
            &self.sequence_number_for_ordering,
        );
        formatter.field("partition_key", &self.partition_key);
        formatter.field("data", &self.data);
        formatter.finish()
    }
}

/// <p>A <code>PutRecords</code> request.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRecordsInputBody<'a> {
    /// <p>The records associated with the request.</p>
    #[serde(rename = "Records")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub records: &'a std::option::Option<std::vec::Vec<crate::model::PutRecordsRequestEntry>>,
    /// <p>The stream name associated with the request.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutRecordsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRecordsInputBody");
        formatter.field("records", &self.records);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterStreamConsumerInputBody<'a> {
    /// <p>For a given Kinesis data stream, each consumer must have a unique name. However,
    /// consumer names don't have to be unique across data streams.</p>
    #[serde(rename = "ConsumerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consumer_name: &'a std::option::Option<std::string::String>,
    /// <p>The ARN of the Kinesis data stream that you want to register the consumer with. For
    /// more info, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kinesis-streams">Amazon Resource Names (ARNs) and AWS Service Namespaces</a>.</p>
    #[serde(rename = "StreamARN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for RegisterStreamConsumerInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterStreamConsumerInputBody");
        formatter.field("consumer_name", &self.consumer_name);
        formatter.field("stream_arn", &self.stream_arn);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>RemoveTagsFromStream</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveTagsFromStreamInputBody<'a> {
    /// <p>A list of tag keys. Each corresponding tag is removed from the stream.</p>
    #[serde(rename = "TagKeys")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tag_keys: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the stream.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for RemoveTagsFromStreamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveTagsFromStreamInputBody");
        formatter.field("tag_keys", &self.tag_keys);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

/// <p>Represents the input for <code>SplitShard</code>.</p>
#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SplitShardInputBody<'a> {
    /// <p>The shard ID of the shard to split.</p>
    #[serde(rename = "ShardToSplit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shard_to_split: &'a std::option::Option<std::string::String>,
    /// <p>A hash key value for the starting hash key of one of the child shards created by
    /// the split. The hash key range for a given shard constitutes a set of ordered contiguous
    /// positive integers. The value for <code>NewStartingHashKey</code> must be in the range of
    /// hash keys being mapped into the shard. The <code>NewStartingHashKey</code> hash key
    /// value and all higher hash key values in hash key range are distributed to one of the
    /// child shards. All the lower hash key values in the range are distributed to the other
    /// child shard.</p>
    #[serde(rename = "NewStartingHashKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_starting_hash_key: &'a std::option::Option<std::string::String>,
    /// <p>The name of the stream for the shard split.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for SplitShardInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SplitShardInputBody");
        formatter.field("shard_to_split", &self.shard_to_split);
        formatter.field("new_starting_hash_key", &self.new_starting_hash_key);
        formatter.field("stream_name", &self.stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StartStreamEncryptionInputBody<'a> {
    /// <p>The name of the stream for which to start encrypting records.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
    /// <p>The encryption type to use. The only valid value is <code>KMS</code>.</p>
    #[serde(rename = "EncryptionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encryption_type: &'a std::option::Option<crate::model::EncryptionType>,
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
    /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
    /// owned by Kinesis Data Streams by specifying the alias
    /// <code>aws/kinesis</code>.</p>
    /// <ul>
    /// <li>
    /// <p>Key ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Globally unique key ID example:
    /// <code>12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name example: <code>alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Master key owned by Kinesis Data Streams:
    /// <code>alias/aws/kinesis</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "KeyId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StartStreamEncryptionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartStreamEncryptionInputBody");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("key_id", &self.key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StopStreamEncryptionInputBody<'a> {
    /// <p>The name of the stream on which to stop encrypting records.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
    /// <p>The encryption type. The only valid value is <code>KMS</code>.</p>
    #[serde(rename = "EncryptionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encryption_type: &'a std::option::Option<crate::model::EncryptionType>,
    /// <p>The GUID for the customer-managed AWS KMS key to use for encryption. This value can
    /// be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either
    /// an alias or a key, or an alias name prefixed by "alias/".You can also use a master key
    /// owned by Kinesis Data Streams by specifying the alias
    /// <code>aws/kinesis</code>.</p>
    /// <ul>
    /// <li>
    /// <p>Key ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias ARN example:
    /// <code>arn:aws:kms:us-east-1:123456789012:alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Globally unique key ID example:
    /// <code>12345678-1234-1234-1234-123456789012</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Alias name example: <code>alias/MyAliasName</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Master key owned by Kinesis Data Streams:
    /// <code>alias/aws/kinesis</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "KeyId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopStreamEncryptionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopStreamEncryptionInputBody");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("key_id", &self.key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateShardCountInputBody<'a> {
    /// <p>The scaling type. Uniform scaling creates shards of equal size.</p>
    #[serde(rename = "ScalingType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scaling_type: &'a std::option::Option<crate::model::ScalingType>,
    /// <p>The name of the stream.</p>
    #[serde(rename = "StreamName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_name: &'a std::option::Option<std::string::String>,
    /// <p>The new number of shards. This value has the following default limits. By default,
    /// you cannot do the following: </p>
    /// <ul>
    /// <li>
    /// <p>Set this value to more than double your current shard count for a
    /// stream.</p>
    /// </li>
    /// <li>
    /// <p>Set this value below half your current shard count for a stream.</p>
    /// </li>
    /// <li>
    /// <p>Set this value to more than 500 shards in a stream (the default limit for
    /// shard count per stream is 500 per account per region), unless you request a
    /// limit increase.</p>
    /// </li>
    /// <li>
    /// <p>Scale a stream with more than 500 shards down unless you set this value to
    /// less than 500 shards.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "TargetShardCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_shard_count: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for UpdateShardCountInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateShardCountInputBody");
        formatter.field("scaling_type", &self.scaling_type);
        formatter.field("stream_name", &self.stream_name);
        formatter.field("target_shard_count", &self.target_shard_count);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLimitsOutputBody {
    /// <p>The number of open shards.</p>
    #[serde(rename = "OpenShardCount")]
    #[serde(default)]
    pub open_shard_count: std::option::Option<i32>,
    /// <p>The maximum number of shards.</p>
    #[serde(rename = "ShardLimit")]
    #[serde(default)]
    pub shard_limit: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeLimitsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLimitsOutputBody");
        formatter.field("open_shard_count", &self.open_shard_count);
        formatter.field("shard_limit", &self.shard_limit);
        formatter.finish()
    }
}

/// <p>Represents the output for <code>DescribeStream</code>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamOutputBody {
    /// <p>The current status of the stream, the stream Amazon Resource Name (ARN), an array
    /// of shard objects that comprise the stream, and whether there are more shards
    /// available.</p>
    #[serde(rename = "StreamDescription")]
    #[serde(default)]
    pub stream_description: std::option::Option<crate::model::StreamDescription>,
}
impl std::fmt::Debug for DescribeStreamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamOutputBody");
        formatter.field("stream_description", &self.stream_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamConsumerOutputBody {
    /// <p>An object that represents the details of the consumer.</p>
    #[serde(rename = "ConsumerDescription")]
    #[serde(default)]
    pub consumer_description: std::option::Option<crate::model::ConsumerDescription>,
}
impl std::fmt::Debug for DescribeStreamConsumerOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamConsumerOutputBody");
        formatter.field("consumer_description", &self.consumer_description);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeStreamSummaryOutputBody {
    /// <p>A <a>StreamDescriptionSummary</a> containing information about the
    /// stream.</p>
    #[serde(rename = "StreamDescriptionSummary")]
    #[serde(default)]
    pub stream_description_summary: std::option::Option<crate::model::StreamDescriptionSummary>,
}
impl std::fmt::Debug for DescribeStreamSummaryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeStreamSummaryOutputBody");
        formatter.field(
            "stream_description_summary",
            &self.stream_description_summary,
        );
        formatter.finish()
    }
}

/// <p>Represents the output for <a>EnableEnhancedMonitoring</a> and <a>DisableEnhancedMonitoring</a>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableEnhancedMonitoringOutputBody {
    /// <p>Represents the list of all the metrics that would be in the enhanced state after
    /// the operation.</p>
    #[serde(rename = "DesiredShardLevelMetrics")]
    #[serde(default)]
    pub desired_shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
    /// <p>The name of the Kinesis data stream.</p>
    #[serde(rename = "StreamName")]
    #[serde(default)]
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>Represents the current state of the metrics that are in the enhanced state before
    /// the operation.</p>
    #[serde(rename = "CurrentShardLevelMetrics")]
    #[serde(default)]
    pub current_shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
}
impl std::fmt::Debug for DisableEnhancedMonitoringOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableEnhancedMonitoringOutputBody");
        formatter.field(
            "desired_shard_level_metrics",
            &self.desired_shard_level_metrics,
        );
        formatter.field("stream_name", &self.stream_name);
        formatter.field(
            "current_shard_level_metrics",
            &self.current_shard_level_metrics,
        );
        formatter.finish()
    }
}

/// <p>Represents the output for <a>EnableEnhancedMonitoring</a> and <a>DisableEnhancedMonitoring</a>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableEnhancedMonitoringOutputBody {
    /// <p>Represents the list of all the metrics that would be in the enhanced state after
    /// the operation.</p>
    #[serde(rename = "DesiredShardLevelMetrics")]
    #[serde(default)]
    pub desired_shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
    /// <p>The name of the Kinesis data stream.</p>
    #[serde(rename = "StreamName")]
    #[serde(default)]
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>Represents the current state of the metrics that are in the enhanced state before
    /// the operation.</p>
    #[serde(rename = "CurrentShardLevelMetrics")]
    #[serde(default)]
    pub current_shard_level_metrics: std::option::Option<std::vec::Vec<crate::model::MetricsName>>,
}
impl std::fmt::Debug for EnableEnhancedMonitoringOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableEnhancedMonitoringOutputBody");
        formatter.field(
            "desired_shard_level_metrics",
            &self.desired_shard_level_metrics,
        );
        formatter.field("stream_name", &self.stream_name);
        formatter.field(
            "current_shard_level_metrics",
            &self.current_shard_level_metrics,
        );
        formatter.finish()
    }
}

/// <p>Represents the output for <a>GetRecords</a>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRecordsOutputBody {
    /// <p>The next position in the shard from which to start sequentially reading data
    /// records. If set to <code>null</code>, the shard has been closed and the requested
    /// iterator does not return any more data. </p>
    #[serde(rename = "NextShardIterator")]
    #[serde(default)]
    pub next_shard_iterator: std::option::Option<std::string::String>,
    /// <p>The data records retrieved from the shard.</p>
    #[serde(rename = "Records")]
    #[serde(default)]
    pub records: std::option::Option<std::vec::Vec<crate::model::Record>>,
    /// <p>The number of milliseconds the <a>GetRecords</a> response is from the
    /// tip of the stream, indicating how far behind current time the consumer is. A value of
    /// zero indicates that record processing is caught up, and there are no new records to
    /// process at this moment.</p>
    #[serde(rename = "MillisBehindLatest")]
    #[serde(default)]
    pub millis_behind_latest: std::option::Option<i64>,
    #[serde(rename = "ChildShards")]
    #[serde(default)]
    pub child_shards: std::option::Option<std::vec::Vec<crate::model::ChildShard>>,
}
impl std::fmt::Debug for GetRecordsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRecordsOutputBody");
        formatter.field("next_shard_iterator", &self.next_shard_iterator);
        formatter.field("records", &self.records);
        formatter.field("millis_behind_latest", &self.millis_behind_latest);
        formatter.field("child_shards", &self.child_shards);
        formatter.finish()
    }
}

/// <p>Represents the output for <code>GetShardIterator</code>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetShardIteratorOutputBody {
    /// <p>The position in the shard from which to start reading data records sequentially. A
    /// shard iterator specifies this position using the sequence number of a data record in a
    /// shard.</p>
    #[serde(rename = "ShardIterator")]
    #[serde(default)]
    pub shard_iterator: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetShardIteratorOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetShardIteratorOutputBody");
        formatter.field("shard_iterator", &self.shard_iterator);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListShardsOutputBody {
    /// <p>When the number of shards in the data stream is greater than the default value for
    /// the <code>MaxResults</code> parameter, or if you explicitly specify a value for
    /// <code>MaxResults</code> that is less than the number of shards in the data stream,
    /// the response includes a pagination token named <code>NextToken</code>. You can specify
    /// this <code>NextToken</code> value in a subsequent call to <code>ListShards</code> to
    /// list the next set of shards. For more information about the use of this pagination token
    /// when calling the <code>ListShards</code> operation, see <a>ListShardsInput$NextToken</a>.</p>
    /// <important>
    /// <p>Tokens expire after 300 seconds. When you obtain a value for
    /// <code>NextToken</code> in the response to a call to <code>ListShards</code>, you
    /// have 300 seconds to use that value. If you specify an expired token in a call to
    /// <code>ListShards</code>, you get
    /// <code>ExpiredNextTokenException</code>.</p>
    /// </important>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>An array of JSON objects. Each object represents one shard and specifies the IDs of
    /// the shard, the shard's parent, and the shard that's adjacent to the shard's parent. Each
    /// object also contains the starting and ending hash keys and the starting and ending
    /// sequence numbers for the shard.</p>
    #[serde(rename = "Shards")]
    #[serde(default)]
    pub shards: std::option::Option<std::vec::Vec<crate::model::Shard>>,
}
impl std::fmt::Debug for ListShardsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListShardsOutputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("shards", &self.shards);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListStreamConsumersOutputBody {
    /// <p>An array of JSON objects. Each object represents one registered consumer.</p>
    #[serde(rename = "Consumers")]
    #[serde(default)]
    pub consumers: std::option::Option<std::vec::Vec<crate::model::Consumer>>,
    /// <p>When the number of consumers that are registered with the data stream is greater than
    /// the default value for the <code>MaxResults</code> parameter, or if you explicitly
    /// specify a value for <code>MaxResults</code> that is less than the number of registered
    /// consumers, the response includes a pagination token named <code>NextToken</code>. You
    /// can specify this <code>NextToken</code> value in a subsequent call to
    /// <code>ListStreamConsumers</code> to list the next set of registered consumers. For
    /// more information about the use of this pagination token when calling the
    /// <code>ListStreamConsumers</code> operation, see <a>ListStreamConsumersInput$NextToken</a>.</p>
    /// <important>
    /// <p>Tokens expire after 300 seconds. When you obtain a value for
    /// <code>NextToken</code> in the response to a call to
    /// <code>ListStreamConsumers</code>, you have 300 seconds to use that value. If you
    /// specify an expired token in a call to <code>ListStreamConsumers</code>, you get
    /// <code>ExpiredNextTokenException</code>.</p>
    /// </important>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListStreamConsumersOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListStreamConsumersOutputBody");
        formatter.field("consumers", &self.consumers);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>Represents the output for <code>ListStreams</code>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListStreamsOutputBody {
    /// <p>The names of the streams that are associated with the AWS account making the
    /// <code>ListStreams</code> request.</p>
    #[serde(rename = "StreamNames")]
    #[serde(default)]
    pub stream_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>If set to <code>true</code>, there are more streams available to list.</p>
    #[serde(rename = "HasMoreStreams")]
    #[serde(default)]
    pub has_more_streams: std::option::Option<bool>,
}
impl std::fmt::Debug for ListStreamsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListStreamsOutputBody");
        formatter.field("stream_names", &self.stream_names);
        formatter.field("has_more_streams", &self.has_more_streams);
        formatter.finish()
    }
}

/// <p>Represents the output for <code>ListTagsForStream</code>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForStreamOutputBody {
    /// <p>A list of tags associated with <code>StreamName</code>, starting with the first tag
    /// after <code>ExclusiveStartTagKey</code> and up to the specified <code>Limit</code>.
    /// </p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>If set to <code>true</code>, more tags are available. To request additional tags,
    /// set <code>ExclusiveStartTagKey</code> to the key of the last tag returned.</p>
    #[serde(rename = "HasMoreTags")]
    #[serde(default)]
    pub has_more_tags: std::option::Option<bool>,
}
impl std::fmt::Debug for ListTagsForStreamOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForStreamOutputBody");
        formatter.field("tags", &self.tags);
        formatter.field("has_more_tags", &self.has_more_tags);
        formatter.finish()
    }
}

/// <p>Represents the output for <code>PutRecord</code>.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRecordOutputBody {
    /// <p>The shard ID of the shard where the data record was placed.</p>
    #[serde(rename = "ShardId")]
    #[serde(default)]
    pub shard_id: std::option::Option<std::string::String>,
    /// <p>The sequence number identifier that was assigned to the put data record. The
    /// sequence number for the record is unique across all records in the stream. A sequence
    /// number is the identifier associated with every record put into the stream.</p>
    #[serde(rename = "SequenceNumber")]
    #[serde(default)]
    pub sequence_number: std::option::Option<std::string::String>,
    /// <p>The encryption type to use on the record. This parameter can be one of the
    /// following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code>: Do not encrypt the records in the stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KMS</code>: Use server-side encryption on the records in the stream
    /// using a customer-managed AWS KMS key.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "EncryptionType")]
    #[serde(default)]
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
}
impl std::fmt::Debug for PutRecordOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRecordOutputBody");
        formatter.field("shard_id", &self.shard_id);
        formatter.field("sequence_number", &self.sequence_number);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.finish()
    }
}

/// <p>
/// <code>PutRecords</code> results.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRecordsOutputBody {
    /// <p>An array of successfully and unsuccessfully processed record results, correlated
    /// with the request by natural ordering. A record that is successfully added to a stream
    /// includes <code>SequenceNumber</code> and <code>ShardId</code> in the result. A record
    /// that fails to be added to a stream includes <code>ErrorCode</code> and
    /// <code>ErrorMessage</code> in the result.</p>
    #[serde(rename = "Records")]
    #[serde(default)]
    pub records: std::option::Option<std::vec::Vec<crate::model::PutRecordsResultEntry>>,
    /// <p>The encryption type used on the records. This parameter can be one of the following
    /// values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code>: Do not encrypt the records.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KMS</code>: Use server-side encryption on the records using a
    /// customer-managed AWS KMS key.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "EncryptionType")]
    #[serde(default)]
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>The number of unsuccessfully processed records in a <code>PutRecords</code>
    /// request.</p>
    #[serde(rename = "FailedRecordCount")]
    #[serde(default)]
    pub failed_record_count: std::option::Option<i32>,
}
impl std::fmt::Debug for PutRecordsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRecordsOutputBody");
        formatter.field("records", &self.records);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("failed_record_count", &self.failed_record_count);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterStreamConsumerOutputBody {
    /// <p>An object that represents the details of the consumer you registered. When you
    /// register a consumer, it gets an ARN that is generated by Kinesis Data Streams.</p>
    #[serde(rename = "Consumer")]
    #[serde(default)]
    pub consumer: std::option::Option<crate::model::Consumer>,
}
impl std::fmt::Debug for RegisterStreamConsumerOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterStreamConsumerOutputBody");
        formatter.field("consumer", &self.consumer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateShardCountOutputBody {
    /// <p>The name of the stream.</p>
    #[serde(rename = "StreamName")]
    #[serde(default)]
    pub stream_name: std::option::Option<std::string::String>,
    /// <p>The updated number of shards.</p>
    #[serde(rename = "TargetShardCount")]
    #[serde(default)]
    pub target_shard_count: std::option::Option<i32>,
    /// <p>The current number of shards.</p>
    #[serde(rename = "CurrentShardCount")]
    #[serde(default)]
    pub current_shard_count: std::option::Option<i32>,
}
impl std::fmt::Debug for UpdateShardCountOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateShardCountOutputBody");
        formatter.field("stream_name", &self.stream_name);
        formatter.field("target_shard_count", &self.target_shard_count);
        formatter.field("current_shard_count", &self.current_shard_count);
        formatter.finish()
    }
}
