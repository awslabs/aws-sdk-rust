// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateAssessmentReportEvidenceFolderError {
    pub kind: AssociateAssessmentReportEvidenceFolderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateAssessmentReportEvidenceFolderErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateAssessmentReportEvidenceFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateAssessmentReportEvidenceFolderErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAssessmentReportEvidenceFolderErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAssessmentReportEvidenceFolderErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAssessmentReportEvidenceFolderErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAssessmentReportEvidenceFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateAssessmentReportEvidenceFolderError {
    fn code(&self) -> Option<&str> {
        AssociateAssessmentReportEvidenceFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateAssessmentReportEvidenceFolderError {
    pub fn new(
        kind: AssociateAssessmentReportEvidenceFolderErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateAssessmentReportEvidenceFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateAssessmentReportEvidenceFolderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAssessmentReportEvidenceFolderErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAssessmentReportEvidenceFolderErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAssessmentReportEvidenceFolderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAssessmentReportEvidenceFolderErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for AssociateAssessmentReportEvidenceFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateAssessmentReportEvidenceFolderErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AssociateAssessmentReportEvidenceFolderErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            AssociateAssessmentReportEvidenceFolderErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateAssessmentReportEvidenceFolderErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            AssociateAssessmentReportEvidenceFolderErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchAssociateAssessmentReportEvidenceError {
    pub kind: BatchAssociateAssessmentReportEvidenceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchAssociateAssessmentReportEvidenceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchAssociateAssessmentReportEvidenceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchAssociateAssessmentReportEvidenceErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            BatchAssociateAssessmentReportEvidenceErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            BatchAssociateAssessmentReportEvidenceErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            BatchAssociateAssessmentReportEvidenceErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            BatchAssociateAssessmentReportEvidenceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchAssociateAssessmentReportEvidenceError {
    fn code(&self) -> Option<&str> {
        BatchAssociateAssessmentReportEvidenceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchAssociateAssessmentReportEvidenceError {
    pub fn new(
        kind: BatchAssociateAssessmentReportEvidenceErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchAssociateAssessmentReportEvidenceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchAssociateAssessmentReportEvidenceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateAssessmentReportEvidenceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateAssessmentReportEvidenceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateAssessmentReportEvidenceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateAssessmentReportEvidenceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchAssociateAssessmentReportEvidenceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchAssociateAssessmentReportEvidenceErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            BatchAssociateAssessmentReportEvidenceErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            BatchAssociateAssessmentReportEvidenceErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            BatchAssociateAssessmentReportEvidenceErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            BatchAssociateAssessmentReportEvidenceErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchCreateDelegationByAssessmentError {
    pub kind: BatchCreateDelegationByAssessmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchCreateDelegationByAssessmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchCreateDelegationByAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchCreateDelegationByAssessmentErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateDelegationByAssessmentErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateDelegationByAssessmentErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateDelegationByAssessmentErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            BatchCreateDelegationByAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchCreateDelegationByAssessmentError {
    fn code(&self) -> Option<&str> {
        BatchCreateDelegationByAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchCreateDelegationByAssessmentError {
    pub fn new(
        kind: BatchCreateDelegationByAssessmentErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchCreateDelegationByAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchCreateDelegationByAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateDelegationByAssessmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateDelegationByAssessmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateDelegationByAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchCreateDelegationByAssessmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchCreateDelegationByAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchCreateDelegationByAssessmentErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            BatchCreateDelegationByAssessmentErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            BatchCreateDelegationByAssessmentErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            BatchCreateDelegationByAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            BatchCreateDelegationByAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDeleteDelegationByAssessmentError {
    pub kind: BatchDeleteDelegationByAssessmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeleteDelegationByAssessmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDeleteDelegationByAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDeleteDelegationByAssessmentErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            BatchDeleteDelegationByAssessmentErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            BatchDeleteDelegationByAssessmentErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            BatchDeleteDelegationByAssessmentErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            BatchDeleteDelegationByAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDeleteDelegationByAssessmentError {
    fn code(&self) -> Option<&str> {
        BatchDeleteDelegationByAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeleteDelegationByAssessmentError {
    pub fn new(
        kind: BatchDeleteDelegationByAssessmentErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDeleteDelegationByAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDeleteDelegationByAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDelegationByAssessmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDelegationByAssessmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDelegationByAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDeleteDelegationByAssessmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchDeleteDelegationByAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDeleteDelegationByAssessmentErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            BatchDeleteDelegationByAssessmentErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            BatchDeleteDelegationByAssessmentErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            BatchDeleteDelegationByAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            BatchDeleteDelegationByAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDisassociateAssessmentReportEvidenceError {
    pub kind: BatchDisassociateAssessmentReportEvidenceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDisassociateAssessmentReportEvidenceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDisassociateAssessmentReportEvidenceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDisassociateAssessmentReportEvidenceErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            BatchDisassociateAssessmentReportEvidenceErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            BatchDisassociateAssessmentReportEvidenceErrorKind::ResourceNotFoundException(
                _inner,
            ) => _inner.fmt(f),
            BatchDisassociateAssessmentReportEvidenceErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            BatchDisassociateAssessmentReportEvidenceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDisassociateAssessmentReportEvidenceError {
    fn code(&self) -> Option<&str> {
        BatchDisassociateAssessmentReportEvidenceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDisassociateAssessmentReportEvidenceError {
    pub fn new(
        kind: BatchDisassociateAssessmentReportEvidenceErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDisassociateAssessmentReportEvidenceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDisassociateAssessmentReportEvidenceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateAssessmentReportEvidenceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateAssessmentReportEvidenceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateAssessmentReportEvidenceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateAssessmentReportEvidenceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchDisassociateAssessmentReportEvidenceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDisassociateAssessmentReportEvidenceErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            BatchDisassociateAssessmentReportEvidenceErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            BatchDisassociateAssessmentReportEvidenceErrorKind::ResourceNotFoundException(
                _inner,
            ) => Some(_inner),
            BatchDisassociateAssessmentReportEvidenceErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            BatchDisassociateAssessmentReportEvidenceErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchImportEvidenceToAssessmentControlError {
    pub kind: BatchImportEvidenceToAssessmentControlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchImportEvidenceToAssessmentControlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchImportEvidenceToAssessmentControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchImportEvidenceToAssessmentControlErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            BatchImportEvidenceToAssessmentControlErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            BatchImportEvidenceToAssessmentControlErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            BatchImportEvidenceToAssessmentControlErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            BatchImportEvidenceToAssessmentControlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchImportEvidenceToAssessmentControlError {
    fn code(&self) -> Option<&str> {
        BatchImportEvidenceToAssessmentControlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchImportEvidenceToAssessmentControlError {
    pub fn new(
        kind: BatchImportEvidenceToAssessmentControlErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchImportEvidenceToAssessmentControlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchImportEvidenceToAssessmentControlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchImportEvidenceToAssessmentControlErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchImportEvidenceToAssessmentControlErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchImportEvidenceToAssessmentControlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchImportEvidenceToAssessmentControlErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for BatchImportEvidenceToAssessmentControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchImportEvidenceToAssessmentControlErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            BatchImportEvidenceToAssessmentControlErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            BatchImportEvidenceToAssessmentControlErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            BatchImportEvidenceToAssessmentControlErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            BatchImportEvidenceToAssessmentControlErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAssessmentError {
    pub kind: CreateAssessmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAssessmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAssessmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateAssessmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateAssessmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateAssessmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAssessmentError {
    fn code(&self) -> Option<&str> {
        CreateAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAssessmentError {
    pub fn new(kind: CreateAssessmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAssessmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateAssessmentErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateAssessmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            CreateAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAssessmentFrameworkError {
    pub kind: CreateAssessmentFrameworkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAssessmentFrameworkErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAssessmentFrameworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAssessmentFrameworkErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateAssessmentFrameworkErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateAssessmentFrameworkErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateAssessmentFrameworkErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateAssessmentFrameworkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAssessmentFrameworkError {
    fn code(&self) -> Option<&str> {
        CreateAssessmentFrameworkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAssessmentFrameworkError {
    pub fn new(kind: CreateAssessmentFrameworkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAssessmentFrameworkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAssessmentFrameworkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentFrameworkErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentFrameworkErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentFrameworkErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentFrameworkErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateAssessmentFrameworkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAssessmentFrameworkErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateAssessmentFrameworkErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateAssessmentFrameworkErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateAssessmentFrameworkErrorKind::ValidationException(_inner) => Some(_inner),
            CreateAssessmentFrameworkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAssessmentReportError {
    pub kind: CreateAssessmentReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAssessmentReportErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAssessmentReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAssessmentReportErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateAssessmentReportErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateAssessmentReportErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateAssessmentReportErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateAssessmentReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAssessmentReportError {
    fn code(&self) -> Option<&str> {
        CreateAssessmentReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAssessmentReportError {
    pub fn new(kind: CreateAssessmentReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAssessmentReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAssessmentReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentReportErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentReportErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentReportErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAssessmentReportErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateAssessmentReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAssessmentReportErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateAssessmentReportErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateAssessmentReportErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateAssessmentReportErrorKind::ValidationException(_inner) => Some(_inner),
            CreateAssessmentReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateControlError {
    pub kind: CreateControlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateControlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateControlErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateControlErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateControlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateControlErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateControlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateControlError {
    fn code(&self) -> Option<&str> {
        CreateControlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateControlError {
    pub fn new(kind: CreateControlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateControlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateControlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateControlErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateControlErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateControlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateControlErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateControlErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateControlErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateControlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateControlErrorKind::ValidationException(_inner) => Some(_inner),
            CreateControlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAssessmentError {
    pub kind: DeleteAssessmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAssessmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAssessmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAssessmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteAssessmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteAssessmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAssessmentError {
    fn code(&self) -> Option<&str> {
        DeleteAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAssessmentError {
    pub fn new(kind: DeleteAssessmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAssessmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAssessmentErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteAssessmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAssessmentFrameworkError {
    pub kind: DeleteAssessmentFrameworkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAssessmentFrameworkErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAssessmentFrameworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAssessmentFrameworkErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAssessmentFrameworkErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteAssessmentFrameworkErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteAssessmentFrameworkErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteAssessmentFrameworkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAssessmentFrameworkError {
    fn code(&self) -> Option<&str> {
        DeleteAssessmentFrameworkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAssessmentFrameworkError {
    pub fn new(kind: DeleteAssessmentFrameworkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAssessmentFrameworkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAssessmentFrameworkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentFrameworkErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentFrameworkErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentFrameworkErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentFrameworkErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteAssessmentFrameworkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAssessmentFrameworkErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAssessmentFrameworkErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteAssessmentFrameworkErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteAssessmentFrameworkErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteAssessmentFrameworkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAssessmentReportError {
    pub kind: DeleteAssessmentReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAssessmentReportErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAssessmentReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAssessmentReportErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAssessmentReportErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteAssessmentReportErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteAssessmentReportErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteAssessmentReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAssessmentReportError {
    fn code(&self) -> Option<&str> {
        DeleteAssessmentReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAssessmentReportError {
    pub fn new(kind: DeleteAssessmentReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAssessmentReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAssessmentReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentReportErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentReportErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentReportErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAssessmentReportErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteAssessmentReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAssessmentReportErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAssessmentReportErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteAssessmentReportErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteAssessmentReportErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteAssessmentReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteControlError {
    pub kind: DeleteControlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteControlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteControlErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteControlErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteControlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteControlErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteControlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteControlError {
    fn code(&self) -> Option<&str> {
        DeleteControlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteControlError {
    pub fn new(kind: DeleteControlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteControlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteControlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteControlErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteControlErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteControlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteControlErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteControlErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteControlErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteControlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteControlErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteControlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterAccountError {
    pub kind: DeregisterAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterAccountErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterAccountErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeregisterAccountErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeregisterAccountErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeregisterAccountErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeregisterAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterAccountError {
    fn code(&self) -> Option<&str> {
        DeregisterAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterAccountError {
    pub fn new(kind: DeregisterAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterAccountErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterAccountErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterAccountErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeregisterAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterAccountErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeregisterAccountErrorKind::InternalServerException(_inner) => Some(_inner),
            DeregisterAccountErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeregisterAccountErrorKind::ValidationException(_inner) => Some(_inner),
            DeregisterAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterOrganizationAdminAccountError {
    pub kind: DeregisterOrganizationAdminAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterOrganizationAdminAccountErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterOrganizationAdminAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterOrganizationAdminAccountErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterOrganizationAdminAccountErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterOrganizationAdminAccountErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterOrganizationAdminAccountErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DeregisterOrganizationAdminAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterOrganizationAdminAccountError {
    fn code(&self) -> Option<&str> {
        DeregisterOrganizationAdminAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterOrganizationAdminAccountError {
    pub fn new(
        kind: DeregisterOrganizationAdminAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterOrganizationAdminAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterOrganizationAdminAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterOrganizationAdminAccountErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterOrganizationAdminAccountErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterOrganizationAdminAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeregisterOrganizationAdminAccountErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeregisterOrganizationAdminAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterOrganizationAdminAccountErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DeregisterOrganizationAdminAccountErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DeregisterOrganizationAdminAccountErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeregisterOrganizationAdminAccountErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DeregisterOrganizationAdminAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateAssessmentReportEvidenceFolderError {
    pub kind: DisassociateAssessmentReportEvidenceFolderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateAssessmentReportEvidenceFolderErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateAssessmentReportEvidenceFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateAssessmentReportEvidenceFolderErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateAssessmentReportEvidenceFolderErrorKind::InternalServerException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateAssessmentReportEvidenceFolderErrorKind::ResourceNotFoundException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateAssessmentReportEvidenceFolderErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateAssessmentReportEvidenceFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateAssessmentReportEvidenceFolderError {
    fn code(&self) -> Option<&str> {
        DisassociateAssessmentReportEvidenceFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateAssessmentReportEvidenceFolderError {
    pub fn new(
        kind: DisassociateAssessmentReportEvidenceFolderErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateAssessmentReportEvidenceFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateAssessmentReportEvidenceFolderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateAssessmentReportEvidenceFolderErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateAssessmentReportEvidenceFolderErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateAssessmentReportEvidenceFolderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateAssessmentReportEvidenceFolderErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DisassociateAssessmentReportEvidenceFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateAssessmentReportEvidenceFolderErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DisassociateAssessmentReportEvidenceFolderErrorKind::InternalServerException(
                _inner,
            ) => Some(_inner),
            DisassociateAssessmentReportEvidenceFolderErrorKind::ResourceNotFoundException(
                _inner,
            ) => Some(_inner),
            DisassociateAssessmentReportEvidenceFolderErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DisassociateAssessmentReportEvidenceFolderErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountStatusError {
    pub kind: GetAccountStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountStatusErrorKind {
    InternalServerException(crate::error::InternalServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountStatusErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetAccountStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountStatusError {
    fn code(&self) -> Option<&str> {
        GetAccountStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountStatusError {
    pub fn new(kind: GetAccountStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountStatusErrorKind::InternalServerException(_)
        )
    }
}
impl std::error::Error for GetAccountStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountStatusErrorKind::InternalServerException(_inner) => Some(_inner),
            GetAccountStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAssessmentError {
    pub kind: GetAssessmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAssessmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAssessmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetAssessmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetAssessmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetAssessmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAssessmentError {
    fn code(&self) -> Option<&str> {
        GetAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAssessmentError {
    pub fn new(kind: GetAssessmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetAssessmentErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetAssessmentErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAssessmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetAssessmentErrorKind::InternalServerException(_inner) => Some(_inner),
            GetAssessmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            GetAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAssessmentFrameworkError {
    pub kind: GetAssessmentFrameworkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAssessmentFrameworkErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAssessmentFrameworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAssessmentFrameworkErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetAssessmentFrameworkErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetAssessmentFrameworkErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetAssessmentFrameworkErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetAssessmentFrameworkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAssessmentFrameworkError {
    fn code(&self) -> Option<&str> {
        GetAssessmentFrameworkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAssessmentFrameworkError {
    pub fn new(kind: GetAssessmentFrameworkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAssessmentFrameworkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAssessmentFrameworkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentFrameworkErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentFrameworkErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentFrameworkErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentFrameworkErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetAssessmentFrameworkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAssessmentFrameworkErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetAssessmentFrameworkErrorKind::InternalServerException(_inner) => Some(_inner),
            GetAssessmentFrameworkErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetAssessmentFrameworkErrorKind::ValidationException(_inner) => Some(_inner),
            GetAssessmentFrameworkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAssessmentReportUrlError {
    pub kind: GetAssessmentReportUrlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAssessmentReportUrlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAssessmentReportUrlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAssessmentReportUrlErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetAssessmentReportUrlErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetAssessmentReportUrlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetAssessmentReportUrlErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetAssessmentReportUrlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAssessmentReportUrlError {
    fn code(&self) -> Option<&str> {
        GetAssessmentReportUrlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAssessmentReportUrlError {
    pub fn new(kind: GetAssessmentReportUrlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAssessmentReportUrlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAssessmentReportUrlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportUrlErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportUrlErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportUrlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAssessmentReportUrlErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetAssessmentReportUrlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAssessmentReportUrlErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetAssessmentReportUrlErrorKind::InternalServerException(_inner) => Some(_inner),
            GetAssessmentReportUrlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetAssessmentReportUrlErrorKind::ValidationException(_inner) => Some(_inner),
            GetAssessmentReportUrlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetChangeLogsError {
    pub kind: GetChangeLogsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetChangeLogsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetChangeLogsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetChangeLogsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetChangeLogsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetChangeLogsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetChangeLogsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetChangeLogsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetChangeLogsError {
    fn code(&self) -> Option<&str> {
        GetChangeLogsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetChangeLogsError {
    pub fn new(kind: GetChangeLogsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetChangeLogsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetChangeLogsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetChangeLogsErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChangeLogsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChangeLogsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetChangeLogsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetChangeLogsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetChangeLogsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetChangeLogsErrorKind::InternalServerException(_inner) => Some(_inner),
            GetChangeLogsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetChangeLogsErrorKind::ValidationException(_inner) => Some(_inner),
            GetChangeLogsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetControlError {
    pub kind: GetControlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetControlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetControlErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetControlErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetControlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetControlErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetControlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetControlError {
    fn code(&self) -> Option<&str> {
        GetControlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetControlError {
    pub fn new(kind: GetControlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetControlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetControlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetControlErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetControlErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetControlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetControlErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetControlErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetControlErrorKind::InternalServerException(_inner) => Some(_inner),
            GetControlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetControlErrorKind::ValidationException(_inner) => Some(_inner),
            GetControlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDelegationsError {
    pub kind: GetDelegationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDelegationsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDelegationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDelegationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDelegationsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetDelegationsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetDelegationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDelegationsError {
    fn code(&self) -> Option<&str> {
        GetDelegationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDelegationsError {
    pub fn new(kind: GetDelegationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDelegationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDelegationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDelegationsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDelegationsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetDelegationsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetDelegationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDelegationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDelegationsErrorKind::InternalServerException(_inner) => Some(_inner),
            GetDelegationsErrorKind::ValidationException(_inner) => Some(_inner),
            GetDelegationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEvidenceError {
    pub kind: GetEvidenceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEvidenceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEvidenceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEvidenceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetEvidenceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetEvidenceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetEvidenceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetEvidenceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEvidenceError {
    fn code(&self) -> Option<&str> {
        GetEvidenceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEvidenceError {
    pub fn new(kind: GetEvidenceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEvidenceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEvidenceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetEvidenceErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetEvidenceErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetEvidenceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetEvidenceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEvidenceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetEvidenceErrorKind::InternalServerException(_inner) => Some(_inner),
            GetEvidenceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetEvidenceErrorKind::ValidationException(_inner) => Some(_inner),
            GetEvidenceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEvidenceByEvidenceFolderError {
    pub kind: GetEvidenceByEvidenceFolderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEvidenceByEvidenceFolderErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEvidenceByEvidenceFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEvidenceByEvidenceFolderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetEvidenceByEvidenceFolderErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetEvidenceByEvidenceFolderErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetEvidenceByEvidenceFolderErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetEvidenceByEvidenceFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEvidenceByEvidenceFolderError {
    fn code(&self) -> Option<&str> {
        GetEvidenceByEvidenceFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEvidenceByEvidenceFolderError {
    pub fn new(kind: GetEvidenceByEvidenceFolderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEvidenceByEvidenceFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEvidenceByEvidenceFolderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceByEvidenceFolderErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceByEvidenceFolderErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceByEvidenceFolderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceByEvidenceFolderErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetEvidenceByEvidenceFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEvidenceByEvidenceFolderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetEvidenceByEvidenceFolderErrorKind::InternalServerException(_inner) => Some(_inner),
            GetEvidenceByEvidenceFolderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetEvidenceByEvidenceFolderErrorKind::ValidationException(_inner) => Some(_inner),
            GetEvidenceByEvidenceFolderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEvidenceFolderError {
    pub kind: GetEvidenceFolderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEvidenceFolderErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEvidenceFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEvidenceFolderErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetEvidenceFolderErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetEvidenceFolderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetEvidenceFolderErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetEvidenceFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEvidenceFolderError {
    fn code(&self) -> Option<&str> {
        GetEvidenceFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEvidenceFolderError {
    pub fn new(kind: GetEvidenceFolderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEvidenceFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEvidenceFolderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFolderErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFolderErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFolderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFolderErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetEvidenceFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEvidenceFolderErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetEvidenceFolderErrorKind::InternalServerException(_inner) => Some(_inner),
            GetEvidenceFolderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetEvidenceFolderErrorKind::ValidationException(_inner) => Some(_inner),
            GetEvidenceFolderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEvidenceFoldersByAssessmentError {
    pub kind: GetEvidenceFoldersByAssessmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEvidenceFoldersByAssessmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEvidenceFoldersByAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEvidenceFoldersByAssessmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetEvidenceFoldersByAssessmentErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            GetEvidenceFoldersByAssessmentErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetEvidenceFoldersByAssessmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetEvidenceFoldersByAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEvidenceFoldersByAssessmentError {
    fn code(&self) -> Option<&str> {
        GetEvidenceFoldersByAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEvidenceFoldersByAssessmentError {
    pub fn new(kind: GetEvidenceFoldersByAssessmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEvidenceFoldersByAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEvidenceFoldersByAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFoldersByAssessmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFoldersByAssessmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFoldersByAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFoldersByAssessmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetEvidenceFoldersByAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEvidenceFoldersByAssessmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetEvidenceFoldersByAssessmentErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            GetEvidenceFoldersByAssessmentErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetEvidenceFoldersByAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            GetEvidenceFoldersByAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEvidenceFoldersByAssessmentControlError {
    pub kind: GetEvidenceFoldersByAssessmentControlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEvidenceFoldersByAssessmentControlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEvidenceFoldersByAssessmentControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEvidenceFoldersByAssessmentControlErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetEvidenceFoldersByAssessmentControlErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            GetEvidenceFoldersByAssessmentControlErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetEvidenceFoldersByAssessmentControlErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            GetEvidenceFoldersByAssessmentControlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEvidenceFoldersByAssessmentControlError {
    fn code(&self) -> Option<&str> {
        GetEvidenceFoldersByAssessmentControlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEvidenceFoldersByAssessmentControlError {
    pub fn new(
        kind: GetEvidenceFoldersByAssessmentControlErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEvidenceFoldersByAssessmentControlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEvidenceFoldersByAssessmentControlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFoldersByAssessmentControlErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFoldersByAssessmentControlErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFoldersByAssessmentControlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEvidenceFoldersByAssessmentControlErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetEvidenceFoldersByAssessmentControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEvidenceFoldersByAssessmentControlErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetEvidenceFoldersByAssessmentControlErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            GetEvidenceFoldersByAssessmentControlErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetEvidenceFoldersByAssessmentControlErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            GetEvidenceFoldersByAssessmentControlErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOrganizationAdminAccountError {
    pub kind: GetOrganizationAdminAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOrganizationAdminAccountErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOrganizationAdminAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOrganizationAdminAccountErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetOrganizationAdminAccountErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetOrganizationAdminAccountErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetOrganizationAdminAccountErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetOrganizationAdminAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOrganizationAdminAccountError {
    fn code(&self) -> Option<&str> {
        GetOrganizationAdminAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOrganizationAdminAccountError {
    pub fn new(kind: GetOrganizationAdminAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOrganizationAdminAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOrganizationAdminAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationAdminAccountErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationAdminAccountErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationAdminAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOrganizationAdminAccountErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetOrganizationAdminAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOrganizationAdminAccountErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetOrganizationAdminAccountErrorKind::InternalServerException(_inner) => Some(_inner),
            GetOrganizationAdminAccountErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetOrganizationAdminAccountErrorKind::ValidationException(_inner) => Some(_inner),
            GetOrganizationAdminAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServicesInScopeError {
    pub kind: GetServicesInScopeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServicesInScopeErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServicesInScopeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServicesInScopeErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetServicesInScopeErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetServicesInScopeErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetServicesInScopeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServicesInScopeError {
    fn code(&self) -> Option<&str> {
        GetServicesInScopeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServicesInScopeError {
    pub fn new(kind: GetServicesInScopeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServicesInScopeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServicesInScopeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServicesInScopeErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServicesInScopeErrorKind::InternalServerException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServicesInScopeErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetServicesInScopeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServicesInScopeErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetServicesInScopeErrorKind::InternalServerException(_inner) => Some(_inner),
            GetServicesInScopeErrorKind::ValidationException(_inner) => Some(_inner),
            GetServicesInScopeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSettingsError {
    pub kind: GetSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSettingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSettingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetSettingsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSettingsError {
    fn code(&self) -> Option<&str> {
        GetSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSettingsError {
    pub fn new(kind: GetSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetSettingsErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetSettingsErrorKind::InternalServerException(_))
    }
}
impl std::error::Error for GetSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSettingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetSettingsErrorKind::InternalServerException(_inner) => Some(_inner),
            GetSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssessmentFrameworksError {
    pub kind: ListAssessmentFrameworksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssessmentFrameworksErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssessmentFrameworksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssessmentFrameworksErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAssessmentFrameworksErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListAssessmentFrameworksErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAssessmentFrameworksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssessmentFrameworksError {
    fn code(&self) -> Option<&str> {
        ListAssessmentFrameworksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssessmentFrameworksError {
    pub fn new(kind: ListAssessmentFrameworksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssessmentFrameworksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssessmentFrameworksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentFrameworksErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentFrameworksErrorKind::InternalServerException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentFrameworksErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListAssessmentFrameworksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssessmentFrameworksErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAssessmentFrameworksErrorKind::InternalServerException(_inner) => Some(_inner),
            ListAssessmentFrameworksErrorKind::ValidationException(_inner) => Some(_inner),
            ListAssessmentFrameworksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssessmentReportsError {
    pub kind: ListAssessmentReportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssessmentReportsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssessmentReportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssessmentReportsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAssessmentReportsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListAssessmentReportsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAssessmentReportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssessmentReportsError {
    fn code(&self) -> Option<&str> {
        ListAssessmentReportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssessmentReportsError {
    pub fn new(kind: ListAssessmentReportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssessmentReportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssessmentReportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentReportsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentReportsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentReportsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListAssessmentReportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssessmentReportsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAssessmentReportsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListAssessmentReportsErrorKind::ValidationException(_inner) => Some(_inner),
            ListAssessmentReportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssessmentsError {
    pub kind: ListAssessmentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssessmentsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssessmentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssessmentsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListAssessmentsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListAssessmentsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListAssessmentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssessmentsError {
    fn code(&self) -> Option<&str> {
        ListAssessmentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssessmentsError {
    pub fn new(kind: ListAssessmentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssessmentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssessmentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssessmentsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListAssessmentsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListAssessmentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssessmentsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListAssessmentsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListAssessmentsErrorKind::ValidationException(_inner) => Some(_inner),
            ListAssessmentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListControlsError {
    pub kind: ListControlsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListControlsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListControlsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListControlsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListControlsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListControlsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListControlsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListControlsError {
    fn code(&self) -> Option<&str> {
        ListControlsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListControlsError {
    pub fn new(kind: ListControlsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListControlsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListControlsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListControlsErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListControlsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListControlsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListControlsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListControlsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListControlsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListControlsErrorKind::ValidationException(_inner) => Some(_inner),
            ListControlsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListKeywordsForDataSourceError {
    pub kind: ListKeywordsForDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListKeywordsForDataSourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListKeywordsForDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListKeywordsForDataSourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListKeywordsForDataSourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListKeywordsForDataSourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListKeywordsForDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListKeywordsForDataSourceError {
    fn code(&self) -> Option<&str> {
        ListKeywordsForDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListKeywordsForDataSourceError {
    pub fn new(kind: ListKeywordsForDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListKeywordsForDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListKeywordsForDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKeywordsForDataSourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKeywordsForDataSourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKeywordsForDataSourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListKeywordsForDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListKeywordsForDataSourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListKeywordsForDataSourceErrorKind::InternalServerException(_inner) => Some(_inner),
            ListKeywordsForDataSourceErrorKind::ValidationException(_inner) => Some(_inner),
            ListKeywordsForDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListNotificationsError {
    pub kind: ListNotificationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListNotificationsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListNotificationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListNotificationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListNotificationsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListNotificationsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListNotificationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListNotificationsError {
    fn code(&self) -> Option<&str> {
        ListNotificationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListNotificationsError {
    pub fn new(kind: ListNotificationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListNotificationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListNotificationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNotificationsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNotificationsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNotificationsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListNotificationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListNotificationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListNotificationsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListNotificationsErrorKind::ValidationException(_inner) => Some(_inner),
            ListNotificationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ValidationException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterAccountError {
    pub kind: RegisterAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterAccountErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterAccountErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RegisterAccountErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            RegisterAccountErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RegisterAccountErrorKind::ValidationException(_inner) => _inner.fmt(f),
            RegisterAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterAccountError {
    fn code(&self) -> Option<&str> {
        RegisterAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterAccountError {
    pub fn new(kind: RegisterAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterAccountErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterAccountErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, RegisterAccountErrorKind::ValidationException(_))
    }
}
impl std::error::Error for RegisterAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterAccountErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RegisterAccountErrorKind::InternalServerException(_inner) => Some(_inner),
            RegisterAccountErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RegisterAccountErrorKind::ValidationException(_inner) => Some(_inner),
            RegisterAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterOrganizationAdminAccountError {
    pub kind: RegisterOrganizationAdminAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterOrganizationAdminAccountErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterOrganizationAdminAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterOrganizationAdminAccountErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            RegisterOrganizationAdminAccountErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            RegisterOrganizationAdminAccountErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            RegisterOrganizationAdminAccountErrorKind::ValidationException(_inner) => _inner.fmt(f),
            RegisterOrganizationAdminAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterOrganizationAdminAccountError {
    fn code(&self) -> Option<&str> {
        RegisterOrganizationAdminAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterOrganizationAdminAccountError {
    pub fn new(kind: RegisterOrganizationAdminAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterOrganizationAdminAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterOrganizationAdminAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterOrganizationAdminAccountErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterOrganizationAdminAccountErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterOrganizationAdminAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterOrganizationAdminAccountErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for RegisterOrganizationAdminAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterOrganizationAdminAccountErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            RegisterOrganizationAdminAccountErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            RegisterOrganizationAdminAccountErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            RegisterOrganizationAdminAccountErrorKind::ValidationException(_inner) => Some(_inner),
            RegisterOrganizationAdminAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssessmentError {
    pub kind: UpdateAssessmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssessmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssessmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssessmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateAssessmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateAssessmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAssessmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateAssessmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssessmentError {
    fn code(&self) -> Option<&str> {
        UpdateAssessmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssessmentError {
    pub fn new(kind: UpdateAssessmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssessmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssessmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateAssessmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssessmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateAssessmentErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateAssessmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAssessmentErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateAssessmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssessmentControlError {
    pub kind: UpdateAssessmentControlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssessmentControlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssessmentControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssessmentControlErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateAssessmentControlErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateAssessmentControlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAssessmentControlErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateAssessmentControlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssessmentControlError {
    fn code(&self) -> Option<&str> {
        UpdateAssessmentControlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssessmentControlError {
    pub fn new(kind: UpdateAssessmentControlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssessmentControlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssessmentControlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentControlErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentControlErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentControlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentControlErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateAssessmentControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssessmentControlErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateAssessmentControlErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateAssessmentControlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAssessmentControlErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateAssessmentControlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssessmentControlSetStatusError {
    pub kind: UpdateAssessmentControlSetStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssessmentControlSetStatusErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssessmentControlSetStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssessmentControlSetStatusErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAssessmentControlSetStatusErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAssessmentControlSetStatusErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAssessmentControlSetStatusErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateAssessmentControlSetStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssessmentControlSetStatusError {
    fn code(&self) -> Option<&str> {
        UpdateAssessmentControlSetStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssessmentControlSetStatusError {
    pub fn new(kind: UpdateAssessmentControlSetStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssessmentControlSetStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssessmentControlSetStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentControlSetStatusErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentControlSetStatusErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentControlSetStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentControlSetStatusErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateAssessmentControlSetStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssessmentControlSetStatusErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateAssessmentControlSetStatusErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            UpdateAssessmentControlSetStatusErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateAssessmentControlSetStatusErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateAssessmentControlSetStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssessmentFrameworkError {
    pub kind: UpdateAssessmentFrameworkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssessmentFrameworkErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssessmentFrameworkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssessmentFrameworkErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateAssessmentFrameworkErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateAssessmentFrameworkErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAssessmentFrameworkErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateAssessmentFrameworkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssessmentFrameworkError {
    fn code(&self) -> Option<&str> {
        UpdateAssessmentFrameworkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssessmentFrameworkError {
    pub fn new(kind: UpdateAssessmentFrameworkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssessmentFrameworkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssessmentFrameworkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentFrameworkErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentFrameworkErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentFrameworkErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentFrameworkErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateAssessmentFrameworkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssessmentFrameworkErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateAssessmentFrameworkErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateAssessmentFrameworkErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAssessmentFrameworkErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateAssessmentFrameworkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAssessmentStatusError {
    pub kind: UpdateAssessmentStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAssessmentStatusErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAssessmentStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAssessmentStatusErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateAssessmentStatusErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateAssessmentStatusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAssessmentStatusErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateAssessmentStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAssessmentStatusError {
    fn code(&self) -> Option<&str> {
        UpdateAssessmentStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAssessmentStatusError {
    pub fn new(kind: UpdateAssessmentStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAssessmentStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAssessmentStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentStatusErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentStatusErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAssessmentStatusErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateAssessmentStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAssessmentStatusErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateAssessmentStatusErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateAssessmentStatusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAssessmentStatusErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateAssessmentStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateControlError {
    pub kind: UpdateControlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateControlErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateControlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateControlErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateControlErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateControlErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateControlErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateControlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateControlError {
    fn code(&self) -> Option<&str> {
        UpdateControlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateControlError {
    pub fn new(kind: UpdateControlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateControlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateControlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateControlErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateControlErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateControlErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateControlErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateControlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateControlErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateControlErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateControlErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateControlErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateControlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSettingsError {
    pub kind: UpdateSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSettingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSettingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateSettingsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateSettingsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSettingsError {
    pub fn new(kind: UpdateSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSettingsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSettingsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateSettingsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSettingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateSettingsErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateSettingsErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateAssessmentReportIntegrityError {
    pub kind: ValidateAssessmentReportIntegrityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateAssessmentReportIntegrityErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateAssessmentReportIntegrityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ValidateAssessmentReportIntegrityErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ValidateAssessmentReportIntegrityErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ValidateAssessmentReportIntegrityErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ValidateAssessmentReportIntegrityErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            ValidateAssessmentReportIntegrityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ValidateAssessmentReportIntegrityError {
    fn code(&self) -> Option<&str> {
        ValidateAssessmentReportIntegrityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ValidateAssessmentReportIntegrityError {
    pub fn new(
        kind: ValidateAssessmentReportIntegrityErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ValidateAssessmentReportIntegrityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ValidateAssessmentReportIntegrityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateAssessmentReportIntegrityErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateAssessmentReportIntegrityErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateAssessmentReportIntegrityErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ValidateAssessmentReportIntegrityErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ValidateAssessmentReportIntegrityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ValidateAssessmentReportIntegrityErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ValidateAssessmentReportIntegrityErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ValidateAssessmentReportIntegrityErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ValidateAssessmentReportIntegrityErrorKind::ValidationException(_inner) => Some(_inner),
            ValidateAssessmentReportIntegrityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>
/// The request has invalid or missing parameters.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    pub message: std::option::Option<std::string::String>,
    /// <p>
    /// The reason the request failed validation.
    /// </p>
    pub reason: std::option::Option<crate::model::ValidationExceptionReason>,
    /// <p>
    /// The fields that caused the error, if applicable.
    /// </p>
    pub fields: std::option::Option<std::vec::Vec<crate::model::ValidationExceptionField>>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.field("reason", &self.reason);
        formatter.field("fields", &self.fields);
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::ValidationExceptionReason>,
        pub(crate) fields:
            std::option::Option<std::vec::Vec<crate::model::ValidationExceptionField>>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>
        /// The reason the request failed validation.
        /// </p>
        pub fn reason(mut self, input: crate::model::ValidationExceptionReason) -> Self {
            self.reason = Some(input);
            self
        }
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::ValidationExceptionReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        pub fn fields(mut self, input: impl Into<crate::model::ValidationExceptionField>) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input.into());
            self.fields = Some(v);
            self
        }
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValidationExceptionField>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
                reason: self.reason,
                fields: self.fields,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>
/// The resource specified in the request cannot be found.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
    /// <p>
    /// The unique identifier for the specified resource.
    /// </p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>
    /// The type of resource affected by the error.
    /// </p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>
        /// The unique identifier for the specified resource.
        /// </p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>
        /// The type of resource affected by the error.
        /// </p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>
/// An internal service error occurred during the processing of your request. Try again later.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException)
pub mod internal_server_exception {
    /// A builder for [`InternalServerException`](crate::error::InternalServerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException)
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message,
            }
        }
    }
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException)
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>
/// Your account is not registered with AWS Audit Manager. Check the delegated administrator setup on the AWS Audit Manager settings page, and try again.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}
