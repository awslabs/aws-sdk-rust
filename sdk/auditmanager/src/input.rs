// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
impl AssociateAssessmentReportEvidenceFolderInput {
    /// Consumes the builder and constructs an Operation<[`AssociateAssessmentReportEvidenceFolder`](crate::operation::AssociateAssessmentReportEvidenceFolder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateAssessmentReportEvidenceFolder,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateAssessmentReportEvidenceFolderInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.assessment_id;
                let input_1 = input_1.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_1,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/associateToAssessmentReport",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateAssessmentReportEvidenceFolderInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_assessment_report_evidence_folder::ser_associate_assessment_report_evidence_folder_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateAssessmentReportEvidenceFolder::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateAssessmentReportEvidenceFolder",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl BatchAssociateAssessmentReportEvidenceInput {
    /// Consumes the builder and constructs an Operation<[`BatchAssociateAssessmentReportEvidence`](crate::operation::BatchAssociateAssessmentReportEvidence)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchAssociateAssessmentReportEvidence,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchAssociateAssessmentReportEvidenceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_2 = &_input.assessment_id;
                let input_2 = input_2.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_2,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/batchAssociateToAssessmentReport",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchAssociateAssessmentReportEvidenceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_batch_associate_assessment_report_evidence::ser_batch_associate_assessment_report_evidence_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchAssociateAssessmentReportEvidence::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchAssociateAssessmentReportEvidence",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl BatchCreateDelegationByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`BatchCreateDelegationByAssessment`](crate::operation::BatchCreateDelegationByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchCreateDelegationByAssessment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchCreateDelegationByAssessmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.assessment_id;
                let input_3 = input_3.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_3,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/delegations",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchCreateDelegationByAssessmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_batch_create_delegation_by_assessment::ser_batch_create_delegation_by_assessment_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchCreateDelegationByAssessment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchCreateDelegationByAssessment",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl BatchDeleteDelegationByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`BatchDeleteDelegationByAssessment`](crate::operation::BatchDeleteDelegationByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchDeleteDelegationByAssessment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchDeleteDelegationByAssessmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.assessment_id;
                let input_4 = input_4.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_4,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/delegations",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchDeleteDelegationByAssessmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_batch_delete_delegation_by_assessment::ser_batch_delete_delegation_by_assessment_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchDeleteDelegationByAssessment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchDeleteDelegationByAssessment",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl BatchDisassociateAssessmentReportEvidenceInput {
    /// Consumes the builder and constructs an Operation<[`BatchDisassociateAssessmentReportEvidence`](crate::operation::BatchDisassociateAssessmentReportEvidence)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchDisassociateAssessmentReportEvidence,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchDisassociateAssessmentReportEvidenceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.assessment_id;
                let input_5 = input_5.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_5,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/batchDisassociateFromAssessmentReport",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchDisassociateAssessmentReportEvidenceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_batch_disassociate_assessment_report_evidence::ser_batch_disassociate_assessment_report_evidence_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchDisassociateAssessmentReportEvidence::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchDisassociateAssessmentReportEvidence",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl BatchImportEvidenceToAssessmentControlInput {
    /// Consumes the builder and constructs an Operation<[`BatchImportEvidenceToAssessmentControl`](crate::operation::BatchImportEvidenceToAssessmentControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchImportEvidenceToAssessmentControl,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchImportEvidenceToAssessmentControlInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.assessment_id;
                let input_6 = input_6.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_6,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_7 = &_input.control_set_id;
                let input_7 = input_7.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_set_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_set_id = aws_smithy_http::label::fmt_string(
                    input_7,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_set_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_set_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_8 = &_input.control_id;
                let input_8 = input_8.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_id = aws_smithy_http::label::fmt_string(
                    input_8,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/controls/{controlId}/evidence", assessmentId = assessment_id, controlSetId = control_set_id, controlId = control_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchImportEvidenceToAssessmentControlInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_batch_import_evidence_to_assessment_control::ser_batch_import_evidence_to_assessment_control_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchImportEvidenceToAssessmentControl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchImportEvidenceToAssessmentControl",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateAssessment`](crate::operation::CreateAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAssessment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAssessmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessments").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAssessmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_assessment::ser_create_assessment_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAssessment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAssessment",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateAssessmentFrameworkInput {
    /// Consumes the builder and constructs an Operation<[`CreateAssessmentFramework`](crate::operation::CreateAssessmentFramework)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAssessmentFramework,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAssessmentFrameworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentFrameworks").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAssessmentFrameworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_assessment_framework::ser_create_assessment_framework_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAssessmentFramework::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAssessmentFramework",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateAssessmentReportInput {
    /// Consumes the builder and constructs an Operation<[`CreateAssessmentReport`](crate::operation::CreateAssessmentReport)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAssessmentReport,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAssessmentReportInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.assessment_id;
                let input_9 = input_9.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_9,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/reports",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAssessmentReportInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_assessment_report::ser_create_assessment_report_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAssessmentReport::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAssessmentReport",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateControlInput {
    /// Consumes the builder and constructs an Operation<[`CreateControl`](crate::operation::CreateControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateControl,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateControlInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/controls").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateControlInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_control::ser_create_control_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateControl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateControl",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAssessment`](crate::operation::DeleteAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAssessment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAssessmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.assessment_id;
                let input_10 = input_10.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_10,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAssessmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAssessment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAssessment",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteAssessmentFrameworkInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAssessmentFramework`](crate::operation::DeleteAssessmentFramework)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAssessmentFramework,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAssessmentFrameworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_11 = &_input.framework_id;
                let input_11 = input_11.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "framework_id",
                        "cannot be empty or unset",
                    )
                })?;
                let framework_id = aws_smithy_http::label::fmt_string(
                    input_11,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if framework_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "framework_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessmentFrameworks/{frameworkId}",
                    frameworkId = framework_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAssessmentFrameworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAssessmentFramework::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAssessmentFramework",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteAssessmentFrameworkShareInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAssessmentFrameworkShare`](crate::operation::DeleteAssessmentFrameworkShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAssessmentFrameworkShare,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAssessmentFrameworkShareInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_12 = &_input.request_id;
                let input_12 = input_12.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "request_id",
                        "cannot be empty or unset",
                    )
                })?;
                let request_id = aws_smithy_http::label::fmt_string(
                    input_12,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if request_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "request_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessmentFrameworkShareRequests/{requestId}",
                    requestId = request_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DeleteAssessmentFrameworkShareInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_13 = &_input.request_type;
                let inner_13 = inner_13.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "request_type",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv(
                    "requestType",
                    &aws_smithy_http::query::fmt_string(&inner_13),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAssessmentFrameworkShareInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAssessmentFrameworkShare::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAssessmentFrameworkShare",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteAssessmentReportInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAssessmentReport`](crate::operation::DeleteAssessmentReport)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAssessmentReport,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAssessmentReportInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_14 = &_input.assessment_id;
                let input_14 = input_14.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_14,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_15 = &_input.assessment_report_id;
                let input_15 = input_15.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_report_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_report_id = aws_smithy_http::label::fmt_string(
                    input_15,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_report_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_report_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/reports/{assessmentReportId}",
                    assessmentId = assessment_id,
                    assessmentReportId = assessment_report_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAssessmentReportInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAssessmentReport::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAssessmentReport",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteControlInput {
    /// Consumes the builder and constructs an Operation<[`DeleteControl`](crate::operation::DeleteControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteControl,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteControlInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.control_id;
                let input_16 = input_16.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_id = aws_smithy_http::label::fmt_string(
                    input_16,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/controls/{controlId}", controlId = control_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteControlInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteControl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteControl",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeregisterAccountInput {
    /// Consumes the builder and constructs an Operation<[`DeregisterAccount`](crate::operation::DeregisterAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeregisterAccount,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeregisterAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/deregisterAccount").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeregisterAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeregisterAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeregisterAccount",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeregisterOrganizationAdminAccountInput {
    /// Consumes the builder and constructs an Operation<[`DeregisterOrganizationAdminAccount`](crate::operation::DeregisterOrganizationAdminAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeregisterOrganizationAdminAccount,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeregisterOrganizationAdminAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/deregisterOrganizationAdminAccount")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeregisterOrganizationAdminAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_deregister_organization_admin_account::ser_deregister_organization_admin_account_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeregisterOrganizationAdminAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeregisterOrganizationAdminAccount",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateAssessmentReportEvidenceFolderInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateAssessmentReportEvidenceFolder`](crate::operation::DisassociateAssessmentReportEvidenceFolder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateAssessmentReportEvidenceFolder,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateAssessmentReportEvidenceFolderInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_17 = &_input.assessment_id;
                let input_17 = input_17.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_17,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/disassociateFromAssessmentReport",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateAssessmentReportEvidenceFolderInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_disassociate_assessment_report_evidence_folder::ser_disassociate_assessment_report_evidence_folder_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateAssessmentReportEvidenceFolder::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateAssessmentReportEvidenceFolder",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetAccountStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetAccountStatus`](crate::operation::GetAccountStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAccountStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAccountStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/status").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAccountStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAccountStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAccountStatus",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`GetAssessment`](crate::operation::GetAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAssessment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAssessmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_18 = &_input.assessment_id;
                let input_18 = input_18.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_18,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAssessmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAssessment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAssessment",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetAssessmentFrameworkInput {
    /// Consumes the builder and constructs an Operation<[`GetAssessmentFramework`](crate::operation::GetAssessmentFramework)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAssessmentFramework,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAssessmentFrameworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_19 = &_input.framework_id;
                let input_19 = input_19.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "framework_id",
                        "cannot be empty or unset",
                    )
                })?;
                let framework_id = aws_smithy_http::label::fmt_string(
                    input_19,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if framework_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "framework_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessmentFrameworks/{frameworkId}",
                    frameworkId = framework_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAssessmentFrameworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAssessmentFramework::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAssessmentFramework",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetAssessmentReportUrlInput {
    /// Consumes the builder and constructs an Operation<[`GetAssessmentReportUrl`](crate::operation::GetAssessmentReportUrl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAssessmentReportUrl,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAssessmentReportUrlInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_20 = &_input.assessment_id;
                let input_20 = input_20.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_20,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_21 = &_input.assessment_report_id;
                let input_21 = input_21.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_report_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_report_id = aws_smithy_http::label::fmt_string(
                    input_21,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_report_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_report_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/reports/{assessmentReportId}/url",
                    assessmentId = assessment_id,
                    assessmentReportId = assessment_report_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAssessmentReportUrlInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAssessmentReportUrl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAssessmentReportUrl",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetChangeLogsInput {
    /// Consumes the builder and constructs an Operation<[`GetChangeLogs`](crate::operation::GetChangeLogs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetChangeLogs,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetChangeLogsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_22 = &_input.assessment_id;
                let input_22 = input_22.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_22,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/changelogs",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetChangeLogsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_23) = &_input.control_set_id {
                    {
                        query.push_kv(
                            "controlSetId",
                            &aws_smithy_http::query::fmt_string(&inner_23),
                        );
                    }
                }
                if let Some(inner_24) = &_input.control_id {
                    {
                        query.push_kv("controlId", &aws_smithy_http::query::fmt_string(&inner_24));
                    }
                }
                if let Some(inner_25) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_25));
                    }
                }
                if let Some(inner_26) = &_input.max_results {
                    if *inner_26 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_26).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetChangeLogsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetChangeLogs::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetChangeLogs",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetControlInput {
    /// Consumes the builder and constructs an Operation<[`GetControl`](crate::operation::GetControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetControl,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetControlInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_27 = &_input.control_id;
                let input_27 = input_27.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_id = aws_smithy_http::label::fmt_string(
                    input_27,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/controls/{controlId}", controlId = control_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetControlInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetControl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetControl",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetDelegationsInput {
    /// Consumes the builder and constructs an Operation<[`GetDelegations`](crate::operation::GetDelegations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDelegations,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetDelegationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/delegations").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetDelegationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_28) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_28));
                    }
                }
                if let Some(inner_29) = &_input.max_results {
                    if *inner_29 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_29).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetDelegationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDelegations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDelegations",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetEvidenceInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidence`](crate::operation::GetEvidence)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetEvidence,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetEvidenceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_30 = &_input.assessment_id;
                let input_30 = input_30.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_30,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_31 = &_input.control_set_id;
                let input_31 = input_31.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_set_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_set_id = aws_smithy_http::label::fmt_string(
                    input_31,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_set_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_set_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_32 = &_input.evidence_folder_id;
                let input_32 = input_32.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "evidence_folder_id",
                        "cannot be empty or unset",
                    )
                })?;
                let evidence_folder_id = aws_smithy_http::label::fmt_string(
                    input_32,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if evidence_folder_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "evidence_folder_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_33 = &_input.evidence_id;
                let input_33 = input_33.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "evidence_id",
                        "cannot be empty or unset",
                    )
                })?;
                let evidence_id = aws_smithy_http::label::fmt_string(
                    input_33,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if evidence_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "evidence_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/evidenceFolders/{evidenceFolderId}/evidence/{evidenceId}", assessmentId = assessment_id, controlSetId = control_set_id, evidenceFolderId = evidence_folder_id, evidenceId = evidence_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetEvidenceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetEvidence::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetEvidence",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetEvidenceByEvidenceFolderInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidenceByEvidenceFolder`](crate::operation::GetEvidenceByEvidenceFolder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetEvidenceByEvidenceFolder,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetEvidenceByEvidenceFolderInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_34 = &_input.assessment_id;
                let input_34 = input_34.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_34,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_35 = &_input.control_set_id;
                let input_35 = input_35.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_set_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_set_id = aws_smithy_http::label::fmt_string(
                    input_35,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_set_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_set_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_36 = &_input.evidence_folder_id;
                let input_36 = input_36.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "evidence_folder_id",
                        "cannot be empty or unset",
                    )
                })?;
                let evidence_folder_id = aws_smithy_http::label::fmt_string(
                    input_36,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if evidence_folder_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "evidence_folder_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/evidenceFolders/{evidenceFolderId}/evidence", assessmentId = assessment_id, controlSetId = control_set_id, evidenceFolderId = evidence_folder_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetEvidenceByEvidenceFolderInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_37) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_37));
                    }
                }
                if let Some(inner_38) = &_input.max_results {
                    if *inner_38 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_38).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetEvidenceByEvidenceFolderInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetEvidenceByEvidenceFolder::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetEvidenceByEvidenceFolder",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetEvidenceFolderInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidenceFolder`](crate::operation::GetEvidenceFolder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetEvidenceFolder,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetEvidenceFolderInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_39 = &_input.assessment_id;
                let input_39 = input_39.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_39,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_40 = &_input.control_set_id;
                let input_40 = input_40.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_set_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_set_id = aws_smithy_http::label::fmt_string(
                    input_40,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_set_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_set_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_41 = &_input.evidence_folder_id;
                let input_41 = input_41.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "evidence_folder_id",
                        "cannot be empty or unset",
                    )
                })?;
                let evidence_folder_id = aws_smithy_http::label::fmt_string(
                    input_41,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if evidence_folder_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "evidence_folder_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/evidenceFolders/{evidenceFolderId}", assessmentId = assessment_id, controlSetId = control_set_id, evidenceFolderId = evidence_folder_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetEvidenceFolderInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetEvidenceFolder::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetEvidenceFolder",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetEvidenceFoldersByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidenceFoldersByAssessment`](crate::operation::GetEvidenceFoldersByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetEvidenceFoldersByAssessment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetEvidenceFoldersByAssessmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_42 = &_input.assessment_id;
                let input_42 = input_42.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_42,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/evidenceFolders",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetEvidenceFoldersByAssessmentInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_43) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_43));
                    }
                }
                if let Some(inner_44) = &_input.max_results {
                    if *inner_44 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_44).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetEvidenceFoldersByAssessmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetEvidenceFoldersByAssessment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetEvidenceFoldersByAssessment",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetEvidenceFoldersByAssessmentControlInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidenceFoldersByAssessmentControl`](crate::operation::GetEvidenceFoldersByAssessmentControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetEvidenceFoldersByAssessmentControl,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetEvidenceFoldersByAssessmentControlInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_45 = &_input.assessment_id;
                let input_45 = input_45.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_45,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_46 = &_input.control_set_id;
                let input_46 = input_46.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_set_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_set_id = aws_smithy_http::label::fmt_string(
                    input_46,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_set_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_set_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_47 = &_input.control_id;
                let input_47 = input_47.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_id = aws_smithy_http::label::fmt_string(
                    input_47,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/assessments/{assessmentId}/evidenceFolders-by-assessment-control/{controlSetId}/{controlId}", assessmentId = assessment_id, controlSetId = control_set_id, controlId = control_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetEvidenceFoldersByAssessmentControlInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_48) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_48));
                    }
                }
                if let Some(inner_49) = &_input.max_results {
                    if *inner_49 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_49).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetEvidenceFoldersByAssessmentControlInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetEvidenceFoldersByAssessmentControl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetEvidenceFoldersByAssessmentControl",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetInsightsInput {
    /// Consumes the builder and constructs an Operation<[`GetInsights`](crate::operation::GetInsights)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInsights,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetInsightsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetInsightsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInsights::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInsights",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetInsightsByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`GetInsightsByAssessment`](crate::operation::GetInsightsByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInsightsByAssessment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetInsightsByAssessmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_50 = &_input.assessment_id;
                let input_50 = input_50.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_50,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/insights/assessments/{assessmentId}",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetInsightsByAssessmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInsightsByAssessment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInsightsByAssessment",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetOrganizationAdminAccountInput {
    /// Consumes the builder and constructs an Operation<[`GetOrganizationAdminAccount`](crate::operation::GetOrganizationAdminAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetOrganizationAdminAccount,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetOrganizationAdminAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/organizationAdminAccount")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetOrganizationAdminAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetOrganizationAdminAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetOrganizationAdminAccount",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetServicesInScopeInput {
    /// Consumes the builder and constructs an Operation<[`GetServicesInScope`](crate::operation::GetServicesInScope)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetServicesInScope,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetServicesInScopeInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/services").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetServicesInScopeInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetServicesInScope::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetServicesInScope",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetSettingsInput {
    /// Consumes the builder and constructs an Operation<[`GetSettings`](crate::operation::GetSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSettings,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_51 = &_input.attribute;
                let input_51 = input_51.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attribute",
                        "cannot be empty or unset",
                    )
                })?;
                let attribute = aws_smithy_http::label::fmt_string(
                    input_51,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attribute.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attribute",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/settings/{attribute}", attribute = attribute)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSettings",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListAssessmentControlInsightsByControlDomainInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessmentControlInsightsByControlDomain`](crate::operation::ListAssessmentControlInsightsByControlDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAssessmentControlInsightsByControlDomain,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAssessmentControlInsightsByControlDomainInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights/controls-by-assessment")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAssessmentControlInsightsByControlDomainInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_52 = &_input.control_domain_id;
                let inner_52 = inner_52.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_52.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "controlDomainId",
                    &aws_smithy_http::query::fmt_string(&inner_52),
                );
                let inner_53 = &_input.assessment_id;
                let inner_53 = inner_53.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_53.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "assessmentId",
                    &aws_smithy_http::query::fmt_string(&inner_53),
                );
                if let Some(inner_54) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_54));
                    }
                }
                if let Some(inner_55) = &_input.max_results {
                    if *inner_55 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_55).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAssessmentControlInsightsByControlDomainInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAssessmentControlInsightsByControlDomain::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAssessmentControlInsightsByControlDomain",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListAssessmentFrameworksInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessmentFrameworks`](crate::operation::ListAssessmentFrameworks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAssessmentFrameworks,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAssessmentFrameworksInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentFrameworks").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAssessmentFrameworksInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_56 = &_input.framework_type;
                let inner_56 = inner_56.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "framework_type",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv(
                    "frameworkType",
                    &aws_smithy_http::query::fmt_string(&inner_56),
                );
                if let Some(inner_57) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_57));
                    }
                }
                if let Some(inner_58) = &_input.max_results {
                    if *inner_58 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_58).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAssessmentFrameworksInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAssessmentFrameworks::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAssessmentFrameworks",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListAssessmentFrameworkShareRequestsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessmentFrameworkShareRequests`](crate::operation::ListAssessmentFrameworkShareRequests)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAssessmentFrameworkShareRequests,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAssessmentFrameworkShareRequestsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentFrameworkShareRequests")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAssessmentFrameworkShareRequestsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_59 = &_input.request_type;
                let inner_59 = inner_59.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "request_type",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv(
                    "requestType",
                    &aws_smithy_http::query::fmt_string(&inner_59),
                );
                if let Some(inner_60) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_60));
                    }
                }
                if let Some(inner_61) = &_input.max_results {
                    if *inner_61 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_61).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAssessmentFrameworkShareRequestsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAssessmentFrameworkShareRequests::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAssessmentFrameworkShareRequests",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListAssessmentReportsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessmentReports`](crate::operation::ListAssessmentReports)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAssessmentReports,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAssessmentReportsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentReports").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAssessmentReportsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_62) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_62));
                    }
                }
                if let Some(inner_63) = &_input.max_results {
                    if *inner_63 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_63).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAssessmentReportsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAssessmentReports::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAssessmentReports",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListAssessmentsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessments`](crate::operation::ListAssessments)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAssessments,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAssessmentsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessments").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAssessmentsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_64) = &_input.status {
                    {
                        query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_64));
                    }
                }
                if let Some(inner_65) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_65));
                    }
                }
                if let Some(inner_66) = &_input.max_results {
                    if *inner_66 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_66).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAssessmentsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAssessments::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAssessments",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListControlDomainInsightsInput {
    /// Consumes the builder and constructs an Operation<[`ListControlDomainInsights`](crate::operation::ListControlDomainInsights)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListControlDomainInsights,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListControlDomainInsightsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights/control-domains").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListControlDomainInsightsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_67) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_67));
                    }
                }
                if let Some(inner_68) = &_input.max_results {
                    if *inner_68 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_68).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListControlDomainInsightsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListControlDomainInsights::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListControlDomainInsights",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListControlDomainInsightsByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`ListControlDomainInsightsByAssessment`](crate::operation::ListControlDomainInsightsByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListControlDomainInsightsByAssessment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListControlDomainInsightsByAssessmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights/control-domains-by-assessment")
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListControlDomainInsightsByAssessmentInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_69 = &_input.assessment_id;
                let inner_69 = inner_69.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_69.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "assessmentId",
                    &aws_smithy_http::query::fmt_string(&inner_69),
                );
                if let Some(inner_70) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_70));
                    }
                }
                if let Some(inner_71) = &_input.max_results {
                    if *inner_71 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_71).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListControlDomainInsightsByAssessmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListControlDomainInsightsByAssessment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListControlDomainInsightsByAssessment",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListControlInsightsByControlDomainInput {
    /// Consumes the builder and constructs an Operation<[`ListControlInsightsByControlDomain`](crate::operation::ListControlInsightsByControlDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListControlInsightsByControlDomain,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListControlInsightsByControlDomainInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights/controls").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListControlInsightsByControlDomainInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_72 = &_input.control_domain_id;
                let inner_72 = inner_72.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_72.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "controlDomainId",
                    &aws_smithy_http::query::fmt_string(&inner_72),
                );
                if let Some(inner_73) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_73));
                    }
                }
                if let Some(inner_74) = &_input.max_results {
                    if *inner_74 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_74).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListControlInsightsByControlDomainInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListControlInsightsByControlDomain::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListControlInsightsByControlDomain",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListControlsInput {
    /// Consumes the builder and constructs an Operation<[`ListControls`](crate::operation::ListControls)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListControls,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListControlsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/controls").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListControlsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_75 = &_input.control_type;
                let inner_75 = inner_75.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_type",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv(
                    "controlType",
                    &aws_smithy_http::query::fmt_string(&inner_75),
                );
                if let Some(inner_76) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_76));
                    }
                }
                if let Some(inner_77) = &_input.max_results {
                    if *inner_77 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_77).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListControlsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListControls::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListControls",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListKeywordsForDataSourceInput {
    /// Consumes the builder and constructs an Operation<[`ListKeywordsForDataSource`](crate::operation::ListKeywordsForDataSource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListKeywordsForDataSource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListKeywordsForDataSourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/dataSourceKeywords").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListKeywordsForDataSourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_78 = &_input.source;
                let inner_78 = inner_78.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "source",
                        "cannot be empty or unset",
                    )
                })?;
                query.push_kv("source", &aws_smithy_http::query::fmt_string(&inner_78));
                if let Some(inner_79) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_79));
                    }
                }
                if let Some(inner_80) = &_input.max_results {
                    if *inner_80 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_80).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListKeywordsForDataSourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListKeywordsForDataSource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListKeywordsForDataSource",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListNotificationsInput {
    /// Consumes the builder and constructs an Operation<[`ListNotifications`](crate::operation::ListNotifications)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListNotifications,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListNotificationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/notifications").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListNotificationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_81) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_81));
                    }
                }
                if let Some(inner_82) = &_input.max_results {
                    if *inner_82 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_82).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListNotificationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListNotifications::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListNotifications",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_83 = &_input.resource_arn;
                let input_83 = input_83.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_83,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl RegisterAccountInput {
    /// Consumes the builder and constructs an Operation<[`RegisterAccount`](crate::operation::RegisterAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterAccount,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::RegisterAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/registerAccount").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RegisterAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_register_account::ser_register_account_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterAccount",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl RegisterOrganizationAdminAccountInput {
    /// Consumes the builder and constructs an Operation<[`RegisterOrganizationAdminAccount`](crate::operation::RegisterOrganizationAdminAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterOrganizationAdminAccount,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::RegisterOrganizationAdminAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/registerOrganizationAdminAccount")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RegisterOrganizationAdminAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_register_organization_admin_account::ser_register_organization_admin_account_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterOrganizationAdminAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterOrganizationAdminAccount",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StartAssessmentFrameworkShareInput {
    /// Consumes the builder and constructs an Operation<[`StartAssessmentFrameworkShare`](crate::operation::StartAssessmentFrameworkShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartAssessmentFrameworkShare,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartAssessmentFrameworkShareInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_84 = &_input.framework_id;
                let input_84 = input_84.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "framework_id",
                        "cannot be empty or unset",
                    )
                })?;
                let framework_id = aws_smithy_http::label::fmt_string(
                    input_84,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if framework_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "framework_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessmentFrameworks/{frameworkId}/shareRequests",
                    frameworkId = framework_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartAssessmentFrameworkShareInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_start_assessment_framework_share::ser_start_assessment_framework_share_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartAssessmentFrameworkShare::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartAssessmentFrameworkShare",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_85 = &_input.resource_arn;
                let input_85 = input_85.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_85,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_tag_resource::ser_tag_resource_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_86 = &_input.resource_arn;
                let input_86 = input_86.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_86,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_87 = &_input.tag_keys;
                let inner_87 = inner_87.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "tag_keys",
                        "cannot be empty or unset",
                    )
                })?;
                for inner_88 in inner_87 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_88));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessment`](crate::operation::UpdateAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAssessment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAssessmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_89 = &_input.assessment_id;
                let input_89 = input_89.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_89,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAssessmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_assessment::ser_update_assessment_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAssessment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAssessment",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateAssessmentControlInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentControl`](crate::operation::UpdateAssessmentControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAssessmentControl,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAssessmentControlInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_90 = &_input.assessment_id;
                let input_90 = input_90.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_90,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_91 = &_input.control_set_id;
                let input_91 = input_91.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_set_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_set_id = aws_smithy_http::label::fmt_string(
                    input_91,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_set_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_set_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_92 = &_input.control_id;
                let input_92 = input_92.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_id = aws_smithy_http::label::fmt_string(
                    input_92,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/controlSets/{controlSetId}/controls/{controlId}",
                    assessmentId = assessment_id,
                    controlSetId = control_set_id,
                    controlId = control_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAssessmentControlInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_assessment_control::ser_update_assessment_control_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAssessmentControl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAssessmentControl",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateAssessmentControlSetStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentControlSetStatus`](crate::operation::UpdateAssessmentControlSetStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAssessmentControlSetStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAssessmentControlSetStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_93 = &_input.assessment_id;
                let input_93 = input_93.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_93,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_94 = &_input.control_set_id;
                let input_94 = input_94.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_set_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_set_id = aws_smithy_http::label::fmt_string(
                    input_94,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_set_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_set_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/controlSets/{controlSetId}/status",
                    assessmentId = assessment_id,
                    controlSetId = control_set_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAssessmentControlSetStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_assessment_control_set_status::ser_update_assessment_control_set_status_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAssessmentControlSetStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAssessmentControlSetStatus",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateAssessmentFrameworkInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentFramework`](crate::operation::UpdateAssessmentFramework)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAssessmentFramework,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAssessmentFrameworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_95 = &_input.framework_id;
                let input_95 = input_95.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "framework_id",
                        "cannot be empty or unset",
                    )
                })?;
                let framework_id = aws_smithy_http::label::fmt_string(
                    input_95,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if framework_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "framework_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessmentFrameworks/{frameworkId}",
                    frameworkId = framework_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAssessmentFrameworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_assessment_framework::ser_update_assessment_framework_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAssessmentFramework::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAssessmentFramework",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateAssessmentFrameworkShareInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentFrameworkShare`](crate::operation::UpdateAssessmentFrameworkShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAssessmentFrameworkShare,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAssessmentFrameworkShareInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_96 = &_input.request_id;
                let input_96 = input_96.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "request_id",
                        "cannot be empty or unset",
                    )
                })?;
                let request_id = aws_smithy_http::label::fmt_string(
                    input_96,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if request_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "request_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessmentFrameworkShareRequests/{requestId}",
                    requestId = request_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAssessmentFrameworkShareInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_assessment_framework_share::ser_update_assessment_framework_share_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAssessmentFrameworkShare::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAssessmentFrameworkShare",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateAssessmentStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentStatus`](crate::operation::UpdateAssessmentStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAssessmentStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAssessmentStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_97 = &_input.assessment_id;
                let input_97 = input_97.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "assessment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let assessment_id = aws_smithy_http::label::fmt_string(
                    input_97,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if assessment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "assessment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/assessments/{assessmentId}/status",
                    assessmentId = assessment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAssessmentStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_assessment_status::ser_update_assessment_status_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAssessmentStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAssessmentStatus",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateControlInput {
    /// Consumes the builder and constructs an Operation<[`UpdateControl`](crate::operation::UpdateControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateControl,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateControlInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_98 = &_input.control_id;
                let input_98 = input_98.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "control_id",
                        "cannot be empty or unset",
                    )
                })?;
                let control_id = aws_smithy_http::label::fmt_string(
                    input_98,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if control_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "control_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/controls/{controlId}", controlId = control_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateControlInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_control::ser_update_control_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateControl::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateControl",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSettings`](crate::operation::UpdateSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSettings,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateSettingsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/settings").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateSettingsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_settings::ser_update_settings_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSettings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSettings",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ValidateAssessmentReportIntegrityInput {
    /// Consumes the builder and constructs an Operation<[`ValidateAssessmentReportIntegrity`](crate::operation::ValidateAssessmentReportIntegrity)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ValidateAssessmentReportIntegrity,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ValidateAssessmentReportIntegrityInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentReports/integrity").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ValidateAssessmentReportIntegrityInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_validate_assessment_report_integrity::ser_validate_assessment_report_integrity_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ValidateAssessmentReportIntegrity::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ValidateAssessmentReportIntegrity",
            "auditmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidateAssessmentReportIntegrityInput {
    /// <p> The relative path of the Amazon S3 bucket that the assessment report is stored in. </p>
    #[doc(hidden)]
    pub s3_relative_path: std::option::Option<std::string::String>,
}
impl ValidateAssessmentReportIntegrityInput {
    /// <p> The relative path of the Amazon S3 bucket that the assessment report is stored in. </p>
    pub fn s3_relative_path(&self) -> std::option::Option<&str> {
        self.s3_relative_path.as_deref()
    }
}
impl ValidateAssessmentReportIntegrityInput {
    /// Creates a new builder-style object to manufacture [`ValidateAssessmentReportIntegrityInput`](crate::input::ValidateAssessmentReportIntegrityInput).
    pub fn builder() -> crate::input::validate_assessment_report_integrity_input::Builder {
        crate::input::validate_assessment_report_integrity_input::Builder::default()
    }
}

/// See [`ValidateAssessmentReportIntegrityInput`](crate::input::ValidateAssessmentReportIntegrityInput).
pub mod validate_assessment_report_integrity_input {

    /// A builder for [`ValidateAssessmentReportIntegrityInput`](crate::input::ValidateAssessmentReportIntegrityInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_relative_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The relative path of the Amazon S3 bucket that the assessment report is stored in. </p>
        pub fn s3_relative_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_relative_path = Some(input.into());
            self
        }
        /// <p> The relative path of the Amazon S3 bucket that the assessment report is stored in. </p>
        pub fn set_s3_relative_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_relative_path = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidateAssessmentReportIntegrityInput`](crate::input::ValidateAssessmentReportIntegrityInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ValidateAssessmentReportIntegrityInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ValidateAssessmentReportIntegrityInput {
                s3_relative_path: self.s3_relative_path,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateSettingsInput {
    /// <p> The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to. </p>
    #[doc(hidden)]
    pub sns_topic: std::option::Option<std::string::String>,
    /// <p> The default storage destination for assessment reports. </p>
    #[doc(hidden)]
    pub default_assessment_reports_destination:
        std::option::Option<crate::model::AssessmentReportsDestination>,
    /// <p> A list of the default audit owners. </p>
    #[doc(hidden)]
    pub default_process_owners: std::option::Option<std::vec::Vec<crate::model::Role>>,
    /// <p> The KMS key details. </p>
    #[doc(hidden)]
    pub kms_key: std::option::Option<std::string::String>,
    /// <p>Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.</p> <important>
    /// <p>When you use this attribute to disable evidence finder, Audit Manager deletes the event data store that’s used to query your evidence data. As a result, you can’t re-enable evidence finder and use the feature again. Your only alternative is to <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html">deregister</a> and then <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html">re-register</a> Audit Manager. </p>
    /// </important>
    #[doc(hidden)]
    pub evidence_finder_enabled: std::option::Option<bool>,
    /// <p>The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.</p>
    #[doc(hidden)]
    pub deregistration_policy: std::option::Option<crate::model::DeregistrationPolicy>,
}
impl UpdateSettingsInput {
    /// <p> The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to. </p>
    pub fn sns_topic(&self) -> std::option::Option<&str> {
        self.sns_topic.as_deref()
    }
    /// <p> The default storage destination for assessment reports. </p>
    pub fn default_assessment_reports_destination(
        &self,
    ) -> std::option::Option<&crate::model::AssessmentReportsDestination> {
        self.default_assessment_reports_destination.as_ref()
    }
    /// <p> A list of the default audit owners. </p>
    pub fn default_process_owners(&self) -> std::option::Option<&[crate::model::Role]> {
        self.default_process_owners.as_deref()
    }
    /// <p> The KMS key details. </p>
    pub fn kms_key(&self) -> std::option::Option<&str> {
        self.kms_key.as_deref()
    }
    /// <p>Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.</p> <important>
    /// <p>When you use this attribute to disable evidence finder, Audit Manager deletes the event data store that’s used to query your evidence data. As a result, you can’t re-enable evidence finder and use the feature again. Your only alternative is to <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html">deregister</a> and then <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html">re-register</a> Audit Manager. </p>
    /// </important>
    pub fn evidence_finder_enabled(&self) -> std::option::Option<bool> {
        self.evidence_finder_enabled
    }
    /// <p>The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.</p>
    pub fn deregistration_policy(
        &self,
    ) -> std::option::Option<&crate::model::DeregistrationPolicy> {
        self.deregistration_policy.as_ref()
    }
}
impl UpdateSettingsInput {
    /// Creates a new builder-style object to manufacture [`UpdateSettingsInput`](crate::input::UpdateSettingsInput).
    pub fn builder() -> crate::input::update_settings_input::Builder {
        crate::input::update_settings_input::Builder::default()
    }
}

/// See [`UpdateSettingsInput`](crate::input::UpdateSettingsInput).
pub mod update_settings_input {

    /// A builder for [`UpdateSettingsInput`](crate::input::UpdateSettingsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sns_topic: std::option::Option<std::string::String>,
        pub(crate) default_assessment_reports_destination:
            std::option::Option<crate::model::AssessmentReportsDestination>,
        pub(crate) default_process_owners: std::option::Option<std::vec::Vec<crate::model::Role>>,
        pub(crate) kms_key: std::option::Option<std::string::String>,
        pub(crate) evidence_finder_enabled: std::option::Option<bool>,
        pub(crate) deregistration_policy: std::option::Option<crate::model::DeregistrationPolicy>,
    }
    impl Builder {
        /// <p> The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to. </p>
        pub fn sns_topic(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic = Some(input.into());
            self
        }
        /// <p> The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to. </p>
        pub fn set_sns_topic(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sns_topic = input;
            self
        }
        /// <p> The default storage destination for assessment reports. </p>
        pub fn default_assessment_reports_destination(
            mut self,
            input: crate::model::AssessmentReportsDestination,
        ) -> Self {
            self.default_assessment_reports_destination = Some(input);
            self
        }
        /// <p> The default storage destination for assessment reports. </p>
        pub fn set_default_assessment_reports_destination(
            mut self,
            input: std::option::Option<crate::model::AssessmentReportsDestination>,
        ) -> Self {
            self.default_assessment_reports_destination = input;
            self
        }
        /// Appends an item to `default_process_owners`.
        ///
        /// To override the contents of this collection use [`set_default_process_owners`](Self::set_default_process_owners).
        ///
        /// <p> A list of the default audit owners. </p>
        pub fn default_process_owners(mut self, input: crate::model::Role) -> Self {
            let mut v = self.default_process_owners.unwrap_or_default();
            v.push(input);
            self.default_process_owners = Some(v);
            self
        }
        /// <p> A list of the default audit owners. </p>
        pub fn set_default_process_owners(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Role>>,
        ) -> Self {
            self.default_process_owners = input;
            self
        }
        /// <p> The KMS key details. </p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key = Some(input.into());
            self
        }
        /// <p> The KMS key details. </p>
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key = input;
            self
        }
        /// <p>Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.</p> <important>
        /// <p>When you use this attribute to disable evidence finder, Audit Manager deletes the event data store that’s used to query your evidence data. As a result, you can’t re-enable evidence finder and use the feature again. Your only alternative is to <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html">deregister</a> and then <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html">re-register</a> Audit Manager. </p>
        /// </important>
        pub fn evidence_finder_enabled(mut self, input: bool) -> Self {
            self.evidence_finder_enabled = Some(input);
            self
        }
        /// <p>Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.</p> <important>
        /// <p>When you use this attribute to disable evidence finder, Audit Manager deletes the event data store that’s used to query your evidence data. As a result, you can’t re-enable evidence finder and use the feature again. Your only alternative is to <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html">deregister</a> and then <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html">re-register</a> Audit Manager. </p>
        /// </important>
        pub fn set_evidence_finder_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.evidence_finder_enabled = input;
            self
        }
        /// <p>The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.</p>
        pub fn deregistration_policy(mut self, input: crate::model::DeregistrationPolicy) -> Self {
            self.deregistration_policy = Some(input);
            self
        }
        /// <p>The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.</p>
        pub fn set_deregistration_policy(
            mut self,
            input: std::option::Option<crate::model::DeregistrationPolicy>,
        ) -> Self {
            self.deregistration_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSettingsInput`](crate::input::UpdateSettingsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateSettingsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateSettingsInput {
                sns_topic: self.sns_topic,
                default_assessment_reports_destination: self.default_assessment_reports_destination,
                default_process_owners: self.default_process_owners,
                kms_key: self.kms_key,
                evidence_finder_enabled: self.evidence_finder_enabled,
                deregistration_policy: self.deregistration_policy,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateControlInput {
    /// <p> The identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The name of the updated control. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The optional description of the control. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The steps that you should follow to determine if the control is met. </p>
    #[doc(hidden)]
    pub testing_information: std::option::Option<std::string::String>,
    /// <p> The title of the action plan for remediating the control. </p>
    #[doc(hidden)]
    pub action_plan_title: std::option::Option<std::string::String>,
    /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
    #[doc(hidden)]
    pub action_plan_instructions: std::option::Option<std::string::String>,
    /// <p> The data mapping sources for the control. </p>
    #[doc(hidden)]
    pub control_mapping_sources:
        std::option::Option<std::vec::Vec<crate::model::ControlMappingSource>>,
}
impl UpdateControlInput {
    /// <p> The identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<&str> {
        self.control_id.as_deref()
    }
    /// <p> The name of the updated control. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The optional description of the control. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The steps that you should follow to determine if the control is met. </p>
    pub fn testing_information(&self) -> std::option::Option<&str> {
        self.testing_information.as_deref()
    }
    /// <p> The title of the action plan for remediating the control. </p>
    pub fn action_plan_title(&self) -> std::option::Option<&str> {
        self.action_plan_title.as_deref()
    }
    /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
    pub fn action_plan_instructions(&self) -> std::option::Option<&str> {
        self.action_plan_instructions.as_deref()
    }
    /// <p> The data mapping sources for the control. </p>
    pub fn control_mapping_sources(
        &self,
    ) -> std::option::Option<&[crate::model::ControlMappingSource]> {
        self.control_mapping_sources.as_deref()
    }
}
impl UpdateControlInput {
    /// Creates a new builder-style object to manufacture [`UpdateControlInput`](crate::input::UpdateControlInput).
    pub fn builder() -> crate::input::update_control_input::Builder {
        crate::input::update_control_input::Builder::default()
    }
}

/// See [`UpdateControlInput`](crate::input::UpdateControlInput).
pub mod update_control_input {

    /// A builder for [`UpdateControlInput`](crate::input::UpdateControlInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) testing_information: std::option::Option<std::string::String>,
        pub(crate) action_plan_title: std::option::Option<std::string::String>,
        pub(crate) action_plan_instructions: std::option::Option<std::string::String>,
        pub(crate) control_mapping_sources:
            std::option::Option<std::vec::Vec<crate::model::ControlMappingSource>>,
    }
    impl Builder {
        /// <p> The identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input;
            self
        }
        /// <p> The name of the updated control. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the updated control. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> The optional description of the control. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The optional description of the control. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The steps that you should follow to determine if the control is met. </p>
        pub fn testing_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.testing_information = Some(input.into());
            self
        }
        /// <p> The steps that you should follow to determine if the control is met. </p>
        pub fn set_testing_information(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.testing_information = input;
            self
        }
        /// <p> The title of the action plan for remediating the control. </p>
        pub fn action_plan_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_plan_title = Some(input.into());
            self
        }
        /// <p> The title of the action plan for remediating the control. </p>
        pub fn set_action_plan_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.action_plan_title = input;
            self
        }
        /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
        pub fn action_plan_instructions(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_plan_instructions = Some(input.into());
            self
        }
        /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
        pub fn set_action_plan_instructions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.action_plan_instructions = input;
            self
        }
        /// Appends an item to `control_mapping_sources`.
        ///
        /// To override the contents of this collection use [`set_control_mapping_sources`](Self::set_control_mapping_sources).
        ///
        /// <p> The data mapping sources for the control. </p>
        pub fn control_mapping_sources(
            mut self,
            input: crate::model::ControlMappingSource,
        ) -> Self {
            let mut v = self.control_mapping_sources.unwrap_or_default();
            v.push(input);
            self.control_mapping_sources = Some(v);
            self
        }
        /// <p> The data mapping sources for the control. </p>
        pub fn set_control_mapping_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ControlMappingSource>>,
        ) -> Self {
            self.control_mapping_sources = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateControlInput`](crate::input::UpdateControlInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateControlInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateControlInput {
                control_id: self.control_id,
                name: self.name,
                description: self.description,
                testing_information: self.testing_information,
                action_plan_title: self.action_plan_title,
                action_plan_instructions: self.action_plan_instructions,
                control_mapping_sources: self.control_mapping_sources,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentStatusInput {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The current status of the assessment. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AssessmentStatus>,
}
impl UpdateAssessmentStatusInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The current status of the assessment. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::AssessmentStatus> {
        self.status.as_ref()
    }
}
impl UpdateAssessmentStatusInput {
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentStatusInput`](crate::input::UpdateAssessmentStatusInput).
    pub fn builder() -> crate::input::update_assessment_status_input::Builder {
        crate::input::update_assessment_status_input::Builder::default()
    }
}

/// See [`UpdateAssessmentStatusInput`](crate::input::UpdateAssessmentStatusInput).
pub mod update_assessment_status_input {

    /// A builder for [`UpdateAssessmentStatusInput`](crate::input::UpdateAssessmentStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AssessmentStatus>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The current status of the assessment. </p>
        pub fn status(mut self, input: crate::model::AssessmentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The current status of the assessment. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AssessmentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentStatusInput`](crate::input::UpdateAssessmentStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAssessmentStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateAssessmentStatusInput {
                assessment_id: self.assessment_id,
                status: self.status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentFrameworkShareInput {
    /// <p> The unique identifier for the share request. </p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the share request is a sent request or a received request.</p>
    #[doc(hidden)]
    pub request_type: std::option::Option<crate::model::ShareRequestType>,
    /// <p>Specifies the update action for the share request.</p>
    #[doc(hidden)]
    pub action: std::option::Option<crate::model::ShareRequestAction>,
}
impl UpdateAssessmentFrameworkShareInput {
    /// <p> The unique identifier for the share request. </p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
    /// <p>Specifies whether the share request is a sent request or a received request.</p>
    pub fn request_type(&self) -> std::option::Option<&crate::model::ShareRequestType> {
        self.request_type.as_ref()
    }
    /// <p>Specifies the update action for the share request.</p>
    pub fn action(&self) -> std::option::Option<&crate::model::ShareRequestAction> {
        self.action.as_ref()
    }
}
impl UpdateAssessmentFrameworkShareInput {
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentFrameworkShareInput`](crate::input::UpdateAssessmentFrameworkShareInput).
    pub fn builder() -> crate::input::update_assessment_framework_share_input::Builder {
        crate::input::update_assessment_framework_share_input::Builder::default()
    }
}

/// See [`UpdateAssessmentFrameworkShareInput`](crate::input::UpdateAssessmentFrameworkShareInput).
pub mod update_assessment_framework_share_input {

    /// A builder for [`UpdateAssessmentFrameworkShareInput`](crate::input::UpdateAssessmentFrameworkShareInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) request_type: std::option::Option<crate::model::ShareRequestType>,
        pub(crate) action: std::option::Option<crate::model::ShareRequestAction>,
    }
    impl Builder {
        /// <p> The unique identifier for the share request. </p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the share request. </p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// <p>Specifies whether the share request is a sent request or a received request.</p>
        pub fn request_type(mut self, input: crate::model::ShareRequestType) -> Self {
            self.request_type = Some(input);
            self
        }
        /// <p>Specifies whether the share request is a sent request or a received request.</p>
        pub fn set_request_type(
            mut self,
            input: std::option::Option<crate::model::ShareRequestType>,
        ) -> Self {
            self.request_type = input;
            self
        }
        /// <p>Specifies the update action for the share request.</p>
        pub fn action(mut self, input: crate::model::ShareRequestAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>Specifies the update action for the share request.</p>
        pub fn set_action(
            mut self,
            input: std::option::Option<crate::model::ShareRequestAction>,
        ) -> Self {
            self.action = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentFrameworkShareInput`](crate::input::UpdateAssessmentFrameworkShareInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAssessmentFrameworkShareInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateAssessmentFrameworkShareInput {
                request_id: self.request_id,
                request_type: self.request_type,
                action: self.action,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentFrameworkInput {
    /// <p> The unique identifier for the framework. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
    /// <p> The name of the framework to be updated. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The description of the updated framework. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<std::string::String>,
    /// <p> The control sets that are associated with the framework. </p>
    #[doc(hidden)]
    pub control_sets:
        std::option::Option<std::vec::Vec<crate::model::UpdateAssessmentFrameworkControlSet>>,
}
impl UpdateAssessmentFrameworkInput {
    /// <p> The unique identifier for the framework. </p>
    pub fn framework_id(&self) -> std::option::Option<&str> {
        self.framework_id.as_deref()
    }
    /// <p> The name of the framework to be updated. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The description of the updated framework. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
    pub fn compliance_type(&self) -> std::option::Option<&str> {
        self.compliance_type.as_deref()
    }
    /// <p> The control sets that are associated with the framework. </p>
    pub fn control_sets(
        &self,
    ) -> std::option::Option<&[crate::model::UpdateAssessmentFrameworkControlSet]> {
        self.control_sets.as_deref()
    }
}
impl UpdateAssessmentFrameworkInput {
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentFrameworkInput`](crate::input::UpdateAssessmentFrameworkInput).
    pub fn builder() -> crate::input::update_assessment_framework_input::Builder {
        crate::input::update_assessment_framework_input::Builder::default()
    }
}

/// See [`UpdateAssessmentFrameworkInput`](crate::input::UpdateAssessmentFrameworkInput).
pub mod update_assessment_framework_input {

    /// A builder for [`UpdateAssessmentFrameworkInput`](crate::input::UpdateAssessmentFrameworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) compliance_type: std::option::Option<std::string::String>,
        pub(crate) control_sets:
            std::option::Option<std::vec::Vec<crate::model::UpdateAssessmentFrameworkControlSet>>,
    }
    impl Builder {
        /// <p> The unique identifier for the framework. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the framework. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input;
            self
        }
        /// <p> The name of the framework to be updated. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the framework to be updated. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> The description of the updated framework. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The description of the updated framework. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
        pub fn compliance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_type = Some(input.into());
            self
        }
        /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// Appends an item to `control_sets`.
        ///
        /// To override the contents of this collection use [`set_control_sets`](Self::set_control_sets).
        ///
        /// <p> The control sets that are associated with the framework. </p>
        pub fn control_sets(
            mut self,
            input: crate::model::UpdateAssessmentFrameworkControlSet,
        ) -> Self {
            let mut v = self.control_sets.unwrap_or_default();
            v.push(input);
            self.control_sets = Some(v);
            self
        }
        /// <p> The control sets that are associated with the framework. </p>
        pub fn set_control_sets(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::UpdateAssessmentFrameworkControlSet>,
            >,
        ) -> Self {
            self.control_sets = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentFrameworkInput`](crate::input::UpdateAssessmentFrameworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAssessmentFrameworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateAssessmentFrameworkInput {
                framework_id: self.framework_id,
                name: self.name,
                description: self.description,
                compliance_type: self.compliance_type,
                control_sets: self.control_sets,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentControlSetStatusInput {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The status of the control set that's being updated. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ControlSetStatus>,
    /// <p> The comment that's related to the status update. </p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
}
impl UpdateAssessmentControlSetStatusInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<&str> {
        self.control_set_id.as_deref()
    }
    /// <p> The status of the control set that's being updated. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::ControlSetStatus> {
        self.status.as_ref()
    }
    /// <p> The comment that's related to the status update. </p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
}
impl UpdateAssessmentControlSetStatusInput {
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentControlSetStatusInput`](crate::input::UpdateAssessmentControlSetStatusInput).
    pub fn builder() -> crate::input::update_assessment_control_set_status_input::Builder {
        crate::input::update_assessment_control_set_status_input::Builder::default()
    }
}

/// See [`UpdateAssessmentControlSetStatusInput`](crate::input::UpdateAssessmentControlSetStatusInput).
pub mod update_assessment_control_set_status_input {

    /// A builder for [`UpdateAssessmentControlSetStatusInput`](crate::input::UpdateAssessmentControlSetStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ControlSetStatus>,
        pub(crate) comment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_set_id = input;
            self
        }
        /// <p> The status of the control set that's being updated. </p>
        pub fn status(mut self, input: crate::model::ControlSetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The status of the control set that's being updated. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ControlSetStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> The comment that's related to the status update. </p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p> The comment that's related to the status update. </p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentControlSetStatusInput`](crate::input::UpdateAssessmentControlSetStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAssessmentControlSetStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateAssessmentControlSetStatusInput {
                assessment_id: self.assessment_id,
                control_set_id: self.control_set_id,
                status: self.status,
                comment: self.comment,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentControlInput {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The status of the control. </p>
    #[doc(hidden)]
    pub control_status: std::option::Option<crate::model::ControlStatus>,
    /// <p> The comment body text for the control. </p>
    #[doc(hidden)]
    pub comment_body: std::option::Option<std::string::String>,
}
impl UpdateAssessmentControlInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<&str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<&str> {
        self.control_id.as_deref()
    }
    /// <p> The status of the control. </p>
    pub fn control_status(&self) -> std::option::Option<&crate::model::ControlStatus> {
        self.control_status.as_ref()
    }
    /// <p> The comment body text for the control. </p>
    pub fn comment_body(&self) -> std::option::Option<&str> {
        self.comment_body.as_deref()
    }
}
impl UpdateAssessmentControlInput {
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentControlInput`](crate::input::UpdateAssessmentControlInput).
    pub fn builder() -> crate::input::update_assessment_control_input::Builder {
        crate::input::update_assessment_control_input::Builder::default()
    }
}

/// See [`UpdateAssessmentControlInput`](crate::input::UpdateAssessmentControlInput).
pub mod update_assessment_control_input {

    /// A builder for [`UpdateAssessmentControlInput`](crate::input::UpdateAssessmentControlInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) control_status: std::option::Option<crate::model::ControlStatus>,
        pub(crate) comment_body: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_set_id = input;
            self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input;
            self
        }
        /// <p> The status of the control. </p>
        pub fn control_status(mut self, input: crate::model::ControlStatus) -> Self {
            self.control_status = Some(input);
            self
        }
        /// <p> The status of the control. </p>
        pub fn set_control_status(
            mut self,
            input: std::option::Option<crate::model::ControlStatus>,
        ) -> Self {
            self.control_status = input;
            self
        }
        /// <p> The comment body text for the control. </p>
        pub fn comment_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment_body = Some(input.into());
            self
        }
        /// <p> The comment body text for the control. </p>
        pub fn set_comment_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment_body = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentControlInput`](crate::input::UpdateAssessmentControlInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAssessmentControlInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateAssessmentControlInput {
                assessment_id: self.assessment_id,
                control_set_id: self.control_set_id,
                control_id: self.control_id,
                control_status: self.control_status,
                comment_body: self.comment_body,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentInput {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The name of the assessment to be updated. </p>
    #[doc(hidden)]
    pub assessment_name: std::option::Option<std::string::String>,
    /// <p> The description of the assessment. </p>
    #[doc(hidden)]
    pub assessment_description: std::option::Option<std::string::String>,
    /// <p> The scope of the assessment. </p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p> The assessment report storage destination for the assessment that's being updated. </p>
    #[doc(hidden)]
    pub assessment_reports_destination:
        std::option::Option<crate::model::AssessmentReportsDestination>,
    /// <p> The list of roles for the assessment. </p>
    #[doc(hidden)]
    pub roles: std::option::Option<std::vec::Vec<crate::model::Role>>,
}
impl UpdateAssessmentInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The name of the assessment to be updated. </p>
    pub fn assessment_name(&self) -> std::option::Option<&str> {
        self.assessment_name.as_deref()
    }
    /// <p> The description of the assessment. </p>
    pub fn assessment_description(&self) -> std::option::Option<&str> {
        self.assessment_description.as_deref()
    }
    /// <p> The scope of the assessment. </p>
    pub fn scope(&self) -> std::option::Option<&crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p> The assessment report storage destination for the assessment that's being updated. </p>
    pub fn assessment_reports_destination(
        &self,
    ) -> std::option::Option<&crate::model::AssessmentReportsDestination> {
        self.assessment_reports_destination.as_ref()
    }
    /// <p> The list of roles for the assessment. </p>
    pub fn roles(&self) -> std::option::Option<&[crate::model::Role]> {
        self.roles.as_deref()
    }
}
impl UpdateAssessmentInput {
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentInput`](crate::input::UpdateAssessmentInput).
    pub fn builder() -> crate::input::update_assessment_input::Builder {
        crate::input::update_assessment_input::Builder::default()
    }
}

/// See [`UpdateAssessmentInput`](crate::input::UpdateAssessmentInput).
pub mod update_assessment_input {

    /// A builder for [`UpdateAssessmentInput`](crate::input::UpdateAssessmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) assessment_name: std::option::Option<std::string::String>,
        pub(crate) assessment_description: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) assessment_reports_destination:
            std::option::Option<crate::model::AssessmentReportsDestination>,
        pub(crate) roles: std::option::Option<std::vec::Vec<crate::model::Role>>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The name of the assessment to be updated. </p>
        pub fn assessment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_name = Some(input.into());
            self
        }
        /// <p> The name of the assessment to be updated. </p>
        pub fn set_assessment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_name = input;
            self
        }
        /// <p> The description of the assessment. </p>
        pub fn assessment_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_description = Some(input.into());
            self
        }
        /// <p> The description of the assessment. </p>
        pub fn set_assessment_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_description = input;
            self
        }
        /// <p> The scope of the assessment. </p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p> The scope of the assessment. </p>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// <p> The assessment report storage destination for the assessment that's being updated. </p>
        pub fn assessment_reports_destination(
            mut self,
            input: crate::model::AssessmentReportsDestination,
        ) -> Self {
            self.assessment_reports_destination = Some(input);
            self
        }
        /// <p> The assessment report storage destination for the assessment that's being updated. </p>
        pub fn set_assessment_reports_destination(
            mut self,
            input: std::option::Option<crate::model::AssessmentReportsDestination>,
        ) -> Self {
            self.assessment_reports_destination = input;
            self
        }
        /// Appends an item to `roles`.
        ///
        /// To override the contents of this collection use [`set_roles`](Self::set_roles).
        ///
        /// <p> The list of roles for the assessment. </p>
        pub fn roles(mut self, input: crate::model::Role) -> Self {
            let mut v = self.roles.unwrap_or_default();
            v.push(input);
            self.roles = Some(v);
            self
        }
        /// <p> The list of roles for the assessment. </p>
        pub fn set_roles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Role>>,
        ) -> Self {
            self.roles = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentInput`](crate::input::UpdateAssessmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAssessmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateAssessmentInput {
                assessment_id: self.assessment_id,
                assessment_name: self.assessment_name,
                assessment_description: self.assessment_description,
                scope: self.scope,
                assessment_reports_destination: self.assessment_reports_destination,
                roles: self.roles,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput {
    /// <p> The Amazon Resource Name (ARN) of the specified resource. </p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p> The name or key of the tag. </p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p> The Amazon Resource Name (ARN) of the specified resource. </p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p> The name or key of the tag. </p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl UntagResourceInput {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the specified resource. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the specified resource. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p> The name or key of the tag. </p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p> The name or key of the tag. </p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput {
    /// <p> The Amazon Resource Name (ARN) of the resource. </p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p> The tags that are associated with the resource. </p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TagResourceInput {
    /// <p> The Amazon Resource Name (ARN) of the resource. </p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p> The tags that are associated with the resource. </p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl TagResourceInput {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the resource. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the resource. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> The tags that are associated with the resource. </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p> The tags that are associated with the resource. </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartAssessmentFrameworkShareInput {
    /// <p> The unique identifier for the custom framework to be shared. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
    /// <p> The Amazon Web Services account of the recipient. </p>
    #[doc(hidden)]
    pub destination_account: std::option::Option<std::string::String>,
    /// <p> The Amazon Web Services Region of the recipient. </p>
    #[doc(hidden)]
    pub destination_region: std::option::Option<std::string::String>,
    /// <p> An optional comment from the sender about the share request. </p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
}
impl StartAssessmentFrameworkShareInput {
    /// <p> The unique identifier for the custom framework to be shared. </p>
    pub fn framework_id(&self) -> std::option::Option<&str> {
        self.framework_id.as_deref()
    }
    /// <p> The Amazon Web Services account of the recipient. </p>
    pub fn destination_account(&self) -> std::option::Option<&str> {
        self.destination_account.as_deref()
    }
    /// <p> The Amazon Web Services Region of the recipient. </p>
    pub fn destination_region(&self) -> std::option::Option<&str> {
        self.destination_region.as_deref()
    }
    /// <p> An optional comment from the sender about the share request. </p>
    pub fn comment(&self) -> std::option::Option<&str> {
        self.comment.as_deref()
    }
}
impl StartAssessmentFrameworkShareInput {
    /// Creates a new builder-style object to manufacture [`StartAssessmentFrameworkShareInput`](crate::input::StartAssessmentFrameworkShareInput).
    pub fn builder() -> crate::input::start_assessment_framework_share_input::Builder {
        crate::input::start_assessment_framework_share_input::Builder::default()
    }
}

/// See [`StartAssessmentFrameworkShareInput`](crate::input::StartAssessmentFrameworkShareInput).
pub mod start_assessment_framework_share_input {

    /// A builder for [`StartAssessmentFrameworkShareInput`](crate::input::StartAssessmentFrameworkShareInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_id: std::option::Option<std::string::String>,
        pub(crate) destination_account: std::option::Option<std::string::String>,
        pub(crate) destination_region: std::option::Option<std::string::String>,
        pub(crate) comment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the custom framework to be shared. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the custom framework to be shared. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input;
            self
        }
        /// <p> The Amazon Web Services account of the recipient. </p>
        pub fn destination_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_account = Some(input.into());
            self
        }
        /// <p> The Amazon Web Services account of the recipient. </p>
        pub fn set_destination_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_account = input;
            self
        }
        /// <p> The Amazon Web Services Region of the recipient. </p>
        pub fn destination_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_region = Some(input.into());
            self
        }
        /// <p> The Amazon Web Services Region of the recipient. </p>
        pub fn set_destination_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_region = input;
            self
        }
        /// <p> An optional comment from the sender about the share request. </p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p> An optional comment from the sender about the share request. </p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input;
            self
        }
        /// Consumes the builder and constructs a [`StartAssessmentFrameworkShareInput`](crate::input::StartAssessmentFrameworkShareInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartAssessmentFrameworkShareInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartAssessmentFrameworkShareInput {
                framework_id: self.framework_id,
                destination_account: self.destination_account,
                destination_region: self.destination_region,
                comment: self.comment,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterOrganizationAdminAccountInput {
    /// <p> The identifier for the delegated administrator account. </p>
    #[doc(hidden)]
    pub admin_account_id: std::option::Option<std::string::String>,
}
impl RegisterOrganizationAdminAccountInput {
    /// <p> The identifier for the delegated administrator account. </p>
    pub fn admin_account_id(&self) -> std::option::Option<&str> {
        self.admin_account_id.as_deref()
    }
}
impl RegisterOrganizationAdminAccountInput {
    /// Creates a new builder-style object to manufacture [`RegisterOrganizationAdminAccountInput`](crate::input::RegisterOrganizationAdminAccountInput).
    pub fn builder() -> crate::input::register_organization_admin_account_input::Builder {
        crate::input::register_organization_admin_account_input::Builder::default()
    }
}

/// See [`RegisterOrganizationAdminAccountInput`](crate::input::RegisterOrganizationAdminAccountInput).
pub mod register_organization_admin_account_input {

    /// A builder for [`RegisterOrganizationAdminAccountInput`](crate::input::RegisterOrganizationAdminAccountInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) admin_account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the delegated administrator account. </p>
        pub fn admin_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_account_id = Some(input.into());
            self
        }
        /// <p> The identifier for the delegated administrator account. </p>
        pub fn set_admin_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.admin_account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterOrganizationAdminAccountInput`](crate::input::RegisterOrganizationAdminAccountInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::RegisterOrganizationAdminAccountInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::RegisterOrganizationAdminAccountInput {
                admin_account_id: self.admin_account_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterAccountInput {
    /// <p> The KMS key details. </p>
    #[doc(hidden)]
    pub kms_key: std::option::Option<std::string::String>,
    /// <p> The delegated administrator account for Audit Manager. </p>
    #[doc(hidden)]
    pub delegated_admin_account: std::option::Option<std::string::String>,
}
impl RegisterAccountInput {
    /// <p> The KMS key details. </p>
    pub fn kms_key(&self) -> std::option::Option<&str> {
        self.kms_key.as_deref()
    }
    /// <p> The delegated administrator account for Audit Manager. </p>
    pub fn delegated_admin_account(&self) -> std::option::Option<&str> {
        self.delegated_admin_account.as_deref()
    }
}
impl RegisterAccountInput {
    /// Creates a new builder-style object to manufacture [`RegisterAccountInput`](crate::input::RegisterAccountInput).
    pub fn builder() -> crate::input::register_account_input::Builder {
        crate::input::register_account_input::Builder::default()
    }
}

/// See [`RegisterAccountInput`](crate::input::RegisterAccountInput).
pub mod register_account_input {

    /// A builder for [`RegisterAccountInput`](crate::input::RegisterAccountInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key: std::option::Option<std::string::String>,
        pub(crate) delegated_admin_account: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The KMS key details. </p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key = Some(input.into());
            self
        }
        /// <p> The KMS key details. </p>
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key = input;
            self
        }
        /// <p> The delegated administrator account for Audit Manager. </p>
        pub fn delegated_admin_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.delegated_admin_account = Some(input.into());
            self
        }
        /// <p> The delegated administrator account for Audit Manager. </p>
        pub fn set_delegated_admin_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.delegated_admin_account = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterAccountInput`](crate::input::RegisterAccountInput).
        pub fn build(
            self,
        ) -> Result<crate::input::RegisterAccountInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::RegisterAccountInput {
                kms_key: self.kms_key,
                delegated_admin_account: self.delegated_admin_account,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput {
    /// <p> The Amazon Resource Name (ARN) of the resource. </p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p> The Amazon Resource Name (ARN) of the resource. </p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl ListTagsForResourceInput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the resource. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the resource. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListNotificationsInput {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListNotificationsInput {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListNotificationsInput {
    /// Creates a new builder-style object to manufacture [`ListNotificationsInput`](crate::input::ListNotificationsInput).
    pub fn builder() -> crate::input::list_notifications_input::Builder {
        crate::input::list_notifications_input::Builder::default()
    }
}

/// See [`ListNotificationsInput`](crate::input::ListNotificationsInput).
pub mod list_notifications_input {

    /// A builder for [`ListNotificationsInput`](crate::input::ListNotificationsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListNotificationsInput`](crate::input::ListNotificationsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListNotificationsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListNotificationsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListKeywordsForDataSourceInput {
    /// <p> The control mapping data source that the keywords apply to. </p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::SourceType>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListKeywordsForDataSourceInput {
    /// <p> The control mapping data source that the keywords apply to. </p>
    pub fn source(&self) -> std::option::Option<&crate::model::SourceType> {
        self.source.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListKeywordsForDataSourceInput {
    /// Creates a new builder-style object to manufacture [`ListKeywordsForDataSourceInput`](crate::input::ListKeywordsForDataSourceInput).
    pub fn builder() -> crate::input::list_keywords_for_data_source_input::Builder {
        crate::input::list_keywords_for_data_source_input::Builder::default()
    }
}

/// See [`ListKeywordsForDataSourceInput`](crate::input::ListKeywordsForDataSourceInput).
pub mod list_keywords_for_data_source_input {

    /// A builder for [`ListKeywordsForDataSourceInput`](crate::input::ListKeywordsForDataSourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<crate::model::SourceType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The control mapping data source that the keywords apply to. </p>
        pub fn source(mut self, input: crate::model::SourceType) -> Self {
            self.source = Some(input);
            self
        }
        /// <p> The control mapping data source that the keywords apply to. </p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::SourceType>) -> Self {
            self.source = input;
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListKeywordsForDataSourceInput`](crate::input::ListKeywordsForDataSourceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListKeywordsForDataSourceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListKeywordsForDataSourceInput {
                source: self.source,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlsInput {
    /// <p> The type of control, such as a standard control or a custom control. </p>
    #[doc(hidden)]
    pub control_type: std::option::Option<crate::model::ControlType>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListControlsInput {
    /// <p> The type of control, such as a standard control or a custom control. </p>
    pub fn control_type(&self) -> std::option::Option<&crate::model::ControlType> {
        self.control_type.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListControlsInput {
    /// Creates a new builder-style object to manufacture [`ListControlsInput`](crate::input::ListControlsInput).
    pub fn builder() -> crate::input::list_controls_input::Builder {
        crate::input::list_controls_input::Builder::default()
    }
}

/// See [`ListControlsInput`](crate::input::ListControlsInput).
pub mod list_controls_input {

    /// A builder for [`ListControlsInput`](crate::input::ListControlsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_type: std::option::Option<crate::model::ControlType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The type of control, such as a standard control or a custom control. </p>
        pub fn control_type(mut self, input: crate::model::ControlType) -> Self {
            self.control_type = Some(input);
            self
        }
        /// <p> The type of control, such as a standard control or a custom control. </p>
        pub fn set_control_type(
            mut self,
            input: std::option::Option<crate::model::ControlType>,
        ) -> Self {
            self.control_type = input;
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListControlsInput`](crate::input::ListControlsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListControlsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListControlsInput {
                control_type: self.control_type,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlInsightsByControlDomainInput {
    /// <p>The unique identifier for the control domain. </p>
    #[doc(hidden)]
    pub control_domain_id: std::option::Option<std::string::String>,
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListControlInsightsByControlDomainInput {
    /// <p>The unique identifier for the control domain. </p>
    pub fn control_domain_id(&self) -> std::option::Option<&str> {
        self.control_domain_id.as_deref()
    }
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListControlInsightsByControlDomainInput {
    /// Creates a new builder-style object to manufacture [`ListControlInsightsByControlDomainInput`](crate::input::ListControlInsightsByControlDomainInput).
    pub fn builder() -> crate::input::list_control_insights_by_control_domain_input::Builder {
        crate::input::list_control_insights_by_control_domain_input::Builder::default()
    }
}

/// See [`ListControlInsightsByControlDomainInput`](crate::input::ListControlInsightsByControlDomainInput).
pub mod list_control_insights_by_control_domain_input {

    /// A builder for [`ListControlInsightsByControlDomainInput`](crate::input::ListControlInsightsByControlDomainInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_domain_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the control domain. </p>
        pub fn control_domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the control domain. </p>
        pub fn set_control_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_domain_id = input;
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListControlInsightsByControlDomainInput`](crate::input::ListControlInsightsByControlDomainInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListControlInsightsByControlDomainInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListControlInsightsByControlDomainInput {
                control_domain_id: self.control_domain_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlDomainInsightsByAssessmentInput {
    /// <p>The unique identifier for the active assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListControlDomainInsightsByAssessmentInput {
    /// <p>The unique identifier for the active assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListControlDomainInsightsByAssessmentInput {
    /// Creates a new builder-style object to manufacture [`ListControlDomainInsightsByAssessmentInput`](crate::input::ListControlDomainInsightsByAssessmentInput).
    pub fn builder() -> crate::input::list_control_domain_insights_by_assessment_input::Builder {
        crate::input::list_control_domain_insights_by_assessment_input::Builder::default()
    }
}

/// See [`ListControlDomainInsightsByAssessmentInput`](crate::input::ListControlDomainInsightsByAssessmentInput).
pub mod list_control_domain_insights_by_assessment_input {

    /// A builder for [`ListControlDomainInsightsByAssessmentInput`](crate::input::ListControlDomainInsightsByAssessmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the active assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the active assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListControlDomainInsightsByAssessmentInput`](crate::input::ListControlDomainInsightsByAssessmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListControlDomainInsightsByAssessmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListControlDomainInsightsByAssessmentInput {
                assessment_id: self.assessment_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlDomainInsightsInput {
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListControlDomainInsightsInput {
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListControlDomainInsightsInput {
    /// Creates a new builder-style object to manufacture [`ListControlDomainInsightsInput`](crate::input::ListControlDomainInsightsInput).
    pub fn builder() -> crate::input::list_control_domain_insights_input::Builder {
        crate::input::list_control_domain_insights_input::Builder::default()
    }
}

/// See [`ListControlDomainInsightsInput`](crate::input::ListControlDomainInsightsInput).
pub mod list_control_domain_insights_input {

    /// A builder for [`ListControlDomainInsightsInput`](crate::input::ListControlDomainInsightsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListControlDomainInsightsInput`](crate::input::ListControlDomainInsightsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListControlDomainInsightsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListControlDomainInsightsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentsInput {
    /// <p> The current status of the assessment.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AssessmentStatus>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentsInput {
    /// <p> The current status of the assessment.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AssessmentStatus> {
        self.status.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListAssessmentsInput {
    /// Creates a new builder-style object to manufacture [`ListAssessmentsInput`](crate::input::ListAssessmentsInput).
    pub fn builder() -> crate::input::list_assessments_input::Builder {
        crate::input::list_assessments_input::Builder::default()
    }
}

/// See [`ListAssessmentsInput`](crate::input::ListAssessmentsInput).
pub mod list_assessments_input {

    /// A builder for [`ListAssessmentsInput`](crate::input::ListAssessmentsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::AssessmentStatus>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The current status of the assessment.</p>
        pub fn status(mut self, input: crate::model::AssessmentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The current status of the assessment.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AssessmentStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAssessmentsInput`](crate::input::ListAssessmentsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListAssessmentsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListAssessmentsInput {
                status: self.status,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentReportsInput {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentReportsInput {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListAssessmentReportsInput {
    /// Creates a new builder-style object to manufacture [`ListAssessmentReportsInput`](crate::input::ListAssessmentReportsInput).
    pub fn builder() -> crate::input::list_assessment_reports_input::Builder {
        crate::input::list_assessment_reports_input::Builder::default()
    }
}

/// See [`ListAssessmentReportsInput`](crate::input::ListAssessmentReportsInput).
pub mod list_assessment_reports_input {

    /// A builder for [`ListAssessmentReportsInput`](crate::input::ListAssessmentReportsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAssessmentReportsInput`](crate::input::ListAssessmentReportsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListAssessmentReportsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListAssessmentReportsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentFrameworkShareRequestsInput {
    /// <p> Specifies whether the share request is a sent request or a received request.</p>
    #[doc(hidden)]
    pub request_type: std::option::Option<crate::model::ShareRequestType>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentFrameworkShareRequestsInput {
    /// <p> Specifies whether the share request is a sent request or a received request.</p>
    pub fn request_type(&self) -> std::option::Option<&crate::model::ShareRequestType> {
        self.request_type.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListAssessmentFrameworkShareRequestsInput {
    /// Creates a new builder-style object to manufacture [`ListAssessmentFrameworkShareRequestsInput`](crate::input::ListAssessmentFrameworkShareRequestsInput).
    pub fn builder() -> crate::input::list_assessment_framework_share_requests_input::Builder {
        crate::input::list_assessment_framework_share_requests_input::Builder::default()
    }
}

/// See [`ListAssessmentFrameworkShareRequestsInput`](crate::input::ListAssessmentFrameworkShareRequestsInput).
pub mod list_assessment_framework_share_requests_input {

    /// A builder for [`ListAssessmentFrameworkShareRequestsInput`](crate::input::ListAssessmentFrameworkShareRequestsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request_type: std::option::Option<crate::model::ShareRequestType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> Specifies whether the share request is a sent request or a received request.</p>
        pub fn request_type(mut self, input: crate::model::ShareRequestType) -> Self {
            self.request_type = Some(input);
            self
        }
        /// <p> Specifies whether the share request is a sent request or a received request.</p>
        pub fn set_request_type(
            mut self,
            input: std::option::Option<crate::model::ShareRequestType>,
        ) -> Self {
            self.request_type = input;
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAssessmentFrameworkShareRequestsInput`](crate::input::ListAssessmentFrameworkShareRequestsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListAssessmentFrameworkShareRequestsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListAssessmentFrameworkShareRequestsInput {
                request_type: self.request_type,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentFrameworksInput {
    /// <p> The type of framework, such as a standard framework or a custom framework. </p>
    #[doc(hidden)]
    pub framework_type: std::option::Option<crate::model::FrameworkType>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentFrameworksInput {
    /// <p> The type of framework, such as a standard framework or a custom framework. </p>
    pub fn framework_type(&self) -> std::option::Option<&crate::model::FrameworkType> {
        self.framework_type.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListAssessmentFrameworksInput {
    /// Creates a new builder-style object to manufacture [`ListAssessmentFrameworksInput`](crate::input::ListAssessmentFrameworksInput).
    pub fn builder() -> crate::input::list_assessment_frameworks_input::Builder {
        crate::input::list_assessment_frameworks_input::Builder::default()
    }
}

/// See [`ListAssessmentFrameworksInput`](crate::input::ListAssessmentFrameworksInput).
pub mod list_assessment_frameworks_input {

    /// A builder for [`ListAssessmentFrameworksInput`](crate::input::ListAssessmentFrameworksInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_type: std::option::Option<crate::model::FrameworkType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The type of framework, such as a standard framework or a custom framework. </p>
        pub fn framework_type(mut self, input: crate::model::FrameworkType) -> Self {
            self.framework_type = Some(input);
            self
        }
        /// <p> The type of framework, such as a standard framework or a custom framework. </p>
        pub fn set_framework_type(
            mut self,
            input: std::option::Option<crate::model::FrameworkType>,
        ) -> Self {
            self.framework_type = input;
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAssessmentFrameworksInput`](crate::input::ListAssessmentFrameworksInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListAssessmentFrameworksInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListAssessmentFrameworksInput {
                framework_type: self.framework_type,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentControlInsightsByControlDomainInput {
    /// <p>The unique identifier for the control domain. </p>
    #[doc(hidden)]
    pub control_domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the active assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentControlInsightsByControlDomainInput {
    /// <p>The unique identifier for the control domain. </p>
    pub fn control_domain_id(&self) -> std::option::Option<&str> {
        self.control_domain_id.as_deref()
    }
    /// <p>The unique identifier for the active assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListAssessmentControlInsightsByControlDomainInput {
    /// Creates a new builder-style object to manufacture [`ListAssessmentControlInsightsByControlDomainInput`](crate::input::ListAssessmentControlInsightsByControlDomainInput).
    pub fn builder(
    ) -> crate::input::list_assessment_control_insights_by_control_domain_input::Builder {
        crate::input::list_assessment_control_insights_by_control_domain_input::Builder::default()
    }
}

/// See [`ListAssessmentControlInsightsByControlDomainInput`](crate::input::ListAssessmentControlInsightsByControlDomainInput).
pub mod list_assessment_control_insights_by_control_domain_input {

    /// A builder for [`ListAssessmentControlInsightsByControlDomainInput`](crate::input::ListAssessmentControlInsightsByControlDomainInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_domain_id: std::option::Option<std::string::String>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the control domain. </p>
        pub fn control_domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the control domain. </p>
        pub fn set_control_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_domain_id = input;
            self
        }
        /// <p>The unique identifier for the active assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the active assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAssessmentControlInsightsByControlDomainInput`](crate::input::ListAssessmentControlInsightsByControlDomainInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListAssessmentControlInsightsByControlDomainInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(
                crate::input::ListAssessmentControlInsightsByControlDomainInput {
                    control_domain_id: self.control_domain_id,
                    assessment_id: self.assessment_id,
                    next_token: self.next_token,
                    max_results: self.max_results,
                },
            )
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSettingsInput {
    /// <p> The list of setting attribute enum values. </p>
    #[doc(hidden)]
    pub attribute: std::option::Option<crate::model::SettingAttribute>,
}
impl GetSettingsInput {
    /// <p> The list of setting attribute enum values. </p>
    pub fn attribute(&self) -> std::option::Option<&crate::model::SettingAttribute> {
        self.attribute.as_ref()
    }
}
impl GetSettingsInput {
    /// Creates a new builder-style object to manufacture [`GetSettingsInput`](crate::input::GetSettingsInput).
    pub fn builder() -> crate::input::get_settings_input::Builder {
        crate::input::get_settings_input::Builder::default()
    }
}

/// See [`GetSettingsInput`](crate::input::GetSettingsInput).
pub mod get_settings_input {

    /// A builder for [`GetSettingsInput`](crate::input::GetSettingsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute: std::option::Option<crate::model::SettingAttribute>,
    }
    impl Builder {
        /// <p> The list of setting attribute enum values. </p>
        pub fn attribute(mut self, input: crate::model::SettingAttribute) -> Self {
            self.attribute = Some(input);
            self
        }
        /// <p> The list of setting attribute enum values. </p>
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::SettingAttribute>,
        ) -> Self {
            self.attribute = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSettingsInput`](crate::input::GetSettingsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetSettingsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetSettingsInput {
                attribute: self.attribute,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetServicesInScopeInput {}
impl GetServicesInScopeInput {
    /// Creates a new builder-style object to manufacture [`GetServicesInScopeInput`](crate::input::GetServicesInScopeInput).
    pub fn builder() -> crate::input::get_services_in_scope_input::Builder {
        crate::input::get_services_in_scope_input::Builder::default()
    }
}

/// See [`GetServicesInScopeInput`](crate::input::GetServicesInScopeInput).
pub mod get_services_in_scope_input {

    /// A builder for [`GetServicesInScopeInput`](crate::input::GetServicesInScopeInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetServicesInScopeInput`](crate::input::GetServicesInScopeInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetServicesInScopeInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetServicesInScopeInput {})
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetOrganizationAdminAccountInput {}
impl GetOrganizationAdminAccountInput {
    /// Creates a new builder-style object to manufacture [`GetOrganizationAdminAccountInput`](crate::input::GetOrganizationAdminAccountInput).
    pub fn builder() -> crate::input::get_organization_admin_account_input::Builder {
        crate::input::get_organization_admin_account_input::Builder::default()
    }
}

/// See [`GetOrganizationAdminAccountInput`](crate::input::GetOrganizationAdminAccountInput).
pub mod get_organization_admin_account_input {

    /// A builder for [`GetOrganizationAdminAccountInput`](crate::input::GetOrganizationAdminAccountInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetOrganizationAdminAccountInput`](crate::input::GetOrganizationAdminAccountInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetOrganizationAdminAccountInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetOrganizationAdminAccountInput {})
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetInsightsByAssessmentInput {
    /// <p>The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl GetInsightsByAssessmentInput {
    /// <p>The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
}
impl GetInsightsByAssessmentInput {
    /// Creates a new builder-style object to manufacture [`GetInsightsByAssessmentInput`](crate::input::GetInsightsByAssessmentInput).
    pub fn builder() -> crate::input::get_insights_by_assessment_input::Builder {
        crate::input::get_insights_by_assessment_input::Builder::default()
    }
}

/// See [`GetInsightsByAssessmentInput`](crate::input::GetInsightsByAssessmentInput).
pub mod get_insights_by_assessment_input {

    /// A builder for [`GetInsightsByAssessmentInput`](crate::input::GetInsightsByAssessmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInsightsByAssessmentInput`](crate::input::GetInsightsByAssessmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetInsightsByAssessmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetInsightsByAssessmentInput {
                assessment_id: self.assessment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetInsightsInput {}
impl GetInsightsInput {
    /// Creates a new builder-style object to manufacture [`GetInsightsInput`](crate::input::GetInsightsInput).
    pub fn builder() -> crate::input::get_insights_input::Builder {
        crate::input::get_insights_input::Builder::default()
    }
}

/// See [`GetInsightsInput`](crate::input::GetInsightsInput).
pub mod get_insights_input {

    /// A builder for [`GetInsightsInput`](crate::input::GetInsightsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetInsightsInput`](crate::input::GetInsightsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetInsightsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetInsightsInput {})
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceFoldersByAssessmentControlInput {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetEvidenceFoldersByAssessmentControlInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<&str> {
        self.control_set_id.as_deref()
    }
    /// <p> The identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<&str> {
        self.control_id.as_deref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetEvidenceFoldersByAssessmentControlInput {
    /// Creates a new builder-style object to manufacture [`GetEvidenceFoldersByAssessmentControlInput`](crate::input::GetEvidenceFoldersByAssessmentControlInput).
    pub fn builder() -> crate::input::get_evidence_folders_by_assessment_control_input::Builder {
        crate::input::get_evidence_folders_by_assessment_control_input::Builder::default()
    }
}

/// See [`GetEvidenceFoldersByAssessmentControlInput`](crate::input::GetEvidenceFoldersByAssessmentControlInput).
pub mod get_evidence_folders_by_assessment_control_input {

    /// A builder for [`GetEvidenceFoldersByAssessmentControlInput`](crate::input::GetEvidenceFoldersByAssessmentControlInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control set. </p>
        pub fn set_control_set_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_set_id = input;
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input;
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetEvidenceFoldersByAssessmentControlInput`](crate::input::GetEvidenceFoldersByAssessmentControlInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetEvidenceFoldersByAssessmentControlInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetEvidenceFoldersByAssessmentControlInput {
                assessment_id: self.assessment_id,
                control_set_id: self.control_set_id,
                control_id: self.control_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceFoldersByAssessmentInput {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetEvidenceFoldersByAssessmentInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetEvidenceFoldersByAssessmentInput {
    /// Creates a new builder-style object to manufacture [`GetEvidenceFoldersByAssessmentInput`](crate::input::GetEvidenceFoldersByAssessmentInput).
    pub fn builder() -> crate::input::get_evidence_folders_by_assessment_input::Builder {
        crate::input::get_evidence_folders_by_assessment_input::Builder::default()
    }
}

/// See [`GetEvidenceFoldersByAssessmentInput`](crate::input::GetEvidenceFoldersByAssessmentInput).
pub mod get_evidence_folders_by_assessment_input {

    /// A builder for [`GetEvidenceFoldersByAssessmentInput`](crate::input::GetEvidenceFoldersByAssessmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetEvidenceFoldersByAssessmentInput`](crate::input::GetEvidenceFoldersByAssessmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetEvidenceFoldersByAssessmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetEvidenceFoldersByAssessmentInput {
                assessment_id: self.assessment_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceFolderInput {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
}
impl GetEvidenceFolderInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<&str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<&str> {
        self.evidence_folder_id.as_deref()
    }
}
impl GetEvidenceFolderInput {
    /// Creates a new builder-style object to manufacture [`GetEvidenceFolderInput`](crate::input::GetEvidenceFolderInput).
    pub fn builder() -> crate::input::get_evidence_folder_input::Builder {
        crate::input::get_evidence_folder_input::Builder::default()
    }
}

/// See [`GetEvidenceFolderInput`](crate::input::GetEvidenceFolderInput).
pub mod get_evidence_folder_input {

    /// A builder for [`GetEvidenceFolderInput`](crate::input::GetEvidenceFolderInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_set_id = input;
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evidence_folder_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetEvidenceFolderInput`](crate::input::GetEvidenceFolderInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetEvidenceFolderInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetEvidenceFolderInput {
                assessment_id: self.assessment_id,
                control_set_id: self.control_set_id,
                evidence_folder_id: self.evidence_folder_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceByEvidenceFolderInput {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetEvidenceByEvidenceFolderInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<&str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<&str> {
        self.evidence_folder_id.as_deref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetEvidenceByEvidenceFolderInput {
    /// Creates a new builder-style object to manufacture [`GetEvidenceByEvidenceFolderInput`](crate::input::GetEvidenceByEvidenceFolderInput).
    pub fn builder() -> crate::input::get_evidence_by_evidence_folder_input::Builder {
        crate::input::get_evidence_by_evidence_folder_input::Builder::default()
    }
}

/// See [`GetEvidenceByEvidenceFolderInput`](crate::input::GetEvidenceByEvidenceFolderInput).
pub mod get_evidence_by_evidence_folder_input {

    /// A builder for [`GetEvidenceByEvidenceFolderInput`](crate::input::GetEvidenceByEvidenceFolderInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control set. </p>
        pub fn set_control_set_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_set_id = input;
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evidence_folder_id = input;
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetEvidenceByEvidenceFolderInput`](crate::input::GetEvidenceByEvidenceFolderInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetEvidenceByEvidenceFolderInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetEvidenceByEvidenceFolderInput {
                assessment_id: self.assessment_id,
                control_set_id: self.control_set_id,
                evidence_folder_id: self.evidence_folder_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceInput {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the evidence. </p>
    #[doc(hidden)]
    pub evidence_id: std::option::Option<std::string::String>,
}
impl GetEvidenceInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<&str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<&str> {
        self.evidence_folder_id.as_deref()
    }
    /// <p> The unique identifier for the evidence. </p>
    pub fn evidence_id(&self) -> std::option::Option<&str> {
        self.evidence_id.as_deref()
    }
}
impl GetEvidenceInput {
    /// Creates a new builder-style object to manufacture [`GetEvidenceInput`](crate::input::GetEvidenceInput).
    pub fn builder() -> crate::input::get_evidence_input::Builder {
        crate::input::get_evidence_input::Builder::default()
    }
}

/// See [`GetEvidenceInput`](crate::input::GetEvidenceInput).
pub mod get_evidence_input {

    /// A builder for [`GetEvidenceInput`](crate::input::GetEvidenceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
        pub(crate) evidence_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_set_id = input;
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evidence_folder_id = input;
            self
        }
        /// <p> The unique identifier for the evidence. </p>
        pub fn evidence_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the evidence. </p>
        pub fn set_evidence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.evidence_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetEvidenceInput`](crate::input::GetEvidenceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetEvidenceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetEvidenceInput {
                assessment_id: self.assessment_id,
                control_set_id: self.control_set_id,
                evidence_folder_id: self.evidence_folder_id,
                evidence_id: self.evidence_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDelegationsInput {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetDelegationsInput {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetDelegationsInput {
    /// Creates a new builder-style object to manufacture [`GetDelegationsInput`](crate::input::GetDelegationsInput).
    pub fn builder() -> crate::input::get_delegations_input::Builder {
        crate::input::get_delegations_input::Builder::default()
    }
}

/// See [`GetDelegationsInput`](crate::input::GetDelegationsInput).
pub mod get_delegations_input {

    /// A builder for [`GetDelegationsInput`](crate::input::GetDelegationsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDelegationsInput`](crate::input::GetDelegationsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetDelegationsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetDelegationsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetControlInput {
    /// <p> The identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
}
impl GetControlInput {
    /// <p> The identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<&str> {
        self.control_id.as_deref()
    }
}
impl GetControlInput {
    /// Creates a new builder-style object to manufacture [`GetControlInput`](crate::input::GetControlInput).
    pub fn builder() -> crate::input::get_control_input::Builder {
        crate::input::get_control_input::Builder::default()
    }
}

/// See [`GetControlInput`](crate::input::GetControlInput).
pub mod get_control_input {

    /// A builder for [`GetControlInput`](crate::input::GetControlInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetControlInput`](crate::input::GetControlInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetControlInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetControlInput {
                control_id: self.control_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetChangeLogsInput {
    /// <p>The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetChangeLogsInput {
    /// <p>The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<&str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<&str> {
        self.control_id.as_deref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetChangeLogsInput {
    /// Creates a new builder-style object to manufacture [`GetChangeLogsInput`](crate::input::GetChangeLogsInput).
    pub fn builder() -> crate::input::get_change_logs_input::Builder {
        crate::input::get_change_logs_input::Builder::default()
    }
}

/// See [`GetChangeLogsInput`](crate::input::GetChangeLogsInput).
pub mod get_change_logs_input {

    /// A builder for [`GetChangeLogsInput`](crate::input::GetChangeLogsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_set_id = input;
            self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input;
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetChangeLogsInput`](crate::input::GetChangeLogsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetChangeLogsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetChangeLogsInput {
                assessment_id: self.assessment_id,
                control_set_id: self.control_set_id,
                control_id: self.control_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssessmentReportUrlInput {
    /// <p> The unique identifier for the assessment report. </p>
    #[doc(hidden)]
    pub assessment_report_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl GetAssessmentReportUrlInput {
    /// <p> The unique identifier for the assessment report. </p>
    pub fn assessment_report_id(&self) -> std::option::Option<&str> {
        self.assessment_report_id.as_deref()
    }
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
}
impl GetAssessmentReportUrlInput {
    /// Creates a new builder-style object to manufacture [`GetAssessmentReportUrlInput`](crate::input::GetAssessmentReportUrlInput).
    pub fn builder() -> crate::input::get_assessment_report_url_input::Builder {
        crate::input::get_assessment_report_url_input::Builder::default()
    }
}

/// See [`GetAssessmentReportUrlInput`](crate::input::GetAssessmentReportUrlInput).
pub mod get_assessment_report_url_input {

    /// A builder for [`GetAssessmentReportUrlInput`](crate::input::GetAssessmentReportUrlInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_report_id: std::option::Option<std::string::String>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment report. </p>
        pub fn assessment_report_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_report_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment report. </p>
        pub fn set_assessment_report_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_report_id = input;
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAssessmentReportUrlInput`](crate::input::GetAssessmentReportUrlInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetAssessmentReportUrlInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetAssessmentReportUrlInput {
                assessment_report_id: self.assessment_report_id,
                assessment_id: self.assessment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssessmentFrameworkInput {
    /// <p> The identifier for the framework. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
}
impl GetAssessmentFrameworkInput {
    /// <p> The identifier for the framework. </p>
    pub fn framework_id(&self) -> std::option::Option<&str> {
        self.framework_id.as_deref()
    }
}
impl GetAssessmentFrameworkInput {
    /// Creates a new builder-style object to manufacture [`GetAssessmentFrameworkInput`](crate::input::GetAssessmentFrameworkInput).
    pub fn builder() -> crate::input::get_assessment_framework_input::Builder {
        crate::input::get_assessment_framework_input::Builder::default()
    }
}

/// See [`GetAssessmentFrameworkInput`](crate::input::GetAssessmentFrameworkInput).
pub mod get_assessment_framework_input {

    /// A builder for [`GetAssessmentFrameworkInput`](crate::input::GetAssessmentFrameworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the framework. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The identifier for the framework. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAssessmentFrameworkInput`](crate::input::GetAssessmentFrameworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetAssessmentFrameworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetAssessmentFrameworkInput {
                framework_id: self.framework_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssessmentInput {
    /// <p>The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl GetAssessmentInput {
    /// <p>The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
}
impl GetAssessmentInput {
    /// Creates a new builder-style object to manufacture [`GetAssessmentInput`](crate::input::GetAssessmentInput).
    pub fn builder() -> crate::input::get_assessment_input::Builder {
        crate::input::get_assessment_input::Builder::default()
    }
}

/// See [`GetAssessmentInput`](crate::input::GetAssessmentInput).
pub mod get_assessment_input {

    /// A builder for [`GetAssessmentInput`](crate::input::GetAssessmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAssessmentInput`](crate::input::GetAssessmentInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetAssessmentInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetAssessmentInput {
                assessment_id: self.assessment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAccountStatusInput {}
impl GetAccountStatusInput {
    /// Creates a new builder-style object to manufacture [`GetAccountStatusInput`](crate::input::GetAccountStatusInput).
    pub fn builder() -> crate::input::get_account_status_input::Builder {
        crate::input::get_account_status_input::Builder::default()
    }
}

/// See [`GetAccountStatusInput`](crate::input::GetAccountStatusInput).
pub mod get_account_status_input {

    /// A builder for [`GetAccountStatusInput`](crate::input::GetAccountStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetAccountStatusInput`](crate::input::GetAccountStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetAccountStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetAccountStatusInput {})
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateAssessmentReportEvidenceFolderInput {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
}
impl DisassociateAssessmentReportEvidenceFolderInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<&str> {
        self.evidence_folder_id.as_deref()
    }
}
impl DisassociateAssessmentReportEvidenceFolderInput {
    /// Creates a new builder-style object to manufacture [`DisassociateAssessmentReportEvidenceFolderInput`](crate::input::DisassociateAssessmentReportEvidenceFolderInput).
    pub fn builder() -> crate::input::disassociate_assessment_report_evidence_folder_input::Builder
    {
        crate::input::disassociate_assessment_report_evidence_folder_input::Builder::default()
    }
}

/// See [`DisassociateAssessmentReportEvidenceFolderInput`](crate::input::DisassociateAssessmentReportEvidenceFolderInput).
pub mod disassociate_assessment_report_evidence_folder_input {

    /// A builder for [`DisassociateAssessmentReportEvidenceFolderInput`](crate::input::DisassociateAssessmentReportEvidenceFolderInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evidence_folder_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateAssessmentReportEvidenceFolderInput`](crate::input::DisassociateAssessmentReportEvidenceFolderInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateAssessmentReportEvidenceFolderInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(
                crate::input::DisassociateAssessmentReportEvidenceFolderInput {
                    assessment_id: self.assessment_id,
                    evidence_folder_id: self.evidence_folder_id,
                },
            )
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeregisterOrganizationAdminAccountInput {
    /// <p> The identifier for the administrator account. </p>
    #[doc(hidden)]
    pub admin_account_id: std::option::Option<std::string::String>,
}
impl DeregisterOrganizationAdminAccountInput {
    /// <p> The identifier for the administrator account. </p>
    pub fn admin_account_id(&self) -> std::option::Option<&str> {
        self.admin_account_id.as_deref()
    }
}
impl DeregisterOrganizationAdminAccountInput {
    /// Creates a new builder-style object to manufacture [`DeregisterOrganizationAdminAccountInput`](crate::input::DeregisterOrganizationAdminAccountInput).
    pub fn builder() -> crate::input::deregister_organization_admin_account_input::Builder {
        crate::input::deregister_organization_admin_account_input::Builder::default()
    }
}

/// See [`DeregisterOrganizationAdminAccountInput`](crate::input::DeregisterOrganizationAdminAccountInput).
pub mod deregister_organization_admin_account_input {

    /// A builder for [`DeregisterOrganizationAdminAccountInput`](crate::input::DeregisterOrganizationAdminAccountInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) admin_account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the administrator account. </p>
        pub fn admin_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_account_id = Some(input.into());
            self
        }
        /// <p> The identifier for the administrator account. </p>
        pub fn set_admin_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.admin_account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeregisterOrganizationAdminAccountInput`](crate::input::DeregisterOrganizationAdminAccountInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeregisterOrganizationAdminAccountInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeregisterOrganizationAdminAccountInput {
                admin_account_id: self.admin_account_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeregisterAccountInput {}
impl DeregisterAccountInput {
    /// Creates a new builder-style object to manufacture [`DeregisterAccountInput`](crate::input::DeregisterAccountInput).
    pub fn builder() -> crate::input::deregister_account_input::Builder {
        crate::input::deregister_account_input::Builder::default()
    }
}

/// See [`DeregisterAccountInput`](crate::input::DeregisterAccountInput).
pub mod deregister_account_input {

    /// A builder for [`DeregisterAccountInput`](crate::input::DeregisterAccountInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeregisterAccountInput`](crate::input::DeregisterAccountInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeregisterAccountInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeregisterAccountInput {})
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteControlInput {
    /// <p> The unique identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
}
impl DeleteControlInput {
    /// <p> The unique identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<&str> {
        self.control_id.as_deref()
    }
}
impl DeleteControlInput {
    /// Creates a new builder-style object to manufacture [`DeleteControlInput`](crate::input::DeleteControlInput).
    pub fn builder() -> crate::input::delete_control_input::Builder {
        crate::input::delete_control_input::Builder::default()
    }
}

/// See [`DeleteControlInput`](crate::input::DeleteControlInput).
pub mod delete_control_input {

    /// A builder for [`DeleteControlInput`](crate::input::DeleteControlInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteControlInput`](crate::input::DeleteControlInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteControlInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteControlInput {
                control_id: self.control_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssessmentReportInput {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the assessment report. </p>
    #[doc(hidden)]
    pub assessment_report_id: std::option::Option<std::string::String>,
}
impl DeleteAssessmentReportInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the assessment report. </p>
    pub fn assessment_report_id(&self) -> std::option::Option<&str> {
        self.assessment_report_id.as_deref()
    }
}
impl DeleteAssessmentReportInput {
    /// Creates a new builder-style object to manufacture [`DeleteAssessmentReportInput`](crate::input::DeleteAssessmentReportInput).
    pub fn builder() -> crate::input::delete_assessment_report_input::Builder {
        crate::input::delete_assessment_report_input::Builder::default()
    }
}

/// See [`DeleteAssessmentReportInput`](crate::input::DeleteAssessmentReportInput).
pub mod delete_assessment_report_input {

    /// A builder for [`DeleteAssessmentReportInput`](crate::input::DeleteAssessmentReportInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) assessment_report_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The unique identifier for the assessment report. </p>
        pub fn assessment_report_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_report_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment report. </p>
        pub fn set_assessment_report_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_report_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAssessmentReportInput`](crate::input::DeleteAssessmentReportInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteAssessmentReportInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteAssessmentReportInput {
                assessment_id: self.assessment_id,
                assessment_report_id: self.assessment_report_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssessmentFrameworkShareInput {
    /// <p>The unique identifier for the share request to be deleted.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the share request is a sent request or a received request.</p>
    #[doc(hidden)]
    pub request_type: std::option::Option<crate::model::ShareRequestType>,
}
impl DeleteAssessmentFrameworkShareInput {
    /// <p>The unique identifier for the share request to be deleted.</p>
    pub fn request_id(&self) -> std::option::Option<&str> {
        self.request_id.as_deref()
    }
    /// <p>Specifies whether the share request is a sent request or a received request.</p>
    pub fn request_type(&self) -> std::option::Option<&crate::model::ShareRequestType> {
        self.request_type.as_ref()
    }
}
impl DeleteAssessmentFrameworkShareInput {
    /// Creates a new builder-style object to manufacture [`DeleteAssessmentFrameworkShareInput`](crate::input::DeleteAssessmentFrameworkShareInput).
    pub fn builder() -> crate::input::delete_assessment_framework_share_input::Builder {
        crate::input::delete_assessment_framework_share_input::Builder::default()
    }
}

/// See [`DeleteAssessmentFrameworkShareInput`](crate::input::DeleteAssessmentFrameworkShareInput).
pub mod delete_assessment_framework_share_input {

    /// A builder for [`DeleteAssessmentFrameworkShareInput`](crate::input::DeleteAssessmentFrameworkShareInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) request_type: std::option::Option<crate::model::ShareRequestType>,
    }
    impl Builder {
        /// <p>The unique identifier for the share request to be deleted.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the share request to be deleted.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// <p>Specifies whether the share request is a sent request or a received request.</p>
        pub fn request_type(mut self, input: crate::model::ShareRequestType) -> Self {
            self.request_type = Some(input);
            self
        }
        /// <p>Specifies whether the share request is a sent request or a received request.</p>
        pub fn set_request_type(
            mut self,
            input: std::option::Option<crate::model::ShareRequestType>,
        ) -> Self {
            self.request_type = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAssessmentFrameworkShareInput`](crate::input::DeleteAssessmentFrameworkShareInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteAssessmentFrameworkShareInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteAssessmentFrameworkShareInput {
                request_id: self.request_id,
                request_type: self.request_type,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssessmentFrameworkInput {
    /// <p> The identifier for the custom framework. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
}
impl DeleteAssessmentFrameworkInput {
    /// <p> The identifier for the custom framework. </p>
    pub fn framework_id(&self) -> std::option::Option<&str> {
        self.framework_id.as_deref()
    }
}
impl DeleteAssessmentFrameworkInput {
    /// Creates a new builder-style object to manufacture [`DeleteAssessmentFrameworkInput`](crate::input::DeleteAssessmentFrameworkInput).
    pub fn builder() -> crate::input::delete_assessment_framework_input::Builder {
        crate::input::delete_assessment_framework_input::Builder::default()
    }
}

/// See [`DeleteAssessmentFrameworkInput`](crate::input::DeleteAssessmentFrameworkInput).
pub mod delete_assessment_framework_input {

    /// A builder for [`DeleteAssessmentFrameworkInput`](crate::input::DeleteAssessmentFrameworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the custom framework. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The identifier for the custom framework. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAssessmentFrameworkInput`](crate::input::DeleteAssessmentFrameworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteAssessmentFrameworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteAssessmentFrameworkInput {
                framework_id: self.framework_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssessmentInput {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl DeleteAssessmentInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
}
impl DeleteAssessmentInput {
    /// Creates a new builder-style object to manufacture [`DeleteAssessmentInput`](crate::input::DeleteAssessmentInput).
    pub fn builder() -> crate::input::delete_assessment_input::Builder {
        crate::input::delete_assessment_input::Builder::default()
    }
}

/// See [`DeleteAssessmentInput`](crate::input::DeleteAssessmentInput).
pub mod delete_assessment_input {

    /// A builder for [`DeleteAssessmentInput`](crate::input::DeleteAssessmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAssessmentInput`](crate::input::DeleteAssessmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteAssessmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteAssessmentInput {
                assessment_id: self.assessment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateControlInput {
    /// <p> The name of the control. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The description of the control. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The steps to follow to determine if the control is satisfied. </p>
    #[doc(hidden)]
    pub testing_information: std::option::Option<std::string::String>,
    /// <p> The title of the action plan for remediating the control. </p>
    #[doc(hidden)]
    pub action_plan_title: std::option::Option<std::string::String>,
    /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
    #[doc(hidden)]
    pub action_plan_instructions: std::option::Option<std::string::String>,
    /// <p> The data mapping sources for the control. </p>
    #[doc(hidden)]
    pub control_mapping_sources:
        std::option::Option<std::vec::Vec<crate::model::CreateControlMappingSource>>,
    /// <p> The tags that are associated with the control. </p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateControlInput {
    /// <p> The name of the control. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The description of the control. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The steps to follow to determine if the control is satisfied. </p>
    pub fn testing_information(&self) -> std::option::Option<&str> {
        self.testing_information.as_deref()
    }
    /// <p> The title of the action plan for remediating the control. </p>
    pub fn action_plan_title(&self) -> std::option::Option<&str> {
        self.action_plan_title.as_deref()
    }
    /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
    pub fn action_plan_instructions(&self) -> std::option::Option<&str> {
        self.action_plan_instructions.as_deref()
    }
    /// <p> The data mapping sources for the control. </p>
    pub fn control_mapping_sources(
        &self,
    ) -> std::option::Option<&[crate::model::CreateControlMappingSource]> {
        self.control_mapping_sources.as_deref()
    }
    /// <p> The tags that are associated with the control. </p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateControlInput {
    /// Creates a new builder-style object to manufacture [`CreateControlInput`](crate::input::CreateControlInput).
    pub fn builder() -> crate::input::create_control_input::Builder {
        crate::input::create_control_input::Builder::default()
    }
}

/// See [`CreateControlInput`](crate::input::CreateControlInput).
pub mod create_control_input {

    /// A builder for [`CreateControlInput`](crate::input::CreateControlInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) testing_information: std::option::Option<std::string::String>,
        pub(crate) action_plan_title: std::option::Option<std::string::String>,
        pub(crate) action_plan_instructions: std::option::Option<std::string::String>,
        pub(crate) control_mapping_sources:
            std::option::Option<std::vec::Vec<crate::model::CreateControlMappingSource>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p> The name of the control. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the control. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> The description of the control. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The description of the control. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The steps to follow to determine if the control is satisfied. </p>
        pub fn testing_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.testing_information = Some(input.into());
            self
        }
        /// <p> The steps to follow to determine if the control is satisfied. </p>
        pub fn set_testing_information(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.testing_information = input;
            self
        }
        /// <p> The title of the action plan for remediating the control. </p>
        pub fn action_plan_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_plan_title = Some(input.into());
            self
        }
        /// <p> The title of the action plan for remediating the control. </p>
        pub fn set_action_plan_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.action_plan_title = input;
            self
        }
        /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
        pub fn action_plan_instructions(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_plan_instructions = Some(input.into());
            self
        }
        /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
        pub fn set_action_plan_instructions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.action_plan_instructions = input;
            self
        }
        /// Appends an item to `control_mapping_sources`.
        ///
        /// To override the contents of this collection use [`set_control_mapping_sources`](Self::set_control_mapping_sources).
        ///
        /// <p> The data mapping sources for the control. </p>
        pub fn control_mapping_sources(
            mut self,
            input: crate::model::CreateControlMappingSource,
        ) -> Self {
            let mut v = self.control_mapping_sources.unwrap_or_default();
            v.push(input);
            self.control_mapping_sources = Some(v);
            self
        }
        /// <p> The data mapping sources for the control. </p>
        pub fn set_control_mapping_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateControlMappingSource>>,
        ) -> Self {
            self.control_mapping_sources = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> The tags that are associated with the control. </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p> The tags that are associated with the control. </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateControlInput`](crate::input::CreateControlInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateControlInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateControlInput {
                name: self.name,
                description: self.description,
                testing_information: self.testing_information,
                action_plan_title: self.action_plan_title,
                action_plan_instructions: self.action_plan_instructions,
                control_mapping_sources: self.control_mapping_sources,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAssessmentReportInput {
    /// <p> The name of the new assessment report. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The description of the assessment report. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p>A SQL statement that represents an evidence finder query.</p>
    /// <p>Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence">added to a report using the console</a>, or <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html">associated with a report using the API</a>. </p>
    /// <p>To use this parameter, the <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus">enablementStatus</a> of evidence finder must be <code>ENABLED</code>. </p>
    /// <p> For examples and help resolving <code>queryStatement</code> validation exceptions, see <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions">Troubleshooting evidence finder issues</a> in the <i>Audit Manager User Guide.</i> </p>
    #[doc(hidden)]
    pub query_statement: std::option::Option<std::string::String>,
}
impl CreateAssessmentReportInput {
    /// <p> The name of the new assessment report. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The description of the assessment report. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p>A SQL statement that represents an evidence finder query.</p>
    /// <p>Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence">added to a report using the console</a>, or <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html">associated with a report using the API</a>. </p>
    /// <p>To use this parameter, the <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus">enablementStatus</a> of evidence finder must be <code>ENABLED</code>. </p>
    /// <p> For examples and help resolving <code>queryStatement</code> validation exceptions, see <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions">Troubleshooting evidence finder issues</a> in the <i>Audit Manager User Guide.</i> </p>
    pub fn query_statement(&self) -> std::option::Option<&str> {
        self.query_statement.as_deref()
    }
}
impl CreateAssessmentReportInput {
    /// Creates a new builder-style object to manufacture [`CreateAssessmentReportInput`](crate::input::CreateAssessmentReportInput).
    pub fn builder() -> crate::input::create_assessment_report_input::Builder {
        crate::input::create_assessment_report_input::Builder::default()
    }
}

/// See [`CreateAssessmentReportInput`](crate::input::CreateAssessmentReportInput).
pub mod create_assessment_report_input {

    /// A builder for [`CreateAssessmentReportInput`](crate::input::CreateAssessmentReportInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) query_statement: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the new assessment report. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the new assessment report. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> The description of the assessment report. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The description of the assessment report. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p>A SQL statement that represents an evidence finder query.</p>
        /// <p>Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence">added to a report using the console</a>, or <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html">associated with a report using the API</a>. </p>
        /// <p>To use this parameter, the <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus">enablementStatus</a> of evidence finder must be <code>ENABLED</code>. </p>
        /// <p> For examples and help resolving <code>queryStatement</code> validation exceptions, see <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions">Troubleshooting evidence finder issues</a> in the <i>Audit Manager User Guide.</i> </p>
        pub fn query_statement(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_statement = Some(input.into());
            self
        }
        /// <p>A SQL statement that represents an evidence finder query.</p>
        /// <p>Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence">added to a report using the console</a>, or <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html">associated with a report using the API</a>. </p>
        /// <p>To use this parameter, the <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus">enablementStatus</a> of evidence finder must be <code>ENABLED</code>. </p>
        /// <p> For examples and help resolving <code>queryStatement</code> validation exceptions, see <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions">Troubleshooting evidence finder issues</a> in the <i>Audit Manager User Guide.</i> </p>
        pub fn set_query_statement(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_statement = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAssessmentReportInput`](crate::input::CreateAssessmentReportInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateAssessmentReportInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateAssessmentReportInput {
                name: self.name,
                description: self.description,
                assessment_id: self.assessment_id,
                query_statement: self.query_statement,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAssessmentFrameworkInput {
    /// <p> The name of the new custom framework. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> An optional description for the new custom framework. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<std::string::String>,
    /// <p> The control sets that are associated with the framework. </p>
    #[doc(hidden)]
    pub control_sets:
        std::option::Option<std::vec::Vec<crate::model::CreateAssessmentFrameworkControlSet>>,
    /// <p> The tags that are associated with the framework. </p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateAssessmentFrameworkInput {
    /// <p> The name of the new custom framework. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> An optional description for the new custom framework. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
    pub fn compliance_type(&self) -> std::option::Option<&str> {
        self.compliance_type.as_deref()
    }
    /// <p> The control sets that are associated with the framework. </p>
    pub fn control_sets(
        &self,
    ) -> std::option::Option<&[crate::model::CreateAssessmentFrameworkControlSet]> {
        self.control_sets.as_deref()
    }
    /// <p> The tags that are associated with the framework. </p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateAssessmentFrameworkInput {
    /// Creates a new builder-style object to manufacture [`CreateAssessmentFrameworkInput`](crate::input::CreateAssessmentFrameworkInput).
    pub fn builder() -> crate::input::create_assessment_framework_input::Builder {
        crate::input::create_assessment_framework_input::Builder::default()
    }
}

/// See [`CreateAssessmentFrameworkInput`](crate::input::CreateAssessmentFrameworkInput).
pub mod create_assessment_framework_input {

    /// A builder for [`CreateAssessmentFrameworkInput`](crate::input::CreateAssessmentFrameworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) compliance_type: std::option::Option<std::string::String>,
        pub(crate) control_sets:
            std::option::Option<std::vec::Vec<crate::model::CreateAssessmentFrameworkControlSet>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p> The name of the new custom framework. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the new custom framework. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> An optional description for the new custom framework. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> An optional description for the new custom framework. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
        pub fn compliance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_type = Some(input.into());
            self
        }
        /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
        pub fn set_compliance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.compliance_type = input;
            self
        }
        /// Appends an item to `control_sets`.
        ///
        /// To override the contents of this collection use [`set_control_sets`](Self::set_control_sets).
        ///
        /// <p> The control sets that are associated with the framework. </p>
        pub fn control_sets(
            mut self,
            input: crate::model::CreateAssessmentFrameworkControlSet,
        ) -> Self {
            let mut v = self.control_sets.unwrap_or_default();
            v.push(input);
            self.control_sets = Some(v);
            self
        }
        /// <p> The control sets that are associated with the framework. </p>
        pub fn set_control_sets(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::CreateAssessmentFrameworkControlSet>,
            >,
        ) -> Self {
            self.control_sets = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> The tags that are associated with the framework. </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p> The tags that are associated with the framework. </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAssessmentFrameworkInput`](crate::input::CreateAssessmentFrameworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateAssessmentFrameworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateAssessmentFrameworkInput {
                name: self.name,
                description: self.description,
                compliance_type: self.compliance_type,
                control_sets: self.control_sets,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAssessmentInput {
    /// <p> The name of the assessment to be created. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The optional description of the assessment to be created. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The assessment report storage destination for the assessment that's being created. </p>
    #[doc(hidden)]
    pub assessment_reports_destination:
        std::option::Option<crate::model::AssessmentReportsDestination>,
    /// <p> The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment. </p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p> The list of roles for the assessment. </p>
    #[doc(hidden)]
    pub roles: std::option::Option<std::vec::Vec<crate::model::Role>>,
    /// <p> The identifier for the framework that the assessment will be created from. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
    /// <p> The tags that are associated with the assessment. </p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateAssessmentInput {
    /// <p> The name of the assessment to be created. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The optional description of the assessment to be created. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The assessment report storage destination for the assessment that's being created. </p>
    pub fn assessment_reports_destination(
        &self,
    ) -> std::option::Option<&crate::model::AssessmentReportsDestination> {
        self.assessment_reports_destination.as_ref()
    }
    /// <p> The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment. </p>
    pub fn scope(&self) -> std::option::Option<&crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p> The list of roles for the assessment. </p>
    pub fn roles(&self) -> std::option::Option<&[crate::model::Role]> {
        self.roles.as_deref()
    }
    /// <p> The identifier for the framework that the assessment will be created from. </p>
    pub fn framework_id(&self) -> std::option::Option<&str> {
        self.framework_id.as_deref()
    }
    /// <p> The tags that are associated with the assessment. </p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl CreateAssessmentInput {
    /// Creates a new builder-style object to manufacture [`CreateAssessmentInput`](crate::input::CreateAssessmentInput).
    pub fn builder() -> crate::input::create_assessment_input::Builder {
        crate::input::create_assessment_input::Builder::default()
    }
}

/// See [`CreateAssessmentInput`](crate::input::CreateAssessmentInput).
pub mod create_assessment_input {

    /// A builder for [`CreateAssessmentInput`](crate::input::CreateAssessmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) assessment_reports_destination:
            std::option::Option<crate::model::AssessmentReportsDestination>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) roles: std::option::Option<std::vec::Vec<crate::model::Role>>,
        pub(crate) framework_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p> The name of the assessment to be created. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the assessment to be created. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> The optional description of the assessment to be created. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The optional description of the assessment to be created. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The assessment report storage destination for the assessment that's being created. </p>
        pub fn assessment_reports_destination(
            mut self,
            input: crate::model::AssessmentReportsDestination,
        ) -> Self {
            self.assessment_reports_destination = Some(input);
            self
        }
        /// <p> The assessment report storage destination for the assessment that's being created. </p>
        pub fn set_assessment_reports_destination(
            mut self,
            input: std::option::Option<crate::model::AssessmentReportsDestination>,
        ) -> Self {
            self.assessment_reports_destination = input;
            self
        }
        /// <p> The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment. </p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p> The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment. </p>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input;
            self
        }
        /// Appends an item to `roles`.
        ///
        /// To override the contents of this collection use [`set_roles`](Self::set_roles).
        ///
        /// <p> The list of roles for the assessment. </p>
        pub fn roles(mut self, input: crate::model::Role) -> Self {
            let mut v = self.roles.unwrap_or_default();
            v.push(input);
            self.roles = Some(v);
            self
        }
        /// <p> The list of roles for the assessment. </p>
        pub fn set_roles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Role>>,
        ) -> Self {
            self.roles = input;
            self
        }
        /// <p> The identifier for the framework that the assessment will be created from. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The identifier for the framework that the assessment will be created from. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> The tags that are associated with the assessment. </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p> The tags that are associated with the assessment. </p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAssessmentInput`](crate::input::CreateAssessmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateAssessmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateAssessmentInput {
                name: self.name,
                description: self.description,
                assessment_reports_destination: self.assessment_reports_destination,
                scope: self.scope,
                roles: self.roles,
                framework_id: self.framework_id,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchImportEvidenceToAssessmentControlInput {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The list of manual evidence objects. </p>
    #[doc(hidden)]
    pub manual_evidence: std::option::Option<std::vec::Vec<crate::model::ManualEvidence>>,
}
impl BatchImportEvidenceToAssessmentControlInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<&str> {
        self.control_set_id.as_deref()
    }
    /// <p> The identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<&str> {
        self.control_id.as_deref()
    }
    /// <p> The list of manual evidence objects. </p>
    pub fn manual_evidence(&self) -> std::option::Option<&[crate::model::ManualEvidence]> {
        self.manual_evidence.as_deref()
    }
}
impl BatchImportEvidenceToAssessmentControlInput {
    /// Creates a new builder-style object to manufacture [`BatchImportEvidenceToAssessmentControlInput`](crate::input::BatchImportEvidenceToAssessmentControlInput).
    pub fn builder() -> crate::input::batch_import_evidence_to_assessment_control_input::Builder {
        crate::input::batch_import_evidence_to_assessment_control_input::Builder::default()
    }
}

/// See [`BatchImportEvidenceToAssessmentControlInput`](crate::input::BatchImportEvidenceToAssessmentControlInput).
pub mod batch_import_evidence_to_assessment_control_input {

    /// A builder for [`BatchImportEvidenceToAssessmentControlInput`](crate::input::BatchImportEvidenceToAssessmentControlInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) manual_evidence:
            std::option::Option<std::vec::Vec<crate::model::ManualEvidence>>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control set. </p>
        pub fn set_control_set_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.control_set_id = input;
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input;
            self
        }
        /// Appends an item to `manual_evidence`.
        ///
        /// To override the contents of this collection use [`set_manual_evidence`](Self::set_manual_evidence).
        ///
        /// <p> The list of manual evidence objects. </p>
        pub fn manual_evidence(mut self, input: crate::model::ManualEvidence) -> Self {
            let mut v = self.manual_evidence.unwrap_or_default();
            v.push(input);
            self.manual_evidence = Some(v);
            self
        }
        /// <p> The list of manual evidence objects. </p>
        pub fn set_manual_evidence(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ManualEvidence>>,
        ) -> Self {
            self.manual_evidence = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchImportEvidenceToAssessmentControlInput`](crate::input::BatchImportEvidenceToAssessmentControlInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::BatchImportEvidenceToAssessmentControlInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::BatchImportEvidenceToAssessmentControlInput {
                assessment_id: self.assessment_id,
                control_set_id: self.control_set_id,
                control_id: self.control_id,
                manual_evidence: self.manual_evidence,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDisassociateAssessmentReportEvidenceInput {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
    /// <p> The list of evidence identifiers. </p>
    #[doc(hidden)]
    pub evidence_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl BatchDisassociateAssessmentReportEvidenceInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<&str> {
        self.evidence_folder_id.as_deref()
    }
    /// <p> The list of evidence identifiers. </p>
    pub fn evidence_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.evidence_ids.as_deref()
    }
}
impl BatchDisassociateAssessmentReportEvidenceInput {
    /// Creates a new builder-style object to manufacture [`BatchDisassociateAssessmentReportEvidenceInput`](crate::input::BatchDisassociateAssessmentReportEvidenceInput).
    pub fn builder() -> crate::input::batch_disassociate_assessment_report_evidence_input::Builder {
        crate::input::batch_disassociate_assessment_report_evidence_input::Builder::default()
    }
}

/// See [`BatchDisassociateAssessmentReportEvidenceInput`](crate::input::BatchDisassociateAssessmentReportEvidenceInput).
pub mod batch_disassociate_assessment_report_evidence_input {

    /// A builder for [`BatchDisassociateAssessmentReportEvidenceInput`](crate::input::BatchDisassociateAssessmentReportEvidenceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
        pub(crate) evidence_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evidence_folder_id = input;
            self
        }
        /// Appends an item to `evidence_ids`.
        ///
        /// To override the contents of this collection use [`set_evidence_ids`](Self::set_evidence_ids).
        ///
        /// <p> The list of evidence identifiers. </p>
        pub fn evidence_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.evidence_ids.unwrap_or_default();
            v.push(input.into());
            self.evidence_ids = Some(v);
            self
        }
        /// <p> The list of evidence identifiers. </p>
        pub fn set_evidence_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.evidence_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDisassociateAssessmentReportEvidenceInput`](crate::input::BatchDisassociateAssessmentReportEvidenceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::BatchDisassociateAssessmentReportEvidenceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(
                crate::input::BatchDisassociateAssessmentReportEvidenceInput {
                    assessment_id: self.assessment_id,
                    evidence_folder_id: self.evidence_folder_id,
                    evidence_ids: self.evidence_ids,
                },
            )
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDeleteDelegationByAssessmentInput {
    /// <p> The identifiers for the delegations. </p>
    #[doc(hidden)]
    pub delegation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl BatchDeleteDelegationByAssessmentInput {
    /// <p> The identifiers for the delegations. </p>
    pub fn delegation_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.delegation_ids.as_deref()
    }
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
}
impl BatchDeleteDelegationByAssessmentInput {
    /// Creates a new builder-style object to manufacture [`BatchDeleteDelegationByAssessmentInput`](crate::input::BatchDeleteDelegationByAssessmentInput).
    pub fn builder() -> crate::input::batch_delete_delegation_by_assessment_input::Builder {
        crate::input::batch_delete_delegation_by_assessment_input::Builder::default()
    }
}

/// See [`BatchDeleteDelegationByAssessmentInput`](crate::input::BatchDeleteDelegationByAssessmentInput).
pub mod batch_delete_delegation_by_assessment_input {

    /// A builder for [`BatchDeleteDelegationByAssessmentInput`](crate::input::BatchDeleteDelegationByAssessmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delegation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `delegation_ids`.
        ///
        /// To override the contents of this collection use [`set_delegation_ids`](Self::set_delegation_ids).
        ///
        /// <p> The identifiers for the delegations. </p>
        pub fn delegation_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.delegation_ids.unwrap_or_default();
            v.push(input.into());
            self.delegation_ids = Some(v);
            self
        }
        /// <p> The identifiers for the delegations. </p>
        pub fn set_delegation_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.delegation_ids = input;
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDeleteDelegationByAssessmentInput`](crate::input::BatchDeleteDelegationByAssessmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::BatchDeleteDelegationByAssessmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::BatchDeleteDelegationByAssessmentInput {
                delegation_ids: self.delegation_ids,
                assessment_id: self.assessment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchCreateDelegationByAssessmentInput {
    /// <p> The API request to batch create delegations in Audit Manager. </p>
    #[doc(hidden)]
    pub create_delegation_requests:
        std::option::Option<std::vec::Vec<crate::model::CreateDelegationRequest>>,
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl BatchCreateDelegationByAssessmentInput {
    /// <p> The API request to batch create delegations in Audit Manager. </p>
    pub fn create_delegation_requests(
        &self,
    ) -> std::option::Option<&[crate::model::CreateDelegationRequest]> {
        self.create_delegation_requests.as_deref()
    }
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
}
impl BatchCreateDelegationByAssessmentInput {
    /// Creates a new builder-style object to manufacture [`BatchCreateDelegationByAssessmentInput`](crate::input::BatchCreateDelegationByAssessmentInput).
    pub fn builder() -> crate::input::batch_create_delegation_by_assessment_input::Builder {
        crate::input::batch_create_delegation_by_assessment_input::Builder::default()
    }
}

/// See [`BatchCreateDelegationByAssessmentInput`](crate::input::BatchCreateDelegationByAssessmentInput).
pub mod batch_create_delegation_by_assessment_input {

    /// A builder for [`BatchCreateDelegationByAssessmentInput`](crate::input::BatchCreateDelegationByAssessmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) create_delegation_requests:
            std::option::Option<std::vec::Vec<crate::model::CreateDelegationRequest>>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `create_delegation_requests`.
        ///
        /// To override the contents of this collection use [`set_create_delegation_requests`](Self::set_create_delegation_requests).
        ///
        /// <p> The API request to batch create delegations in Audit Manager. </p>
        pub fn create_delegation_requests(
            mut self,
            input: crate::model::CreateDelegationRequest,
        ) -> Self {
            let mut v = self.create_delegation_requests.unwrap_or_default();
            v.push(input);
            self.create_delegation_requests = Some(v);
            self
        }
        /// <p> The API request to batch create delegations in Audit Manager. </p>
        pub fn set_create_delegation_requests(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateDelegationRequest>>,
        ) -> Self {
            self.create_delegation_requests = input;
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchCreateDelegationByAssessmentInput`](crate::input::BatchCreateDelegationByAssessmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::BatchCreateDelegationByAssessmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::BatchCreateDelegationByAssessmentInput {
                create_delegation_requests: self.create_delegation_requests,
                assessment_id: self.assessment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchAssociateAssessmentReportEvidenceInput {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
    /// <p> The list of evidence identifiers. </p>
    #[doc(hidden)]
    pub evidence_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl BatchAssociateAssessmentReportEvidenceInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<&str> {
        self.evidence_folder_id.as_deref()
    }
    /// <p> The list of evidence identifiers. </p>
    pub fn evidence_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.evidence_ids.as_deref()
    }
}
impl BatchAssociateAssessmentReportEvidenceInput {
    /// Creates a new builder-style object to manufacture [`BatchAssociateAssessmentReportEvidenceInput`](crate::input::BatchAssociateAssessmentReportEvidenceInput).
    pub fn builder() -> crate::input::batch_associate_assessment_report_evidence_input::Builder {
        crate::input::batch_associate_assessment_report_evidence_input::Builder::default()
    }
}

/// See [`BatchAssociateAssessmentReportEvidenceInput`](crate::input::BatchAssociateAssessmentReportEvidenceInput).
pub mod batch_associate_assessment_report_evidence_input {

    /// A builder for [`BatchAssociateAssessmentReportEvidenceInput`](crate::input::BatchAssociateAssessmentReportEvidenceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
        pub(crate) evidence_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evidence_folder_id = input;
            self
        }
        /// Appends an item to `evidence_ids`.
        ///
        /// To override the contents of this collection use [`set_evidence_ids`](Self::set_evidence_ids).
        ///
        /// <p> The list of evidence identifiers. </p>
        pub fn evidence_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.evidence_ids.unwrap_or_default();
            v.push(input.into());
            self.evidence_ids = Some(v);
            self
        }
        /// <p> The list of evidence identifiers. </p>
        pub fn set_evidence_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.evidence_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchAssociateAssessmentReportEvidenceInput`](crate::input::BatchAssociateAssessmentReportEvidenceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::BatchAssociateAssessmentReportEvidenceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::BatchAssociateAssessmentReportEvidenceInput {
                assessment_id: self.assessment_id,
                evidence_folder_id: self.evidence_folder_id,
                evidence_ids: self.evidence_ids,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateAssessmentReportEvidenceFolderInput {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
}
impl AssociateAssessmentReportEvidenceFolderInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<&str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<&str> {
        self.evidence_folder_id.as_deref()
    }
}
impl AssociateAssessmentReportEvidenceFolderInput {
    /// Creates a new builder-style object to manufacture [`AssociateAssessmentReportEvidenceFolderInput`](crate::input::AssociateAssessmentReportEvidenceFolderInput).
    pub fn builder() -> crate::input::associate_assessment_report_evidence_folder_input::Builder {
        crate::input::associate_assessment_report_evidence_folder_input::Builder::default()
    }
}

/// See [`AssociateAssessmentReportEvidenceFolderInput`](crate::input::AssociateAssessmentReportEvidenceFolderInput).
pub mod associate_assessment_report_evidence_folder_input {

    /// A builder for [`AssociateAssessmentReportEvidenceFolderInput`](crate::input::AssociateAssessmentReportEvidenceFolderInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_id = input;
            self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evidence_folder_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateAssessmentReportEvidenceFolderInput`](crate::input::AssociateAssessmentReportEvidenceFolderInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateAssessmentReportEvidenceFolderInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateAssessmentReportEvidenceFolderInput {
                assessment_id: self.assessment_id,
                evidence_folder_id: self.evidence_folder_id,
            })
        }
    }
}
