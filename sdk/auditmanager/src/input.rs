// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`AssociateAssessmentReportEvidenceFolderInput`](crate::input::AssociateAssessmentReportEvidenceFolderInput).
pub mod associate_assessment_report_evidence_folder_input {
    
    /// A builder for [`AssociateAssessmentReportEvidenceFolderInput`](crate::input::AssociateAssessmentReportEvidenceFolderInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.evidence_folder_id = input; self
        }
        /// Consumes the builder and constructs a [`AssociateAssessmentReportEvidenceFolderInput`](crate::input::AssociateAssessmentReportEvidenceFolderInput).
        pub fn build(self) -> Result<crate::input::AssociateAssessmentReportEvidenceFolderInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::AssociateAssessmentReportEvidenceFolderInput {
                    assessment_id: self.assessment_id
                    ,
                    evidence_folder_id: self.evidence_folder_id
                    ,
                }
            )
        }
    }
    
    
}
impl AssociateAssessmentReportEvidenceFolderInput {
    /// Consumes the builder and constructs an Operation<[`AssociateAssessmentReportEvidenceFolder`](crate::operation::AssociateAssessmentReportEvidenceFolder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::AssociateAssessmentReportEvidenceFolder, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::AssociateAssessmentReportEvidenceFolderInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.assessment_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/associateToAssessmentReport", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::AssociateAssessmentReportEvidenceFolderInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_assessment_report_evidence_folder(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::AssociateAssessmentReportEvidenceFolder::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("AssociateAssessmentReportEvidenceFolder", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`AssociateAssessmentReportEvidenceFolderInput`](crate::input::AssociateAssessmentReportEvidenceFolderInput).
    pub fn builder() -> crate::input::associate_assessment_report_evidence_folder_input::Builder {
        crate::input::associate_assessment_report_evidence_folder_input::Builder::default()
    }
}

/// See [`BatchAssociateAssessmentReportEvidenceInput`](crate::input::BatchAssociateAssessmentReportEvidenceInput).
pub mod batch_associate_assessment_report_evidence_input {
    
    /// A builder for [`BatchAssociateAssessmentReportEvidenceInput`](crate::input::BatchAssociateAssessmentReportEvidenceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
        pub(crate) evidence_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.evidence_folder_id = input; self
        }
        /// Appends an item to `evidence_ids`.
        ///
        /// To override the contents of this collection use [`set_evidence_ids`](Self::set_evidence_ids).
        ///
        /// <p> The list of evidence identifiers. </p>
        pub fn evidence_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.evidence_ids.unwrap_or_default();
                            v.push(input.into());
                            self.evidence_ids = Some(v);
                            self
        }
        /// <p> The list of evidence identifiers. </p>
        pub fn set_evidence_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.evidence_ids = input; self
        }
        /// Consumes the builder and constructs a [`BatchAssociateAssessmentReportEvidenceInput`](crate::input::BatchAssociateAssessmentReportEvidenceInput).
        pub fn build(self) -> Result<crate::input::BatchAssociateAssessmentReportEvidenceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchAssociateAssessmentReportEvidenceInput {
                    assessment_id: self.assessment_id
                    ,
                    evidence_folder_id: self.evidence_folder_id
                    ,
                    evidence_ids: self.evidence_ids
                    ,
                }
            )
        }
    }
    
    
}
impl BatchAssociateAssessmentReportEvidenceInput {
    /// Consumes the builder and constructs an Operation<[`BatchAssociateAssessmentReportEvidence`](crate::operation::BatchAssociateAssessmentReportEvidence)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchAssociateAssessmentReportEvidence, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchAssociateAssessmentReportEvidenceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_2 = &_input.assessment_id;
                let input_2 = input_2.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_2, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/batchAssociateToAssessmentReport", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchAssociateAssessmentReportEvidenceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_associate_assessment_report_evidence(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchAssociateAssessmentReportEvidence::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchAssociateAssessmentReportEvidence", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchAssociateAssessmentReportEvidenceInput`](crate::input::BatchAssociateAssessmentReportEvidenceInput).
    pub fn builder() -> crate::input::batch_associate_assessment_report_evidence_input::Builder {
        crate::input::batch_associate_assessment_report_evidence_input::Builder::default()
    }
}

/// See [`BatchCreateDelegationByAssessmentInput`](crate::input::BatchCreateDelegationByAssessmentInput).
pub mod batch_create_delegation_by_assessment_input {
    
    /// A builder for [`BatchCreateDelegationByAssessmentInput`](crate::input::BatchCreateDelegationByAssessmentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) create_delegation_requests: std::option::Option<std::vec::Vec<crate::model::CreateDelegationRequest>>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `create_delegation_requests`.
        ///
        /// To override the contents of this collection use [`set_create_delegation_requests`](Self::set_create_delegation_requests).
        ///
        /// <p> The API request to batch create delegations in Audit Manager. </p>
        pub fn create_delegation_requests(mut self, input: crate::model::CreateDelegationRequest) -> Self {
            let mut v = self.create_delegation_requests.unwrap_or_default();
                            v.push(input);
                            self.create_delegation_requests = Some(v);
                            self
        }
        /// <p> The API request to batch create delegations in Audit Manager. </p>
        pub fn set_create_delegation_requests(mut self, input: std::option::Option<std::vec::Vec<crate::model::CreateDelegationRequest>>) -> Self {
            self.create_delegation_requests = input; self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// Consumes the builder and constructs a [`BatchCreateDelegationByAssessmentInput`](crate::input::BatchCreateDelegationByAssessmentInput).
        pub fn build(self) -> Result<crate::input::BatchCreateDelegationByAssessmentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchCreateDelegationByAssessmentInput {
                    create_delegation_requests: self.create_delegation_requests
                    ,
                    assessment_id: self.assessment_id
                    ,
                }
            )
        }
    }
    
    
}
impl BatchCreateDelegationByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`BatchCreateDelegationByAssessment`](crate::operation::BatchCreateDelegationByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchCreateDelegationByAssessment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchCreateDelegationByAssessmentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.assessment_id;
                let input_3 = input_3.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_3, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/delegations", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchCreateDelegationByAssessmentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_create_delegation_by_assessment(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchCreateDelegationByAssessment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchCreateDelegationByAssessment", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchCreateDelegationByAssessmentInput`](crate::input::BatchCreateDelegationByAssessmentInput).
    pub fn builder() -> crate::input::batch_create_delegation_by_assessment_input::Builder {
        crate::input::batch_create_delegation_by_assessment_input::Builder::default()
    }
}

/// See [`BatchDeleteDelegationByAssessmentInput`](crate::input::BatchDeleteDelegationByAssessmentInput).
pub mod batch_delete_delegation_by_assessment_input {
    
    /// A builder for [`BatchDeleteDelegationByAssessmentInput`](crate::input::BatchDeleteDelegationByAssessmentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delegation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `delegation_ids`.
        ///
        /// To override the contents of this collection use [`set_delegation_ids`](Self::set_delegation_ids).
        ///
        /// <p> The identifiers for the delegations. </p>
        pub fn delegation_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.delegation_ids.unwrap_or_default();
                            v.push(input.into());
                            self.delegation_ids = Some(v);
                            self
        }
        /// <p> The identifiers for the delegations. </p>
        pub fn set_delegation_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.delegation_ids = input; self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// Consumes the builder and constructs a [`BatchDeleteDelegationByAssessmentInput`](crate::input::BatchDeleteDelegationByAssessmentInput).
        pub fn build(self) -> Result<crate::input::BatchDeleteDelegationByAssessmentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchDeleteDelegationByAssessmentInput {
                    delegation_ids: self.delegation_ids
                    ,
                    assessment_id: self.assessment_id
                    ,
                }
            )
        }
    }
    
    
}
impl BatchDeleteDelegationByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`BatchDeleteDelegationByAssessment`](crate::operation::BatchDeleteDelegationByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchDeleteDelegationByAssessment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchDeleteDelegationByAssessmentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.assessment_id;
                let input_4 = input_4.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_4, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/delegations", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchDeleteDelegationByAssessmentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_delete_delegation_by_assessment(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchDeleteDelegationByAssessment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchDeleteDelegationByAssessment", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchDeleteDelegationByAssessmentInput`](crate::input::BatchDeleteDelegationByAssessmentInput).
    pub fn builder() -> crate::input::batch_delete_delegation_by_assessment_input::Builder {
        crate::input::batch_delete_delegation_by_assessment_input::Builder::default()
    }
}

/// See [`BatchDisassociateAssessmentReportEvidenceInput`](crate::input::BatchDisassociateAssessmentReportEvidenceInput).
pub mod batch_disassociate_assessment_report_evidence_input {
    
    /// A builder for [`BatchDisassociateAssessmentReportEvidenceInput`](crate::input::BatchDisassociateAssessmentReportEvidenceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
        pub(crate) evidence_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.evidence_folder_id = input; self
        }
        /// Appends an item to `evidence_ids`.
        ///
        /// To override the contents of this collection use [`set_evidence_ids`](Self::set_evidence_ids).
        ///
        /// <p> The list of evidence identifiers. </p>
        pub fn evidence_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.evidence_ids.unwrap_or_default();
                            v.push(input.into());
                            self.evidence_ids = Some(v);
                            self
        }
        /// <p> The list of evidence identifiers. </p>
        pub fn set_evidence_ids(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.evidence_ids = input; self
        }
        /// Consumes the builder and constructs a [`BatchDisassociateAssessmentReportEvidenceInput`](crate::input::BatchDisassociateAssessmentReportEvidenceInput).
        pub fn build(self) -> Result<crate::input::BatchDisassociateAssessmentReportEvidenceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchDisassociateAssessmentReportEvidenceInput {
                    assessment_id: self.assessment_id
                    ,
                    evidence_folder_id: self.evidence_folder_id
                    ,
                    evidence_ids: self.evidence_ids
                    ,
                }
            )
        }
    }
    
    
}
impl BatchDisassociateAssessmentReportEvidenceInput {
    /// Consumes the builder and constructs an Operation<[`BatchDisassociateAssessmentReportEvidence`](crate::operation::BatchDisassociateAssessmentReportEvidence)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchDisassociateAssessmentReportEvidence, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchDisassociateAssessmentReportEvidenceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.assessment_id;
                let input_5 = input_5.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_5, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/batchDisassociateFromAssessmentReport", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchDisassociateAssessmentReportEvidenceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_disassociate_assessment_report_evidence(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchDisassociateAssessmentReportEvidence::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchDisassociateAssessmentReportEvidence", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchDisassociateAssessmentReportEvidenceInput`](crate::input::BatchDisassociateAssessmentReportEvidenceInput).
    pub fn builder() -> crate::input::batch_disassociate_assessment_report_evidence_input::Builder {
        crate::input::batch_disassociate_assessment_report_evidence_input::Builder::default()
    }
}

/// See [`BatchImportEvidenceToAssessmentControlInput`](crate::input::BatchImportEvidenceToAssessmentControlInput).
pub mod batch_import_evidence_to_assessment_control_input {
    
    /// A builder for [`BatchImportEvidenceToAssessmentControlInput`](crate::input::BatchImportEvidenceToAssessmentControlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) manual_evidence: std::option::Option<std::vec::Vec<crate::model::ManualEvidence>>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control set. </p>
        pub fn set_control_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_set_id = input; self
        }
        /// <p> The identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input; self
        }
        /// Appends an item to `manual_evidence`.
        ///
        /// To override the contents of this collection use [`set_manual_evidence`](Self::set_manual_evidence).
        ///
        /// <p> The list of manual evidence objects. </p>
        pub fn manual_evidence(mut self, input: crate::model::ManualEvidence) -> Self {
            let mut v = self.manual_evidence.unwrap_or_default();
                            v.push(input);
                            self.manual_evidence = Some(v);
                            self
        }
        /// <p> The list of manual evidence objects. </p>
        pub fn set_manual_evidence(mut self, input: std::option::Option<std::vec::Vec<crate::model::ManualEvidence>>) -> Self {
            self.manual_evidence = input; self
        }
        /// Consumes the builder and constructs a [`BatchImportEvidenceToAssessmentControlInput`](crate::input::BatchImportEvidenceToAssessmentControlInput).
        pub fn build(self) -> Result<crate::input::BatchImportEvidenceToAssessmentControlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchImportEvidenceToAssessmentControlInput {
                    assessment_id: self.assessment_id
                    ,
                    control_set_id: self.control_set_id
                    ,
                    control_id: self.control_id
                    ,
                    manual_evidence: self.manual_evidence
                    ,
                }
            )
        }
    }
    
    
}
impl BatchImportEvidenceToAssessmentControlInput {
    /// Consumes the builder and constructs an Operation<[`BatchImportEvidenceToAssessmentControl`](crate::operation::BatchImportEvidenceToAssessmentControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchImportEvidenceToAssessmentControl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchImportEvidenceToAssessmentControlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.assessment_id;
                let input_6 = input_6.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_6, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                let input_7 = &_input.control_set_id;
                let input_7 = input_7.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))?;
                let control_set_id = aws_smithy_http::label::fmt_string(input_7, aws_smithy_http::label::EncodingStrategy::Default);
                if control_set_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))
                            }
                let input_8 = &_input.control_id;
                let input_8 = input_8.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))?;
                let control_id = aws_smithy_http::label::fmt_string(input_8, aws_smithy_http::label::EncodingStrategy::Default);
                if control_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/controls/{controlId}/evidence", assessmentId = assessment_id, controlSetId = control_set_id, controlId = control_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchImportEvidenceToAssessmentControlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_import_evidence_to_assessment_control(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchImportEvidenceToAssessmentControl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchImportEvidenceToAssessmentControl", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchImportEvidenceToAssessmentControlInput`](crate::input::BatchImportEvidenceToAssessmentControlInput).
    pub fn builder() -> crate::input::batch_import_evidence_to_assessment_control_input::Builder {
        crate::input::batch_import_evidence_to_assessment_control_input::Builder::default()
    }
}

/// See [`CreateAssessmentInput`](crate::input::CreateAssessmentInput).
pub mod create_assessment_input {
    
    /// A builder for [`CreateAssessmentInput`](crate::input::CreateAssessmentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) assessment_reports_destination: std::option::Option<crate::model::AssessmentReportsDestination>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) roles: std::option::Option<std::vec::Vec<crate::model::Role>>,
        pub(crate) framework_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p> The name of the assessment to be created. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the assessment to be created. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p> The optional description of the assessment to be created. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The optional description of the assessment to be created. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p> The assessment report storage destination for the assessment that's being created. </p>
        pub fn assessment_reports_destination(mut self, input: crate::model::AssessmentReportsDestination) -> Self {
            self.assessment_reports_destination = Some(input);
            self
        }
        /// <p> The assessment report storage destination for the assessment that's being created. </p>
        pub fn set_assessment_reports_destination(mut self, input: std::option::Option<crate::model::AssessmentReportsDestination>) -> Self {
            self.assessment_reports_destination = input; self
        }
        /// <p> The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment. </p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p> The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment. </p>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input; self
        }
        /// Appends an item to `roles`.
        ///
        /// To override the contents of this collection use [`set_roles`](Self::set_roles).
        ///
        /// <p> The list of roles for the assessment. </p>
        pub fn roles(mut self, input: crate::model::Role) -> Self {
            let mut v = self.roles.unwrap_or_default();
                            v.push(input);
                            self.roles = Some(v);
                            self
        }
        /// <p> The list of roles for the assessment. </p>
        pub fn set_roles(mut self, input: std::option::Option<std::vec::Vec<crate::model::Role>>) -> Self {
            self.roles = input; self
        }
        /// <p> The identifier for the framework that the assessment will be created from. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The identifier for the framework that the assessment will be created from. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> The tags that are associated with the assessment. </p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p> The tags that are associated with the assessment. </p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateAssessmentInput`](crate::input::CreateAssessmentInput).
        pub fn build(self) -> Result<crate::input::CreateAssessmentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateAssessmentInput {
                    name: self.name
                    ,
                    description: self.description
                    ,
                    assessment_reports_destination: self.assessment_reports_destination
                    ,
                    scope: self.scope
                    ,
                    roles: self.roles
                    ,
                    framework_id: self.framework_id
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateAssessment`](crate::operation::CreateAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateAssessment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateAssessmentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessments").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateAssessmentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_assessment(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateAssessment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateAssessment", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAssessmentInput`](crate::input::CreateAssessmentInput).
    pub fn builder() -> crate::input::create_assessment_input::Builder {
        crate::input::create_assessment_input::Builder::default()
    }
}

/// See [`CreateAssessmentFrameworkInput`](crate::input::CreateAssessmentFrameworkInput).
pub mod create_assessment_framework_input {
    
    /// A builder for [`CreateAssessmentFrameworkInput`](crate::input::CreateAssessmentFrameworkInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) compliance_type: std::option::Option<std::string::String>,
        pub(crate) control_sets: std::option::Option<std::vec::Vec<crate::model::CreateAssessmentFrameworkControlSet>>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p> The name of the new custom framework. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the new custom framework. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p> An optional description for the new custom framework. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> An optional description for the new custom framework. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
        pub fn compliance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_type = Some(input.into());
            self
        }
        /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
        pub fn set_compliance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.compliance_type = input; self
        }
        /// Appends an item to `control_sets`.
        ///
        /// To override the contents of this collection use [`set_control_sets`](Self::set_control_sets).
        ///
        /// <p> The control sets that are associated with the framework. </p>
        pub fn control_sets(mut self, input: crate::model::CreateAssessmentFrameworkControlSet) -> Self {
            let mut v = self.control_sets.unwrap_or_default();
                            v.push(input);
                            self.control_sets = Some(v);
                            self
        }
        /// <p> The control sets that are associated with the framework. </p>
        pub fn set_control_sets(mut self, input: std::option::Option<std::vec::Vec<crate::model::CreateAssessmentFrameworkControlSet>>) -> Self {
            self.control_sets = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> The tags that are associated with the framework. </p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p> The tags that are associated with the framework. </p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateAssessmentFrameworkInput`](crate::input::CreateAssessmentFrameworkInput).
        pub fn build(self) -> Result<crate::input::CreateAssessmentFrameworkInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateAssessmentFrameworkInput {
                    name: self.name
                    ,
                    description: self.description
                    ,
                    compliance_type: self.compliance_type
                    ,
                    control_sets: self.control_sets
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateAssessmentFrameworkInput {
    /// Consumes the builder and constructs an Operation<[`CreateAssessmentFramework`](crate::operation::CreateAssessmentFramework)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateAssessmentFramework, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateAssessmentFrameworkInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentFrameworks").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateAssessmentFrameworkInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_assessment_framework(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateAssessmentFramework::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateAssessmentFramework", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAssessmentFrameworkInput`](crate::input::CreateAssessmentFrameworkInput).
    pub fn builder() -> crate::input::create_assessment_framework_input::Builder {
        crate::input::create_assessment_framework_input::Builder::default()
    }
}

/// See [`CreateAssessmentReportInput`](crate::input::CreateAssessmentReportInput).
pub mod create_assessment_report_input {
    
    /// A builder for [`CreateAssessmentReportInput`](crate::input::CreateAssessmentReportInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) query_statement: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the new assessment report. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the new assessment report. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p> The description of the assessment report. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The description of the assessment report. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p>A SQL statement that represents an evidence finder query.</p> 
        /// <p>Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence">added to a report using the console</a>, or <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html">associated with a report using the API</a>. </p> 
        /// <p>To use this parameter, the <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus">enablementStatus</a> of evidence finder must be <code>ENABLED</code>. </p> 
        /// <p> For examples and help resolving <code>queryStatement</code> validation exceptions, see <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions">Troubleshooting evidence finder issues</a> in the <i>Audit Manager User Guide.</i> </p>
        pub fn query_statement(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_statement = Some(input.into());
            self
        }
        /// <p>A SQL statement that represents an evidence finder query.</p> 
        /// <p>Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence">added to a report using the console</a>, or <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html">associated with a report using the API</a>. </p> 
        /// <p>To use this parameter, the <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus">enablementStatus</a> of evidence finder must be <code>ENABLED</code>. </p> 
        /// <p> For examples and help resolving <code>queryStatement</code> validation exceptions, see <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions">Troubleshooting evidence finder issues</a> in the <i>Audit Manager User Guide.</i> </p>
        pub fn set_query_statement(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_statement = input; self
        }
        /// Consumes the builder and constructs a [`CreateAssessmentReportInput`](crate::input::CreateAssessmentReportInput).
        pub fn build(self) -> Result<crate::input::CreateAssessmentReportInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateAssessmentReportInput {
                    name: self.name
                    ,
                    description: self.description
                    ,
                    assessment_id: self.assessment_id
                    ,
                    query_statement: self.query_statement
                    ,
                }
            )
        }
    }
    
    
}
impl CreateAssessmentReportInput {
    /// Consumes the builder and constructs an Operation<[`CreateAssessmentReport`](crate::operation::CreateAssessmentReport)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateAssessmentReport, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateAssessmentReportInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.assessment_id;
                let input_9 = input_9.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_9, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/reports", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateAssessmentReportInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_assessment_report(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateAssessmentReport::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateAssessmentReport", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAssessmentReportInput`](crate::input::CreateAssessmentReportInput).
    pub fn builder() -> crate::input::create_assessment_report_input::Builder {
        crate::input::create_assessment_report_input::Builder::default()
    }
}

/// See [`CreateControlInput`](crate::input::CreateControlInput).
pub mod create_control_input {
    
    /// A builder for [`CreateControlInput`](crate::input::CreateControlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) testing_information: std::option::Option<std::string::String>,
        pub(crate) action_plan_title: std::option::Option<std::string::String>,
        pub(crate) action_plan_instructions: std::option::Option<std::string::String>,
        pub(crate) control_mapping_sources: std::option::Option<std::vec::Vec<crate::model::CreateControlMappingSource>>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p> The name of the control. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the control. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p> The description of the control. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The description of the control. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p> The steps to follow to determine if the control is satisfied. </p>
        pub fn testing_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.testing_information = Some(input.into());
            self
        }
        /// <p> The steps to follow to determine if the control is satisfied. </p>
        pub fn set_testing_information(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.testing_information = input; self
        }
        /// <p> The title of the action plan for remediating the control. </p>
        pub fn action_plan_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_plan_title = Some(input.into());
            self
        }
        /// <p> The title of the action plan for remediating the control. </p>
        pub fn set_action_plan_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_plan_title = input; self
        }
        /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
        pub fn action_plan_instructions(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_plan_instructions = Some(input.into());
            self
        }
        /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
        pub fn set_action_plan_instructions(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_plan_instructions = input; self
        }
        /// Appends an item to `control_mapping_sources`.
        ///
        /// To override the contents of this collection use [`set_control_mapping_sources`](Self::set_control_mapping_sources).
        ///
        /// <p> The data mapping sources for the control. </p>
        pub fn control_mapping_sources(mut self, input: crate::model::CreateControlMappingSource) -> Self {
            let mut v = self.control_mapping_sources.unwrap_or_default();
                            v.push(input);
                            self.control_mapping_sources = Some(v);
                            self
        }
        /// <p> The data mapping sources for the control. </p>
        pub fn set_control_mapping_sources(mut self, input: std::option::Option<std::vec::Vec<crate::model::CreateControlMappingSource>>) -> Self {
            self.control_mapping_sources = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> The tags that are associated with the control. </p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p> The tags that are associated with the control. </p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateControlInput`](crate::input::CreateControlInput).
        pub fn build(self) -> Result<crate::input::CreateControlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateControlInput {
                    name: self.name
                    ,
                    description: self.description
                    ,
                    testing_information: self.testing_information
                    ,
                    action_plan_title: self.action_plan_title
                    ,
                    action_plan_instructions: self.action_plan_instructions
                    ,
                    control_mapping_sources: self.control_mapping_sources
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateControlInput {
    /// Consumes the builder and constructs an Operation<[`CreateControl`](crate::operation::CreateControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateControl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateControlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/controls").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateControlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_control(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateControl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateControl", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateControlInput`](crate::input::CreateControlInput).
    pub fn builder() -> crate::input::create_control_input::Builder {
        crate::input::create_control_input::Builder::default()
    }
}

/// See [`DeleteAssessmentInput`](crate::input::DeleteAssessmentInput).
pub mod delete_assessment_input {
    
    /// A builder for [`DeleteAssessmentInput`](crate::input::DeleteAssessmentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteAssessmentInput`](crate::input::DeleteAssessmentInput).
        pub fn build(self) -> Result<crate::input::DeleteAssessmentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteAssessmentInput {
                    assessment_id: self.assessment_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAssessment`](crate::operation::DeleteAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteAssessment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteAssessmentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.assessment_id;
                let input_10 = input_10.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_10, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteAssessmentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteAssessment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteAssessment", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAssessmentInput`](crate::input::DeleteAssessmentInput).
    pub fn builder() -> crate::input::delete_assessment_input::Builder {
        crate::input::delete_assessment_input::Builder::default()
    }
}

/// See [`DeleteAssessmentFrameworkInput`](crate::input::DeleteAssessmentFrameworkInput).
pub mod delete_assessment_framework_input {
    
    /// A builder for [`DeleteAssessmentFrameworkInput`](crate::input::DeleteAssessmentFrameworkInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the custom framework. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The identifier for the custom framework. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteAssessmentFrameworkInput`](crate::input::DeleteAssessmentFrameworkInput).
        pub fn build(self) -> Result<crate::input::DeleteAssessmentFrameworkInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteAssessmentFrameworkInput {
                    framework_id: self.framework_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteAssessmentFrameworkInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAssessmentFramework`](crate::operation::DeleteAssessmentFramework)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteAssessmentFramework, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteAssessmentFrameworkInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_11 = &_input.framework_id;
                let input_11 = input_11.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("framework_id", "cannot be empty or unset"))?;
                let framework_id = aws_smithy_http::label::fmt_string(input_11, aws_smithy_http::label::EncodingStrategy::Default);
                if framework_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("framework_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessmentFrameworks/{frameworkId}", frameworkId = framework_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteAssessmentFrameworkInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteAssessmentFramework::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteAssessmentFramework", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAssessmentFrameworkInput`](crate::input::DeleteAssessmentFrameworkInput).
    pub fn builder() -> crate::input::delete_assessment_framework_input::Builder {
        crate::input::delete_assessment_framework_input::Builder::default()
    }
}

/// See [`DeleteAssessmentFrameworkShareInput`](crate::input::DeleteAssessmentFrameworkShareInput).
pub mod delete_assessment_framework_share_input {
    
    /// A builder for [`DeleteAssessmentFrameworkShareInput`](crate::input::DeleteAssessmentFrameworkShareInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) request_type: std::option::Option<crate::model::ShareRequestType>,
    }
    impl Builder {
        /// <p>The unique identifier for the share request to be deleted.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the share request to be deleted.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input; self
        }
        /// <p>Specifies whether the share request is a sent request or a received request.</p>
        pub fn request_type(mut self, input: crate::model::ShareRequestType) -> Self {
            self.request_type = Some(input);
            self
        }
        /// <p>Specifies whether the share request is a sent request or a received request.</p>
        pub fn set_request_type(mut self, input: std::option::Option<crate::model::ShareRequestType>) -> Self {
            self.request_type = input; self
        }
        /// Consumes the builder and constructs a [`DeleteAssessmentFrameworkShareInput`](crate::input::DeleteAssessmentFrameworkShareInput).
        pub fn build(self) -> Result<crate::input::DeleteAssessmentFrameworkShareInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteAssessmentFrameworkShareInput {
                    request_id: self.request_id
                    ,
                    request_type: self.request_type
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteAssessmentFrameworkShareInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAssessmentFrameworkShare`](crate::operation::DeleteAssessmentFrameworkShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteAssessmentFrameworkShare, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteAssessmentFrameworkShareInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_12 = &_input.request_id;
                let input_12 = input_12.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("request_id", "cannot be empty or unset"))?;
                let request_id = aws_smithy_http::label::fmt_string(input_12, aws_smithy_http::label::EncodingStrategy::Default);
                if request_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("request_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessmentFrameworkShareRequests/{requestId}", requestId = request_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteAssessmentFrameworkShareInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_13 = &_input.request_type;
                let inner_13 = inner_13.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("request_type", "cannot be empty or unset"))?;
                query.push_kv("requestType", &aws_smithy_http::query::fmt_string(&inner_13));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteAssessmentFrameworkShareInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteAssessmentFrameworkShare::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteAssessmentFrameworkShare", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAssessmentFrameworkShareInput`](crate::input::DeleteAssessmentFrameworkShareInput).
    pub fn builder() -> crate::input::delete_assessment_framework_share_input::Builder {
        crate::input::delete_assessment_framework_share_input::Builder::default()
    }
}

/// See [`DeleteAssessmentReportInput`](crate::input::DeleteAssessmentReportInput).
pub mod delete_assessment_report_input {
    
    /// A builder for [`DeleteAssessmentReportInput`](crate::input::DeleteAssessmentReportInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) assessment_report_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The unique identifier for the assessment report. </p>
        pub fn assessment_report_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_report_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment report. </p>
        pub fn set_assessment_report_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_report_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteAssessmentReportInput`](crate::input::DeleteAssessmentReportInput).
        pub fn build(self) -> Result<crate::input::DeleteAssessmentReportInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteAssessmentReportInput {
                    assessment_id: self.assessment_id
                    ,
                    assessment_report_id: self.assessment_report_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteAssessmentReportInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAssessmentReport`](crate::operation::DeleteAssessmentReport)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteAssessmentReport, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteAssessmentReportInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_14 = &_input.assessment_id;
                let input_14 = input_14.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_14, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                let input_15 = &_input.assessment_report_id;
                let input_15 = input_15.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_report_id", "cannot be empty or unset"))?;
                let assessment_report_id = aws_smithy_http::label::fmt_string(input_15, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_report_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_report_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/reports/{assessmentReportId}", assessmentId = assessment_id, assessmentReportId = assessment_report_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteAssessmentReportInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteAssessmentReport::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteAssessmentReport", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAssessmentReportInput`](crate::input::DeleteAssessmentReportInput).
    pub fn builder() -> crate::input::delete_assessment_report_input::Builder {
        crate::input::delete_assessment_report_input::Builder::default()
    }
}

/// See [`DeleteControlInput`](crate::input::DeleteControlInput).
pub mod delete_control_input {
    
    /// A builder for [`DeleteControlInput`](crate::input::DeleteControlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteControlInput`](crate::input::DeleteControlInput).
        pub fn build(self) -> Result<crate::input::DeleteControlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteControlInput {
                    control_id: self.control_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteControlInput {
    /// Consumes the builder and constructs an Operation<[`DeleteControl`](crate::operation::DeleteControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteControl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteControlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.control_id;
                let input_16 = input_16.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))?;
                let control_id = aws_smithy_http::label::fmt_string(input_16, aws_smithy_http::label::EncodingStrategy::Default);
                if control_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))
                            }
                write!(output, "/controls/{controlId}", controlId = control_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteControlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteControl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteControl", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteControlInput`](crate::input::DeleteControlInput).
    pub fn builder() -> crate::input::delete_control_input::Builder {
        crate::input::delete_control_input::Builder::default()
    }
}

/// See [`DeregisterAccountInput`](crate::input::DeregisterAccountInput).
pub mod deregister_account_input {
    
    /// A builder for [`DeregisterAccountInput`](crate::input::DeregisterAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeregisterAccountInput`](crate::input::DeregisterAccountInput).
        pub fn build(self) -> Result<crate::input::DeregisterAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeregisterAccountInput {
                }
            )
        }
    }
    
    
}
impl DeregisterAccountInput {
    /// Consumes the builder and constructs an Operation<[`DeregisterAccount`](crate::operation::DeregisterAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeregisterAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeregisterAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/deregisterAccount").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeregisterAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeregisterAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeregisterAccount", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeregisterAccountInput`](crate::input::DeregisterAccountInput).
    pub fn builder() -> crate::input::deregister_account_input::Builder {
        crate::input::deregister_account_input::Builder::default()
    }
}

/// See [`DeregisterOrganizationAdminAccountInput`](crate::input::DeregisterOrganizationAdminAccountInput).
pub mod deregister_organization_admin_account_input {
    
    /// A builder for [`DeregisterOrganizationAdminAccountInput`](crate::input::DeregisterOrganizationAdminAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) admin_account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the administrator account. </p>
        pub fn admin_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_account_id = Some(input.into());
            self
        }
        /// <p> The identifier for the administrator account. </p>
        pub fn set_admin_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.admin_account_id = input; self
        }
        /// Consumes the builder and constructs a [`DeregisterOrganizationAdminAccountInput`](crate::input::DeregisterOrganizationAdminAccountInput).
        pub fn build(self) -> Result<crate::input::DeregisterOrganizationAdminAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeregisterOrganizationAdminAccountInput {
                    admin_account_id: self.admin_account_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeregisterOrganizationAdminAccountInput {
    /// Consumes the builder and constructs an Operation<[`DeregisterOrganizationAdminAccount`](crate::operation::DeregisterOrganizationAdminAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeregisterOrganizationAdminAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeregisterOrganizationAdminAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/deregisterOrganizationAdminAccount").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeregisterOrganizationAdminAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_deregister_organization_admin_account(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeregisterOrganizationAdminAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeregisterOrganizationAdminAccount", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeregisterOrganizationAdminAccountInput`](crate::input::DeregisterOrganizationAdminAccountInput).
    pub fn builder() -> crate::input::deregister_organization_admin_account_input::Builder {
        crate::input::deregister_organization_admin_account_input::Builder::default()
    }
}

/// See [`DisassociateAssessmentReportEvidenceFolderInput`](crate::input::DisassociateAssessmentReportEvidenceFolderInput).
pub mod disassociate_assessment_report_evidence_folder_input {
    
    /// A builder for [`DisassociateAssessmentReportEvidenceFolderInput`](crate::input::DisassociateAssessmentReportEvidenceFolderInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.evidence_folder_id = input; self
        }
        /// Consumes the builder and constructs a [`DisassociateAssessmentReportEvidenceFolderInput`](crate::input::DisassociateAssessmentReportEvidenceFolderInput).
        pub fn build(self) -> Result<crate::input::DisassociateAssessmentReportEvidenceFolderInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DisassociateAssessmentReportEvidenceFolderInput {
                    assessment_id: self.assessment_id
                    ,
                    evidence_folder_id: self.evidence_folder_id
                    ,
                }
            )
        }
    }
    
    
}
impl DisassociateAssessmentReportEvidenceFolderInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateAssessmentReportEvidenceFolder`](crate::operation::DisassociateAssessmentReportEvidenceFolder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DisassociateAssessmentReportEvidenceFolder, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DisassociateAssessmentReportEvidenceFolderInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_17 = &_input.assessment_id;
                let input_17 = input_17.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_17, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/disassociateFromAssessmentReport", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DisassociateAssessmentReportEvidenceFolderInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_disassociate_assessment_report_evidence_folder(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DisassociateAssessmentReportEvidenceFolder::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DisassociateAssessmentReportEvidenceFolder", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisassociateAssessmentReportEvidenceFolderInput`](crate::input::DisassociateAssessmentReportEvidenceFolderInput).
    pub fn builder() -> crate::input::disassociate_assessment_report_evidence_folder_input::Builder {
        crate::input::disassociate_assessment_report_evidence_folder_input::Builder::default()
    }
}

/// See [`GetAccountStatusInput`](crate::input::GetAccountStatusInput).
pub mod get_account_status_input {
    
    /// A builder for [`GetAccountStatusInput`](crate::input::GetAccountStatusInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`GetAccountStatusInput`](crate::input::GetAccountStatusInput).
        pub fn build(self) -> Result<crate::input::GetAccountStatusInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAccountStatusInput {
                }
            )
        }
    }
    
    
}
impl GetAccountStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetAccountStatus`](crate::operation::GetAccountStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAccountStatus, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAccountStatusInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/status").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAccountStatusInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAccountStatus::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAccountStatus", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAccountStatusInput`](crate::input::GetAccountStatusInput).
    pub fn builder() -> crate::input::get_account_status_input::Builder {
        crate::input::get_account_status_input::Builder::default()
    }
}

/// See [`GetAssessmentInput`](crate::input::GetAssessmentInput).
pub mod get_assessment_input {
    
    /// A builder for [`GetAssessmentInput`](crate::input::GetAssessmentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// Consumes the builder and constructs a [`GetAssessmentInput`](crate::input::GetAssessmentInput).
        pub fn build(self) -> Result<crate::input::GetAssessmentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAssessmentInput {
                    assessment_id: self.assessment_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`GetAssessment`](crate::operation::GetAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAssessment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAssessmentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_18 = &_input.assessment_id;
                let input_18 = input_18.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_18, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAssessmentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAssessment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAssessment", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAssessmentInput`](crate::input::GetAssessmentInput).
    pub fn builder() -> crate::input::get_assessment_input::Builder {
        crate::input::get_assessment_input::Builder::default()
    }
}

/// See [`GetAssessmentFrameworkInput`](crate::input::GetAssessmentFrameworkInput).
pub mod get_assessment_framework_input {
    
    /// A builder for [`GetAssessmentFrameworkInput`](crate::input::GetAssessmentFrameworkInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the framework. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The identifier for the framework. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input; self
        }
        /// Consumes the builder and constructs a [`GetAssessmentFrameworkInput`](crate::input::GetAssessmentFrameworkInput).
        pub fn build(self) -> Result<crate::input::GetAssessmentFrameworkInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAssessmentFrameworkInput {
                    framework_id: self.framework_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetAssessmentFrameworkInput {
    /// Consumes the builder and constructs an Operation<[`GetAssessmentFramework`](crate::operation::GetAssessmentFramework)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAssessmentFramework, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAssessmentFrameworkInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_19 = &_input.framework_id;
                let input_19 = input_19.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("framework_id", "cannot be empty or unset"))?;
                let framework_id = aws_smithy_http::label::fmt_string(input_19, aws_smithy_http::label::EncodingStrategy::Default);
                if framework_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("framework_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessmentFrameworks/{frameworkId}", frameworkId = framework_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAssessmentFrameworkInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAssessmentFramework::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAssessmentFramework", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAssessmentFrameworkInput`](crate::input::GetAssessmentFrameworkInput).
    pub fn builder() -> crate::input::get_assessment_framework_input::Builder {
        crate::input::get_assessment_framework_input::Builder::default()
    }
}

/// See [`GetAssessmentReportUrlInput`](crate::input::GetAssessmentReportUrlInput).
pub mod get_assessment_report_url_input {
    
    /// A builder for [`GetAssessmentReportUrlInput`](crate::input::GetAssessmentReportUrlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_report_id: std::option::Option<std::string::String>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment report. </p>
        pub fn assessment_report_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_report_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment report. </p>
        pub fn set_assessment_report_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_report_id = input; self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// Consumes the builder and constructs a [`GetAssessmentReportUrlInput`](crate::input::GetAssessmentReportUrlInput).
        pub fn build(self) -> Result<crate::input::GetAssessmentReportUrlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetAssessmentReportUrlInput {
                    assessment_report_id: self.assessment_report_id
                    ,
                    assessment_id: self.assessment_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetAssessmentReportUrlInput {
    /// Consumes the builder and constructs an Operation<[`GetAssessmentReportUrl`](crate::operation::GetAssessmentReportUrl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetAssessmentReportUrl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetAssessmentReportUrlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_20 = &_input.assessment_id;
                let input_20 = input_20.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_20, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                let input_21 = &_input.assessment_report_id;
                let input_21 = input_21.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_report_id", "cannot be empty or unset"))?;
                let assessment_report_id = aws_smithy_http::label::fmt_string(input_21, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_report_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_report_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/reports/{assessmentReportId}/url", assessmentId = assessment_id, assessmentReportId = assessment_report_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetAssessmentReportUrlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetAssessmentReportUrl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetAssessmentReportUrl", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetAssessmentReportUrlInput`](crate::input::GetAssessmentReportUrlInput).
    pub fn builder() -> crate::input::get_assessment_report_url_input::Builder {
        crate::input::get_assessment_report_url_input::Builder::default()
    }
}

/// See [`GetChangeLogsInput`](crate::input::GetChangeLogsInput).
pub mod get_change_logs_input {
    
    /// A builder for [`GetChangeLogsInput`](crate::input::GetChangeLogsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_set_id = input; self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input; self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`GetChangeLogsInput`](crate::input::GetChangeLogsInput).
        pub fn build(self) -> Result<crate::input::GetChangeLogsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetChangeLogsInput {
                    assessment_id: self.assessment_id
                    ,
                    control_set_id: self.control_set_id
                    ,
                    control_id: self.control_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl GetChangeLogsInput {
    /// Consumes the builder and constructs an Operation<[`GetChangeLogs`](crate::operation::GetChangeLogs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetChangeLogs, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetChangeLogsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_22 = &_input.assessment_id;
                let input_22 = input_22.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_22, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/changelogs", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetChangeLogsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_23) = &_input.control_set_id {
                     {
                        query.push_kv("controlSetId", &aws_smithy_http::query::fmt_string(&inner_23));
                    }
                }
                if let Some(inner_24) = &_input.control_id {
                     {
                        query.push_kv("controlId", &aws_smithy_http::query::fmt_string(&inner_24));
                    }
                }
                if let Some(inner_25) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_25));
                    }
                }
                if let Some(inner_26) = &_input.max_results {
                    if *inner_26 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_26).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetChangeLogsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetChangeLogs::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetChangeLogs", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetChangeLogsInput`](crate::input::GetChangeLogsInput).
    pub fn builder() -> crate::input::get_change_logs_input::Builder {
        crate::input::get_change_logs_input::Builder::default()
    }
}

/// See [`GetControlInput`](crate::input::GetControlInput).
pub mod get_control_input {
    
    /// A builder for [`GetControlInput`](crate::input::GetControlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input; self
        }
        /// Consumes the builder and constructs a [`GetControlInput`](crate::input::GetControlInput).
        pub fn build(self) -> Result<crate::input::GetControlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetControlInput {
                    control_id: self.control_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetControlInput {
    /// Consumes the builder and constructs an Operation<[`GetControl`](crate::operation::GetControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetControl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetControlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_27 = &_input.control_id;
                let input_27 = input_27.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))?;
                let control_id = aws_smithy_http::label::fmt_string(input_27, aws_smithy_http::label::EncodingStrategy::Default);
                if control_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))
                            }
                write!(output, "/controls/{controlId}", controlId = control_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetControlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetControl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetControl", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetControlInput`](crate::input::GetControlInput).
    pub fn builder() -> crate::input::get_control_input::Builder {
        crate::input::get_control_input::Builder::default()
    }
}

/// See [`GetDelegationsInput`](crate::input::GetDelegationsInput).
pub mod get_delegations_input {
    
    /// A builder for [`GetDelegationsInput`](crate::input::GetDelegationsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`GetDelegationsInput`](crate::input::GetDelegationsInput).
        pub fn build(self) -> Result<crate::input::GetDelegationsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDelegationsInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl GetDelegationsInput {
    /// Consumes the builder and constructs an Operation<[`GetDelegations`](crate::operation::GetDelegations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDelegations, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDelegationsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/delegations").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetDelegationsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_28) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_28));
                    }
                }
                if let Some(inner_29) = &_input.max_results {
                    if *inner_29 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_29).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDelegationsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDelegations::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDelegations", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDelegationsInput`](crate::input::GetDelegationsInput).
    pub fn builder() -> crate::input::get_delegations_input::Builder {
        crate::input::get_delegations_input::Builder::default()
    }
}

/// See [`GetEvidenceInput`](crate::input::GetEvidenceInput).
pub mod get_evidence_input {
    
    /// A builder for [`GetEvidenceInput`](crate::input::GetEvidenceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
        pub(crate) evidence_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_set_id = input; self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.evidence_folder_id = input; self
        }
        /// <p> The unique identifier for the evidence. </p>
        pub fn evidence_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the evidence. </p>
        pub fn set_evidence_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.evidence_id = input; self
        }
        /// Consumes the builder and constructs a [`GetEvidenceInput`](crate::input::GetEvidenceInput).
        pub fn build(self) -> Result<crate::input::GetEvidenceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetEvidenceInput {
                    assessment_id: self.assessment_id
                    ,
                    control_set_id: self.control_set_id
                    ,
                    evidence_folder_id: self.evidence_folder_id
                    ,
                    evidence_id: self.evidence_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetEvidenceInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidence`](crate::operation::GetEvidence)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetEvidence, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetEvidenceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_30 = &_input.assessment_id;
                let input_30 = input_30.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_30, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                let input_31 = &_input.control_set_id;
                let input_31 = input_31.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))?;
                let control_set_id = aws_smithy_http::label::fmt_string(input_31, aws_smithy_http::label::EncodingStrategy::Default);
                if control_set_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))
                            }
                let input_32 = &_input.evidence_folder_id;
                let input_32 = input_32.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("evidence_folder_id", "cannot be empty or unset"))?;
                let evidence_folder_id = aws_smithy_http::label::fmt_string(input_32, aws_smithy_http::label::EncodingStrategy::Default);
                if evidence_folder_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("evidence_folder_id", "cannot be empty or unset"))
                            }
                let input_33 = &_input.evidence_id;
                let input_33 = input_33.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("evidence_id", "cannot be empty or unset"))?;
                let evidence_id = aws_smithy_http::label::fmt_string(input_33, aws_smithy_http::label::EncodingStrategy::Default);
                if evidence_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("evidence_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/evidenceFolders/{evidenceFolderId}/evidence/{evidenceId}", assessmentId = assessment_id, controlSetId = control_set_id, evidenceFolderId = evidence_folder_id, evidenceId = evidence_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetEvidenceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetEvidence::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetEvidence", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetEvidenceInput`](crate::input::GetEvidenceInput).
    pub fn builder() -> crate::input::get_evidence_input::Builder {
        crate::input::get_evidence_input::Builder::default()
    }
}

/// See [`GetEvidenceByEvidenceFolderInput`](crate::input::GetEvidenceByEvidenceFolderInput).
pub mod get_evidence_by_evidence_folder_input {
    
    /// A builder for [`GetEvidenceByEvidenceFolderInput`](crate::input::GetEvidenceByEvidenceFolderInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control set. </p>
        pub fn set_control_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_set_id = input; self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.evidence_folder_id = input; self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`GetEvidenceByEvidenceFolderInput`](crate::input::GetEvidenceByEvidenceFolderInput).
        pub fn build(self) -> Result<crate::input::GetEvidenceByEvidenceFolderInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetEvidenceByEvidenceFolderInput {
                    assessment_id: self.assessment_id
                    ,
                    control_set_id: self.control_set_id
                    ,
                    evidence_folder_id: self.evidence_folder_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl GetEvidenceByEvidenceFolderInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidenceByEvidenceFolder`](crate::operation::GetEvidenceByEvidenceFolder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetEvidenceByEvidenceFolder, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetEvidenceByEvidenceFolderInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_34 = &_input.assessment_id;
                let input_34 = input_34.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_34, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                let input_35 = &_input.control_set_id;
                let input_35 = input_35.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))?;
                let control_set_id = aws_smithy_http::label::fmt_string(input_35, aws_smithy_http::label::EncodingStrategy::Default);
                if control_set_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))
                            }
                let input_36 = &_input.evidence_folder_id;
                let input_36 = input_36.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("evidence_folder_id", "cannot be empty or unset"))?;
                let evidence_folder_id = aws_smithy_http::label::fmt_string(input_36, aws_smithy_http::label::EncodingStrategy::Default);
                if evidence_folder_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("evidence_folder_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/evidenceFolders/{evidenceFolderId}/evidence", assessmentId = assessment_id, controlSetId = control_set_id, evidenceFolderId = evidence_folder_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetEvidenceByEvidenceFolderInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_37) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_37));
                    }
                }
                if let Some(inner_38) = &_input.max_results {
                    if *inner_38 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_38).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetEvidenceByEvidenceFolderInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetEvidenceByEvidenceFolder::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetEvidenceByEvidenceFolder", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetEvidenceByEvidenceFolderInput`](crate::input::GetEvidenceByEvidenceFolderInput).
    pub fn builder() -> crate::input::get_evidence_by_evidence_folder_input::Builder {
        crate::input::get_evidence_by_evidence_folder_input::Builder::default()
    }
}

/// See [`GetEvidenceFolderInput`](crate::input::GetEvidenceFolderInput).
pub mod get_evidence_folder_input {
    
    /// A builder for [`GetEvidenceFolderInput`](crate::input::GetEvidenceFolderInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) evidence_folder_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_set_id = input; self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn evidence_folder_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.evidence_folder_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the folder that the evidence is stored in. </p>
        pub fn set_evidence_folder_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.evidence_folder_id = input; self
        }
        /// Consumes the builder and constructs a [`GetEvidenceFolderInput`](crate::input::GetEvidenceFolderInput).
        pub fn build(self) -> Result<crate::input::GetEvidenceFolderInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetEvidenceFolderInput {
                    assessment_id: self.assessment_id
                    ,
                    control_set_id: self.control_set_id
                    ,
                    evidence_folder_id: self.evidence_folder_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetEvidenceFolderInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidenceFolder`](crate::operation::GetEvidenceFolder)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetEvidenceFolder, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetEvidenceFolderInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_39 = &_input.assessment_id;
                let input_39 = input_39.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_39, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                let input_40 = &_input.control_set_id;
                let input_40 = input_40.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))?;
                let control_set_id = aws_smithy_http::label::fmt_string(input_40, aws_smithy_http::label::EncodingStrategy::Default);
                if control_set_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))
                            }
                let input_41 = &_input.evidence_folder_id;
                let input_41 = input_41.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("evidence_folder_id", "cannot be empty or unset"))?;
                let evidence_folder_id = aws_smithy_http::label::fmt_string(input_41, aws_smithy_http::label::EncodingStrategy::Default);
                if evidence_folder_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("evidence_folder_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/evidenceFolders/{evidenceFolderId}", assessmentId = assessment_id, controlSetId = control_set_id, evidenceFolderId = evidence_folder_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetEvidenceFolderInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetEvidenceFolder::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetEvidenceFolder", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetEvidenceFolderInput`](crate::input::GetEvidenceFolderInput).
    pub fn builder() -> crate::input::get_evidence_folder_input::Builder {
        crate::input::get_evidence_folder_input::Builder::default()
    }
}

/// See [`GetEvidenceFoldersByAssessmentInput`](crate::input::GetEvidenceFoldersByAssessmentInput).
pub mod get_evidence_folders_by_assessment_input {
    
    /// A builder for [`GetEvidenceFoldersByAssessmentInput`](crate::input::GetEvidenceFoldersByAssessmentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`GetEvidenceFoldersByAssessmentInput`](crate::input::GetEvidenceFoldersByAssessmentInput).
        pub fn build(self) -> Result<crate::input::GetEvidenceFoldersByAssessmentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetEvidenceFoldersByAssessmentInput {
                    assessment_id: self.assessment_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl GetEvidenceFoldersByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidenceFoldersByAssessment`](crate::operation::GetEvidenceFoldersByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetEvidenceFoldersByAssessment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetEvidenceFoldersByAssessmentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_42 = &_input.assessment_id;
                let input_42 = input_42.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_42, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/evidenceFolders", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetEvidenceFoldersByAssessmentInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_43) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_43));
                    }
                }
                if let Some(inner_44) = &_input.max_results {
                    if *inner_44 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_44).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetEvidenceFoldersByAssessmentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetEvidenceFoldersByAssessment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetEvidenceFoldersByAssessment", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetEvidenceFoldersByAssessmentInput`](crate::input::GetEvidenceFoldersByAssessmentInput).
    pub fn builder() -> crate::input::get_evidence_folders_by_assessment_input::Builder {
        crate::input::get_evidence_folders_by_assessment_input::Builder::default()
    }
}

/// See [`GetEvidenceFoldersByAssessmentControlInput`](crate::input::GetEvidenceFoldersByAssessmentControlInput).
pub mod get_evidence_folders_by_assessment_control_input {
    
    /// A builder for [`GetEvidenceFoldersByAssessmentControlInput`](crate::input::GetEvidenceFoldersByAssessmentControlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control set. </p>
        pub fn set_control_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_set_id = input; self
        }
        /// <p> The identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input; self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`GetEvidenceFoldersByAssessmentControlInput`](crate::input::GetEvidenceFoldersByAssessmentControlInput).
        pub fn build(self) -> Result<crate::input::GetEvidenceFoldersByAssessmentControlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetEvidenceFoldersByAssessmentControlInput {
                    assessment_id: self.assessment_id
                    ,
                    control_set_id: self.control_set_id
                    ,
                    control_id: self.control_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl GetEvidenceFoldersByAssessmentControlInput {
    /// Consumes the builder and constructs an Operation<[`GetEvidenceFoldersByAssessmentControl`](crate::operation::GetEvidenceFoldersByAssessmentControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetEvidenceFoldersByAssessmentControl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetEvidenceFoldersByAssessmentControlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_45 = &_input.assessment_id;
                let input_45 = input_45.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_45, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                let input_46 = &_input.control_set_id;
                let input_46 = input_46.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))?;
                let control_set_id = aws_smithy_http::label::fmt_string(input_46, aws_smithy_http::label::EncodingStrategy::Default);
                if control_set_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))
                            }
                let input_47 = &_input.control_id;
                let input_47 = input_47.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))?;
                let control_id = aws_smithy_http::label::fmt_string(input_47, aws_smithy_http::label::EncodingStrategy::Default);
                if control_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/evidenceFolders-by-assessment-control/{controlSetId}/{controlId}", assessmentId = assessment_id, controlSetId = control_set_id, controlId = control_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::GetEvidenceFoldersByAssessmentControlInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_48) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_48));
                    }
                }
                if let Some(inner_49) = &_input.max_results {
                    if *inner_49 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_49).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetEvidenceFoldersByAssessmentControlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetEvidenceFoldersByAssessmentControl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetEvidenceFoldersByAssessmentControl", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetEvidenceFoldersByAssessmentControlInput`](crate::input::GetEvidenceFoldersByAssessmentControlInput).
    pub fn builder() -> crate::input::get_evidence_folders_by_assessment_control_input::Builder {
        crate::input::get_evidence_folders_by_assessment_control_input::Builder::default()
    }
}

/// See [`GetInsightsInput`](crate::input::GetInsightsInput).
pub mod get_insights_input {
    
    /// A builder for [`GetInsightsInput`](crate::input::GetInsightsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`GetInsightsInput`](crate::input::GetInsightsInput).
        pub fn build(self) -> Result<crate::input::GetInsightsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetInsightsInput {
                }
            )
        }
    }
    
    
}
impl GetInsightsInput {
    /// Consumes the builder and constructs an Operation<[`GetInsights`](crate::operation::GetInsights)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetInsights, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetInsightsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetInsightsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetInsights::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetInsights", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetInsightsInput`](crate::input::GetInsightsInput).
    pub fn builder() -> crate::input::get_insights_input::Builder {
        crate::input::get_insights_input::Builder::default()
    }
}

/// See [`GetInsightsByAssessmentInput`](crate::input::GetInsightsByAssessmentInput).
pub mod get_insights_by_assessment_input {
    
    /// A builder for [`GetInsightsByAssessmentInput`](crate::input::GetInsightsByAssessmentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// Consumes the builder and constructs a [`GetInsightsByAssessmentInput`](crate::input::GetInsightsByAssessmentInput).
        pub fn build(self) -> Result<crate::input::GetInsightsByAssessmentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetInsightsByAssessmentInput {
                    assessment_id: self.assessment_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetInsightsByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`GetInsightsByAssessment`](crate::operation::GetInsightsByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetInsightsByAssessment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetInsightsByAssessmentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_50 = &_input.assessment_id;
                let input_50 = input_50.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_50, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/insights/assessments/{assessmentId}", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetInsightsByAssessmentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetInsightsByAssessment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetInsightsByAssessment", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetInsightsByAssessmentInput`](crate::input::GetInsightsByAssessmentInput).
    pub fn builder() -> crate::input::get_insights_by_assessment_input::Builder {
        crate::input::get_insights_by_assessment_input::Builder::default()
    }
}

/// See [`GetOrganizationAdminAccountInput`](crate::input::GetOrganizationAdminAccountInput).
pub mod get_organization_admin_account_input {
    
    /// A builder for [`GetOrganizationAdminAccountInput`](crate::input::GetOrganizationAdminAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`GetOrganizationAdminAccountInput`](crate::input::GetOrganizationAdminAccountInput).
        pub fn build(self) -> Result<crate::input::GetOrganizationAdminAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetOrganizationAdminAccountInput {
                }
            )
        }
    }
    
    
}
impl GetOrganizationAdminAccountInput {
    /// Consumes the builder and constructs an Operation<[`GetOrganizationAdminAccount`](crate::operation::GetOrganizationAdminAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetOrganizationAdminAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetOrganizationAdminAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/organizationAdminAccount").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetOrganizationAdminAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetOrganizationAdminAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetOrganizationAdminAccount", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetOrganizationAdminAccountInput`](crate::input::GetOrganizationAdminAccountInput).
    pub fn builder() -> crate::input::get_organization_admin_account_input::Builder {
        crate::input::get_organization_admin_account_input::Builder::default()
    }
}

/// See [`GetServicesInScopeInput`](crate::input::GetServicesInScopeInput).
pub mod get_services_in_scope_input {
    
    /// A builder for [`GetServicesInScopeInput`](crate::input::GetServicesInScopeInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`GetServicesInScopeInput`](crate::input::GetServicesInScopeInput).
        pub fn build(self) -> Result<crate::input::GetServicesInScopeInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetServicesInScopeInput {
                }
            )
        }
    }
    
    
}
impl GetServicesInScopeInput {
    /// Consumes the builder and constructs an Operation<[`GetServicesInScope`](crate::operation::GetServicesInScope)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetServicesInScope, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetServicesInScopeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/services").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetServicesInScopeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetServicesInScope::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetServicesInScope", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetServicesInScopeInput`](crate::input::GetServicesInScopeInput).
    pub fn builder() -> crate::input::get_services_in_scope_input::Builder {
        crate::input::get_services_in_scope_input::Builder::default()
    }
}

/// See [`GetSettingsInput`](crate::input::GetSettingsInput).
pub mod get_settings_input {
    
    /// A builder for [`GetSettingsInput`](crate::input::GetSettingsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute: std::option::Option<crate::model::SettingAttribute>,
    }
    impl Builder {
        /// <p> The list of setting attribute enum values. </p>
        pub fn attribute(mut self, input: crate::model::SettingAttribute) -> Self {
            self.attribute = Some(input);
            self
        }
        /// <p> The list of setting attribute enum values. </p>
        pub fn set_attribute(mut self, input: std::option::Option<crate::model::SettingAttribute>) -> Self {
            self.attribute = input; self
        }
        /// Consumes the builder and constructs a [`GetSettingsInput`](crate::input::GetSettingsInput).
        pub fn build(self) -> Result<crate::input::GetSettingsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetSettingsInput {
                    attribute: self.attribute
                    ,
                }
            )
        }
    }
    
    
}
impl GetSettingsInput {
    /// Consumes the builder and constructs an Operation<[`GetSettings`](crate::operation::GetSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetSettings, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetSettingsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_51 = &_input.attribute;
                let input_51 = input_51.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("attribute", "cannot be empty or unset"))?;
                let attribute = aws_smithy_http::label::fmt_string(input_51, aws_smithy_http::label::EncodingStrategy::Default);
                if attribute.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("attribute", "cannot be empty or unset"))
                            }
                write!(output, "/settings/{attribute}", attribute = attribute).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetSettingsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetSettings::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetSettings", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSettingsInput`](crate::input::GetSettingsInput).
    pub fn builder() -> crate::input::get_settings_input::Builder {
        crate::input::get_settings_input::Builder::default()
    }
}

/// See [`ListAssessmentControlInsightsByControlDomainInput`](crate::input::ListAssessmentControlInsightsByControlDomainInput).
pub mod list_assessment_control_insights_by_control_domain_input {
    
    /// A builder for [`ListAssessmentControlInsightsByControlDomainInput`](crate::input::ListAssessmentControlInsightsByControlDomainInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_domain_id: std::option::Option<std::string::String>,
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the control domain. </p>
        pub fn control_domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the control domain. </p>
        pub fn set_control_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_domain_id = input; self
        }
        /// <p>The unique identifier for the active assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the active assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListAssessmentControlInsightsByControlDomainInput`](crate::input::ListAssessmentControlInsightsByControlDomainInput).
        pub fn build(self) -> Result<crate::input::ListAssessmentControlInsightsByControlDomainInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssessmentControlInsightsByControlDomainInput {
                    control_domain_id: self.control_domain_id
                    ,
                    assessment_id: self.assessment_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssessmentControlInsightsByControlDomainInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessmentControlInsightsByControlDomain`](crate::operation::ListAssessmentControlInsightsByControlDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssessmentControlInsightsByControlDomain, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssessmentControlInsightsByControlDomainInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights/controls-by-assessment").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssessmentControlInsightsByControlDomainInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_52 = &_input.control_domain_id;
                let inner_52 = inner_52.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_domain_id", "cannot be empty or unset"))?;
                if inner_52.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_domain_id", "cannot be empty or unset"));
                }
                query.push_kv("controlDomainId", &aws_smithy_http::query::fmt_string(&inner_52));
                let inner_53 = &_input.assessment_id;
                let inner_53 = inner_53.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                if inner_53.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"));
                }
                query.push_kv("assessmentId", &aws_smithy_http::query::fmt_string(&inner_53));
                if let Some(inner_54) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_54));
                    }
                }
                if let Some(inner_55) = &_input.max_results {
                    if *inner_55 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_55).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssessmentControlInsightsByControlDomainInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssessmentControlInsightsByControlDomain::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssessmentControlInsightsByControlDomain", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssessmentControlInsightsByControlDomainInput`](crate::input::ListAssessmentControlInsightsByControlDomainInput).
    pub fn builder() -> crate::input::list_assessment_control_insights_by_control_domain_input::Builder {
        crate::input::list_assessment_control_insights_by_control_domain_input::Builder::default()
    }
}

/// See [`ListAssessmentFrameworksInput`](crate::input::ListAssessmentFrameworksInput).
pub mod list_assessment_frameworks_input {
    
    /// A builder for [`ListAssessmentFrameworksInput`](crate::input::ListAssessmentFrameworksInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_type: std::option::Option<crate::model::FrameworkType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The type of framework, such as a standard framework or a custom framework. </p>
        pub fn framework_type(mut self, input: crate::model::FrameworkType) -> Self {
            self.framework_type = Some(input);
            self
        }
        /// <p> The type of framework, such as a standard framework or a custom framework. </p>
        pub fn set_framework_type(mut self, input: std::option::Option<crate::model::FrameworkType>) -> Self {
            self.framework_type = input; self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListAssessmentFrameworksInput`](crate::input::ListAssessmentFrameworksInput).
        pub fn build(self) -> Result<crate::input::ListAssessmentFrameworksInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssessmentFrameworksInput {
                    framework_type: self.framework_type
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssessmentFrameworksInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessmentFrameworks`](crate::operation::ListAssessmentFrameworks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssessmentFrameworks, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssessmentFrameworksInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentFrameworks").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssessmentFrameworksInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_56 = &_input.framework_type;
                let inner_56 = inner_56.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("framework_type", "cannot be empty or unset"))?;
                query.push_kv("frameworkType", &aws_smithy_http::query::fmt_string(&inner_56));
                if let Some(inner_57) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_57));
                    }
                }
                if let Some(inner_58) = &_input.max_results {
                    if *inner_58 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_58).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssessmentFrameworksInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssessmentFrameworks::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssessmentFrameworks", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssessmentFrameworksInput`](crate::input::ListAssessmentFrameworksInput).
    pub fn builder() -> crate::input::list_assessment_frameworks_input::Builder {
        crate::input::list_assessment_frameworks_input::Builder::default()
    }
}

/// See [`ListAssessmentFrameworkShareRequestsInput`](crate::input::ListAssessmentFrameworkShareRequestsInput).
pub mod list_assessment_framework_share_requests_input {
    
    /// A builder for [`ListAssessmentFrameworkShareRequestsInput`](crate::input::ListAssessmentFrameworkShareRequestsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request_type: std::option::Option<crate::model::ShareRequestType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> Specifies whether the share request is a sent request or a received request.</p>
        pub fn request_type(mut self, input: crate::model::ShareRequestType) -> Self {
            self.request_type = Some(input);
            self
        }
        /// <p> Specifies whether the share request is a sent request or a received request.</p>
        pub fn set_request_type(mut self, input: std::option::Option<crate::model::ShareRequestType>) -> Self {
            self.request_type = input; self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListAssessmentFrameworkShareRequestsInput`](crate::input::ListAssessmentFrameworkShareRequestsInput).
        pub fn build(self) -> Result<crate::input::ListAssessmentFrameworkShareRequestsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssessmentFrameworkShareRequestsInput {
                    request_type: self.request_type
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssessmentFrameworkShareRequestsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessmentFrameworkShareRequests`](crate::operation::ListAssessmentFrameworkShareRequests)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssessmentFrameworkShareRequests, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssessmentFrameworkShareRequestsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentFrameworkShareRequests").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssessmentFrameworkShareRequestsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_59 = &_input.request_type;
                let inner_59 = inner_59.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("request_type", "cannot be empty or unset"))?;
                query.push_kv("requestType", &aws_smithy_http::query::fmt_string(&inner_59));
                if let Some(inner_60) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_60));
                    }
                }
                if let Some(inner_61) = &_input.max_results {
                    if *inner_61 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_61).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssessmentFrameworkShareRequestsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssessmentFrameworkShareRequests::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssessmentFrameworkShareRequests", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssessmentFrameworkShareRequestsInput`](crate::input::ListAssessmentFrameworkShareRequestsInput).
    pub fn builder() -> crate::input::list_assessment_framework_share_requests_input::Builder {
        crate::input::list_assessment_framework_share_requests_input::Builder::default()
    }
}

/// See [`ListAssessmentReportsInput`](crate::input::ListAssessmentReportsInput).
pub mod list_assessment_reports_input {
    
    /// A builder for [`ListAssessmentReportsInput`](crate::input::ListAssessmentReportsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListAssessmentReportsInput`](crate::input::ListAssessmentReportsInput).
        pub fn build(self) -> Result<crate::input::ListAssessmentReportsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssessmentReportsInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssessmentReportsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessmentReports`](crate::operation::ListAssessmentReports)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssessmentReports, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssessmentReportsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentReports").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssessmentReportsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_62) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_62));
                    }
                }
                if let Some(inner_63) = &_input.max_results {
                    if *inner_63 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_63).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssessmentReportsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssessmentReports::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssessmentReports", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssessmentReportsInput`](crate::input::ListAssessmentReportsInput).
    pub fn builder() -> crate::input::list_assessment_reports_input::Builder {
        crate::input::list_assessment_reports_input::Builder::default()
    }
}

/// See [`ListAssessmentsInput`](crate::input::ListAssessmentsInput).
pub mod list_assessments_input {
    
    /// A builder for [`ListAssessmentsInput`](crate::input::ListAssessmentsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::AssessmentStatus>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The current status of the assessment.</p>
        pub fn status(mut self, input: crate::model::AssessmentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The current status of the assessment.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::AssessmentStatus>) -> Self {
            self.status = input; self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListAssessmentsInput`](crate::input::ListAssessmentsInput).
        pub fn build(self) -> Result<crate::input::ListAssessmentsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListAssessmentsInput {
                    status: self.status
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListAssessmentsInput {
    /// Consumes the builder and constructs an Operation<[`ListAssessments`](crate::operation::ListAssessments)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListAssessments, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListAssessmentsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessments").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListAssessmentsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_64) = &_input.status {
                     {
                        query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_64));
                    }
                }
                if let Some(inner_65) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_65));
                    }
                }
                if let Some(inner_66) = &_input.max_results {
                    if *inner_66 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_66).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListAssessmentsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListAssessments::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListAssessments", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAssessmentsInput`](crate::input::ListAssessmentsInput).
    pub fn builder() -> crate::input::list_assessments_input::Builder {
        crate::input::list_assessments_input::Builder::default()
    }
}

/// See [`ListControlDomainInsightsInput`](crate::input::ListControlDomainInsightsInput).
pub mod list_control_domain_insights_input {
    
    /// A builder for [`ListControlDomainInsightsInput`](crate::input::ListControlDomainInsightsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListControlDomainInsightsInput`](crate::input::ListControlDomainInsightsInput).
        pub fn build(self) -> Result<crate::input::ListControlDomainInsightsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListControlDomainInsightsInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListControlDomainInsightsInput {
    /// Consumes the builder and constructs an Operation<[`ListControlDomainInsights`](crate::operation::ListControlDomainInsights)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListControlDomainInsights, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListControlDomainInsightsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights/control-domains").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListControlDomainInsightsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_67) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_67));
                    }
                }
                if let Some(inner_68) = &_input.max_results {
                    if *inner_68 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_68).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListControlDomainInsightsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListControlDomainInsights::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListControlDomainInsights", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListControlDomainInsightsInput`](crate::input::ListControlDomainInsightsInput).
    pub fn builder() -> crate::input::list_control_domain_insights_input::Builder {
        crate::input::list_control_domain_insights_input::Builder::default()
    }
}

/// See [`ListControlDomainInsightsByAssessmentInput`](crate::input::ListControlDomainInsightsByAssessmentInput).
pub mod list_control_domain_insights_by_assessment_input {
    
    /// A builder for [`ListControlDomainInsightsByAssessmentInput`](crate::input::ListControlDomainInsightsByAssessmentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the active assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the active assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListControlDomainInsightsByAssessmentInput`](crate::input::ListControlDomainInsightsByAssessmentInput).
        pub fn build(self) -> Result<crate::input::ListControlDomainInsightsByAssessmentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListControlDomainInsightsByAssessmentInput {
                    assessment_id: self.assessment_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListControlDomainInsightsByAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`ListControlDomainInsightsByAssessment`](crate::operation::ListControlDomainInsightsByAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListControlDomainInsightsByAssessment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListControlDomainInsightsByAssessmentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights/control-domains-by-assessment").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListControlDomainInsightsByAssessmentInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_69 = &_input.assessment_id;
                let inner_69 = inner_69.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                if inner_69.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"));
                }
                query.push_kv("assessmentId", &aws_smithy_http::query::fmt_string(&inner_69));
                if let Some(inner_70) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_70));
                    }
                }
                if let Some(inner_71) = &_input.max_results {
                    if *inner_71 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_71).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListControlDomainInsightsByAssessmentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListControlDomainInsightsByAssessment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListControlDomainInsightsByAssessment", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListControlDomainInsightsByAssessmentInput`](crate::input::ListControlDomainInsightsByAssessmentInput).
    pub fn builder() -> crate::input::list_control_domain_insights_by_assessment_input::Builder {
        crate::input::list_control_domain_insights_by_assessment_input::Builder::default()
    }
}

/// See [`ListControlInsightsByControlDomainInput`](crate::input::ListControlInsightsByControlDomainInput).
pub mod list_control_insights_by_control_domain_input {
    
    /// A builder for [`ListControlInsightsByControlDomainInput`](crate::input::ListControlInsightsByControlDomainInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_domain_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the control domain. </p>
        pub fn control_domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the control domain. </p>
        pub fn set_control_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_domain_id = input; self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListControlInsightsByControlDomainInput`](crate::input::ListControlInsightsByControlDomainInput).
        pub fn build(self) -> Result<crate::input::ListControlInsightsByControlDomainInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListControlInsightsByControlDomainInput {
                    control_domain_id: self.control_domain_id
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListControlInsightsByControlDomainInput {
    /// Consumes the builder and constructs an Operation<[`ListControlInsightsByControlDomain`](crate::operation::ListControlInsightsByControlDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListControlInsightsByControlDomain, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListControlInsightsByControlDomainInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/insights/controls").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListControlInsightsByControlDomainInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_72 = &_input.control_domain_id;
                let inner_72 = inner_72.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_domain_id", "cannot be empty or unset"))?;
                if inner_72.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_domain_id", "cannot be empty or unset"));
                }
                query.push_kv("controlDomainId", &aws_smithy_http::query::fmt_string(&inner_72));
                if let Some(inner_73) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_73));
                    }
                }
                if let Some(inner_74) = &_input.max_results {
                    if *inner_74 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_74).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListControlInsightsByControlDomainInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListControlInsightsByControlDomain::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListControlInsightsByControlDomain", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListControlInsightsByControlDomainInput`](crate::input::ListControlInsightsByControlDomainInput).
    pub fn builder() -> crate::input::list_control_insights_by_control_domain_input::Builder {
        crate::input::list_control_insights_by_control_domain_input::Builder::default()
    }
}

/// See [`ListControlsInput`](crate::input::ListControlsInput).
pub mod list_controls_input {
    
    /// A builder for [`ListControlsInput`](crate::input::ListControlsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_type: std::option::Option<crate::model::ControlType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The type of control, such as a standard control or a custom control. </p>
        pub fn control_type(mut self, input: crate::model::ControlType) -> Self {
            self.control_type = Some(input);
            self
        }
        /// <p> The type of control, such as a standard control or a custom control. </p>
        pub fn set_control_type(mut self, input: std::option::Option<crate::model::ControlType>) -> Self {
            self.control_type = input; self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListControlsInput`](crate::input::ListControlsInput).
        pub fn build(self) -> Result<crate::input::ListControlsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListControlsInput {
                    control_type: self.control_type
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListControlsInput {
    /// Consumes the builder and constructs an Operation<[`ListControls`](crate::operation::ListControls)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListControls, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListControlsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/controls").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListControlsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_75 = &_input.control_type;
                let inner_75 = inner_75.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_type", "cannot be empty or unset"))?;
                query.push_kv("controlType", &aws_smithy_http::query::fmt_string(&inner_75));
                if let Some(inner_76) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_76));
                    }
                }
                if let Some(inner_77) = &_input.max_results {
                    if *inner_77 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_77).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListControlsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListControls::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListControls", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListControlsInput`](crate::input::ListControlsInput).
    pub fn builder() -> crate::input::list_controls_input::Builder {
        crate::input::list_controls_input::Builder::default()
    }
}

/// See [`ListKeywordsForDataSourceInput`](crate::input::ListKeywordsForDataSourceInput).
pub mod list_keywords_for_data_source_input {
    
    /// A builder for [`ListKeywordsForDataSourceInput`](crate::input::ListKeywordsForDataSourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<crate::model::SourceType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The control mapping data source that the keywords apply to. </p>
        pub fn source(mut self, input: crate::model::SourceType) -> Self {
            self.source = Some(input);
            self
        }
        /// <p> The control mapping data source that the keywords apply to. </p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::SourceType>) -> Self {
            self.source = input; self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListKeywordsForDataSourceInput`](crate::input::ListKeywordsForDataSourceInput).
        pub fn build(self) -> Result<crate::input::ListKeywordsForDataSourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListKeywordsForDataSourceInput {
                    source: self.source
                    ,
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListKeywordsForDataSourceInput {
    /// Consumes the builder and constructs an Operation<[`ListKeywordsForDataSource`](crate::operation::ListKeywordsForDataSource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListKeywordsForDataSource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListKeywordsForDataSourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/dataSourceKeywords").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListKeywordsForDataSourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_78 = &_input.source;
                let inner_78 = inner_78.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("source", "cannot be empty or unset"))?;
                query.push_kv("source", &aws_smithy_http::query::fmt_string(&inner_78));
                if let Some(inner_79) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_79));
                    }
                }
                if let Some(inner_80) = &_input.max_results {
                    if *inner_80 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_80).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListKeywordsForDataSourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListKeywordsForDataSource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListKeywordsForDataSource", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListKeywordsForDataSourceInput`](crate::input::ListKeywordsForDataSourceInput).
    pub fn builder() -> crate::input::list_keywords_for_data_source_input::Builder {
        crate::input::list_keywords_for_data_source_input::Builder::default()
    }
}

/// See [`ListNotificationsInput`](crate::input::ListNotificationsInput).
pub mod list_notifications_input {
    
    /// A builder for [`ListNotificationsInput`](crate::input::ListNotificationsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> The pagination token that's used to fetch the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> Represents the maximum number of results on a page or for an API request call. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListNotificationsInput`](crate::input::ListNotificationsInput).
        pub fn build(self) -> Result<crate::input::ListNotificationsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListNotificationsInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListNotificationsInput {
    /// Consumes the builder and constructs an Operation<[`ListNotifications`](crate::operation::ListNotifications)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListNotifications, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListNotificationsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/notifications").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListNotificationsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_81) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_81));
                    }
                }
                if let Some(inner_82) = &_input.max_results {
                    if *inner_82 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_82).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListNotificationsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListNotifications::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListNotifications", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListNotificationsInput`](crate::input::ListNotificationsInput).
    pub fn builder() -> crate::input::list_notifications_input::Builder {
        crate::input::list_notifications_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {
    
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the resource. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the resource. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(self) -> Result<crate::input::ListTagsForResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListTagsForResourceInput {
                    resource_arn: self.resource_arn
                    ,
                }
            )
        }
    }
    
    
}
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListTagsForResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListTagsForResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_83 = &_input.resource_arn;
                let input_83 = input_83.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                let resource_arn = aws_smithy_http::label::fmt_string(input_83, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListTagsForResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListTagsForResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListTagsForResource", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`RegisterAccountInput`](crate::input::RegisterAccountInput).
pub mod register_account_input {
    
    /// A builder for [`RegisterAccountInput`](crate::input::RegisterAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key: std::option::Option<std::string::String>,
        pub(crate) delegated_admin_account: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The KMS key details. </p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key = Some(input.into());
            self
        }
        /// <p> The KMS key details. </p>
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key = input; self
        }
        /// <p> The delegated administrator account for Audit Manager. </p>
        pub fn delegated_admin_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.delegated_admin_account = Some(input.into());
            self
        }
        /// <p> The delegated administrator account for Audit Manager. </p>
        pub fn set_delegated_admin_account(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delegated_admin_account = input; self
        }
        /// Consumes the builder and constructs a [`RegisterAccountInput`](crate::input::RegisterAccountInput).
        pub fn build(self) -> Result<crate::input::RegisterAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::RegisterAccountInput {
                    kms_key: self.kms_key
                    ,
                    delegated_admin_account: self.delegated_admin_account
                    ,
                }
            )
        }
    }
    
    
}
impl RegisterAccountInput {
    /// Consumes the builder and constructs an Operation<[`RegisterAccount`](crate::operation::RegisterAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::RegisterAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::RegisterAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/registerAccount").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::RegisterAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_register_account(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::RegisterAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("RegisterAccount", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RegisterAccountInput`](crate::input::RegisterAccountInput).
    pub fn builder() -> crate::input::register_account_input::Builder {
        crate::input::register_account_input::Builder::default()
    }
}

/// See [`RegisterOrganizationAdminAccountInput`](crate::input::RegisterOrganizationAdminAccountInput).
pub mod register_organization_admin_account_input {
    
    /// A builder for [`RegisterOrganizationAdminAccountInput`](crate::input::RegisterOrganizationAdminAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) admin_account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier for the delegated administrator account. </p>
        pub fn admin_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_account_id = Some(input.into());
            self
        }
        /// <p> The identifier for the delegated administrator account. </p>
        pub fn set_admin_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.admin_account_id = input; self
        }
        /// Consumes the builder and constructs a [`RegisterOrganizationAdminAccountInput`](crate::input::RegisterOrganizationAdminAccountInput).
        pub fn build(self) -> Result<crate::input::RegisterOrganizationAdminAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::RegisterOrganizationAdminAccountInput {
                    admin_account_id: self.admin_account_id
                    ,
                }
            )
        }
    }
    
    
}
impl RegisterOrganizationAdminAccountInput {
    /// Consumes the builder and constructs an Operation<[`RegisterOrganizationAdminAccount`](crate::operation::RegisterOrganizationAdminAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::RegisterOrganizationAdminAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::RegisterOrganizationAdminAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/account/registerOrganizationAdminAccount").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::RegisterOrganizationAdminAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_register_organization_admin_account(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::RegisterOrganizationAdminAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("RegisterOrganizationAdminAccount", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`RegisterOrganizationAdminAccountInput`](crate::input::RegisterOrganizationAdminAccountInput).
    pub fn builder() -> crate::input::register_organization_admin_account_input::Builder {
        crate::input::register_organization_admin_account_input::Builder::default()
    }
}

/// See [`StartAssessmentFrameworkShareInput`](crate::input::StartAssessmentFrameworkShareInput).
pub mod start_assessment_framework_share_input {
    
    /// A builder for [`StartAssessmentFrameworkShareInput`](crate::input::StartAssessmentFrameworkShareInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_id: std::option::Option<std::string::String>,
        pub(crate) destination_account: std::option::Option<std::string::String>,
        pub(crate) destination_region: std::option::Option<std::string::String>,
        pub(crate) comment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the custom framework to be shared. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the custom framework to be shared. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input; self
        }
        /// <p> The Amazon Web Services account of the recipient. </p>
        pub fn destination_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_account = Some(input.into());
            self
        }
        /// <p> The Amazon Web Services account of the recipient. </p>
        pub fn set_destination_account(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination_account = input; self
        }
        /// <p> The Amazon Web Services Region of the recipient. </p>
        pub fn destination_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_region = Some(input.into());
            self
        }
        /// <p> The Amazon Web Services Region of the recipient. </p>
        pub fn set_destination_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination_region = input; self
        }
        /// <p> An optional comment from the sender about the share request. </p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p> An optional comment from the sender about the share request. </p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input; self
        }
        /// Consumes the builder and constructs a [`StartAssessmentFrameworkShareInput`](crate::input::StartAssessmentFrameworkShareInput).
        pub fn build(self) -> Result<crate::input::StartAssessmentFrameworkShareInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartAssessmentFrameworkShareInput {
                    framework_id: self.framework_id
                    ,
                    destination_account: self.destination_account
                    ,
                    destination_region: self.destination_region
                    ,
                    comment: self.comment
                    ,
                }
            )
        }
    }
    
    
}
impl StartAssessmentFrameworkShareInput {
    /// Consumes the builder and constructs an Operation<[`StartAssessmentFrameworkShare`](crate::operation::StartAssessmentFrameworkShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartAssessmentFrameworkShare, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartAssessmentFrameworkShareInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_84 = &_input.framework_id;
                let input_84 = input_84.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("framework_id", "cannot be empty or unset"))?;
                let framework_id = aws_smithy_http::label::fmt_string(input_84, aws_smithy_http::label::EncodingStrategy::Default);
                if framework_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("framework_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessmentFrameworks/{frameworkId}/shareRequests", frameworkId = framework_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartAssessmentFrameworkShareInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_assessment_framework_share(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartAssessmentFrameworkShare::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartAssessmentFrameworkShare", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartAssessmentFrameworkShareInput`](crate::input::StartAssessmentFrameworkShareInput).
    pub fn builder() -> crate::input::start_assessment_framework_share_input::Builder {
        crate::input::start_assessment_framework_share_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {
    
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the resource. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the resource. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p> The tags that are associated with the resource. </p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p> The tags that are associated with the resource. </p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(self) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::TagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::TagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::TagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_85 = &_input.resource_arn;
                let input_85 = input_85.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                let resource_arn = aws_smithy_http::label::fmt_string(input_85, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::TagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::TagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("TagResource", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {
    
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the specified resource. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the specified resource. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p> The name or key of the tag. </p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
                            v.push(input.into());
                            self.tag_keys = Some(v);
                            self
        }
        /// <p> The name or key of the tag. </p>
        pub fn set_tag_keys(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.tag_keys = input; self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(self) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UntagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tag_keys: self.tag_keys
                    ,
                }
            )
        }
    }
    
    
}
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UntagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UntagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_86 = &_input.resource_arn;
                let input_86 = input_86.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                let resource_arn = aws_smithy_http::label::fmt_string(input_86, aws_smithy_http::label::EncodingStrategy::Default);
                if resource_arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{resourceArn}", resourceArn = resource_arn).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::UntagResourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_87 = &_input.tag_keys;
                let inner_87 = inner_87.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("tag_keys", "cannot be empty or unset"))?;
                for inner_88 in inner_87 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_88));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UntagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UntagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UntagResource", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateAssessmentInput`](crate::input::UpdateAssessmentInput).
pub mod update_assessment_input {
    
    /// A builder for [`UpdateAssessmentInput`](crate::input::UpdateAssessmentInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) assessment_name: std::option::Option<std::string::String>,
        pub(crate) assessment_description: std::option::Option<std::string::String>,
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) assessment_reports_destination: std::option::Option<crate::model::AssessmentReportsDestination>,
        pub(crate) roles: std::option::Option<std::vec::Vec<crate::model::Role>>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The name of the assessment to be updated. </p>
        pub fn assessment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_name = Some(input.into());
            self
        }
        /// <p> The name of the assessment to be updated. </p>
        pub fn set_assessment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_name = input; self
        }
        /// <p> The description of the assessment. </p>
        pub fn assessment_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_description = Some(input.into());
            self
        }
        /// <p> The description of the assessment. </p>
        pub fn set_assessment_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_description = input; self
        }
        /// <p> The scope of the assessment. </p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p> The scope of the assessment. </p>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input; self
        }
        /// <p> The assessment report storage destination for the assessment that's being updated. </p>
        pub fn assessment_reports_destination(mut self, input: crate::model::AssessmentReportsDestination) -> Self {
            self.assessment_reports_destination = Some(input);
            self
        }
        /// <p> The assessment report storage destination for the assessment that's being updated. </p>
        pub fn set_assessment_reports_destination(mut self, input: std::option::Option<crate::model::AssessmentReportsDestination>) -> Self {
            self.assessment_reports_destination = input; self
        }
        /// Appends an item to `roles`.
        ///
        /// To override the contents of this collection use [`set_roles`](Self::set_roles).
        ///
        /// <p> The list of roles for the assessment. </p>
        pub fn roles(mut self, input: crate::model::Role) -> Self {
            let mut v = self.roles.unwrap_or_default();
                            v.push(input);
                            self.roles = Some(v);
                            self
        }
        /// <p> The list of roles for the assessment. </p>
        pub fn set_roles(mut self, input: std::option::Option<std::vec::Vec<crate::model::Role>>) -> Self {
            self.roles = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentInput`](crate::input::UpdateAssessmentInput).
        pub fn build(self) -> Result<crate::input::UpdateAssessmentInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAssessmentInput {
                    assessment_id: self.assessment_id
                    ,
                    assessment_name: self.assessment_name
                    ,
                    assessment_description: self.assessment_description
                    ,
                    scope: self.scope
                    ,
                    assessment_reports_destination: self.assessment_reports_destination
                    ,
                    roles: self.roles
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAssessmentInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessment`](crate::operation::UpdateAssessment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAssessment, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAssessmentInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_89 = &_input.assessment_id;
                let input_89 = input_89.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_89, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAssessmentInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_assessment(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAssessment::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAssessment", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentInput`](crate::input::UpdateAssessmentInput).
    pub fn builder() -> crate::input::update_assessment_input::Builder {
        crate::input::update_assessment_input::Builder::default()
    }
}

/// See [`UpdateAssessmentControlInput`](crate::input::UpdateAssessmentControlInput).
pub mod update_assessment_control_input {
    
    /// A builder for [`UpdateAssessmentControlInput`](crate::input::UpdateAssessmentControlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) control_status: std::option::Option<crate::model::ControlStatus>,
        pub(crate) comment_body: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_set_id = input; self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input; self
        }
        /// <p> The status of the control. </p>
        pub fn control_status(mut self, input: crate::model::ControlStatus) -> Self {
            self.control_status = Some(input);
            self
        }
        /// <p> The status of the control. </p>
        pub fn set_control_status(mut self, input: std::option::Option<crate::model::ControlStatus>) -> Self {
            self.control_status = input; self
        }
        /// <p> The comment body text for the control. </p>
        pub fn comment_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment_body = Some(input.into());
            self
        }
        /// <p> The comment body text for the control. </p>
        pub fn set_comment_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment_body = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentControlInput`](crate::input::UpdateAssessmentControlInput).
        pub fn build(self) -> Result<crate::input::UpdateAssessmentControlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAssessmentControlInput {
                    assessment_id: self.assessment_id
                    ,
                    control_set_id: self.control_set_id
                    ,
                    control_id: self.control_id
                    ,
                    control_status: self.control_status
                    ,
                    comment_body: self.comment_body
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAssessmentControlInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentControl`](crate::operation::UpdateAssessmentControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAssessmentControl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAssessmentControlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_90 = &_input.assessment_id;
                let input_90 = input_90.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_90, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                let input_91 = &_input.control_set_id;
                let input_91 = input_91.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))?;
                let control_set_id = aws_smithy_http::label::fmt_string(input_91, aws_smithy_http::label::EncodingStrategy::Default);
                if control_set_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))
                            }
                let input_92 = &_input.control_id;
                let input_92 = input_92.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))?;
                let control_id = aws_smithy_http::label::fmt_string(input_92, aws_smithy_http::label::EncodingStrategy::Default);
                if control_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/controls/{controlId}", assessmentId = assessment_id, controlSetId = control_set_id, controlId = control_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAssessmentControlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_assessment_control(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAssessmentControl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAssessmentControl", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentControlInput`](crate::input::UpdateAssessmentControlInput).
    pub fn builder() -> crate::input::update_assessment_control_input::Builder {
        crate::input::update_assessment_control_input::Builder::default()
    }
}

/// See [`UpdateAssessmentControlSetStatusInput`](crate::input::UpdateAssessmentControlSetStatusInput).
pub mod update_assessment_control_set_status_input {
    
    /// A builder for [`UpdateAssessmentControlSetStatusInput`](crate::input::UpdateAssessmentControlSetStatusInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) control_set_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ControlSetStatus>,
        pub(crate) comment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn control_set_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_set_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the control set. </p>
        pub fn set_control_set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_set_id = input; self
        }
        /// <p> The status of the control set that's being updated. </p>
        pub fn status(mut self, input: crate::model::ControlSetStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The status of the control set that's being updated. </p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ControlSetStatus>) -> Self {
            self.status = input; self
        }
        /// <p> The comment that's related to the status update. </p>
        pub fn comment(mut self, input: impl Into<std::string::String>) -> Self {
            self.comment = Some(input.into());
            self
        }
        /// <p> The comment that's related to the status update. </p>
        pub fn set_comment(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.comment = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentControlSetStatusInput`](crate::input::UpdateAssessmentControlSetStatusInput).
        pub fn build(self) -> Result<crate::input::UpdateAssessmentControlSetStatusInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAssessmentControlSetStatusInput {
                    assessment_id: self.assessment_id
                    ,
                    control_set_id: self.control_set_id
                    ,
                    status: self.status
                    ,
                    comment: self.comment
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAssessmentControlSetStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentControlSetStatus`](crate::operation::UpdateAssessmentControlSetStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAssessmentControlSetStatus, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAssessmentControlSetStatusInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_93 = &_input.assessment_id;
                let input_93 = input_93.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_93, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                let input_94 = &_input.control_set_id;
                let input_94 = input_94.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))?;
                let control_set_id = aws_smithy_http::label::fmt_string(input_94, aws_smithy_http::label::EncodingStrategy::Default);
                if control_set_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_set_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/controlSets/{controlSetId}/status", assessmentId = assessment_id, controlSetId = control_set_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAssessmentControlSetStatusInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_assessment_control_set_status(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAssessmentControlSetStatus::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAssessmentControlSetStatus", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentControlSetStatusInput`](crate::input::UpdateAssessmentControlSetStatusInput).
    pub fn builder() -> crate::input::update_assessment_control_set_status_input::Builder {
        crate::input::update_assessment_control_set_status_input::Builder::default()
    }
}

/// See [`UpdateAssessmentFrameworkInput`](crate::input::UpdateAssessmentFrameworkInput).
pub mod update_assessment_framework_input {
    
    /// A builder for [`UpdateAssessmentFrameworkInput`](crate::input::UpdateAssessmentFrameworkInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) framework_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) compliance_type: std::option::Option<std::string::String>,
        pub(crate) control_sets: std::option::Option<std::vec::Vec<crate::model::UpdateAssessmentFrameworkControlSet>>,
    }
    impl Builder {
        /// <p> The unique identifier for the framework. </p>
        pub fn framework_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.framework_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the framework. </p>
        pub fn set_framework_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.framework_id = input; self
        }
        /// <p> The name of the framework to be updated. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the framework to be updated. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p> The description of the updated framework. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The description of the updated framework. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
        pub fn compliance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.compliance_type = Some(input.into());
            self
        }
        /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
        pub fn set_compliance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.compliance_type = input; self
        }
        /// Appends an item to `control_sets`.
        ///
        /// To override the contents of this collection use [`set_control_sets`](Self::set_control_sets).
        ///
        /// <p> The control sets that are associated with the framework. </p>
        pub fn control_sets(mut self, input: crate::model::UpdateAssessmentFrameworkControlSet) -> Self {
            let mut v = self.control_sets.unwrap_or_default();
                            v.push(input);
                            self.control_sets = Some(v);
                            self
        }
        /// <p> The control sets that are associated with the framework. </p>
        pub fn set_control_sets(mut self, input: std::option::Option<std::vec::Vec<crate::model::UpdateAssessmentFrameworkControlSet>>) -> Self {
            self.control_sets = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentFrameworkInput`](crate::input::UpdateAssessmentFrameworkInput).
        pub fn build(self) -> Result<crate::input::UpdateAssessmentFrameworkInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAssessmentFrameworkInput {
                    framework_id: self.framework_id
                    ,
                    name: self.name
                    ,
                    description: self.description
                    ,
                    compliance_type: self.compliance_type
                    ,
                    control_sets: self.control_sets
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAssessmentFrameworkInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentFramework`](crate::operation::UpdateAssessmentFramework)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAssessmentFramework, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAssessmentFrameworkInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_95 = &_input.framework_id;
                let input_95 = input_95.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("framework_id", "cannot be empty or unset"))?;
                let framework_id = aws_smithy_http::label::fmt_string(input_95, aws_smithy_http::label::EncodingStrategy::Default);
                if framework_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("framework_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessmentFrameworks/{frameworkId}", frameworkId = framework_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAssessmentFrameworkInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_assessment_framework(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAssessmentFramework::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAssessmentFramework", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentFrameworkInput`](crate::input::UpdateAssessmentFrameworkInput).
    pub fn builder() -> crate::input::update_assessment_framework_input::Builder {
        crate::input::update_assessment_framework_input::Builder::default()
    }
}

/// See [`UpdateAssessmentFrameworkShareInput`](crate::input::UpdateAssessmentFrameworkShareInput).
pub mod update_assessment_framework_share_input {
    
    /// A builder for [`UpdateAssessmentFrameworkShareInput`](crate::input::UpdateAssessmentFrameworkShareInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) request_type: std::option::Option<crate::model::ShareRequestType>,
        pub(crate) action: std::option::Option<crate::model::ShareRequestAction>,
    }
    impl Builder {
        /// <p> The unique identifier for the share request. </p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the share request. </p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input; self
        }
        /// <p>Specifies whether the share request is a sent request or a received request.</p>
        pub fn request_type(mut self, input: crate::model::ShareRequestType) -> Self {
            self.request_type = Some(input);
            self
        }
        /// <p>Specifies whether the share request is a sent request or a received request.</p>
        pub fn set_request_type(mut self, input: std::option::Option<crate::model::ShareRequestType>) -> Self {
            self.request_type = input; self
        }
        /// <p>Specifies the update action for the share request.</p>
        pub fn action(mut self, input: crate::model::ShareRequestAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>Specifies the update action for the share request.</p>
        pub fn set_action(mut self, input: std::option::Option<crate::model::ShareRequestAction>) -> Self {
            self.action = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentFrameworkShareInput`](crate::input::UpdateAssessmentFrameworkShareInput).
        pub fn build(self) -> Result<crate::input::UpdateAssessmentFrameworkShareInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAssessmentFrameworkShareInput {
                    request_id: self.request_id
                    ,
                    request_type: self.request_type
                    ,
                    action: self.action
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAssessmentFrameworkShareInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentFrameworkShare`](crate::operation::UpdateAssessmentFrameworkShare)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAssessmentFrameworkShare, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAssessmentFrameworkShareInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_96 = &_input.request_id;
                let input_96 = input_96.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("request_id", "cannot be empty or unset"))?;
                let request_id = aws_smithy_http::label::fmt_string(input_96, aws_smithy_http::label::EncodingStrategy::Default);
                if request_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("request_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessmentFrameworkShareRequests/{requestId}", requestId = request_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAssessmentFrameworkShareInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_assessment_framework_share(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAssessmentFrameworkShare::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAssessmentFrameworkShare", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentFrameworkShareInput`](crate::input::UpdateAssessmentFrameworkShareInput).
    pub fn builder() -> crate::input::update_assessment_framework_share_input::Builder {
        crate::input::update_assessment_framework_share_input::Builder::default()
    }
}

/// See [`UpdateAssessmentStatusInput`](crate::input::UpdateAssessmentStatusInput).
pub mod update_assessment_status_input {
    
    /// A builder for [`UpdateAssessmentStatusInput`](crate::input::UpdateAssessmentStatusInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assessment_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AssessmentStatus>,
    }
    impl Builder {
        /// <p> The unique identifier for the assessment. </p>
        pub fn assessment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the assessment. </p>
        pub fn set_assessment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.assessment_id = input; self
        }
        /// <p> The current status of the assessment. </p>
        pub fn status(mut self, input: crate::model::AssessmentStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The current status of the assessment. </p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::AssessmentStatus>) -> Self {
            self.status = input; self
        }
        /// Consumes the builder and constructs a [`UpdateAssessmentStatusInput`](crate::input::UpdateAssessmentStatusInput).
        pub fn build(self) -> Result<crate::input::UpdateAssessmentStatusInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateAssessmentStatusInput {
                    assessment_id: self.assessment_id
                    ,
                    status: self.status
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateAssessmentStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAssessmentStatus`](crate::operation::UpdateAssessmentStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateAssessmentStatus, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateAssessmentStatusInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_97 = &_input.assessment_id;
                let input_97 = input_97.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))?;
                let assessment_id = aws_smithy_http::label::fmt_string(input_97, aws_smithy_http::label::EncodingStrategy::Default);
                if assessment_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("assessment_id", "cannot be empty or unset"))
                            }
                write!(output, "/assessments/{assessmentId}/status", assessmentId = assessment_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateAssessmentStatusInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_assessment_status(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateAssessmentStatus::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateAssessmentStatus", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateAssessmentStatusInput`](crate::input::UpdateAssessmentStatusInput).
    pub fn builder() -> crate::input::update_assessment_status_input::Builder {
        crate::input::update_assessment_status_input::Builder::default()
    }
}

/// See [`UpdateControlInput`](crate::input::UpdateControlInput).
pub mod update_control_input {
    
    /// A builder for [`UpdateControlInput`](crate::input::UpdateControlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) control_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) testing_information: std::option::Option<std::string::String>,
        pub(crate) action_plan_title: std::option::Option<std::string::String>,
        pub(crate) action_plan_instructions: std::option::Option<std::string::String>,
        pub(crate) control_mapping_sources: std::option::Option<std::vec::Vec<crate::model::ControlMappingSource>>,
    }
    impl Builder {
        /// <p> The identifier for the control. </p>
        pub fn control_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.control_id = Some(input.into());
            self
        }
        /// <p> The identifier for the control. </p>
        pub fn set_control_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.control_id = input; self
        }
        /// <p> The name of the updated control. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the updated control. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p> The optional description of the control. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> The optional description of the control. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p> The steps that you should follow to determine if the control is met. </p>
        pub fn testing_information(mut self, input: impl Into<std::string::String>) -> Self {
            self.testing_information = Some(input.into());
            self
        }
        /// <p> The steps that you should follow to determine if the control is met. </p>
        pub fn set_testing_information(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.testing_information = input; self
        }
        /// <p> The title of the action plan for remediating the control. </p>
        pub fn action_plan_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_plan_title = Some(input.into());
            self
        }
        /// <p> The title of the action plan for remediating the control. </p>
        pub fn set_action_plan_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_plan_title = input; self
        }
        /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
        pub fn action_plan_instructions(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_plan_instructions = Some(input.into());
            self
        }
        /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
        pub fn set_action_plan_instructions(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_plan_instructions = input; self
        }
        /// Appends an item to `control_mapping_sources`.
        ///
        /// To override the contents of this collection use [`set_control_mapping_sources`](Self::set_control_mapping_sources).
        ///
        /// <p> The data mapping sources for the control. </p>
        pub fn control_mapping_sources(mut self, input: crate::model::ControlMappingSource) -> Self {
            let mut v = self.control_mapping_sources.unwrap_or_default();
                            v.push(input);
                            self.control_mapping_sources = Some(v);
                            self
        }
        /// <p> The data mapping sources for the control. </p>
        pub fn set_control_mapping_sources(mut self, input: std::option::Option<std::vec::Vec<crate::model::ControlMappingSource>>) -> Self {
            self.control_mapping_sources = input; self
        }
        /// Consumes the builder and constructs a [`UpdateControlInput`](crate::input::UpdateControlInput).
        pub fn build(self) -> Result<crate::input::UpdateControlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateControlInput {
                    control_id: self.control_id
                    ,
                    name: self.name
                    ,
                    description: self.description
                    ,
                    testing_information: self.testing_information
                    ,
                    action_plan_title: self.action_plan_title
                    ,
                    action_plan_instructions: self.action_plan_instructions
                    ,
                    control_mapping_sources: self.control_mapping_sources
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateControlInput {
    /// Consumes the builder and constructs an Operation<[`UpdateControl`](crate::operation::UpdateControl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateControl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateControlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_98 = &_input.control_id;
                let input_98 = input_98.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))?;
                let control_id = aws_smithy_http::label::fmt_string(input_98, aws_smithy_http::label::EncodingStrategy::Default);
                if control_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("control_id", "cannot be empty or unset"))
                            }
                write!(output, "/controls/{controlId}", controlId = control_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateControlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_control(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateControl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateControl", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateControlInput`](crate::input::UpdateControlInput).
    pub fn builder() -> crate::input::update_control_input::Builder {
        crate::input::update_control_input::Builder::default()
    }
}

/// See [`UpdateSettingsInput`](crate::input::UpdateSettingsInput).
pub mod update_settings_input {
    
    /// A builder for [`UpdateSettingsInput`](crate::input::UpdateSettingsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sns_topic: std::option::Option<std::string::String>,
        pub(crate) default_assessment_reports_destination: std::option::Option<crate::model::AssessmentReportsDestination>,
        pub(crate) default_process_owners: std::option::Option<std::vec::Vec<crate::model::Role>>,
        pub(crate) kms_key: std::option::Option<std::string::String>,
        pub(crate) evidence_finder_enabled: std::option::Option<bool>,
        pub(crate) deregistration_policy: std::option::Option<crate::model::DeregistrationPolicy>,
    }
    impl Builder {
        /// <p> The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to. </p>
        pub fn sns_topic(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic = Some(input.into());
            self
        }
        /// <p> The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to. </p>
        pub fn set_sns_topic(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sns_topic = input; self
        }
        /// <p> The default storage destination for assessment reports. </p>
        pub fn default_assessment_reports_destination(mut self, input: crate::model::AssessmentReportsDestination) -> Self {
            self.default_assessment_reports_destination = Some(input);
            self
        }
        /// <p> The default storage destination for assessment reports. </p>
        pub fn set_default_assessment_reports_destination(mut self, input: std::option::Option<crate::model::AssessmentReportsDestination>) -> Self {
            self.default_assessment_reports_destination = input; self
        }
        /// Appends an item to `default_process_owners`.
        ///
        /// To override the contents of this collection use [`set_default_process_owners`](Self::set_default_process_owners).
        ///
        /// <p> A list of the default audit owners. </p>
        pub fn default_process_owners(mut self, input: crate::model::Role) -> Self {
            let mut v = self.default_process_owners.unwrap_or_default();
                            v.push(input);
                            self.default_process_owners = Some(v);
                            self
        }
        /// <p> A list of the default audit owners. </p>
        pub fn set_default_process_owners(mut self, input: std::option::Option<std::vec::Vec<crate::model::Role>>) -> Self {
            self.default_process_owners = input; self
        }
        /// <p> The KMS key details. </p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key = Some(input.into());
            self
        }
        /// <p> The KMS key details. </p>
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key = input; self
        }
        /// <p>Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.</p> <important> 
        /// <p>When you use this attribute to disable evidence finder, Audit Manager deletes the event data store thats used to query your evidence data. As a result, you cant re-enable evidence finder and use the feature again. Your only alternative is to <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html">deregister</a> and then <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html">re-register</a> Audit Manager. </p> 
        /// </important>
        pub fn evidence_finder_enabled(mut self, input: bool) -> Self {
            self.evidence_finder_enabled = Some(input);
            self
        }
        /// <p>Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.</p> <important> 
        /// <p>When you use this attribute to disable evidence finder, Audit Manager deletes the event data store thats used to query your evidence data. As a result, you cant re-enable evidence finder and use the feature again. Your only alternative is to <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html">deregister</a> and then <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html">re-register</a> Audit Manager. </p> 
        /// </important>
        pub fn set_evidence_finder_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.evidence_finder_enabled = input; self
        }
        /// <p>The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.</p>
        pub fn deregistration_policy(mut self, input: crate::model::DeregistrationPolicy) -> Self {
            self.deregistration_policy = Some(input);
            self
        }
        /// <p>The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.</p>
        pub fn set_deregistration_policy(mut self, input: std::option::Option<crate::model::DeregistrationPolicy>) -> Self {
            self.deregistration_policy = input; self
        }
        /// Consumes the builder and constructs a [`UpdateSettingsInput`](crate::input::UpdateSettingsInput).
        pub fn build(self) -> Result<crate::input::UpdateSettingsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateSettingsInput {
                    sns_topic: self.sns_topic
                    ,
                    default_assessment_reports_destination: self.default_assessment_reports_destination
                    ,
                    default_process_owners: self.default_process_owners
                    ,
                    kms_key: self.kms_key
                    ,
                    evidence_finder_enabled: self.evidence_finder_enabled
                    ,
                    deregistration_policy: self.deregistration_policy
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateSettingsInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSettings`](crate::operation::UpdateSettings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateSettings, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateSettingsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/settings").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateSettingsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_settings(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateSettings::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateSettings", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateSettingsInput`](crate::input::UpdateSettingsInput).
    pub fn builder() -> crate::input::update_settings_input::Builder {
        crate::input::update_settings_input::Builder::default()
    }
}

/// See [`ValidateAssessmentReportIntegrityInput`](crate::input::ValidateAssessmentReportIntegrityInput).
pub mod validate_assessment_report_integrity_input {
    
    /// A builder for [`ValidateAssessmentReportIntegrityInput`](crate::input::ValidateAssessmentReportIntegrityInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_relative_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The relative path of the Amazon S3 bucket that the assessment report is stored in. </p>
        pub fn s3_relative_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_relative_path = Some(input.into());
            self
        }
        /// <p> The relative path of the Amazon S3 bucket that the assessment report is stored in. </p>
        pub fn set_s3_relative_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_relative_path = input; self
        }
        /// Consumes the builder and constructs a [`ValidateAssessmentReportIntegrityInput`](crate::input::ValidateAssessmentReportIntegrityInput).
        pub fn build(self) -> Result<crate::input::ValidateAssessmentReportIntegrityInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ValidateAssessmentReportIntegrityInput {
                    s3_relative_path: self.s3_relative_path
                    ,
                }
            )
        }
    }
    
    
}
impl ValidateAssessmentReportIntegrityInput {
    /// Consumes the builder and constructs an Operation<[`ValidateAssessmentReportIntegrity`](crate::operation::ValidateAssessmentReportIntegrity)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ValidateAssessmentReportIntegrity, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ValidateAssessmentReportIntegrityInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/assessmentReports/integrity").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ValidateAssessmentReportIntegrityInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_validate_assessment_report_integrity(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ValidateAssessmentReportIntegrity::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ValidateAssessmentReportIntegrity", "auditmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ValidateAssessmentReportIntegrityInput`](crate::input::ValidateAssessmentReportIntegrityInput).
    pub fn builder() -> crate::input::validate_assessment_report_integrity_input::Builder {
        crate::input::validate_assessment_report_integrity_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidateAssessmentReportIntegrityInput  {
    /// <p> The relative path of the Amazon S3 bucket that the assessment report is stored in. </p>
    #[doc(hidden)]
    pub s3_relative_path: std::option::Option<std::string::String>,
}
impl ValidateAssessmentReportIntegrityInput {
    /// <p> The relative path of the Amazon S3 bucket that the assessment report is stored in. </p>
    pub fn s3_relative_path(&self) -> std::option::Option<& str> {
        self.s3_relative_path.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateSettingsInput  {
    /// <p> The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to. </p>
    #[doc(hidden)]
    pub sns_topic: std::option::Option<std::string::String>,
    /// <p> The default storage destination for assessment reports. </p>
    #[doc(hidden)]
    pub default_assessment_reports_destination: std::option::Option<crate::model::AssessmentReportsDestination>,
    /// <p> A list of the default audit owners. </p>
    #[doc(hidden)]
    pub default_process_owners: std::option::Option<std::vec::Vec<crate::model::Role>>,
    /// <p> The KMS key details. </p>
    #[doc(hidden)]
    pub kms_key: std::option::Option<std::string::String>,
    /// <p>Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.</p> <important> 
    /// <p>When you use this attribute to disable evidence finder, Audit Manager deletes the event data store thats used to query your evidence data. As a result, you cant re-enable evidence finder and use the feature again. Your only alternative is to <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html">deregister</a> and then <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html">re-register</a> Audit Manager. </p> 
    /// </important>
    #[doc(hidden)]
    pub evidence_finder_enabled: std::option::Option<bool>,
    /// <p>The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.</p>
    #[doc(hidden)]
    pub deregistration_policy: std::option::Option<crate::model::DeregistrationPolicy>,
}
impl UpdateSettingsInput {
    /// <p> The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to. </p>
    pub fn sns_topic(&self) -> std::option::Option<& str> {
        self.sns_topic.as_deref()
    }
    /// <p> The default storage destination for assessment reports. </p>
    pub fn default_assessment_reports_destination(&self) -> std::option::Option<& crate::model::AssessmentReportsDestination> {
        self.default_assessment_reports_destination.as_ref()
    }
    /// <p> A list of the default audit owners. </p>
    pub fn default_process_owners(&self) -> std::option::Option<& [crate::model::Role]> {
        self.default_process_owners.as_deref()
    }
    /// <p> The KMS key details. </p>
    pub fn kms_key(&self) -> std::option::Option<& str> {
        self.kms_key.as_deref()
    }
    /// <p>Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder.</p> <important> 
    /// <p>When you use this attribute to disable evidence finder, Audit Manager deletes the event data store thats used to query your evidence data. As a result, you cant re-enable evidence finder and use the feature again. Your only alternative is to <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html">deregister</a> and then <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html">re-register</a> Audit Manager. </p> 
    /// </important>
    pub fn evidence_finder_enabled(&self) -> std::option::Option<bool> {
        self.evidence_finder_enabled
    }
    /// <p>The deregistration policy for your Audit Manager data. You can use this attribute to determine how your data is handled when you deregister Audit Manager.</p>
    pub fn deregistration_policy(&self) -> std::option::Option<& crate::model::DeregistrationPolicy> {
        self.deregistration_policy.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateControlInput  {
    /// <p> The identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The name of the updated control. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The optional description of the control. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The steps that you should follow to determine if the control is met. </p>
    #[doc(hidden)]
    pub testing_information: std::option::Option<std::string::String>,
    /// <p> The title of the action plan for remediating the control. </p>
    #[doc(hidden)]
    pub action_plan_title: std::option::Option<std::string::String>,
    /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
    #[doc(hidden)]
    pub action_plan_instructions: std::option::Option<std::string::String>,
    /// <p> The data mapping sources for the control. </p>
    #[doc(hidden)]
    pub control_mapping_sources: std::option::Option<std::vec::Vec<crate::model::ControlMappingSource>>,
}
impl UpdateControlInput {
    /// <p> The identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<& str> {
        self.control_id.as_deref()
    }
    /// <p> The name of the updated control. </p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p> The optional description of the control. </p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p> The steps that you should follow to determine if the control is met. </p>
    pub fn testing_information(&self) -> std::option::Option<& str> {
        self.testing_information.as_deref()
    }
    /// <p> The title of the action plan for remediating the control. </p>
    pub fn action_plan_title(&self) -> std::option::Option<& str> {
        self.action_plan_title.as_deref()
    }
    /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
    pub fn action_plan_instructions(&self) -> std::option::Option<& str> {
        self.action_plan_instructions.as_deref()
    }
    /// <p> The data mapping sources for the control. </p>
    pub fn control_mapping_sources(&self) -> std::option::Option<& [crate::model::ControlMappingSource]> {
        self.control_mapping_sources.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentStatusInput  {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The current status of the assessment. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AssessmentStatus>,
}
impl UpdateAssessmentStatusInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The current status of the assessment. </p>
    pub fn status(&self) -> std::option::Option<& crate::model::AssessmentStatus> {
        self.status.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentFrameworkShareInput  {
    /// <p> The unique identifier for the share request. </p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the share request is a sent request or a received request.</p>
    #[doc(hidden)]
    pub request_type: std::option::Option<crate::model::ShareRequestType>,
    /// <p>Specifies the update action for the share request.</p>
    #[doc(hidden)]
    pub action: std::option::Option<crate::model::ShareRequestAction>,
}
impl UpdateAssessmentFrameworkShareInput {
    /// <p> The unique identifier for the share request. </p>
    pub fn request_id(&self) -> std::option::Option<& str> {
        self.request_id.as_deref()
    }
    /// <p>Specifies whether the share request is a sent request or a received request.</p>
    pub fn request_type(&self) -> std::option::Option<& crate::model::ShareRequestType> {
        self.request_type.as_ref()
    }
    /// <p>Specifies the update action for the share request.</p>
    pub fn action(&self) -> std::option::Option<& crate::model::ShareRequestAction> {
        self.action.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentFrameworkInput  {
    /// <p> The unique identifier for the framework. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
    /// <p> The name of the framework to be updated. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The description of the updated framework. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<std::string::String>,
    /// <p> The control sets that are associated with the framework. </p>
    #[doc(hidden)]
    pub control_sets: std::option::Option<std::vec::Vec<crate::model::UpdateAssessmentFrameworkControlSet>>,
}
impl UpdateAssessmentFrameworkInput {
    /// <p> The unique identifier for the framework. </p>
    pub fn framework_id(&self) -> std::option::Option<& str> {
        self.framework_id.as_deref()
    }
    /// <p> The name of the framework to be updated. </p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p> The description of the updated framework. </p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
    pub fn compliance_type(&self) -> std::option::Option<& str> {
        self.compliance_type.as_deref()
    }
    /// <p> The control sets that are associated with the framework. </p>
    pub fn control_sets(&self) -> std::option::Option<& [crate::model::UpdateAssessmentFrameworkControlSet]> {
        self.control_sets.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentControlSetStatusInput  {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The status of the control set that's being updated. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ControlSetStatus>,
    /// <p> The comment that's related to the status update. </p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
}
impl UpdateAssessmentControlSetStatusInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<& str> {
        self.control_set_id.as_deref()
    }
    /// <p> The status of the control set that's being updated. </p>
    pub fn status(&self) -> std::option::Option<& crate::model::ControlSetStatus> {
        self.status.as_ref()
    }
    /// <p> The comment that's related to the status update. </p>
    pub fn comment(&self) -> std::option::Option<& str> {
        self.comment.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentControlInput  {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The status of the control. </p>
    #[doc(hidden)]
    pub control_status: std::option::Option<crate::model::ControlStatus>,
    /// <p> The comment body text for the control. </p>
    #[doc(hidden)]
    pub comment_body: std::option::Option<std::string::String>,
}
impl UpdateAssessmentControlInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<& str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<& str> {
        self.control_id.as_deref()
    }
    /// <p> The status of the control. </p>
    pub fn control_status(&self) -> std::option::Option<& crate::model::ControlStatus> {
        self.control_status.as_ref()
    }
    /// <p> The comment body text for the control. </p>
    pub fn comment_body(&self) -> std::option::Option<& str> {
        self.comment_body.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAssessmentInput  {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The name of the assessment to be updated. </p>
    #[doc(hidden)]
    pub assessment_name: std::option::Option<std::string::String>,
    /// <p> The description of the assessment. </p>
    #[doc(hidden)]
    pub assessment_description: std::option::Option<std::string::String>,
    /// <p> The scope of the assessment. </p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p> The assessment report storage destination for the assessment that's being updated. </p>
    #[doc(hidden)]
    pub assessment_reports_destination: std::option::Option<crate::model::AssessmentReportsDestination>,
    /// <p> The list of roles for the assessment. </p>
    #[doc(hidden)]
    pub roles: std::option::Option<std::vec::Vec<crate::model::Role>>,
}
impl UpdateAssessmentInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The name of the assessment to be updated. </p>
    pub fn assessment_name(&self) -> std::option::Option<& str> {
        self.assessment_name.as_deref()
    }
    /// <p> The description of the assessment. </p>
    pub fn assessment_description(&self) -> std::option::Option<& str> {
        self.assessment_description.as_deref()
    }
    /// <p> The scope of the assessment. </p>
    pub fn scope(&self) -> std::option::Option<& crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p> The assessment report storage destination for the assessment that's being updated. </p>
    pub fn assessment_reports_destination(&self) -> std::option::Option<& crate::model::AssessmentReportsDestination> {
        self.assessment_reports_destination.as_ref()
    }
    /// <p> The list of roles for the assessment. </p>
    pub fn roles(&self) -> std::option::Option<& [crate::model::Role]> {
        self.roles.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput  {
    /// <p> The Amazon Resource Name (ARN) of the specified resource. </p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p> The name or key of the tag. </p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p> The Amazon Resource Name (ARN) of the specified resource. </p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p> The name or key of the tag. </p>
    pub fn tag_keys(&self) -> std::option::Option<& [std::string::String]> {
        self.tag_keys.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput  {
    /// <p> The Amazon Resource Name (ARN) of the resource. </p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p> The tags that are associated with the resource. </p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl TagResourceInput {
    /// <p> The Amazon Resource Name (ARN) of the resource. </p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p> The tags that are associated with the resource. </p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartAssessmentFrameworkShareInput  {
    /// <p> The unique identifier for the custom framework to be shared. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
    /// <p> The Amazon Web Services account of the recipient. </p>
    #[doc(hidden)]
    pub destination_account: std::option::Option<std::string::String>,
    /// <p> The Amazon Web Services Region of the recipient. </p>
    #[doc(hidden)]
    pub destination_region: std::option::Option<std::string::String>,
    /// <p> An optional comment from the sender about the share request. </p>
    #[doc(hidden)]
    pub comment: std::option::Option<std::string::String>,
}
impl StartAssessmentFrameworkShareInput {
    /// <p> The unique identifier for the custom framework to be shared. </p>
    pub fn framework_id(&self) -> std::option::Option<& str> {
        self.framework_id.as_deref()
    }
    /// <p> The Amazon Web Services account of the recipient. </p>
    pub fn destination_account(&self) -> std::option::Option<& str> {
        self.destination_account.as_deref()
    }
    /// <p> The Amazon Web Services Region of the recipient. </p>
    pub fn destination_region(&self) -> std::option::Option<& str> {
        self.destination_region.as_deref()
    }
    /// <p> An optional comment from the sender about the share request. </p>
    pub fn comment(&self) -> std::option::Option<& str> {
        self.comment.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterOrganizationAdminAccountInput  {
    /// <p> The identifier for the delegated administrator account. </p>
    #[doc(hidden)]
    pub admin_account_id: std::option::Option<std::string::String>,
}
impl RegisterOrganizationAdminAccountInput {
    /// <p> The identifier for the delegated administrator account. </p>
    pub fn admin_account_id(&self) -> std::option::Option<& str> {
        self.admin_account_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterAccountInput  {
    /// <p> The KMS key details. </p>
    #[doc(hidden)]
    pub kms_key: std::option::Option<std::string::String>,
    /// <p> The delegated administrator account for Audit Manager. </p>
    #[doc(hidden)]
    pub delegated_admin_account: std::option::Option<std::string::String>,
}
impl RegisterAccountInput {
    /// <p> The KMS key details. </p>
    pub fn kms_key(&self) -> std::option::Option<& str> {
        self.kms_key.as_deref()
    }
    /// <p> The delegated administrator account for Audit Manager. </p>
    pub fn delegated_admin_account(&self) -> std::option::Option<& str> {
        self.delegated_admin_account.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput  {
    /// <p> The Amazon Resource Name (ARN) of the resource. </p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p> The Amazon Resource Name (ARN) of the resource. </p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListNotificationsInput  {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListNotificationsInput {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListKeywordsForDataSourceInput  {
    /// <p> The control mapping data source that the keywords apply to. </p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::SourceType>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListKeywordsForDataSourceInput {
    /// <p> The control mapping data source that the keywords apply to. </p>
    pub fn source(&self) -> std::option::Option<& crate::model::SourceType> {
        self.source.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlsInput  {
    /// <p> The type of control, such as a standard control or a custom control. </p>
    #[doc(hidden)]
    pub control_type: std::option::Option<crate::model::ControlType>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListControlsInput {
    /// <p> The type of control, such as a standard control or a custom control. </p>
    pub fn control_type(&self) -> std::option::Option<& crate::model::ControlType> {
        self.control_type.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlInsightsByControlDomainInput  {
    /// <p>The unique identifier for the control domain. </p>
    #[doc(hidden)]
    pub control_domain_id: std::option::Option<std::string::String>,
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListControlInsightsByControlDomainInput {
    /// <p>The unique identifier for the control domain. </p>
    pub fn control_domain_id(&self) -> std::option::Option<& str> {
        self.control_domain_id.as_deref()
    }
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlDomainInsightsByAssessmentInput  {
    /// <p>The unique identifier for the active assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListControlDomainInsightsByAssessmentInput {
    /// <p>The unique identifier for the active assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListControlDomainInsightsInput  {
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListControlDomainInsightsInput {
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentsInput  {
    /// <p> The current status of the assessment.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AssessmentStatus>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentsInput {
    /// <p> The current status of the assessment.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::AssessmentStatus> {
        self.status.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentReportsInput  {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentReportsInput {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentFrameworkShareRequestsInput  {
    /// <p> Specifies whether the share request is a sent request or a received request.</p>
    #[doc(hidden)]
    pub request_type: std::option::Option<crate::model::ShareRequestType>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentFrameworkShareRequestsInput {
    /// <p> Specifies whether the share request is a sent request or a received request.</p>
    pub fn request_type(&self) -> std::option::Option<& crate::model::ShareRequestType> {
        self.request_type.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentFrameworksInput  {
    /// <p> The type of framework, such as a standard framework or a custom framework. </p>
    #[doc(hidden)]
    pub framework_type: std::option::Option<crate::model::FrameworkType>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentFrameworksInput {
    /// <p> The type of framework, such as a standard framework or a custom framework. </p>
    pub fn framework_type(&self) -> std::option::Option<& crate::model::FrameworkType> {
        self.framework_type.as_ref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAssessmentControlInsightsByControlDomainInput  {
    /// <p>The unique identifier for the control domain. </p>
    #[doc(hidden)]
    pub control_domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the active assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListAssessmentControlInsightsByControlDomainInput {
    /// <p>The unique identifier for the control domain. </p>
    pub fn control_domain_id(&self) -> std::option::Option<& str> {
        self.control_domain_id.as_deref()
    }
    /// <p>The unique identifier for the active assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p>The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSettingsInput  {
    /// <p> The list of setting attribute enum values. </p>
    #[doc(hidden)]
    pub attribute: std::option::Option<crate::model::SettingAttribute>,
}
impl GetSettingsInput {
    /// <p> The list of setting attribute enum values. </p>
    pub fn attribute(&self) -> std::option::Option<& crate::model::SettingAttribute> {
        self.attribute.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetServicesInScopeInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetOrganizationAdminAccountInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetInsightsByAssessmentInput  {
    /// <p>The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl GetInsightsByAssessmentInput {
    /// <p>The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetInsightsInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceFoldersByAssessmentControlInput  {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetEvidenceFoldersByAssessmentControlInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<& str> {
        self.control_set_id.as_deref()
    }
    /// <p> The identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<& str> {
        self.control_id.as_deref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceFoldersByAssessmentInput  {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetEvidenceFoldersByAssessmentInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceFolderInput  {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
}
impl GetEvidenceFolderInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<& str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<& str> {
        self.evidence_folder_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceByEvidenceFolderInput  {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetEvidenceByEvidenceFolderInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<& str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<& str> {
        self.evidence_folder_id.as_deref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetEvidenceInput  {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the evidence. </p>
    #[doc(hidden)]
    pub evidence_id: std::option::Option<std::string::String>,
}
impl GetEvidenceInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<& str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<& str> {
        self.evidence_folder_id.as_deref()
    }
    /// <p> The unique identifier for the evidence. </p>
    pub fn evidence_id(&self) -> std::option::Option<& str> {
        self.evidence_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDelegationsInput  {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetDelegationsInput {
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p> Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetControlInput  {
    /// <p> The identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
}
impl GetControlInput {
    /// <p> The identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<& str> {
        self.control_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetChangeLogsInput  {
    /// <p>The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetChangeLogsInput {
    /// <p>The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<& str> {
        self.control_set_id.as_deref()
    }
    /// <p> The unique identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<& str> {
        self.control_id.as_deref()
    }
    /// <p> The pagination token that's used to fetch the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>Represents the maximum number of results on a page or for an API request call. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssessmentReportUrlInput  {
    /// <p> The unique identifier for the assessment report. </p>
    #[doc(hidden)]
    pub assessment_report_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl GetAssessmentReportUrlInput {
    /// <p> The unique identifier for the assessment report. </p>
    pub fn assessment_report_id(&self) -> std::option::Option<& str> {
        self.assessment_report_id.as_deref()
    }
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssessmentFrameworkInput  {
    /// <p> The identifier for the framework. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
}
impl GetAssessmentFrameworkInput {
    /// <p> The identifier for the framework. </p>
    pub fn framework_id(&self) -> std::option::Option<& str> {
        self.framework_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAssessmentInput  {
    /// <p>The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl GetAssessmentInput {
    /// <p>The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAccountStatusInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateAssessmentReportEvidenceFolderInput  {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
}
impl DisassociateAssessmentReportEvidenceFolderInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<& str> {
        self.evidence_folder_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeregisterOrganizationAdminAccountInput  {
    /// <p> The identifier for the administrator account. </p>
    #[doc(hidden)]
    pub admin_account_id: std::option::Option<std::string::String>,
}
impl DeregisterOrganizationAdminAccountInput {
    /// <p> The identifier for the administrator account. </p>
    pub fn admin_account_id(&self) -> std::option::Option<& str> {
        self.admin_account_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeregisterAccountInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteControlInput  {
    /// <p> The unique identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
}
impl DeleteControlInput {
    /// <p> The unique identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<& str> {
        self.control_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssessmentReportInput  {
    /// <p> The unique identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The unique identifier for the assessment report. </p>
    #[doc(hidden)]
    pub assessment_report_id: std::option::Option<std::string::String>,
}
impl DeleteAssessmentReportInput {
    /// <p> The unique identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The unique identifier for the assessment report. </p>
    pub fn assessment_report_id(&self) -> std::option::Option<& str> {
        self.assessment_report_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssessmentFrameworkShareInput  {
    /// <p>The unique identifier for the share request to be deleted.</p>
    #[doc(hidden)]
    pub request_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the share request is a sent request or a received request.</p>
    #[doc(hidden)]
    pub request_type: std::option::Option<crate::model::ShareRequestType>,
}
impl DeleteAssessmentFrameworkShareInput {
    /// <p>The unique identifier for the share request to be deleted.</p>
    pub fn request_id(&self) -> std::option::Option<& str> {
        self.request_id.as_deref()
    }
    /// <p>Specifies whether the share request is a sent request or a received request.</p>
    pub fn request_type(&self) -> std::option::Option<& crate::model::ShareRequestType> {
        self.request_type.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssessmentFrameworkInput  {
    /// <p> The identifier for the custom framework. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
}
impl DeleteAssessmentFrameworkInput {
    /// <p> The identifier for the custom framework. </p>
    pub fn framework_id(&self) -> std::option::Option<& str> {
        self.framework_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAssessmentInput  {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl DeleteAssessmentInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateControlInput  {
    /// <p> The name of the control. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The description of the control. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The steps to follow to determine if the control is satisfied. </p>
    #[doc(hidden)]
    pub testing_information: std::option::Option<std::string::String>,
    /// <p> The title of the action plan for remediating the control. </p>
    #[doc(hidden)]
    pub action_plan_title: std::option::Option<std::string::String>,
    /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
    #[doc(hidden)]
    pub action_plan_instructions: std::option::Option<std::string::String>,
    /// <p> The data mapping sources for the control. </p>
    #[doc(hidden)]
    pub control_mapping_sources: std::option::Option<std::vec::Vec<crate::model::CreateControlMappingSource>>,
    /// <p> The tags that are associated with the control. </p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateControlInput {
    /// <p> The name of the control. </p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p> The description of the control. </p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p> The steps to follow to determine if the control is satisfied. </p>
    pub fn testing_information(&self) -> std::option::Option<& str> {
        self.testing_information.as_deref()
    }
    /// <p> The title of the action plan for remediating the control. </p>
    pub fn action_plan_title(&self) -> std::option::Option<& str> {
        self.action_plan_title.as_deref()
    }
    /// <p> The recommended actions to carry out if the control isn't fulfilled. </p>
    pub fn action_plan_instructions(&self) -> std::option::Option<& str> {
        self.action_plan_instructions.as_deref()
    }
    /// <p> The data mapping sources for the control. </p>
    pub fn control_mapping_sources(&self) -> std::option::Option<& [crate::model::CreateControlMappingSource]> {
        self.control_mapping_sources.as_deref()
    }
    /// <p> The tags that are associated with the control. </p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAssessmentReportInput  {
    /// <p> The name of the new assessment report. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The description of the assessment report. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p>A SQL statement that represents an evidence finder query.</p> 
    /// <p>Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence">added to a report using the console</a>, or <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html">associated with a report using the API</a>. </p> 
    /// <p>To use this parameter, the <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus">enablementStatus</a> of evidence finder must be <code>ENABLED</code>. </p> 
    /// <p> For examples and help resolving <code>queryStatement</code> validation exceptions, see <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions">Troubleshooting evidence finder issues</a> in the <i>Audit Manager User Guide.</i> </p>
    #[doc(hidden)]
    pub query_statement: std::option::Option<std::string::String>,
}
impl CreateAssessmentReportInput {
    /// <p> The name of the new assessment report. </p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p> The description of the assessment report. </p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p>A SQL statement that represents an evidence finder query.</p> 
    /// <p>Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence">added to a report using the console</a>, or <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_BatchAssociateAssessmentReportEvidence.html">associated with a report using the API</a>. </p> 
    /// <p>To use this parameter, the <a href="https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_EvidenceFinderEnablement.html#auditmanager-Type-EvidenceFinderEnablement-enablementStatus">enablementStatus</a> of evidence finder must be <code>ENABLED</code>. </p> 
    /// <p> For examples and help resolving <code>queryStatement</code> validation exceptions, see <a href="https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions">Troubleshooting evidence finder issues</a> in the <i>Audit Manager User Guide.</i> </p>
    pub fn query_statement(&self) -> std::option::Option<& str> {
        self.query_statement.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAssessmentFrameworkInput  {
    /// <p> The name of the new custom framework. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> An optional description for the new custom framework. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
    #[doc(hidden)]
    pub compliance_type: std::option::Option<std::string::String>,
    /// <p> The control sets that are associated with the framework. </p>
    #[doc(hidden)]
    pub control_sets: std::option::Option<std::vec::Vec<crate::model::CreateAssessmentFrameworkControlSet>>,
    /// <p> The tags that are associated with the framework. </p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateAssessmentFrameworkInput {
    /// <p> The name of the new custom framework. </p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p> An optional description for the new custom framework. </p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p> The compliance type that the new custom framework supports, such as CIS or HIPAA. </p>
    pub fn compliance_type(&self) -> std::option::Option<& str> {
        self.compliance_type.as_deref()
    }
    /// <p> The control sets that are associated with the framework. </p>
    pub fn control_sets(&self) -> std::option::Option<& [crate::model::CreateAssessmentFrameworkControlSet]> {
        self.control_sets.as_deref()
    }
    /// <p> The tags that are associated with the framework. </p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAssessmentInput  {
    /// <p> The name of the assessment to be created. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The optional description of the assessment to be created. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The assessment report storage destination for the assessment that's being created. </p>
    #[doc(hidden)]
    pub assessment_reports_destination: std::option::Option<crate::model::AssessmentReportsDestination>,
    /// <p> The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment. </p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p> The list of roles for the assessment. </p>
    #[doc(hidden)]
    pub roles: std::option::Option<std::vec::Vec<crate::model::Role>>,
    /// <p> The identifier for the framework that the assessment will be created from. </p>
    #[doc(hidden)]
    pub framework_id: std::option::Option<std::string::String>,
    /// <p> The tags that are associated with the assessment. </p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateAssessmentInput {
    /// <p> The name of the assessment to be created. </p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p> The optional description of the assessment to be created. </p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p> The assessment report storage destination for the assessment that's being created. </p>
    pub fn assessment_reports_destination(&self) -> std::option::Option<& crate::model::AssessmentReportsDestination> {
        self.assessment_reports_destination.as_ref()
    }
    /// <p> The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment. </p>
    pub fn scope(&self) -> std::option::Option<& crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p> The list of roles for the assessment. </p>
    pub fn roles(&self) -> std::option::Option<& [crate::model::Role]> {
        self.roles.as_deref()
    }
    /// <p> The identifier for the framework that the assessment will be created from. </p>
    pub fn framework_id(&self) -> std::option::Option<& str> {
        self.framework_id.as_deref()
    }
    /// <p> The tags that are associated with the assessment. </p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchImportEvidenceToAssessmentControlInput  {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control set. </p>
    #[doc(hidden)]
    pub control_set_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the control. </p>
    #[doc(hidden)]
    pub control_id: std::option::Option<std::string::String>,
    /// <p> The list of manual evidence objects. </p>
    #[doc(hidden)]
    pub manual_evidence: std::option::Option<std::vec::Vec<crate::model::ManualEvidence>>,
}
impl BatchImportEvidenceToAssessmentControlInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the control set. </p>
    pub fn control_set_id(&self) -> std::option::Option<& str> {
        self.control_set_id.as_deref()
    }
    /// <p> The identifier for the control. </p>
    pub fn control_id(&self) -> std::option::Option<& str> {
        self.control_id.as_deref()
    }
    /// <p> The list of manual evidence objects. </p>
    pub fn manual_evidence(&self) -> std::option::Option<& [crate::model::ManualEvidence]> {
        self.manual_evidence.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDisassociateAssessmentReportEvidenceInput  {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
    /// <p> The list of evidence identifiers. </p>
    #[doc(hidden)]
    pub evidence_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl BatchDisassociateAssessmentReportEvidenceInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<& str> {
        self.evidence_folder_id.as_deref()
    }
    /// <p> The list of evidence identifiers. </p>
    pub fn evidence_ids(&self) -> std::option::Option<& [std::string::String]> {
        self.evidence_ids.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDeleteDelegationByAssessmentInput  {
    /// <p> The identifiers for the delegations. </p>
    #[doc(hidden)]
    pub delegation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl BatchDeleteDelegationByAssessmentInput {
    /// <p> The identifiers for the delegations. </p>
    pub fn delegation_ids(&self) -> std::option::Option<& [std::string::String]> {
        self.delegation_ids.as_deref()
    }
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchCreateDelegationByAssessmentInput  {
    /// <p> The API request to batch create delegations in Audit Manager. </p>
    #[doc(hidden)]
    pub create_delegation_requests: std::option::Option<std::vec::Vec<crate::model::CreateDelegationRequest>>,
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
}
impl BatchCreateDelegationByAssessmentInput {
    /// <p> The API request to batch create delegations in Audit Manager. </p>
    pub fn create_delegation_requests(&self) -> std::option::Option<& [crate::model::CreateDelegationRequest]> {
        self.create_delegation_requests.as_deref()
    }
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchAssociateAssessmentReportEvidenceInput  {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
    /// <p> The list of evidence identifiers. </p>
    #[doc(hidden)]
    pub evidence_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl BatchAssociateAssessmentReportEvidenceInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<& str> {
        self.evidence_folder_id.as_deref()
    }
    /// <p> The list of evidence identifiers. </p>
    pub fn evidence_ids(&self) -> std::option::Option<& [std::string::String]> {
        self.evidence_ids.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateAssessmentReportEvidenceFolderInput  {
    /// <p> The identifier for the assessment. </p>
    #[doc(hidden)]
    pub assessment_id: std::option::Option<std::string::String>,
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    #[doc(hidden)]
    pub evidence_folder_id: std::option::Option<std::string::String>,
}
impl AssociateAssessmentReportEvidenceFolderInput {
    /// <p> The identifier for the assessment. </p>
    pub fn assessment_id(&self) -> std::option::Option<& str> {
        self.assessment_id.as_deref()
    }
    /// <p> The identifier for the folder that the evidence is stored in. </p>
    pub fn evidence_folder_id(&self) -> std::option::Option<& str> {
        self.evidence_folder_id.as_deref()
    }
}

