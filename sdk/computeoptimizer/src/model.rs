// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `Status`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let status = unimplemented!();
/// match status {
///     Status::Active => { /* ... */ },
///     Status::Failed => { /* ... */ },
///     Status::Inactive => { /* ... */ },
///     Status::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `status` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Status::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Status::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Status::NewFeature` is defined.
/// Specifically, when `status` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Status::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum Status {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for Status {
    fn from(s: &str) -> Self {
        match s {
            "Active" => Status::Active,
            "Failed" => Status::Failed,
            "Inactive" => Status::Inactive,
            "Pending" => Status::Pending,
            other => Status::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for Status {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(Status::from(s))
                }
            }
impl Status {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Status::Active => "Active",
            Status::Failed => "Failed",
            Status::Inactive => "Inactive",
            Status::Pending => "Pending",
            Status::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Active", "Failed", "Inactive", "Pending"
        ]
    }
}
impl AsRef<str> for Status {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Describes the external metrics preferences for EC2 rightsizing recommendations. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExternalMetricsPreference  {
    /// <p> Contains the source options for external metrics preferences. </p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::ExternalMetricsSource>,
}
impl ExternalMetricsPreference {
    /// <p> Contains the source options for external metrics preferences. </p>
    pub fn source(&self) -> std::option::Option<& crate::model::ExternalMetricsSource> {
        self.source.as_ref()
    }
}
/// See [`ExternalMetricsPreference`](crate::model::ExternalMetricsPreference).
pub mod external_metrics_preference {
    
    /// A builder for [`ExternalMetricsPreference`](crate::model::ExternalMetricsPreference).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source: std::option::Option<crate::model::ExternalMetricsSource>,
    }
    impl Builder {
        /// <p> Contains the source options for external metrics preferences. </p>
        pub fn source(mut self, input: crate::model::ExternalMetricsSource) -> Self {
            self.source = Some(input);
            self
        }
        /// <p> Contains the source options for external metrics preferences. </p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::ExternalMetricsSource>) -> Self {
            self.source = input; self
        }
        /// Consumes the builder and constructs a [`ExternalMetricsPreference`](crate::model::ExternalMetricsPreference).
        pub fn build(self) -> crate::model::ExternalMetricsPreference {
            crate::model::ExternalMetricsPreference {
                source: self.source
                ,
            }
        }
    }
    
    
}
impl ExternalMetricsPreference {
    /// Creates a new builder-style object to manufacture [`ExternalMetricsPreference`](crate::model::ExternalMetricsPreference).
    pub fn builder() -> crate::model::external_metrics_preference::Builder {
        crate::model::external_metrics_preference::Builder::default()
    }
}

/// When writing a match expression against `ExternalMetricsSource`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let externalmetricssource = unimplemented!();
/// match externalmetricssource {
///     ExternalMetricsSource::Datadog => { /* ... */ },
///     ExternalMetricsSource::Dynatrace => { /* ... */ },
///     ExternalMetricsSource::Instana => { /* ... */ },
///     ExternalMetricsSource::Newrelic => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `externalmetricssource` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExternalMetricsSource::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExternalMetricsSource::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExternalMetricsSource::NewFeature` is defined.
/// Specifically, when `externalmetricssource` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExternalMetricsSource::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ExternalMetricsSource {
    #[allow(missing_docs)] // documentation missing in model
    Datadog,
    #[allow(missing_docs)] // documentation missing in model
    Dynatrace,
    #[allow(missing_docs)] // documentation missing in model
    Instana,
    #[allow(missing_docs)] // documentation missing in model
    Newrelic,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ExternalMetricsSource {
    fn from(s: &str) -> Self {
        match s {
            "Datadog" => ExternalMetricsSource::Datadog,
            "Dynatrace" => ExternalMetricsSource::Dynatrace,
            "Instana" => ExternalMetricsSource::Instana,
            "NewRelic" => ExternalMetricsSource::Newrelic,
            other => ExternalMetricsSource::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ExternalMetricsSource {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ExternalMetricsSource::from(s))
                }
            }
impl ExternalMetricsSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExternalMetricsSource::Datadog => "Datadog",
            ExternalMetricsSource::Dynatrace => "Dynatrace",
            ExternalMetricsSource::Instana => "Instana",
            ExternalMetricsSource::Newrelic => "NewRelic",
            ExternalMetricsSource::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Datadog", "Dynatrace", "Instana", "NewRelic"
        ]
    }
}
impl AsRef<str> for ExternalMetricsSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InferredWorkloadTypesPreference`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let inferredworkloadtypespreference = unimplemented!();
/// match inferredworkloadtypespreference {
///     InferredWorkloadTypesPreference::Active => { /* ... */ },
///     InferredWorkloadTypesPreference::Inactive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `inferredworkloadtypespreference` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InferredWorkloadTypesPreference::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InferredWorkloadTypesPreference::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InferredWorkloadTypesPreference::NewFeature` is defined.
/// Specifically, when `inferredworkloadtypespreference` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InferredWorkloadTypesPreference::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum InferredWorkloadTypesPreference {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for InferredWorkloadTypesPreference {
    fn from(s: &str) -> Self {
        match s {
            "Active" => InferredWorkloadTypesPreference::Active,
            "Inactive" => InferredWorkloadTypesPreference::Inactive,
            other => InferredWorkloadTypesPreference::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for InferredWorkloadTypesPreference {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(InferredWorkloadTypesPreference::from(s))
                }
            }
impl InferredWorkloadTypesPreference {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InferredWorkloadTypesPreference::Active => "Active",
            InferredWorkloadTypesPreference::Inactive => "Inactive",
            InferredWorkloadTypesPreference::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Active", "Inactive"
        ]
    }
}
impl AsRef<str> for InferredWorkloadTypesPreference {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EnhancedInfrastructureMetrics`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let enhancedinfrastructuremetrics = unimplemented!();
/// match enhancedinfrastructuremetrics {
///     EnhancedInfrastructureMetrics::Active => { /* ... */ },
///     EnhancedInfrastructureMetrics::Inactive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `enhancedinfrastructuremetrics` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EnhancedInfrastructureMetrics::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EnhancedInfrastructureMetrics::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EnhancedInfrastructureMetrics::NewFeature` is defined.
/// Specifically, when `enhancedinfrastructuremetrics` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EnhancedInfrastructureMetrics::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EnhancedInfrastructureMetrics {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EnhancedInfrastructureMetrics {
    fn from(s: &str) -> Self {
        match s {
            "Active" => EnhancedInfrastructureMetrics::Active,
            "Inactive" => EnhancedInfrastructureMetrics::Inactive,
            other => EnhancedInfrastructureMetrics::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EnhancedInfrastructureMetrics {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EnhancedInfrastructureMetrics::from(s))
                }
            }
impl EnhancedInfrastructureMetrics {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EnhancedInfrastructureMetrics::Active => "Active",
            EnhancedInfrastructureMetrics::Inactive => "Inactive",
            EnhancedInfrastructureMetrics::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Active", "Inactive"
        ]
    }
}
impl AsRef<str> for EnhancedInfrastructureMetrics {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the scope of a recommendation preference.</p> 
/// <p>Recommendation preferences can be created at the organization level (for management accounts of an organization only), account level, and resource level. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Activating enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p> <note> 
/// <p>You cannot create recommendation preferences for Auto Scaling groups at the organization and account levels. You can create recommendation preferences for Auto Scaling groups only at the resource level by specifying a scope name of <code>ResourceArn</code> and a scope value of the Auto Scaling group Amazon Resource Name (ARN). This will configure the preference for all instances that are part of the specified Auto Scaling group. You also cannot create recommendation preferences at the resource level for instances that are part of an Auto Scaling group. You can create recommendation preferences at the resource level only for standalone instances.</p> 
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Scope  {
    /// <p>The name of the scope.</p> 
    /// <p>The following scopes are possible:</p> 
    /// <ul> 
    /// <li> <p> <code>Organization</code> - Specifies that the recommendation preference applies at the organization level, for all member accounts of an organization.</p> </li> 
    /// <li> <p> <code>AccountId</code> - Specifies that the recommendation preference applies at the account level, for all resources of a given resource type in an account.</p> </li> 
    /// <li> <p> <code>ResourceArn</code> - Specifies that the recommendation preference applies at the individual resource level.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::ScopeName>,
    /// <p>The value of the scope.</p> 
    /// <p>If you specified the <code>name</code> of the scope as:</p> 
    /// <ul> 
    /// <li> <p> <code>Organization</code> - The <code>value</code> must be <code>ALL_ACCOUNTS</code>.</p> </li> 
    /// <li> <p> <code>AccountId</code> - The <code>value</code> must be a 12-digit Amazon Web Services account ID.</p> </li> 
    /// <li> <p> <code>ResourceArn</code> - The <code>value</code> must be the Amazon Resource Name (ARN) of an EC2 instance or an Auto Scaling group.</p> </li> 
    /// </ul> 
    /// <p>Only EC2 instance and Auto Scaling group ARNs are currently supported.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Scope {
    /// <p>The name of the scope.</p> 
    /// <p>The following scopes are possible:</p> 
    /// <ul> 
    /// <li> <p> <code>Organization</code> - Specifies that the recommendation preference applies at the organization level, for all member accounts of an organization.</p> </li> 
    /// <li> <p> <code>AccountId</code> - Specifies that the recommendation preference applies at the account level, for all resources of a given resource type in an account.</p> </li> 
    /// <li> <p> <code>ResourceArn</code> - Specifies that the recommendation preference applies at the individual resource level.</p> </li> 
    /// </ul>
    pub fn name(&self) -> std::option::Option<& crate::model::ScopeName> {
        self.name.as_ref()
    }
    /// <p>The value of the scope.</p> 
    /// <p>If you specified the <code>name</code> of the scope as:</p> 
    /// <ul> 
    /// <li> <p> <code>Organization</code> - The <code>value</code> must be <code>ALL_ACCOUNTS</code>.</p> </li> 
    /// <li> <p> <code>AccountId</code> - The <code>value</code> must be a 12-digit Amazon Web Services account ID.</p> </li> 
    /// <li> <p> <code>ResourceArn</code> - The <code>value</code> must be the Amazon Resource Name (ARN) of an EC2 instance or an Auto Scaling group.</p> </li> 
    /// </ul> 
    /// <p>Only EC2 instance and Auto Scaling group ARNs are currently supported.</p>
    pub fn value(&self) -> std::option::Option<& str> {
        self.value.as_deref()
    }
}
/// See [`Scope`](crate::model::Scope).
pub mod scope {
    
    /// A builder for [`Scope`](crate::model::Scope).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::ScopeName>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the scope.</p> 
        /// <p>The following scopes are possible:</p> 
        /// <ul> 
        /// <li> <p> <code>Organization</code> - Specifies that the recommendation preference applies at the organization level, for all member accounts of an organization.</p> </li> 
        /// <li> <p> <code>AccountId</code> - Specifies that the recommendation preference applies at the account level, for all resources of a given resource type in an account.</p> </li> 
        /// <li> <p> <code>ResourceArn</code> - Specifies that the recommendation preference applies at the individual resource level.</p> </li> 
        /// </ul>
        pub fn name(mut self, input: crate::model::ScopeName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the scope.</p> 
        /// <p>The following scopes are possible:</p> 
        /// <ul> 
        /// <li> <p> <code>Organization</code> - Specifies that the recommendation preference applies at the organization level, for all member accounts of an organization.</p> </li> 
        /// <li> <p> <code>AccountId</code> - Specifies that the recommendation preference applies at the account level, for all resources of a given resource type in an account.</p> </li> 
        /// <li> <p> <code>ResourceArn</code> - Specifies that the recommendation preference applies at the individual resource level.</p> </li> 
        /// </ul>
        pub fn set_name(mut self, input: std::option::Option<crate::model::ScopeName>) -> Self {
            self.name = input; self
        }
        /// <p>The value of the scope.</p> 
        /// <p>If you specified the <code>name</code> of the scope as:</p> 
        /// <ul> 
        /// <li> <p> <code>Organization</code> - The <code>value</code> must be <code>ALL_ACCOUNTS</code>.</p> </li> 
        /// <li> <p> <code>AccountId</code> - The <code>value</code> must be a 12-digit Amazon Web Services account ID.</p> </li> 
        /// <li> <p> <code>ResourceArn</code> - The <code>value</code> must be the Amazon Resource Name (ARN) of an EC2 instance or an Auto Scaling group.</p> </li> 
        /// </ul> 
        /// <p>Only EC2 instance and Auto Scaling group ARNs are currently supported.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the scope.</p> 
        /// <p>If you specified the <code>name</code> of the scope as:</p> 
        /// <ul> 
        /// <li> <p> <code>Organization</code> - The <code>value</code> must be <code>ALL_ACCOUNTS</code>.</p> </li> 
        /// <li> <p> <code>AccountId</code> - The <code>value</code> must be a 12-digit Amazon Web Services account ID.</p> </li> 
        /// <li> <p> <code>ResourceArn</code> - The <code>value</code> must be the Amazon Resource Name (ARN) of an EC2 instance or an Auto Scaling group.</p> </li> 
        /// </ul> 
        /// <p>Only EC2 instance and Auto Scaling group ARNs are currently supported.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`Scope`](crate::model::Scope).
        pub fn build(self) -> crate::model::Scope {
            crate::model::Scope {
                name: self.name
                ,
                value: self.value
                ,
            }
        }
    }
    
    
}
impl Scope {
    /// Creates a new builder-style object to manufacture [`Scope`](crate::model::Scope).
    pub fn builder() -> crate::model::scope::Builder {
        crate::model::scope::Builder::default()
    }
}

/// When writing a match expression against `ScopeName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let scopename = unimplemented!();
/// match scopename {
///     ScopeName::AccountId => { /* ... */ },
///     ScopeName::Organization => { /* ... */ },
///     ScopeName::ResourceArn => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scopename` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScopeName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScopeName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScopeName::NewFeature` is defined.
/// Specifically, when `scopename` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScopeName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ScopeName {
    #[allow(missing_docs)] // documentation missing in model
    AccountId,
    #[allow(missing_docs)] // documentation missing in model
    Organization,
    #[allow(missing_docs)] // documentation missing in model
    ResourceArn,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ScopeName {
    fn from(s: &str) -> Self {
        match s {
            "AccountId" => ScopeName::AccountId,
            "Organization" => ScopeName::Organization,
            "ResourceArn" => ScopeName::ResourceArn,
            other => ScopeName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ScopeName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ScopeName::from(s))
                }
            }
impl ScopeName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScopeName::AccountId => "AccountId",
            ScopeName::Organization => "Organization",
            ScopeName::ResourceArn => "ResourceArn",
            ScopeName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccountId", "Organization", "ResourceArn"
        ]
    }
}
impl AsRef<str> for ScopeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::AutoScalingGroup => { /* ... */ },
///     ResourceType::EbsVolume => { /* ... */ },
///     ResourceType::Ec2Instance => { /* ... */ },
///     ResourceType::EcsService => { /* ... */ },
///     ResourceType::LambdaFunction => { /* ... */ },
///     ResourceType::NotApplicable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    AutoScalingGroup,
    #[allow(missing_docs)] // documentation missing in model
    EbsVolume,
    #[allow(missing_docs)] // documentation missing in model
    Ec2Instance,
    #[allow(missing_docs)] // documentation missing in model
    EcsService,
    #[allow(missing_docs)] // documentation missing in model
    LambdaFunction,
    #[allow(missing_docs)] // documentation missing in model
    NotApplicable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "AutoScalingGroup" => ResourceType::AutoScalingGroup,
            "EbsVolume" => ResourceType::EbsVolume,
            "Ec2Instance" => ResourceType::Ec2Instance,
            "EcsService" => ResourceType::EcsService,
            "LambdaFunction" => ResourceType::LambdaFunction,
            "NotApplicable" => ResourceType::NotApplicable,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ResourceType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ResourceType::from(s))
                }
            }
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::AutoScalingGroup => "AutoScalingGroup",
            ResourceType::EbsVolume => "EbsVolume",
            ResourceType::Ec2Instance => "Ec2Instance",
            ResourceType::EcsService => "EcsService",
            ResourceType::LambdaFunction => "LambdaFunction",
            ResourceType::NotApplicable => "NotApplicable",
            ResourceType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AutoScalingGroup", "EbsVolume", "Ec2Instance", "EcsService", "LambdaFunction", "NotApplicable"
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A summary of a recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendationSummary  {
    /// <p>An array of objects that describe a recommendation summary.</p>
    #[doc(hidden)]
    pub summaries: std::option::Option<std::vec::Vec<crate::model::Summary>>,
    /// <p>The resource type that the recommendation summary applies to.</p>
    #[doc(hidden)]
    pub recommendation_resource_type: std::option::Option<crate::model::RecommendationSourceType>,
    /// <p>The Amazon Web Services account ID of the recommendation summary.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>An object that describes the savings opportunity for a given resource type. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    #[doc(hidden)]
    pub savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
    /// <p>An object that describes the performance risk ratings for a given resource type.</p>
    #[doc(hidden)]
    pub current_performance_risk_ratings: std::option::Option<crate::model::CurrentPerformanceRiskRatings>,
}
impl RecommendationSummary {
    /// <p>An array of objects that describe a recommendation summary.</p>
    pub fn summaries(&self) -> std::option::Option<& [crate::model::Summary]> {
        self.summaries.as_deref()
    }
    /// <p>The resource type that the recommendation summary applies to.</p>
    pub fn recommendation_resource_type(&self) -> std::option::Option<& crate::model::RecommendationSourceType> {
        self.recommendation_resource_type.as_ref()
    }
    /// <p>The Amazon Web Services account ID of the recommendation summary.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>An object that describes the savings opportunity for a given resource type. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    pub fn savings_opportunity(&self) -> std::option::Option<& crate::model::SavingsOpportunity> {
        self.savings_opportunity.as_ref()
    }
    /// <p>An object that describes the performance risk ratings for a given resource type.</p>
    pub fn current_performance_risk_ratings(&self) -> std::option::Option<& crate::model::CurrentPerformanceRiskRatings> {
        self.current_performance_risk_ratings.as_ref()
    }
}
/// See [`RecommendationSummary`](crate::model::RecommendationSummary).
pub mod recommendation_summary {
    
    /// A builder for [`RecommendationSummary`](crate::model::RecommendationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) summaries: std::option::Option<std::vec::Vec<crate::model::Summary>>,
        pub(crate) recommendation_resource_type: std::option::Option<crate::model::RecommendationSourceType>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
        pub(crate) current_performance_risk_ratings: std::option::Option<crate::model::CurrentPerformanceRiskRatings>,
    }
    impl Builder {
        /// Appends an item to `summaries`.
        ///
        /// To override the contents of this collection use [`set_summaries`](Self::set_summaries).
        ///
        /// <p>An array of objects that describe a recommendation summary.</p>
        pub fn summaries(mut self, input: crate::model::Summary) -> Self {
            let mut v = self.summaries.unwrap_or_default();
                            v.push(input);
                            self.summaries = Some(v);
                            self
        }
        /// <p>An array of objects that describe a recommendation summary.</p>
        pub fn set_summaries(mut self, input: std::option::Option<std::vec::Vec<crate::model::Summary>>) -> Self {
            self.summaries = input; self
        }
        /// <p>The resource type that the recommendation summary applies to.</p>
        pub fn recommendation_resource_type(mut self, input: crate::model::RecommendationSourceType) -> Self {
            self.recommendation_resource_type = Some(input);
            self
        }
        /// <p>The resource type that the recommendation summary applies to.</p>
        pub fn set_recommendation_resource_type(mut self, input: std::option::Option<crate::model::RecommendationSourceType>) -> Self {
            self.recommendation_resource_type = input; self
        }
        /// <p>The Amazon Web Services account ID of the recommendation summary.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the recommendation summary.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>An object that describes the savings opportunity for a given resource type. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn savings_opportunity(mut self, input: crate::model::SavingsOpportunity) -> Self {
            self.savings_opportunity = Some(input);
            self
        }
        /// <p>An object that describes the savings opportunity for a given resource type. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn set_savings_opportunity(mut self, input: std::option::Option<crate::model::SavingsOpportunity>) -> Self {
            self.savings_opportunity = input; self
        }
        /// <p>An object that describes the performance risk ratings for a given resource type.</p>
        pub fn current_performance_risk_ratings(mut self, input: crate::model::CurrentPerformanceRiskRatings) -> Self {
            self.current_performance_risk_ratings = Some(input);
            self
        }
        /// <p>An object that describes the performance risk ratings for a given resource type.</p>
        pub fn set_current_performance_risk_ratings(mut self, input: std::option::Option<crate::model::CurrentPerformanceRiskRatings>) -> Self {
            self.current_performance_risk_ratings = input; self
        }
        /// Consumes the builder and constructs a [`RecommendationSummary`](crate::model::RecommendationSummary).
        pub fn build(self) -> crate::model::RecommendationSummary {
            crate::model::RecommendationSummary {
                summaries: self.summaries
                ,
                recommendation_resource_type: self.recommendation_resource_type
                ,
                account_id: self.account_id
                ,
                savings_opportunity: self.savings_opportunity
                ,
                current_performance_risk_ratings: self.current_performance_risk_ratings
                ,
            }
        }
    }
    
    
}
impl RecommendationSummary {
    /// Creates a new builder-style object to manufacture [`RecommendationSummary`](crate::model::RecommendationSummary).
    pub fn builder() -> crate::model::recommendation_summary::Builder {
        crate::model::recommendation_summary::Builder::default()
    }
}

/// <p>Describes the performance risk ratings for a given resource type.</p> 
/// <p>Resources with a <code>high</code> or <code>medium</code> rating are at risk of not meeting the performance needs of their workloads, while resources with a <code>low</code> rating are performing well in their workloads.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CurrentPerformanceRiskRatings  {
    /// <p>A count of the applicable resource types with a high performance risk rating.</p>
    #[doc(hidden)]
    pub high: i64,
    /// <p>A count of the applicable resource types with a medium performance risk rating.</p>
    #[doc(hidden)]
    pub medium: i64,
    /// <p>A count of the applicable resource types with a low performance risk rating.</p>
    #[doc(hidden)]
    pub low: i64,
    /// <p>A count of the applicable resource types with a very low performance risk rating.</p>
    #[doc(hidden)]
    pub very_low: i64,
}
impl CurrentPerformanceRiskRatings {
    /// <p>A count of the applicable resource types with a high performance risk rating.</p>
    pub fn high(&self) -> i64 {
        self.high
    }
    /// <p>A count of the applicable resource types with a medium performance risk rating.</p>
    pub fn medium(&self) -> i64 {
        self.medium
    }
    /// <p>A count of the applicable resource types with a low performance risk rating.</p>
    pub fn low(&self) -> i64 {
        self.low
    }
    /// <p>A count of the applicable resource types with a very low performance risk rating.</p>
    pub fn very_low(&self) -> i64 {
        self.very_low
    }
}
/// See [`CurrentPerformanceRiskRatings`](crate::model::CurrentPerformanceRiskRatings).
pub mod current_performance_risk_ratings {
    
    /// A builder for [`CurrentPerformanceRiskRatings`](crate::model::CurrentPerformanceRiskRatings).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) high: std::option::Option<i64>,
        pub(crate) medium: std::option::Option<i64>,
        pub(crate) low: std::option::Option<i64>,
        pub(crate) very_low: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>A count of the applicable resource types with a high performance risk rating.</p>
        pub fn high(mut self, input: i64) -> Self {
            self.high = Some(input);
            self
        }
        /// <p>A count of the applicable resource types with a high performance risk rating.</p>
        pub fn set_high(mut self, input: std::option::Option<i64>) -> Self {
            self.high = input; self
        }
        /// <p>A count of the applicable resource types with a medium performance risk rating.</p>
        pub fn medium(mut self, input: i64) -> Self {
            self.medium = Some(input);
            self
        }
        /// <p>A count of the applicable resource types with a medium performance risk rating.</p>
        pub fn set_medium(mut self, input: std::option::Option<i64>) -> Self {
            self.medium = input; self
        }
        /// <p>A count of the applicable resource types with a low performance risk rating.</p>
        pub fn low(mut self, input: i64) -> Self {
            self.low = Some(input);
            self
        }
        /// <p>A count of the applicable resource types with a low performance risk rating.</p>
        pub fn set_low(mut self, input: std::option::Option<i64>) -> Self {
            self.low = input; self
        }
        /// <p>A count of the applicable resource types with a very low performance risk rating.</p>
        pub fn very_low(mut self, input: i64) -> Self {
            self.very_low = Some(input);
            self
        }
        /// <p>A count of the applicable resource types with a very low performance risk rating.</p>
        pub fn set_very_low(mut self, input: std::option::Option<i64>) -> Self {
            self.very_low = input; self
        }
        /// Consumes the builder and constructs a [`CurrentPerformanceRiskRatings`](crate::model::CurrentPerformanceRiskRatings).
        pub fn build(self) -> crate::model::CurrentPerformanceRiskRatings {
            crate::model::CurrentPerformanceRiskRatings {
                high: self.high
                    .unwrap_or_default()
                ,
                medium: self.medium
                    .unwrap_or_default()
                ,
                low: self.low
                    .unwrap_or_default()
                ,
                very_low: self.very_low
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl CurrentPerformanceRiskRatings {
    /// Creates a new builder-style object to manufacture [`CurrentPerformanceRiskRatings`](crate::model::CurrentPerformanceRiskRatings).
    pub fn builder() -> crate::model::current_performance_risk_ratings::Builder {
        crate::model::current_performance_risk_ratings::Builder::default()
    }
}

/// <p>Describes the savings opportunity for recommendations of a given resource type or for the recommendation option of an individual resource.</p> 
/// <p>Savings opportunity represents the estimated monthly savings you can achieve by implementing a given Compute Optimizer recommendation.</p> <important> 
/// <p>Savings opportunity data requires that you opt in to Cost Explorer, as well as activate <b>Receive Amazon EC2 resource recommendations</b> in the Cost Explorer preferences page. That creates a connection between Cost Explorer and Compute Optimizer. With this connection, Cost Explorer generates savings estimates considering the price of existing resources, the price of recommended resources, and historical usage data. Estimated monthly savings reflects the projected dollar savings associated with each of the recommendations generated. For more information, see <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-enable.html">Enabling Cost Explorer</a> and <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-rightsizing.html">Optimizing your cost with Rightsizing Recommendations</a> in the <i>Cost Management User Guide</i>.</p> 
/// </important>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SavingsOpportunity  {
    /// <p>The estimated monthly savings possible as a percentage of monthly cost by adopting Compute Optimizer recommendations for a given resource.</p>
    #[doc(hidden)]
    pub savings_opportunity_percentage: f64,
    /// <p>An object that describes the estimated monthly savings amount possible, based on On-Demand instance pricing, by adopting Compute Optimizer recommendations for a given resource.</p>
    #[doc(hidden)]
    pub estimated_monthly_savings: std::option::Option<crate::model::EstimatedMonthlySavings>,
}
impl SavingsOpportunity {
    /// <p>The estimated monthly savings possible as a percentage of monthly cost by adopting Compute Optimizer recommendations for a given resource.</p>
    pub fn savings_opportunity_percentage(&self) -> f64 {
        self.savings_opportunity_percentage
    }
    /// <p>An object that describes the estimated monthly savings amount possible, based on On-Demand instance pricing, by adopting Compute Optimizer recommendations for a given resource.</p>
    pub fn estimated_monthly_savings(&self) -> std::option::Option<& crate::model::EstimatedMonthlySavings> {
        self.estimated_monthly_savings.as_ref()
    }
}
/// See [`SavingsOpportunity`](crate::model::SavingsOpportunity).
pub mod savings_opportunity {
    
    /// A builder for [`SavingsOpportunity`](crate::model::SavingsOpportunity).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) savings_opportunity_percentage: std::option::Option<f64>,
        pub(crate) estimated_monthly_savings: std::option::Option<crate::model::EstimatedMonthlySavings>,
    }
    impl Builder {
        /// <p>The estimated monthly savings possible as a percentage of monthly cost by adopting Compute Optimizer recommendations for a given resource.</p>
        pub fn savings_opportunity_percentage(mut self, input: f64) -> Self {
            self.savings_opportunity_percentage = Some(input);
            self
        }
        /// <p>The estimated monthly savings possible as a percentage of monthly cost by adopting Compute Optimizer recommendations for a given resource.</p>
        pub fn set_savings_opportunity_percentage(mut self, input: std::option::Option<f64>) -> Self {
            self.savings_opportunity_percentage = input; self
        }
        /// <p>An object that describes the estimated monthly savings amount possible, based on On-Demand instance pricing, by adopting Compute Optimizer recommendations for a given resource.</p>
        pub fn estimated_monthly_savings(mut self, input: crate::model::EstimatedMonthlySavings) -> Self {
            self.estimated_monthly_savings = Some(input);
            self
        }
        /// <p>An object that describes the estimated monthly savings amount possible, based on On-Demand instance pricing, by adopting Compute Optimizer recommendations for a given resource.</p>
        pub fn set_estimated_monthly_savings(mut self, input: std::option::Option<crate::model::EstimatedMonthlySavings>) -> Self {
            self.estimated_monthly_savings = input; self
        }
        /// Consumes the builder and constructs a [`SavingsOpportunity`](crate::model::SavingsOpportunity).
        pub fn build(self) -> crate::model::SavingsOpportunity {
            crate::model::SavingsOpportunity {
                savings_opportunity_percentage: self.savings_opportunity_percentage
                    .unwrap_or_default()
                ,
                estimated_monthly_savings: self.estimated_monthly_savings
                ,
            }
        }
    }
    
    
}
impl SavingsOpportunity {
    /// Creates a new builder-style object to manufacture [`SavingsOpportunity`](crate::model::SavingsOpportunity).
    pub fn builder() -> crate::model::savings_opportunity::Builder {
        crate::model::savings_opportunity::Builder::default()
    }
}

/// <p>Describes the estimated monthly savings amount possible, based on On-Demand instance pricing, by adopting Compute Optimizer recommendations for a given resource.</p> 
/// <p>For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/view-ec2-recommendations.html#ec2-savings-calculation">Estimated monthly savings and savings opportunities</a> in the <i>Compute Optimizer User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EstimatedMonthlySavings  {
    /// <p>The currency of the estimated monthly savings.</p>
    #[doc(hidden)]
    pub currency: std::option::Option<crate::model::Currency>,
    /// <p>The value of the estimated monthly savings.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl EstimatedMonthlySavings {
    /// <p>The currency of the estimated monthly savings.</p>
    pub fn currency(&self) -> std::option::Option<& crate::model::Currency> {
        self.currency.as_ref()
    }
    /// <p>The value of the estimated monthly savings.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`EstimatedMonthlySavings`](crate::model::EstimatedMonthlySavings).
pub mod estimated_monthly_savings {
    
    /// A builder for [`EstimatedMonthlySavings`](crate::model::EstimatedMonthlySavings).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) currency: std::option::Option<crate::model::Currency>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The currency of the estimated monthly savings.</p>
        pub fn currency(mut self, input: crate::model::Currency) -> Self {
            self.currency = Some(input);
            self
        }
        /// <p>The currency of the estimated monthly savings.</p>
        pub fn set_currency(mut self, input: std::option::Option<crate::model::Currency>) -> Self {
            self.currency = input; self
        }
        /// <p>The value of the estimated monthly savings.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the estimated monthly savings.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`EstimatedMonthlySavings`](crate::model::EstimatedMonthlySavings).
        pub fn build(self) -> crate::model::EstimatedMonthlySavings {
            crate::model::EstimatedMonthlySavings {
                currency: self.currency
                ,
                value: self.value
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl EstimatedMonthlySavings {
    /// Creates a new builder-style object to manufacture [`EstimatedMonthlySavings`](crate::model::EstimatedMonthlySavings).
    pub fn builder() -> crate::model::estimated_monthly_savings::Builder {
        crate::model::estimated_monthly_savings::Builder::default()
    }
}

/// When writing a match expression against `Currency`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let currency = unimplemented!();
/// match currency {
///     Currency::Cny => { /* ... */ },
///     Currency::Usd => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `currency` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Currency::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Currency::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Currency::NewFeature` is defined.
/// Specifically, when `currency` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Currency::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum Currency {
    #[allow(missing_docs)] // documentation missing in model
    Cny,
    #[allow(missing_docs)] // documentation missing in model
    Usd,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for Currency {
    fn from(s: &str) -> Self {
        match s {
            "CNY" => Currency::Cny,
            "USD" => Currency::Usd,
            other => Currency::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for Currency {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(Currency::from(s))
                }
            }
impl Currency {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Currency::Cny => "CNY",
            Currency::Usd => "USD",
            Currency::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CNY", "USD"
        ]
    }
}
impl AsRef<str> for Currency {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RecommendationSourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let recommendationsourcetype = unimplemented!();
/// match recommendationsourcetype {
///     RecommendationSourceType::AutoScalingGroup => { /* ... */ },
///     RecommendationSourceType::EbsVolume => { /* ... */ },
///     RecommendationSourceType::Ec2Instance => { /* ... */ },
///     RecommendationSourceType::EcsService => { /* ... */ },
///     RecommendationSourceType::LambdaFunction => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recommendationsourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecommendationSourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecommendationSourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecommendationSourceType::NewFeature` is defined.
/// Specifically, when `recommendationsourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecommendationSourceType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum RecommendationSourceType {
    #[allow(missing_docs)] // documentation missing in model
    AutoScalingGroup,
    #[allow(missing_docs)] // documentation missing in model
    EbsVolume,
    #[allow(missing_docs)] // documentation missing in model
    Ec2Instance,
    #[allow(missing_docs)] // documentation missing in model
    EcsService,
    #[allow(missing_docs)] // documentation missing in model
    LambdaFunction,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for RecommendationSourceType {
    fn from(s: &str) -> Self {
        match s {
            "AutoScalingGroup" => RecommendationSourceType::AutoScalingGroup,
            "EbsVolume" => RecommendationSourceType::EbsVolume,
            "Ec2Instance" => RecommendationSourceType::Ec2Instance,
            "EcsService" => RecommendationSourceType::EcsService,
            "LambdaFunction" => RecommendationSourceType::LambdaFunction,
            other => RecommendationSourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for RecommendationSourceType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(RecommendationSourceType::from(s))
                }
            }
impl RecommendationSourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecommendationSourceType::AutoScalingGroup => "AutoScalingGroup",
            RecommendationSourceType::EbsVolume => "EbsVolume",
            RecommendationSourceType::Ec2Instance => "Ec2Instance",
            RecommendationSourceType::EcsService => "EcsService",
            RecommendationSourceType::LambdaFunction => "LambdaFunction",
            RecommendationSourceType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AutoScalingGroup", "EbsVolume", "Ec2Instance", "EcsService", "LambdaFunction"
        ]
    }
}
impl AsRef<str> for RecommendationSourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of a recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Summary  {
    /// <p>The finding classification of the recommendation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::Finding>,
    /// <p>The value of the recommendation summary.</p>
    #[doc(hidden)]
    pub value: f64,
    /// <p>An array of objects that summarize a finding reason code.</p>
    #[doc(hidden)]
    pub reason_code_summaries: std::option::Option<std::vec::Vec<crate::model::ReasonCodeSummary>>,
}
impl Summary {
    /// <p>The finding classification of the recommendation.</p>
    pub fn name(&self) -> std::option::Option<& crate::model::Finding> {
        self.name.as_ref()
    }
    /// <p>The value of the recommendation summary.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
    /// <p>An array of objects that summarize a finding reason code.</p>
    pub fn reason_code_summaries(&self) -> std::option::Option<& [crate::model::ReasonCodeSummary]> {
        self.reason_code_summaries.as_deref()
    }
}
/// See [`Summary`](crate::model::Summary).
pub mod summary {
    
    /// A builder for [`Summary`](crate::model::Summary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::Finding>,
        pub(crate) value: std::option::Option<f64>,
        pub(crate) reason_code_summaries: std::option::Option<std::vec::Vec<crate::model::ReasonCodeSummary>>,
    }
    impl Builder {
        /// <p>The finding classification of the recommendation.</p>
        pub fn name(mut self, input: crate::model::Finding) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The finding classification of the recommendation.</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::Finding>) -> Self {
            self.name = input; self
        }
        /// <p>The value of the recommendation summary.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the recommendation summary.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input; self
        }
        /// Appends an item to `reason_code_summaries`.
        ///
        /// To override the contents of this collection use [`set_reason_code_summaries`](Self::set_reason_code_summaries).
        ///
        /// <p>An array of objects that summarize a finding reason code.</p>
        pub fn reason_code_summaries(mut self, input: crate::model::ReasonCodeSummary) -> Self {
            let mut v = self.reason_code_summaries.unwrap_or_default();
                            v.push(input);
                            self.reason_code_summaries = Some(v);
                            self
        }
        /// <p>An array of objects that summarize a finding reason code.</p>
        pub fn set_reason_code_summaries(mut self, input: std::option::Option<std::vec::Vec<crate::model::ReasonCodeSummary>>) -> Self {
            self.reason_code_summaries = input; self
        }
        /// Consumes the builder and constructs a [`Summary`](crate::model::Summary).
        pub fn build(self) -> crate::model::Summary {
            crate::model::Summary {
                name: self.name
                ,
                value: self.value
                    .unwrap_or_default()
                ,
                reason_code_summaries: self.reason_code_summaries
                ,
            }
        }
    }
    
    
}
impl Summary {
    /// Creates a new builder-style object to manufacture [`Summary`](crate::model::Summary).
    pub fn builder() -> crate::model::summary::Builder {
        crate::model::summary::Builder::default()
    }
}

/// <p>A summary of a finding reason code.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReasonCodeSummary  {
    /// <p>The name of the finding reason code.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::FindingReasonCode>,
    /// <p>The value of the finding reason code summary.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl ReasonCodeSummary {
    /// <p>The name of the finding reason code.</p>
    pub fn name(&self) -> std::option::Option<& crate::model::FindingReasonCode> {
        self.name.as_ref()
    }
    /// <p>The value of the finding reason code summary.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`ReasonCodeSummary`](crate::model::ReasonCodeSummary).
pub mod reason_code_summary {
    
    /// A builder for [`ReasonCodeSummary`](crate::model::ReasonCodeSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::FindingReasonCode>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the finding reason code.</p>
        pub fn name(mut self, input: crate::model::FindingReasonCode) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the finding reason code.</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::FindingReasonCode>) -> Self {
            self.name = input; self
        }
        /// <p>The value of the finding reason code summary.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the finding reason code summary.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`ReasonCodeSummary`](crate::model::ReasonCodeSummary).
        pub fn build(self) -> crate::model::ReasonCodeSummary {
            crate::model::ReasonCodeSummary {
                name: self.name
                ,
                value: self.value
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl ReasonCodeSummary {
    /// Creates a new builder-style object to manufacture [`ReasonCodeSummary`](crate::model::ReasonCodeSummary).
    pub fn builder() -> crate::model::reason_code_summary::Builder {
        crate::model::reason_code_summary::Builder::default()
    }
}

/// When writing a match expression against `FindingReasonCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let findingreasoncode = unimplemented!();
/// match findingreasoncode {
///     FindingReasonCode::MemoryOverProvisioned => { /* ... */ },
///     FindingReasonCode::MemoryUnderProvisioned => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `findingreasoncode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FindingReasonCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FindingReasonCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FindingReasonCode::NewFeature` is defined.
/// Specifically, when `findingreasoncode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FindingReasonCode::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum FindingReasonCode {
    #[allow(missing_docs)] // documentation missing in model
    MemoryOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    MemoryUnderProvisioned,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for FindingReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "MemoryOverprovisioned" => FindingReasonCode::MemoryOverProvisioned,
            "MemoryUnderprovisioned" => FindingReasonCode::MemoryUnderProvisioned,
            other => FindingReasonCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for FindingReasonCode {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(FindingReasonCode::from(s))
                }
            }
impl FindingReasonCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FindingReasonCode::MemoryOverProvisioned => "MemoryOverprovisioned",
            FindingReasonCode::MemoryUnderProvisioned => "MemoryUnderprovisioned",
            FindingReasonCode::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "MemoryOverprovisioned", "MemoryUnderprovisioned"
        ]
    }
}
impl AsRef<str> for FindingReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Finding`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let finding = unimplemented!();
/// match finding {
///     Finding::NotOptimized => { /* ... */ },
///     Finding::Optimized => { /* ... */ },
///     Finding::OverProvisioned => { /* ... */ },
///     Finding::UnderProvisioned => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `finding` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Finding::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Finding::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Finding::NewFeature` is defined.
/// Specifically, when `finding` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Finding::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum Finding {
    #[allow(missing_docs)] // documentation missing in model
    NotOptimized,
    #[allow(missing_docs)] // documentation missing in model
    Optimized,
    #[allow(missing_docs)] // documentation missing in model
    OverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    UnderProvisioned,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for Finding {
    fn from(s: &str) -> Self {
        match s {
            "NotOptimized" => Finding::NotOptimized,
            "Optimized" => Finding::Optimized,
            "Overprovisioned" => Finding::OverProvisioned,
            "Underprovisioned" => Finding::UnderProvisioned,
            other => Finding::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for Finding {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(Finding::from(s))
                }
            }
impl Finding {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Finding::NotOptimized => "NotOptimized",
            Finding::Optimized => "Optimized",
            Finding::OverProvisioned => "Overprovisioned",
            Finding::UnderProvisioned => "Underprovisioned",
            Finding::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "NotOptimized", "Optimized", "Overprovisioned", "Underprovisioned"
        ]
    }
}
impl AsRef<str> for Finding {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a recommendation preference.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendationPreferencesDetail  {
    /// <p>An object that describes the scope of the recommendation preference.</p> 
    /// <p>Recommendation preferences can be created at the organization level (for management accounts of an organization only), account level, and resource level. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Activating enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
    #[doc(hidden)]
    pub scope: std::option::Option<crate::model::Scope>,
    /// <p>The target resource type of the recommendation preference to create.</p> 
    /// <p>The <code>Ec2Instance</code> option encompasses standalone instances and instances that are part of Auto Scaling groups. The <code>AutoScalingGroup</code> option encompasses only instances that are part of an Auto Scaling group.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The status of the enhanced infrastructure metrics recommendation preference.</p> 
    /// <p>When the recommendations page is refreshed, a status of <code>Active</code> confirms that the preference is applied to the recommendations, and a status of <code>Inactive</code> confirms that the preference isn't yet applied to recommendations.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
    #[doc(hidden)]
    pub enhanced_infrastructure_metrics: std::option::Option<crate::model::EnhancedInfrastructureMetrics>,
    /// <p>The status of the inferred workload types recommendation preference.</p> 
    /// <p>When the recommendations page is refreshed, a status of <code>Active</code> confirms that the preference is applied to the recommendations, and a status of <code>Inactive</code> confirms that the preference isn't yet applied to recommendations.</p>
    #[doc(hidden)]
    pub inferred_workload_types: std::option::Option<crate::model::InferredWorkloadTypesPreference>,
    /// <p> An object that describes the external metrics recommendation preference. </p> 
    /// <p> If the preference is applied in the latest recommendation refresh, an object with a valid <code>source</code> value appears in the response. If the preference isn't applied to the recommendations already, then this object doesn't appear in the response. </p>
    #[doc(hidden)]
    pub external_metrics_preference: std::option::Option<crate::model::ExternalMetricsPreference>,
}
impl RecommendationPreferencesDetail {
    /// <p>An object that describes the scope of the recommendation preference.</p> 
    /// <p>Recommendation preferences can be created at the organization level (for management accounts of an organization only), account level, and resource level. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Activating enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
    pub fn scope(&self) -> std::option::Option<& crate::model::Scope> {
        self.scope.as_ref()
    }
    /// <p>The target resource type of the recommendation preference to create.</p> 
    /// <p>The <code>Ec2Instance</code> option encompasses standalone instances and instances that are part of Auto Scaling groups. The <code>AutoScalingGroup</code> option encompasses only instances that are part of an Auto Scaling group.</p>
    pub fn resource_type(&self) -> std::option::Option<& crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The status of the enhanced infrastructure metrics recommendation preference.</p> 
    /// <p>When the recommendations page is refreshed, a status of <code>Active</code> confirms that the preference is applied to the recommendations, and a status of <code>Inactive</code> confirms that the preference isn't yet applied to recommendations.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
    pub fn enhanced_infrastructure_metrics(&self) -> std::option::Option<& crate::model::EnhancedInfrastructureMetrics> {
        self.enhanced_infrastructure_metrics.as_ref()
    }
    /// <p>The status of the inferred workload types recommendation preference.</p> 
    /// <p>When the recommendations page is refreshed, a status of <code>Active</code> confirms that the preference is applied to the recommendations, and a status of <code>Inactive</code> confirms that the preference isn't yet applied to recommendations.</p>
    pub fn inferred_workload_types(&self) -> std::option::Option<& crate::model::InferredWorkloadTypesPreference> {
        self.inferred_workload_types.as_ref()
    }
    /// <p> An object that describes the external metrics recommendation preference. </p> 
    /// <p> If the preference is applied in the latest recommendation refresh, an object with a valid <code>source</code> value appears in the response. If the preference isn't applied to the recommendations already, then this object doesn't appear in the response. </p>
    pub fn external_metrics_preference(&self) -> std::option::Option<& crate::model::ExternalMetricsPreference> {
        self.external_metrics_preference.as_ref()
    }
}
/// See [`RecommendationPreferencesDetail`](crate::model::RecommendationPreferencesDetail).
pub mod recommendation_preferences_detail {
    
    /// A builder for [`RecommendationPreferencesDetail`](crate::model::RecommendationPreferencesDetail).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scope: std::option::Option<crate::model::Scope>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) enhanced_infrastructure_metrics: std::option::Option<crate::model::EnhancedInfrastructureMetrics>,
        pub(crate) inferred_workload_types: std::option::Option<crate::model::InferredWorkloadTypesPreference>,
        pub(crate) external_metrics_preference: std::option::Option<crate::model::ExternalMetricsPreference>,
    }
    impl Builder {
        /// <p>An object that describes the scope of the recommendation preference.</p> 
        /// <p>Recommendation preferences can be created at the organization level (for management accounts of an organization only), account level, and resource level. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Activating enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
        pub fn scope(mut self, input: crate::model::Scope) -> Self {
            self.scope = Some(input);
            self
        }
        /// <p>An object that describes the scope of the recommendation preference.</p> 
        /// <p>Recommendation preferences can be created at the organization level (for management accounts of an organization only), account level, and resource level. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Activating enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
        pub fn set_scope(mut self, input: std::option::Option<crate::model::Scope>) -> Self {
            self.scope = input; self
        }
        /// <p>The target resource type of the recommendation preference to create.</p> 
        /// <p>The <code>Ec2Instance</code> option encompasses standalone instances and instances that are part of Auto Scaling groups. The <code>AutoScalingGroup</code> option encompasses only instances that are part of an Auto Scaling group.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The target resource type of the recommendation preference to create.</p> 
        /// <p>The <code>Ec2Instance</code> option encompasses standalone instances and instances that are part of Auto Scaling groups. The <code>AutoScalingGroup</code> option encompasses only instances that are part of an Auto Scaling group.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<crate::model::ResourceType>) -> Self {
            self.resource_type = input; self
        }
        /// <p>The status of the enhanced infrastructure metrics recommendation preference.</p> 
        /// <p>When the recommendations page is refreshed, a status of <code>Active</code> confirms that the preference is applied to the recommendations, and a status of <code>Inactive</code> confirms that the preference isn't yet applied to recommendations.</p> 
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
        pub fn enhanced_infrastructure_metrics(mut self, input: crate::model::EnhancedInfrastructureMetrics) -> Self {
            self.enhanced_infrastructure_metrics = Some(input);
            self
        }
        /// <p>The status of the enhanced infrastructure metrics recommendation preference.</p> 
        /// <p>When the recommendations page is refreshed, a status of <code>Active</code> confirms that the preference is applied to the recommendations, and a status of <code>Inactive</code> confirms that the preference isn't yet applied to recommendations.</p> 
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
        pub fn set_enhanced_infrastructure_metrics(mut self, input: std::option::Option<crate::model::EnhancedInfrastructureMetrics>) -> Self {
            self.enhanced_infrastructure_metrics = input; self
        }
        /// <p>The status of the inferred workload types recommendation preference.</p> 
        /// <p>When the recommendations page is refreshed, a status of <code>Active</code> confirms that the preference is applied to the recommendations, and a status of <code>Inactive</code> confirms that the preference isn't yet applied to recommendations.</p>
        pub fn inferred_workload_types(mut self, input: crate::model::InferredWorkloadTypesPreference) -> Self {
            self.inferred_workload_types = Some(input);
            self
        }
        /// <p>The status of the inferred workload types recommendation preference.</p> 
        /// <p>When the recommendations page is refreshed, a status of <code>Active</code> confirms that the preference is applied to the recommendations, and a status of <code>Inactive</code> confirms that the preference isn't yet applied to recommendations.</p>
        pub fn set_inferred_workload_types(mut self, input: std::option::Option<crate::model::InferredWorkloadTypesPreference>) -> Self {
            self.inferred_workload_types = input; self
        }
        /// <p> An object that describes the external metrics recommendation preference. </p> 
        /// <p> If the preference is applied in the latest recommendation refresh, an object with a valid <code>source</code> value appears in the response. If the preference isn't applied to the recommendations already, then this object doesn't appear in the response. </p>
        pub fn external_metrics_preference(mut self, input: crate::model::ExternalMetricsPreference) -> Self {
            self.external_metrics_preference = Some(input);
            self
        }
        /// <p> An object that describes the external metrics recommendation preference. </p> 
        /// <p> If the preference is applied in the latest recommendation refresh, an object with a valid <code>source</code> value appears in the response. If the preference isn't applied to the recommendations already, then this object doesn't appear in the response. </p>
        pub fn set_external_metrics_preference(mut self, input: std::option::Option<crate::model::ExternalMetricsPreference>) -> Self {
            self.external_metrics_preference = input; self
        }
        /// Consumes the builder and constructs a [`RecommendationPreferencesDetail`](crate::model::RecommendationPreferencesDetail).
        pub fn build(self) -> crate::model::RecommendationPreferencesDetail {
            crate::model::RecommendationPreferencesDetail {
                scope: self.scope
                ,
                resource_type: self.resource_type
                ,
                enhanced_infrastructure_metrics: self.enhanced_infrastructure_metrics
                ,
                inferred_workload_types: self.inferred_workload_types
                ,
                external_metrics_preference: self.external_metrics_preference
                ,
            }
        }
    }
    
    
}
impl RecommendationPreferencesDetail {
    /// Creates a new builder-style object to manufacture [`RecommendationPreferencesDetail`](crate::model::RecommendationPreferencesDetail).
    pub fn builder() -> crate::model::recommendation_preferences_detail::Builder {
        crate::model::recommendation_preferences_detail::Builder::default()
    }
}

/// <p>Describes an Lambda function recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LambdaFunctionRecommendation  {
    /// <p>The Amazon Resource Name (ARN) of the current function.</p>
    #[doc(hidden)]
    pub function_arn: std::option::Option<std::string::String>,
    /// <p>The version number of the current function.</p>
    #[doc(hidden)]
    pub function_version: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the function.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The amount of memory, in MB, that's allocated to the current function.</p>
    #[doc(hidden)]
    pub current_memory_size: i32,
    /// <p>The number of times your function code was applied during the look-back period.</p>
    #[doc(hidden)]
    pub number_of_invocations: i64,
    /// <p>An array of objects that describe the utilization metrics of the function.</p>
    #[doc(hidden)]
    pub utilization_metrics: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionUtilizationMetric>>,
    /// <p>The number of days for which utilization metrics were analyzed for the function.</p>
    #[doc(hidden)]
    pub lookback_period_in_days: f64,
    /// <p>The timestamp of when the function recommendation was last generated.</p>
    #[doc(hidden)]
    pub last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The finding classification of the function.</p> 
    /// <p>Findings for functions include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>Optimized</code> </b>  The function is correctly provisioned to run your workload based on its current configuration and its utilization history. This finding classification does not include finding reason codes.</p> </li> 
    /// <li> <p> <b> <code>NotOptimized</code> </b>  The function is performing at a higher level (over-provisioned) or at a lower level (under-provisioned) than required for your workload because its current configuration is not optimal. Over-provisioned resources might lead to unnecessary infrastructure cost, and under-provisioned resources might lead to poor application performance. This finding classification can include the <code>MemoryUnderprovisioned</code> and <code>MemoryUnderprovisioned</code> finding reason codes.</p> </li> 
    /// <li> <p> <b> <code>Unavailable</code> </b>  Compute Optimizer was unable to generate a recommendation for the function. This could be because the function has not accumulated sufficient metric data, or the function does not qualify for a recommendation. This finding classification can include the <code>InsufficientData</code> and <code>Inconclusive</code> finding reason codes.</p> <note> 
    /// <p>Functions with a finding of unavailable are not returned unless you specify the <code>filter</code> parameter with a value of <code>Unavailable</code> in your <code>GetLambdaFunctionRecommendations</code> request.</p> 
    /// </note> </li> 
    /// </ul>
    #[doc(hidden)]
    pub finding: std::option::Option<crate::model::LambdaFunctionRecommendationFinding>,
    /// <p>The reason for the finding classification of the function.</p> <note> 
    /// <p>Functions that have a finding classification of <code>Optimized</code> don't have a finding reason code.</p> 
    /// </note> 
    /// <p>Finding reason codes for functions include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The function is over-provisioned when its memory configuration can be sized down while still meeting the performance requirements of your workload. An over-provisioned function might lead to unnecessary infrastructure cost. This finding reason code is part of the <code>NotOptimized</code> finding classification.</p> </li> 
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The function is under-provisioned when its memory configuration doesn't meet the performance requirements of the workload. An under-provisioned function might lead to poor application performance. This finding reason code is part of the <code>NotOptimized</code> finding classification.</p> </li> 
    /// <li> <p> <b> <code>InsufficientData</code> </b>  The function does not have sufficient metric data for Compute Optimizer to generate a recommendation. For more information, see the <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/requirements.html">Supported resources and requirements</a> in the <i>Compute Optimizer User Guide</i>. This finding reason code is part of the <code>Unavailable</code> finding classification.</p> </li> 
    /// <li> <p> <b> <code>Inconclusive</code> </b>  The function does not qualify for a recommendation because Compute Optimizer cannot generate a recommendation with a high degree of confidence. This finding reason code is part of the <code>Unavailable</code> finding classification.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub finding_reason_codes: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionRecommendationFindingReasonCode>>,
    /// <p>An array of objects that describe the memory configuration recommendation options for the function.</p>
    #[doc(hidden)]
    pub memory_size_recommendation_options: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionMemoryRecommendationOption>>,
    /// <p>The risk of the current Lambda function not meeting the performance needs of its workloads. The higher the risk, the more likely the current Lambda function requires more memory.</p>
    #[doc(hidden)]
    pub current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
}
impl LambdaFunctionRecommendation {
    /// <p>The Amazon Resource Name (ARN) of the current function.</p>
    pub fn function_arn(&self) -> std::option::Option<& str> {
        self.function_arn.as_deref()
    }
    /// <p>The version number of the current function.</p>
    pub fn function_version(&self) -> std::option::Option<& str> {
        self.function_version.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the function.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The amount of memory, in MB, that's allocated to the current function.</p>
    pub fn current_memory_size(&self) -> i32 {
        self.current_memory_size
    }
    /// <p>The number of times your function code was applied during the look-back period.</p>
    pub fn number_of_invocations(&self) -> i64 {
        self.number_of_invocations
    }
    /// <p>An array of objects that describe the utilization metrics of the function.</p>
    pub fn utilization_metrics(&self) -> std::option::Option<& [crate::model::LambdaFunctionUtilizationMetric]> {
        self.utilization_metrics.as_deref()
    }
    /// <p>The number of days for which utilization metrics were analyzed for the function.</p>
    pub fn lookback_period_in_days(&self) -> f64 {
        self.lookback_period_in_days
    }
    /// <p>The timestamp of when the function recommendation was last generated.</p>
    pub fn last_refresh_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.last_refresh_timestamp.as_ref()
    }
    /// <p>The finding classification of the function.</p> 
    /// <p>Findings for functions include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>Optimized</code> </b>  The function is correctly provisioned to run your workload based on its current configuration and its utilization history. This finding classification does not include finding reason codes.</p> </li> 
    /// <li> <p> <b> <code>NotOptimized</code> </b>  The function is performing at a higher level (over-provisioned) or at a lower level (under-provisioned) than required for your workload because its current configuration is not optimal. Over-provisioned resources might lead to unnecessary infrastructure cost, and under-provisioned resources might lead to poor application performance. This finding classification can include the <code>MemoryUnderprovisioned</code> and <code>MemoryUnderprovisioned</code> finding reason codes.</p> </li> 
    /// <li> <p> <b> <code>Unavailable</code> </b>  Compute Optimizer was unable to generate a recommendation for the function. This could be because the function has not accumulated sufficient metric data, or the function does not qualify for a recommendation. This finding classification can include the <code>InsufficientData</code> and <code>Inconclusive</code> finding reason codes.</p> <note> 
    /// <p>Functions with a finding of unavailable are not returned unless you specify the <code>filter</code> parameter with a value of <code>Unavailable</code> in your <code>GetLambdaFunctionRecommendations</code> request.</p> 
    /// </note> </li> 
    /// </ul>
    pub fn finding(&self) -> std::option::Option<& crate::model::LambdaFunctionRecommendationFinding> {
        self.finding.as_ref()
    }
    /// <p>The reason for the finding classification of the function.</p> <note> 
    /// <p>Functions that have a finding classification of <code>Optimized</code> don't have a finding reason code.</p> 
    /// </note> 
    /// <p>Finding reason codes for functions include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The function is over-provisioned when its memory configuration can be sized down while still meeting the performance requirements of your workload. An over-provisioned function might lead to unnecessary infrastructure cost. This finding reason code is part of the <code>NotOptimized</code> finding classification.</p> </li> 
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The function is under-provisioned when its memory configuration doesn't meet the performance requirements of the workload. An under-provisioned function might lead to poor application performance. This finding reason code is part of the <code>NotOptimized</code> finding classification.</p> </li> 
    /// <li> <p> <b> <code>InsufficientData</code> </b>  The function does not have sufficient metric data for Compute Optimizer to generate a recommendation. For more information, see the <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/requirements.html">Supported resources and requirements</a> in the <i>Compute Optimizer User Guide</i>. This finding reason code is part of the <code>Unavailable</code> finding classification.</p> </li> 
    /// <li> <p> <b> <code>Inconclusive</code> </b>  The function does not qualify for a recommendation because Compute Optimizer cannot generate a recommendation with a high degree of confidence. This finding reason code is part of the <code>Unavailable</code> finding classification.</p> </li> 
    /// </ul>
    pub fn finding_reason_codes(&self) -> std::option::Option<& [crate::model::LambdaFunctionRecommendationFindingReasonCode]> {
        self.finding_reason_codes.as_deref()
    }
    /// <p>An array of objects that describe the memory configuration recommendation options for the function.</p>
    pub fn memory_size_recommendation_options(&self) -> std::option::Option<& [crate::model::LambdaFunctionMemoryRecommendationOption]> {
        self.memory_size_recommendation_options.as_deref()
    }
    /// <p>The risk of the current Lambda function not meeting the performance needs of its workloads. The higher the risk, the more likely the current Lambda function requires more memory.</p>
    pub fn current_performance_risk(&self) -> std::option::Option<& crate::model::CurrentPerformanceRisk> {
        self.current_performance_risk.as_ref()
    }
}
/// See [`LambdaFunctionRecommendation`](crate::model::LambdaFunctionRecommendation).
pub mod lambda_function_recommendation {
    
    /// A builder for [`LambdaFunctionRecommendation`](crate::model::LambdaFunctionRecommendation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) function_arn: std::option::Option<std::string::String>,
        pub(crate) function_version: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) current_memory_size: std::option::Option<i32>,
        pub(crate) number_of_invocations: std::option::Option<i64>,
        pub(crate) utilization_metrics: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionUtilizationMetric>>,
        pub(crate) lookback_period_in_days: std::option::Option<f64>,
        pub(crate) last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) finding: std::option::Option<crate::model::LambdaFunctionRecommendationFinding>,
        pub(crate) finding_reason_codes: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionRecommendationFindingReasonCode>>,
        pub(crate) memory_size_recommendation_options: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionMemoryRecommendationOption>>,
        pub(crate) current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the current function.</p>
        pub fn function_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the current function.</p>
        pub fn set_function_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_arn = input; self
        }
        /// <p>The version number of the current function.</p>
        pub fn function_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.function_version = Some(input.into());
            self
        }
        /// <p>The version number of the current function.</p>
        pub fn set_function_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.function_version = input; self
        }
        /// <p>The Amazon Web Services account ID of the function.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the function.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The amount of memory, in MB, that's allocated to the current function.</p>
        pub fn current_memory_size(mut self, input: i32) -> Self {
            self.current_memory_size = Some(input);
            self
        }
        /// <p>The amount of memory, in MB, that's allocated to the current function.</p>
        pub fn set_current_memory_size(mut self, input: std::option::Option<i32>) -> Self {
            self.current_memory_size = input; self
        }
        /// <p>The number of times your function code was applied during the look-back period.</p>
        pub fn number_of_invocations(mut self, input: i64) -> Self {
            self.number_of_invocations = Some(input);
            self
        }
        /// <p>The number of times your function code was applied during the look-back period.</p>
        pub fn set_number_of_invocations(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_invocations = input; self
        }
        /// Appends an item to `utilization_metrics`.
        ///
        /// To override the contents of this collection use [`set_utilization_metrics`](Self::set_utilization_metrics).
        ///
        /// <p>An array of objects that describe the utilization metrics of the function.</p>
        pub fn utilization_metrics(mut self, input: crate::model::LambdaFunctionUtilizationMetric) -> Self {
            let mut v = self.utilization_metrics.unwrap_or_default();
                            v.push(input);
                            self.utilization_metrics = Some(v);
                            self
        }
        /// <p>An array of objects that describe the utilization metrics of the function.</p>
        pub fn set_utilization_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionUtilizationMetric>>) -> Self {
            self.utilization_metrics = input; self
        }
        /// <p>The number of days for which utilization metrics were analyzed for the function.</p>
        pub fn lookback_period_in_days(mut self, input: f64) -> Self {
            self.lookback_period_in_days = Some(input);
            self
        }
        /// <p>The number of days for which utilization metrics were analyzed for the function.</p>
        pub fn set_lookback_period_in_days(mut self, input: std::option::Option<f64>) -> Self {
            self.lookback_period_in_days = input; self
        }
        /// <p>The timestamp of when the function recommendation was last generated.</p>
        pub fn last_refresh_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_refresh_timestamp = Some(input);
            self
        }
        /// <p>The timestamp of when the function recommendation was last generated.</p>
        pub fn set_last_refresh_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.last_refresh_timestamp = input; self
        }
        /// <p>The finding classification of the function.</p> 
        /// <p>Findings for functions include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>Optimized</code> </b>  The function is correctly provisioned to run your workload based on its current configuration and its utilization history. This finding classification does not include finding reason codes.</p> </li> 
        /// <li> <p> <b> <code>NotOptimized</code> </b>  The function is performing at a higher level (over-provisioned) or at a lower level (under-provisioned) than required for your workload because its current configuration is not optimal. Over-provisioned resources might lead to unnecessary infrastructure cost, and under-provisioned resources might lead to poor application performance. This finding classification can include the <code>MemoryUnderprovisioned</code> and <code>MemoryUnderprovisioned</code> finding reason codes.</p> </li> 
        /// <li> <p> <b> <code>Unavailable</code> </b>  Compute Optimizer was unable to generate a recommendation for the function. This could be because the function has not accumulated sufficient metric data, or the function does not qualify for a recommendation. This finding classification can include the <code>InsufficientData</code> and <code>Inconclusive</code> finding reason codes.</p> <note> 
        /// <p>Functions with a finding of unavailable are not returned unless you specify the <code>filter</code> parameter with a value of <code>Unavailable</code> in your <code>GetLambdaFunctionRecommendations</code> request.</p> 
        /// </note> </li> 
        /// </ul>
        pub fn finding(mut self, input: crate::model::LambdaFunctionRecommendationFinding) -> Self {
            self.finding = Some(input);
            self
        }
        /// <p>The finding classification of the function.</p> 
        /// <p>Findings for functions include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>Optimized</code> </b>  The function is correctly provisioned to run your workload based on its current configuration and its utilization history. This finding classification does not include finding reason codes.</p> </li> 
        /// <li> <p> <b> <code>NotOptimized</code> </b>  The function is performing at a higher level (over-provisioned) or at a lower level (under-provisioned) than required for your workload because its current configuration is not optimal. Over-provisioned resources might lead to unnecessary infrastructure cost, and under-provisioned resources might lead to poor application performance. This finding classification can include the <code>MemoryUnderprovisioned</code> and <code>MemoryUnderprovisioned</code> finding reason codes.</p> </li> 
        /// <li> <p> <b> <code>Unavailable</code> </b>  Compute Optimizer was unable to generate a recommendation for the function. This could be because the function has not accumulated sufficient metric data, or the function does not qualify for a recommendation. This finding classification can include the <code>InsufficientData</code> and <code>Inconclusive</code> finding reason codes.</p> <note> 
        /// <p>Functions with a finding of unavailable are not returned unless you specify the <code>filter</code> parameter with a value of <code>Unavailable</code> in your <code>GetLambdaFunctionRecommendations</code> request.</p> 
        /// </note> </li> 
        /// </ul>
        pub fn set_finding(mut self, input: std::option::Option<crate::model::LambdaFunctionRecommendationFinding>) -> Self {
            self.finding = input; self
        }
        /// Appends an item to `finding_reason_codes`.
        ///
        /// To override the contents of this collection use [`set_finding_reason_codes`](Self::set_finding_reason_codes).
        ///
        /// <p>The reason for the finding classification of the function.</p> <note> 
        /// <p>Functions that have a finding classification of <code>Optimized</code> don't have a finding reason code.</p> 
        /// </note> 
        /// <p>Finding reason codes for functions include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The function is over-provisioned when its memory configuration can be sized down while still meeting the performance requirements of your workload. An over-provisioned function might lead to unnecessary infrastructure cost. This finding reason code is part of the <code>NotOptimized</code> finding classification.</p> </li> 
        /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The function is under-provisioned when its memory configuration doesn't meet the performance requirements of the workload. An under-provisioned function might lead to poor application performance. This finding reason code is part of the <code>NotOptimized</code> finding classification.</p> </li> 
        /// <li> <p> <b> <code>InsufficientData</code> </b>  The function does not have sufficient metric data for Compute Optimizer to generate a recommendation. For more information, see the <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/requirements.html">Supported resources and requirements</a> in the <i>Compute Optimizer User Guide</i>. This finding reason code is part of the <code>Unavailable</code> finding classification.</p> </li> 
        /// <li> <p> <b> <code>Inconclusive</code> </b>  The function does not qualify for a recommendation because Compute Optimizer cannot generate a recommendation with a high degree of confidence. This finding reason code is part of the <code>Unavailable</code> finding classification.</p> </li> 
        /// </ul>
        pub fn finding_reason_codes(mut self, input: crate::model::LambdaFunctionRecommendationFindingReasonCode) -> Self {
            let mut v = self.finding_reason_codes.unwrap_or_default();
                            v.push(input);
                            self.finding_reason_codes = Some(v);
                            self
        }
        /// <p>The reason for the finding classification of the function.</p> <note> 
        /// <p>Functions that have a finding classification of <code>Optimized</code> don't have a finding reason code.</p> 
        /// </note> 
        /// <p>Finding reason codes for functions include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The function is over-provisioned when its memory configuration can be sized down while still meeting the performance requirements of your workload. An over-provisioned function might lead to unnecessary infrastructure cost. This finding reason code is part of the <code>NotOptimized</code> finding classification.</p> </li> 
        /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The function is under-provisioned when its memory configuration doesn't meet the performance requirements of the workload. An under-provisioned function might lead to poor application performance. This finding reason code is part of the <code>NotOptimized</code> finding classification.</p> </li> 
        /// <li> <p> <b> <code>InsufficientData</code> </b>  The function does not have sufficient metric data for Compute Optimizer to generate a recommendation. For more information, see the <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/requirements.html">Supported resources and requirements</a> in the <i>Compute Optimizer User Guide</i>. This finding reason code is part of the <code>Unavailable</code> finding classification.</p> </li> 
        /// <li> <p> <b> <code>Inconclusive</code> </b>  The function does not qualify for a recommendation because Compute Optimizer cannot generate a recommendation with a high degree of confidence. This finding reason code is part of the <code>Unavailable</code> finding classification.</p> </li> 
        /// </ul>
        pub fn set_finding_reason_codes(mut self, input: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionRecommendationFindingReasonCode>>) -> Self {
            self.finding_reason_codes = input; self
        }
        /// Appends an item to `memory_size_recommendation_options`.
        ///
        /// To override the contents of this collection use [`set_memory_size_recommendation_options`](Self::set_memory_size_recommendation_options).
        ///
        /// <p>An array of objects that describe the memory configuration recommendation options for the function.</p>
        pub fn memory_size_recommendation_options(mut self, input: crate::model::LambdaFunctionMemoryRecommendationOption) -> Self {
            let mut v = self.memory_size_recommendation_options.unwrap_or_default();
                            v.push(input);
                            self.memory_size_recommendation_options = Some(v);
                            self
        }
        /// <p>An array of objects that describe the memory configuration recommendation options for the function.</p>
        pub fn set_memory_size_recommendation_options(mut self, input: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionMemoryRecommendationOption>>) -> Self {
            self.memory_size_recommendation_options = input; self
        }
        /// <p>The risk of the current Lambda function not meeting the performance needs of its workloads. The higher the risk, the more likely the current Lambda function requires more memory.</p>
        pub fn current_performance_risk(mut self, input: crate::model::CurrentPerformanceRisk) -> Self {
            self.current_performance_risk = Some(input);
            self
        }
        /// <p>The risk of the current Lambda function not meeting the performance needs of its workloads. The higher the risk, the more likely the current Lambda function requires more memory.</p>
        pub fn set_current_performance_risk(mut self, input: std::option::Option<crate::model::CurrentPerformanceRisk>) -> Self {
            self.current_performance_risk = input; self
        }
        /// Consumes the builder and constructs a [`LambdaFunctionRecommendation`](crate::model::LambdaFunctionRecommendation).
        pub fn build(self) -> crate::model::LambdaFunctionRecommendation {
            crate::model::LambdaFunctionRecommendation {
                function_arn: self.function_arn
                ,
                function_version: self.function_version
                ,
                account_id: self.account_id
                ,
                current_memory_size: self.current_memory_size
                    .unwrap_or_default()
                ,
                number_of_invocations: self.number_of_invocations
                    .unwrap_or_default()
                ,
                utilization_metrics: self.utilization_metrics
                ,
                lookback_period_in_days: self.lookback_period_in_days
                    .unwrap_or_default()
                ,
                last_refresh_timestamp: self.last_refresh_timestamp
                ,
                finding: self.finding
                ,
                finding_reason_codes: self.finding_reason_codes
                ,
                memory_size_recommendation_options: self.memory_size_recommendation_options
                ,
                current_performance_risk: self.current_performance_risk
                ,
            }
        }
    }
    
    
}
impl LambdaFunctionRecommendation {
    /// Creates a new builder-style object to manufacture [`LambdaFunctionRecommendation`](crate::model::LambdaFunctionRecommendation).
    pub fn builder() -> crate::model::lambda_function_recommendation::Builder {
        crate::model::lambda_function_recommendation::Builder::default()
    }
}

/// When writing a match expression against `CurrentPerformanceRisk`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let currentperformancerisk = unimplemented!();
/// match currentperformancerisk {
///     CurrentPerformanceRisk::High => { /* ... */ },
///     CurrentPerformanceRisk::Low => { /* ... */ },
///     CurrentPerformanceRisk::Medium => { /* ... */ },
///     CurrentPerformanceRisk::VeryLow => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `currentperformancerisk` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CurrentPerformanceRisk::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CurrentPerformanceRisk::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CurrentPerformanceRisk::NewFeature` is defined.
/// Specifically, when `currentperformancerisk` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CurrentPerformanceRisk::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum CurrentPerformanceRisk {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    VeryLow,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for CurrentPerformanceRisk {
    fn from(s: &str) -> Self {
        match s {
            "High" => CurrentPerformanceRisk::High,
            "Low" => CurrentPerformanceRisk::Low,
            "Medium" => CurrentPerformanceRisk::Medium,
            "VeryLow" => CurrentPerformanceRisk::VeryLow,
            other => CurrentPerformanceRisk::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for CurrentPerformanceRisk {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(CurrentPerformanceRisk::from(s))
                }
            }
impl CurrentPerformanceRisk {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CurrentPerformanceRisk::High => "High",
            CurrentPerformanceRisk::Low => "Low",
            CurrentPerformanceRisk::Medium => "Medium",
            CurrentPerformanceRisk::VeryLow => "VeryLow",
            CurrentPerformanceRisk::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "High", "Low", "Medium", "VeryLow"
        ]
    }
}
impl AsRef<str> for CurrentPerformanceRisk {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a recommendation option for an Lambda function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LambdaFunctionMemoryRecommendationOption  {
    /// <p>The rank of the function recommendation option.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p>
    #[doc(hidden)]
    pub rank: i32,
    /// <p>The memory size, in MB, of the function recommendation option.</p>
    #[doc(hidden)]
    pub memory_size: i32,
    /// <p>An array of objects that describe the projected utilization metrics of the function recommendation option.</p>
    #[doc(hidden)]
    pub projected_utilization_metrics: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionMemoryProjectedMetric>>,
    /// <p>An object that describes the savings opportunity for the Lambda function recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    #[doc(hidden)]
    pub savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
}
impl LambdaFunctionMemoryRecommendationOption {
    /// <p>The rank of the function recommendation option.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p>
    pub fn rank(&self) -> i32 {
        self.rank
    }
    /// <p>The memory size, in MB, of the function recommendation option.</p>
    pub fn memory_size(&self) -> i32 {
        self.memory_size
    }
    /// <p>An array of objects that describe the projected utilization metrics of the function recommendation option.</p>
    pub fn projected_utilization_metrics(&self) -> std::option::Option<& [crate::model::LambdaFunctionMemoryProjectedMetric]> {
        self.projected_utilization_metrics.as_deref()
    }
    /// <p>An object that describes the savings opportunity for the Lambda function recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    pub fn savings_opportunity(&self) -> std::option::Option<& crate::model::SavingsOpportunity> {
        self.savings_opportunity.as_ref()
    }
}
/// See [`LambdaFunctionMemoryRecommendationOption`](crate::model::LambdaFunctionMemoryRecommendationOption).
pub mod lambda_function_memory_recommendation_option {
    
    /// A builder for [`LambdaFunctionMemoryRecommendationOption`](crate::model::LambdaFunctionMemoryRecommendationOption).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rank: std::option::Option<i32>,
        pub(crate) memory_size: std::option::Option<i32>,
        pub(crate) projected_utilization_metrics: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionMemoryProjectedMetric>>,
        pub(crate) savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
    }
    impl Builder {
        /// <p>The rank of the function recommendation option.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p>
        pub fn rank(mut self, input: i32) -> Self {
            self.rank = Some(input);
            self
        }
        /// <p>The rank of the function recommendation option.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p>
        pub fn set_rank(mut self, input: std::option::Option<i32>) -> Self {
            self.rank = input; self
        }
        /// <p>The memory size, in MB, of the function recommendation option.</p>
        pub fn memory_size(mut self, input: i32) -> Self {
            self.memory_size = Some(input);
            self
        }
        /// <p>The memory size, in MB, of the function recommendation option.</p>
        pub fn set_memory_size(mut self, input: std::option::Option<i32>) -> Self {
            self.memory_size = input; self
        }
        /// Appends an item to `projected_utilization_metrics`.
        ///
        /// To override the contents of this collection use [`set_projected_utilization_metrics`](Self::set_projected_utilization_metrics).
        ///
        /// <p>An array of objects that describe the projected utilization metrics of the function recommendation option.</p>
        pub fn projected_utilization_metrics(mut self, input: crate::model::LambdaFunctionMemoryProjectedMetric) -> Self {
            let mut v = self.projected_utilization_metrics.unwrap_or_default();
                            v.push(input);
                            self.projected_utilization_metrics = Some(v);
                            self
        }
        /// <p>An array of objects that describe the projected utilization metrics of the function recommendation option.</p>
        pub fn set_projected_utilization_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::LambdaFunctionMemoryProjectedMetric>>) -> Self {
            self.projected_utilization_metrics = input; self
        }
        /// <p>An object that describes the savings opportunity for the Lambda function recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn savings_opportunity(mut self, input: crate::model::SavingsOpportunity) -> Self {
            self.savings_opportunity = Some(input);
            self
        }
        /// <p>An object that describes the savings opportunity for the Lambda function recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn set_savings_opportunity(mut self, input: std::option::Option<crate::model::SavingsOpportunity>) -> Self {
            self.savings_opportunity = input; self
        }
        /// Consumes the builder and constructs a [`LambdaFunctionMemoryRecommendationOption`](crate::model::LambdaFunctionMemoryRecommendationOption).
        pub fn build(self) -> crate::model::LambdaFunctionMemoryRecommendationOption {
            crate::model::LambdaFunctionMemoryRecommendationOption {
                rank: self.rank
                    .unwrap_or_default()
                ,
                memory_size: self.memory_size
                    .unwrap_or_default()
                ,
                projected_utilization_metrics: self.projected_utilization_metrics
                ,
                savings_opportunity: self.savings_opportunity
                ,
            }
        }
    }
    
    
}
impl LambdaFunctionMemoryRecommendationOption {
    /// Creates a new builder-style object to manufacture [`LambdaFunctionMemoryRecommendationOption`](crate::model::LambdaFunctionMemoryRecommendationOption).
    pub fn builder() -> crate::model::lambda_function_memory_recommendation_option::Builder {
        crate::model::lambda_function_memory_recommendation_option::Builder::default()
    }
}

/// <p>Describes a projected utilization metric of an Lambda function recommendation option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LambdaFunctionMemoryProjectedMetric  {
    /// <p>The name of the projected utilization metric.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::LambdaFunctionMemoryMetricName>,
    /// <p>The statistic of the projected utilization metric.</p>
    #[doc(hidden)]
    pub statistic: std::option::Option<crate::model::LambdaFunctionMemoryMetricStatistic>,
    /// <p>The values of the projected utilization metrics.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl LambdaFunctionMemoryProjectedMetric {
    /// <p>The name of the projected utilization metric.</p>
    pub fn name(&self) -> std::option::Option<& crate::model::LambdaFunctionMemoryMetricName> {
        self.name.as_ref()
    }
    /// <p>The statistic of the projected utilization metric.</p>
    pub fn statistic(&self) -> std::option::Option<& crate::model::LambdaFunctionMemoryMetricStatistic> {
        self.statistic.as_ref()
    }
    /// <p>The values of the projected utilization metrics.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`LambdaFunctionMemoryProjectedMetric`](crate::model::LambdaFunctionMemoryProjectedMetric).
pub mod lambda_function_memory_projected_metric {
    
    /// A builder for [`LambdaFunctionMemoryProjectedMetric`](crate::model::LambdaFunctionMemoryProjectedMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::LambdaFunctionMemoryMetricName>,
        pub(crate) statistic: std::option::Option<crate::model::LambdaFunctionMemoryMetricStatistic>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the projected utilization metric.</p>
        pub fn name(mut self, input: crate::model::LambdaFunctionMemoryMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the projected utilization metric.</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::LambdaFunctionMemoryMetricName>) -> Self {
            self.name = input; self
        }
        /// <p>The statistic of the projected utilization metric.</p>
        pub fn statistic(mut self, input: crate::model::LambdaFunctionMemoryMetricStatistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic of the projected utilization metric.</p>
        pub fn set_statistic(mut self, input: std::option::Option<crate::model::LambdaFunctionMemoryMetricStatistic>) -> Self {
            self.statistic = input; self
        }
        /// <p>The values of the projected utilization metrics.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The values of the projected utilization metrics.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`LambdaFunctionMemoryProjectedMetric`](crate::model::LambdaFunctionMemoryProjectedMetric).
        pub fn build(self) -> crate::model::LambdaFunctionMemoryProjectedMetric {
            crate::model::LambdaFunctionMemoryProjectedMetric {
                name: self.name
                ,
                statistic: self.statistic
                ,
                value: self.value
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl LambdaFunctionMemoryProjectedMetric {
    /// Creates a new builder-style object to manufacture [`LambdaFunctionMemoryProjectedMetric`](crate::model::LambdaFunctionMemoryProjectedMetric).
    pub fn builder() -> crate::model::lambda_function_memory_projected_metric::Builder {
        crate::model::lambda_function_memory_projected_metric::Builder::default()
    }
}

/// When writing a match expression against `LambdaFunctionMemoryMetricStatistic`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let lambdafunctionmemorymetricstatistic = unimplemented!();
/// match lambdafunctionmemorymetricstatistic {
///     LambdaFunctionMemoryMetricStatistic::Expected => { /* ... */ },
///     LambdaFunctionMemoryMetricStatistic::LowerBound => { /* ... */ },
///     LambdaFunctionMemoryMetricStatistic::UpperBound => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lambdafunctionmemorymetricstatistic` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LambdaFunctionMemoryMetricStatistic::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LambdaFunctionMemoryMetricStatistic::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LambdaFunctionMemoryMetricStatistic::NewFeature` is defined.
/// Specifically, when `lambdafunctionmemorymetricstatistic` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LambdaFunctionMemoryMetricStatistic::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum LambdaFunctionMemoryMetricStatistic {
    #[allow(missing_docs)] // documentation missing in model
    Expected,
    #[allow(missing_docs)] // documentation missing in model
    LowerBound,
    #[allow(missing_docs)] // documentation missing in model
    UpperBound,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for LambdaFunctionMemoryMetricStatistic {
    fn from(s: &str) -> Self {
        match s {
            "Expected" => LambdaFunctionMemoryMetricStatistic::Expected,
            "LowerBound" => LambdaFunctionMemoryMetricStatistic::LowerBound,
            "UpperBound" => LambdaFunctionMemoryMetricStatistic::UpperBound,
            other => LambdaFunctionMemoryMetricStatistic::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for LambdaFunctionMemoryMetricStatistic {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(LambdaFunctionMemoryMetricStatistic::from(s))
                }
            }
impl LambdaFunctionMemoryMetricStatistic {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LambdaFunctionMemoryMetricStatistic::Expected => "Expected",
            LambdaFunctionMemoryMetricStatistic::LowerBound => "LowerBound",
            LambdaFunctionMemoryMetricStatistic::UpperBound => "UpperBound",
            LambdaFunctionMemoryMetricStatistic::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Expected", "LowerBound", "UpperBound"
        ]
    }
}
impl AsRef<str> for LambdaFunctionMemoryMetricStatistic {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LambdaFunctionMemoryMetricName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let lambdafunctionmemorymetricname = unimplemented!();
/// match lambdafunctionmemorymetricname {
///     LambdaFunctionMemoryMetricName::Duration => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lambdafunctionmemorymetricname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LambdaFunctionMemoryMetricName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LambdaFunctionMemoryMetricName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LambdaFunctionMemoryMetricName::NewFeature` is defined.
/// Specifically, when `lambdafunctionmemorymetricname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LambdaFunctionMemoryMetricName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum LambdaFunctionMemoryMetricName {
    #[allow(missing_docs)] // documentation missing in model
    Duration,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for LambdaFunctionMemoryMetricName {
    fn from(s: &str) -> Self {
        match s {
            "Duration" => LambdaFunctionMemoryMetricName::Duration,
            other => LambdaFunctionMemoryMetricName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for LambdaFunctionMemoryMetricName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(LambdaFunctionMemoryMetricName::from(s))
                }
            }
impl LambdaFunctionMemoryMetricName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LambdaFunctionMemoryMetricName::Duration => "Duration",
            LambdaFunctionMemoryMetricName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Duration"
        ]
    }
}
impl AsRef<str> for LambdaFunctionMemoryMetricName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LambdaFunctionRecommendationFindingReasonCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let lambdafunctionrecommendationfindingreasoncode = unimplemented!();
/// match lambdafunctionrecommendationfindingreasoncode {
///     LambdaFunctionRecommendationFindingReasonCode::Inconclusive => { /* ... */ },
///     LambdaFunctionRecommendationFindingReasonCode::InsufficientData => { /* ... */ },
///     LambdaFunctionRecommendationFindingReasonCode::MemoryOverProvisioned => { /* ... */ },
///     LambdaFunctionRecommendationFindingReasonCode::MemoryUnderProvisioned => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lambdafunctionrecommendationfindingreasoncode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LambdaFunctionRecommendationFindingReasonCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LambdaFunctionRecommendationFindingReasonCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LambdaFunctionRecommendationFindingReasonCode::NewFeature` is defined.
/// Specifically, when `lambdafunctionrecommendationfindingreasoncode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LambdaFunctionRecommendationFindingReasonCode::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum LambdaFunctionRecommendationFindingReasonCode {
    #[allow(missing_docs)] // documentation missing in model
    Inconclusive,
    #[allow(missing_docs)] // documentation missing in model
    InsufficientData,
    #[allow(missing_docs)] // documentation missing in model
    MemoryOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    MemoryUnderProvisioned,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for LambdaFunctionRecommendationFindingReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "Inconclusive" => LambdaFunctionRecommendationFindingReasonCode::Inconclusive,
            "InsufficientData" => LambdaFunctionRecommendationFindingReasonCode::InsufficientData,
            "MemoryOverprovisioned" => LambdaFunctionRecommendationFindingReasonCode::MemoryOverProvisioned,
            "MemoryUnderprovisioned" => LambdaFunctionRecommendationFindingReasonCode::MemoryUnderProvisioned,
            other => LambdaFunctionRecommendationFindingReasonCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for LambdaFunctionRecommendationFindingReasonCode {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(LambdaFunctionRecommendationFindingReasonCode::from(s))
                }
            }
impl LambdaFunctionRecommendationFindingReasonCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LambdaFunctionRecommendationFindingReasonCode::Inconclusive => "Inconclusive",
            LambdaFunctionRecommendationFindingReasonCode::InsufficientData => "InsufficientData",
            LambdaFunctionRecommendationFindingReasonCode::MemoryOverProvisioned => "MemoryOverprovisioned",
            LambdaFunctionRecommendationFindingReasonCode::MemoryUnderProvisioned => "MemoryUnderprovisioned",
            LambdaFunctionRecommendationFindingReasonCode::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Inconclusive", "InsufficientData", "MemoryOverprovisioned", "MemoryUnderprovisioned"
        ]
    }
}
impl AsRef<str> for LambdaFunctionRecommendationFindingReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LambdaFunctionRecommendationFinding`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let lambdafunctionrecommendationfinding = unimplemented!();
/// match lambdafunctionrecommendationfinding {
///     LambdaFunctionRecommendationFinding::NotOptimized => { /* ... */ },
///     LambdaFunctionRecommendationFinding::Optimized => { /* ... */ },
///     LambdaFunctionRecommendationFinding::Unavailable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lambdafunctionrecommendationfinding` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LambdaFunctionRecommendationFinding::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LambdaFunctionRecommendationFinding::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LambdaFunctionRecommendationFinding::NewFeature` is defined.
/// Specifically, when `lambdafunctionrecommendationfinding` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LambdaFunctionRecommendationFinding::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum LambdaFunctionRecommendationFinding {
    #[allow(missing_docs)] // documentation missing in model
    NotOptimized,
    #[allow(missing_docs)] // documentation missing in model
    Optimized,
    #[allow(missing_docs)] // documentation missing in model
    Unavailable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for LambdaFunctionRecommendationFinding {
    fn from(s: &str) -> Self {
        match s {
            "NotOptimized" => LambdaFunctionRecommendationFinding::NotOptimized,
            "Optimized" => LambdaFunctionRecommendationFinding::Optimized,
            "Unavailable" => LambdaFunctionRecommendationFinding::Unavailable,
            other => LambdaFunctionRecommendationFinding::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for LambdaFunctionRecommendationFinding {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(LambdaFunctionRecommendationFinding::from(s))
                }
            }
impl LambdaFunctionRecommendationFinding {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LambdaFunctionRecommendationFinding::NotOptimized => "NotOptimized",
            LambdaFunctionRecommendationFinding::Optimized => "Optimized",
            LambdaFunctionRecommendationFinding::Unavailable => "Unavailable",
            LambdaFunctionRecommendationFinding::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "NotOptimized", "Optimized", "Unavailable"
        ]
    }
}
impl AsRef<str> for LambdaFunctionRecommendationFinding {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a utilization metric of an Lambda function.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LambdaFunctionUtilizationMetric  {
    /// <p>The name of the utilization metric.</p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>Duration</code> - The amount of time that your function code spends processing an event.</p> </li> 
    /// <li> <p> <code>Memory</code> - The amount of memory used per invocation.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::LambdaFunctionMetricName>,
    /// <p>The statistic of the utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    #[doc(hidden)]
    pub statistic: std::option::Option<crate::model::LambdaFunctionMetricStatistic>,
    /// <p>The value of the utilization metric.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl LambdaFunctionUtilizationMetric {
    /// <p>The name of the utilization metric.</p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>Duration</code> - The amount of time that your function code spends processing an event.</p> </li> 
    /// <li> <p> <code>Memory</code> - The amount of memory used per invocation.</p> </li> 
    /// </ul>
    pub fn name(&self) -> std::option::Option<& crate::model::LambdaFunctionMetricName> {
        self.name.as_ref()
    }
    /// <p>The statistic of the utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    pub fn statistic(&self) -> std::option::Option<& crate::model::LambdaFunctionMetricStatistic> {
        self.statistic.as_ref()
    }
    /// <p>The value of the utilization metric.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`LambdaFunctionUtilizationMetric`](crate::model::LambdaFunctionUtilizationMetric).
pub mod lambda_function_utilization_metric {
    
    /// A builder for [`LambdaFunctionUtilizationMetric`](crate::model::LambdaFunctionUtilizationMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::LambdaFunctionMetricName>,
        pub(crate) statistic: std::option::Option<crate::model::LambdaFunctionMetricStatistic>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the utilization metric.</p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>Duration</code> - The amount of time that your function code spends processing an event.</p> </li> 
        /// <li> <p> <code>Memory</code> - The amount of memory used per invocation.</p> </li> 
        /// </ul>
        pub fn name(mut self, input: crate::model::LambdaFunctionMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the utilization metric.</p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>Duration</code> - The amount of time that your function code spends processing an event.</p> </li> 
        /// <li> <p> <code>Memory</code> - The amount of memory used per invocation.</p> </li> 
        /// </ul>
        pub fn set_name(mut self, input: std::option::Option<crate::model::LambdaFunctionMetricName>) -> Self {
            self.name = input; self
        }
        /// <p>The statistic of the utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn statistic(mut self, input: crate::model::LambdaFunctionMetricStatistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic of the utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn set_statistic(mut self, input: std::option::Option<crate::model::LambdaFunctionMetricStatistic>) -> Self {
            self.statistic = input; self
        }
        /// <p>The value of the utilization metric.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the utilization metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`LambdaFunctionUtilizationMetric`](crate::model::LambdaFunctionUtilizationMetric).
        pub fn build(self) -> crate::model::LambdaFunctionUtilizationMetric {
            crate::model::LambdaFunctionUtilizationMetric {
                name: self.name
                ,
                statistic: self.statistic
                ,
                value: self.value
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl LambdaFunctionUtilizationMetric {
    /// Creates a new builder-style object to manufacture [`LambdaFunctionUtilizationMetric`](crate::model::LambdaFunctionUtilizationMetric).
    pub fn builder() -> crate::model::lambda_function_utilization_metric::Builder {
        crate::model::lambda_function_utilization_metric::Builder::default()
    }
}

/// When writing a match expression against `LambdaFunctionMetricStatistic`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let lambdafunctionmetricstatistic = unimplemented!();
/// match lambdafunctionmetricstatistic {
///     LambdaFunctionMetricStatistic::Average => { /* ... */ },
///     LambdaFunctionMetricStatistic::Maximum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lambdafunctionmetricstatistic` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LambdaFunctionMetricStatistic::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LambdaFunctionMetricStatistic::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LambdaFunctionMetricStatistic::NewFeature` is defined.
/// Specifically, when `lambdafunctionmetricstatistic` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LambdaFunctionMetricStatistic::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum LambdaFunctionMetricStatistic {
    #[allow(missing_docs)] // documentation missing in model
    Average,
    #[allow(missing_docs)] // documentation missing in model
    Maximum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for LambdaFunctionMetricStatistic {
    fn from(s: &str) -> Self {
        match s {
            "Average" => LambdaFunctionMetricStatistic::Average,
            "Maximum" => LambdaFunctionMetricStatistic::Maximum,
            other => LambdaFunctionMetricStatistic::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for LambdaFunctionMetricStatistic {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(LambdaFunctionMetricStatistic::from(s))
                }
            }
impl LambdaFunctionMetricStatistic {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LambdaFunctionMetricStatistic::Average => "Average",
            LambdaFunctionMetricStatistic::Maximum => "Maximum",
            LambdaFunctionMetricStatistic::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Average", "Maximum"
        ]
    }
}
impl AsRef<str> for LambdaFunctionMetricStatistic {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LambdaFunctionMetricName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let lambdafunctionmetricname = unimplemented!();
/// match lambdafunctionmetricname {
///     LambdaFunctionMetricName::Duration => { /* ... */ },
///     LambdaFunctionMetricName::Memory => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lambdafunctionmetricname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LambdaFunctionMetricName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LambdaFunctionMetricName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LambdaFunctionMetricName::NewFeature` is defined.
/// Specifically, when `lambdafunctionmetricname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LambdaFunctionMetricName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum LambdaFunctionMetricName {
    #[allow(missing_docs)] // documentation missing in model
    Duration,
    #[allow(missing_docs)] // documentation missing in model
    Memory,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for LambdaFunctionMetricName {
    fn from(s: &str) -> Self {
        match s {
            "Duration" => LambdaFunctionMetricName::Duration,
            "Memory" => LambdaFunctionMetricName::Memory,
            other => LambdaFunctionMetricName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for LambdaFunctionMetricName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(LambdaFunctionMetricName::from(s))
                }
            }
impl LambdaFunctionMetricName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LambdaFunctionMetricName::Duration => "Duration",
            LambdaFunctionMetricName::Memory => "Memory",
            LambdaFunctionMetricName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Duration", "Memory"
        ]
    }
}
impl AsRef<str> for LambdaFunctionMetricName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a filter that returns a more specific list of Lambda function recommendations. Use this filter with the <code>GetLambdaFunctionRecommendations</code> action.</p> 
/// <p>You can use <code>EBSFilter</code> with the <code>GetEBSVolumeRecommendations</code> action, <code>JobFilter</code> with the <code>DescribeRecommendationExportJobs</code> action, and <code>Filter</code> with the <code>GetAutoScalingGroupRecommendations</code> and <code>GetEC2InstanceRecommendations</code> actions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LambdaFunctionRecommendationFilter  {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p> 
    /// <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code (for example, <code>MemoryUnderprovisioned</code>).</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::LambdaFunctionRecommendationFilterName>,
    /// <p>The value of the filter.</p> 
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p> 
    /// <ul> 
    /// <li> <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code> if you specify the <code>name</code> parameter as <code>Finding</code>.</p> </li> 
    /// <li> <p>Specify <code>MemoryOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or <code>Inconclusive</code> if you specify the <code>name</code> parameter as <code>FindingReasonCode</code>.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl LambdaFunctionRecommendationFilter {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p> 
    /// <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code (for example, <code>MemoryUnderprovisioned</code>).</p>
    pub fn name(&self) -> std::option::Option<& crate::model::LambdaFunctionRecommendationFilterName> {
        self.name.as_ref()
    }
    /// <p>The value of the filter.</p> 
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p> 
    /// <ul> 
    /// <li> <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code> if you specify the <code>name</code> parameter as <code>Finding</code>.</p> </li> 
    /// <li> <p>Specify <code>MemoryOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or <code>Inconclusive</code> if you specify the <code>name</code> parameter as <code>FindingReasonCode</code>.</p> </li> 
    /// </ul>
    pub fn values(&self) -> std::option::Option<& [std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`LambdaFunctionRecommendationFilter`](crate::model::LambdaFunctionRecommendationFilter).
pub mod lambda_function_recommendation_filter {
    
    /// A builder for [`LambdaFunctionRecommendationFilter`](crate::model::LambdaFunctionRecommendationFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::LambdaFunctionRecommendationFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p> 
        /// <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code (for example, <code>MemoryUnderprovisioned</code>).</p>
        pub fn name(mut self, input: crate::model::LambdaFunctionRecommendationFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p> 
        /// <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code (for example, <code>MemoryUnderprovisioned</code>).</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::LambdaFunctionRecommendationFilterName>) -> Self {
            self.name = input; self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value of the filter.</p> 
        /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p> 
        /// <ul> 
        /// <li> <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code> if you specify the <code>name</code> parameter as <code>Finding</code>.</p> </li> 
        /// <li> <p>Specify <code>MemoryOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or <code>Inconclusive</code> if you specify the <code>name</code> parameter as <code>FindingReasonCode</code>.</p> </li> 
        /// </ul>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
                            v.push(input.into());
                            self.values = Some(v);
                            self
        }
        /// <p>The value of the filter.</p> 
        /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p> 
        /// <ul> 
        /// <li> <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code> if you specify the <code>name</code> parameter as <code>Finding</code>.</p> </li> 
        /// <li> <p>Specify <code>MemoryOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or <code>Inconclusive</code> if you specify the <code>name</code> parameter as <code>FindingReasonCode</code>.</p> </li> 
        /// </ul>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`LambdaFunctionRecommendationFilter`](crate::model::LambdaFunctionRecommendationFilter).
        pub fn build(self) -> crate::model::LambdaFunctionRecommendationFilter {
            crate::model::LambdaFunctionRecommendationFilter {
                name: self.name
                ,
                values: self.values
                ,
            }
        }
    }
    
    
}
impl LambdaFunctionRecommendationFilter {
    /// Creates a new builder-style object to manufacture [`LambdaFunctionRecommendationFilter`](crate::model::LambdaFunctionRecommendationFilter).
    pub fn builder() -> crate::model::lambda_function_recommendation_filter::Builder {
        crate::model::lambda_function_recommendation_filter::Builder::default()
    }
}

/// When writing a match expression against `LambdaFunctionRecommendationFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let lambdafunctionrecommendationfiltername = unimplemented!();
/// match lambdafunctionrecommendationfiltername {
///     LambdaFunctionRecommendationFilterName::Finding => { /* ... */ },
///     LambdaFunctionRecommendationFilterName::FindingReasonCode => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lambdafunctionrecommendationfiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LambdaFunctionRecommendationFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LambdaFunctionRecommendationFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LambdaFunctionRecommendationFilterName::NewFeature` is defined.
/// Specifically, when `lambdafunctionrecommendationfiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LambdaFunctionRecommendationFilterName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum LambdaFunctionRecommendationFilterName {
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    #[allow(missing_docs)] // documentation missing in model
    FindingReasonCode,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for LambdaFunctionRecommendationFilterName {
    fn from(s: &str) -> Self {
        match s {
            "Finding" => LambdaFunctionRecommendationFilterName::Finding,
            "FindingReasonCode" => LambdaFunctionRecommendationFilterName::FindingReasonCode,
            other => LambdaFunctionRecommendationFilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for LambdaFunctionRecommendationFilterName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(LambdaFunctionRecommendationFilterName::from(s))
                }
            }
impl LambdaFunctionRecommendationFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LambdaFunctionRecommendationFilterName::Finding => "Finding",
            LambdaFunctionRecommendationFilterName::FindingReasonCode => "FindingReasonCode",
            LambdaFunctionRecommendationFilterName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Finding", "FindingReasonCode"
        ]
    }
}
impl AsRef<str> for LambdaFunctionRecommendationFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the enrollment status of an organization's member accounts in Compute Optimizer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountEnrollmentStatus  {
    /// <p>The Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The account enrollment status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>The reason for the account enrollment status.</p> 
    /// <p>For example, an account might show a status of <code>Pending</code> because member accounts of an organization require more time to be enrolled in the service.</p>
    #[doc(hidden)]
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp, in seconds, of when the account enrollment status was last updated.</p>
    #[doc(hidden)]
    pub last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl AccountEnrollmentStatus {
    /// <p>The Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The account enrollment status.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>The reason for the account enrollment status.</p> 
    /// <p>For example, an account might show a status of <code>Pending</code> because member accounts of an organization require more time to be enrolled in the service.</p>
    pub fn status_reason(&self) -> std::option::Option<& str> {
        self.status_reason.as_deref()
    }
    /// <p>The Unix epoch timestamp, in seconds, of when the account enrollment status was last updated.</p>
    pub fn last_updated_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.last_updated_timestamp.as_ref()
    }
}
/// See [`AccountEnrollmentStatus`](crate::model::AccountEnrollmentStatus).
pub mod account_enrollment_status {
    
    /// A builder for [`AccountEnrollmentStatus`](crate::model::AccountEnrollmentStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The account enrollment status.</p>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The account enrollment status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input; self
        }
        /// <p>The reason for the account enrollment status.</p> 
        /// <p>For example, an account might show a status of <code>Pending</code> because member accounts of an organization require more time to be enrolled in the service.</p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        /// <p>The reason for the account enrollment status.</p> 
        /// <p>For example, an account might show a status of <code>Pending</code> because member accounts of an organization require more time to be enrolled in the service.</p>
        pub fn set_status_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status_reason = input; self
        }
        /// <p>The Unix epoch timestamp, in seconds, of when the account enrollment status was last updated.</p>
        pub fn last_updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_timestamp = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp, in seconds, of when the account enrollment status was last updated.</p>
        pub fn set_last_updated_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.last_updated_timestamp = input; self
        }
        /// Consumes the builder and constructs a [`AccountEnrollmentStatus`](crate::model::AccountEnrollmentStatus).
        pub fn build(self) -> crate::model::AccountEnrollmentStatus {
            crate::model::AccountEnrollmentStatus {
                account_id: self.account_id
                ,
                status: self.status
                ,
                status_reason: self.status_reason
                ,
                last_updated_timestamp: self.last_updated_timestamp
                ,
            }
        }
    }
    
    
}
impl AccountEnrollmentStatus {
    /// Creates a new builder-style object to manufacture [`AccountEnrollmentStatus`](crate::model::AccountEnrollmentStatus).
    pub fn builder() -> crate::model::account_enrollment_status::Builder {
        crate::model::account_enrollment_status::Builder::default()
    }
}

/// <p>Describes a filter that returns a more specific list of account enrollment statuses. Use this filter with the <code>GetEnrollmentStatusesForOrganization</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EnrollmentFilter  {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>Status</code> to return accounts with a specific enrollment status (for example, <code>Active</code>).</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::EnrollmentFilterName>,
    /// <p>The value of the filter.</p> 
    /// <p>The valid values are <code>Active</code>, <code>Inactive</code>, <code>Pending</code>, and <code>Failed</code>.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl EnrollmentFilter {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>Status</code> to return accounts with a specific enrollment status (for example, <code>Active</code>).</p>
    pub fn name(&self) -> std::option::Option<& crate::model::EnrollmentFilterName> {
        self.name.as_ref()
    }
    /// <p>The value of the filter.</p> 
    /// <p>The valid values are <code>Active</code>, <code>Inactive</code>, <code>Pending</code>, and <code>Failed</code>.</p>
    pub fn values(&self) -> std::option::Option<& [std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`EnrollmentFilter`](crate::model::EnrollmentFilter).
pub mod enrollment_filter {
    
    /// A builder for [`EnrollmentFilter`](crate::model::EnrollmentFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::EnrollmentFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>Status</code> to return accounts with a specific enrollment status (for example, <code>Active</code>).</p>
        pub fn name(mut self, input: crate::model::EnrollmentFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>Status</code> to return accounts with a specific enrollment status (for example, <code>Active</code>).</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::EnrollmentFilterName>) -> Self {
            self.name = input; self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value of the filter.</p> 
        /// <p>The valid values are <code>Active</code>, <code>Inactive</code>, <code>Pending</code>, and <code>Failed</code>.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
                            v.push(input.into());
                            self.values = Some(v);
                            self
        }
        /// <p>The value of the filter.</p> 
        /// <p>The valid values are <code>Active</code>, <code>Inactive</code>, <code>Pending</code>, and <code>Failed</code>.</p>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`EnrollmentFilter`](crate::model::EnrollmentFilter).
        pub fn build(self) -> crate::model::EnrollmentFilter {
            crate::model::EnrollmentFilter {
                name: self.name
                ,
                values: self.values
                ,
            }
        }
    }
    
    
}
impl EnrollmentFilter {
    /// Creates a new builder-style object to manufacture [`EnrollmentFilter`](crate::model::EnrollmentFilter).
    pub fn builder() -> crate::model::enrollment_filter::Builder {
        crate::model::enrollment_filter::Builder::default()
    }
}

/// When writing a match expression against `EnrollmentFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let enrollmentfiltername = unimplemented!();
/// match enrollmentfiltername {
///     EnrollmentFilterName::Status => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `enrollmentfiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EnrollmentFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EnrollmentFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EnrollmentFilterName::NewFeature` is defined.
/// Specifically, when `enrollmentfiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EnrollmentFilterName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EnrollmentFilterName {
    #[allow(missing_docs)] // documentation missing in model
    Status,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EnrollmentFilterName {
    fn from(s: &str) -> Self {
        match s {
            "Status" => EnrollmentFilterName::Status,
            other => EnrollmentFilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EnrollmentFilterName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EnrollmentFilterName::from(s))
                }
            }
impl EnrollmentFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EnrollmentFilterName::Status => "Status",
            EnrollmentFilterName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Status"
        ]
    }
}
impl AsRef<str> for EnrollmentFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an error experienced when getting recommendations.</p> 
/// <p>For example, an error is returned if you request recommendations for an unsupported Auto Scaling group, or if you request recommendations for an instance of an unsupported instance family.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRecommendationError  {
    /// <p>The ID of the error.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>The message, or reason, for the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl GetRecommendationError {
    /// <p>The ID of the error.</p>
    pub fn identifier(&self) -> std::option::Option<& str> {
        self.identifier.as_deref()
    }
    /// <p>The error code.</p>
    pub fn code(&self) -> std::option::Option<& str> {
        self.code.as_deref()
    }
    /// <p>The message, or reason, for the error.</p>
    pub fn message(&self) -> std::option::Option<& str> {
        self.message.as_deref()
    }
}
/// See [`GetRecommendationError`](crate::model::GetRecommendationError).
pub mod get_recommendation_error {
    
    /// A builder for [`GetRecommendationError`](crate::model::GetRecommendationError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the error.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The ID of the error.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input; self
        }
        /// <p>The error code.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The error code.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input; self
        }
        /// <p>The message, or reason, for the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message, or reason, for the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`GetRecommendationError`](crate::model::GetRecommendationError).
        pub fn build(self) -> crate::model::GetRecommendationError {
            crate::model::GetRecommendationError {
                identifier: self.identifier
                ,
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl GetRecommendationError {
    /// Creates a new builder-style object to manufacture [`GetRecommendationError`](crate::model::GetRecommendationError).
    pub fn builder() -> crate::model::get_recommendation_error::Builder {
        crate::model::get_recommendation_error::Builder::default()
    }
}

/// <p> Describes an Amazon ECS service recommendation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsServiceRecommendation  {
    /// <p> The Amazon Resource Name (ARN) of the current ECS service. </p> 
    /// <p> The following is the format of the ARN: </p> 
    /// <p> <code>arn:aws:ecs:region:aws_account_id:service/cluster-name/service-name</code> </p>
    #[doc(hidden)]
    pub service_arn: std::option::Option<std::string::String>,
    /// <p> The Amazon Web Services account ID of the ECS service. </p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> The configuration of the current ECS service. </p>
    #[doc(hidden)]
    pub current_service_configuration: std::option::Option<crate::model::ServiceConfiguration>,
    /// <p> An array of objects that describe the utilization metrics of the ECS service. </p>
    #[doc(hidden)]
    pub utilization_metrics: std::option::Option<std::vec::Vec<crate::model::EcsServiceUtilizationMetric>>,
    /// <p> The number of days the ECS service utilization metrics were analyzed. </p>
    #[doc(hidden)]
    pub lookback_period_in_days: f64,
    /// <p> The launch type the ECS service is using. </p> <note> 
    /// <p>Compute Optimizer only supports the Fargate launch type.</p> 
    /// </note>
    #[doc(hidden)]
    pub launch_type: std::option::Option<crate::model::EcsServiceLaunchType>,
    /// <p> The timestamp of when the ECS service recommendation was last generated. </p>
    #[doc(hidden)]
    pub last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The finding classification of an ECS service. </p> 
    /// <p>Findings for ECS services include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>Underprovisioned</code> </b>  When Compute Optimizer detects that theres not enough memory or CPU, an ECS service is considered under-provisioned. An under-provisioned ECS service might result in poor application performance.</p> </li> 
    /// <li> <p> <b> <code>Overprovisioned</code> </b>  When Compute Optimizer detects that theres excessive memory or CPU, an ECS service is considered over-provisioned. An over-provisioned ECS service might result in additional infrastructure costs. </p> </li> 
    /// <li> <p> <b> <code>Optimized</code> </b>  When both the CPU and memory of your ECS service meet the performance requirements of your workload, the service is considered optimized.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub finding: std::option::Option<crate::model::EcsServiceRecommendationFinding>,
    /// <p> The reason for the finding classification of an ECS service. </p> 
    /// <p>Finding reason codes for ECS services include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The ECS service CPU configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The ECS service CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period. </p> </li> 
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The ECS service memory configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The ECS service memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub finding_reason_codes: std::option::Option<std::vec::Vec<crate::model::EcsServiceRecommendationFindingReasonCode>>,
    /// <p> An array of objects that describe the recommendation options for the ECS service. </p>
    #[doc(hidden)]
    pub service_recommendation_options: std::option::Option<std::vec::Vec<crate::model::EcsServiceRecommendationOption>>,
    /// <p> The risk of the current ECS service not meeting the performance needs of its workloads. The higher the risk, the more likely the current service can't meet the performance requirements of its workload. </p>
    #[doc(hidden)]
    pub current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
}
impl EcsServiceRecommendation {
    /// <p> The Amazon Resource Name (ARN) of the current ECS service. </p> 
    /// <p> The following is the format of the ARN: </p> 
    /// <p> <code>arn:aws:ecs:region:aws_account_id:service/cluster-name/service-name</code> </p>
    pub fn service_arn(&self) -> std::option::Option<& str> {
        self.service_arn.as_deref()
    }
    /// <p> The Amazon Web Services account ID of the ECS service. </p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> The configuration of the current ECS service. </p>
    pub fn current_service_configuration(&self) -> std::option::Option<& crate::model::ServiceConfiguration> {
        self.current_service_configuration.as_ref()
    }
    /// <p> An array of objects that describe the utilization metrics of the ECS service. </p>
    pub fn utilization_metrics(&self) -> std::option::Option<& [crate::model::EcsServiceUtilizationMetric]> {
        self.utilization_metrics.as_deref()
    }
    /// <p> The number of days the ECS service utilization metrics were analyzed. </p>
    pub fn lookback_period_in_days(&self) -> f64 {
        self.lookback_period_in_days
    }
    /// <p> The launch type the ECS service is using. </p> <note> 
    /// <p>Compute Optimizer only supports the Fargate launch type.</p> 
    /// </note>
    pub fn launch_type(&self) -> std::option::Option<& crate::model::EcsServiceLaunchType> {
        self.launch_type.as_ref()
    }
    /// <p> The timestamp of when the ECS service recommendation was last generated. </p>
    pub fn last_refresh_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.last_refresh_timestamp.as_ref()
    }
    /// <p> The finding classification of an ECS service. </p> 
    /// <p>Findings for ECS services include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>Underprovisioned</code> </b>  When Compute Optimizer detects that theres not enough memory or CPU, an ECS service is considered under-provisioned. An under-provisioned ECS service might result in poor application performance.</p> </li> 
    /// <li> <p> <b> <code>Overprovisioned</code> </b>  When Compute Optimizer detects that theres excessive memory or CPU, an ECS service is considered over-provisioned. An over-provisioned ECS service might result in additional infrastructure costs. </p> </li> 
    /// <li> <p> <b> <code>Optimized</code> </b>  When both the CPU and memory of your ECS service meet the performance requirements of your workload, the service is considered optimized.</p> </li> 
    /// </ul>
    pub fn finding(&self) -> std::option::Option<& crate::model::EcsServiceRecommendationFinding> {
        self.finding.as_ref()
    }
    /// <p> The reason for the finding classification of an ECS service. </p> 
    /// <p>Finding reason codes for ECS services include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The ECS service CPU configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The ECS service CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period. </p> </li> 
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The ECS service memory configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The ECS service memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li> 
    /// </ul>
    pub fn finding_reason_codes(&self) -> std::option::Option<& [crate::model::EcsServiceRecommendationFindingReasonCode]> {
        self.finding_reason_codes.as_deref()
    }
    /// <p> An array of objects that describe the recommendation options for the ECS service. </p>
    pub fn service_recommendation_options(&self) -> std::option::Option<& [crate::model::EcsServiceRecommendationOption]> {
        self.service_recommendation_options.as_deref()
    }
    /// <p> The risk of the current ECS service not meeting the performance needs of its workloads. The higher the risk, the more likely the current service can't meet the performance requirements of its workload. </p>
    pub fn current_performance_risk(&self) -> std::option::Option<& crate::model::CurrentPerformanceRisk> {
        self.current_performance_risk.as_ref()
    }
}
/// See [`EcsServiceRecommendation`](crate::model::EcsServiceRecommendation).
pub mod ecs_service_recommendation {
    
    /// A builder for [`EcsServiceRecommendation`](crate::model::EcsServiceRecommendation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_arn: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) current_service_configuration: std::option::Option<crate::model::ServiceConfiguration>,
        pub(crate) utilization_metrics: std::option::Option<std::vec::Vec<crate::model::EcsServiceUtilizationMetric>>,
        pub(crate) lookback_period_in_days: std::option::Option<f64>,
        pub(crate) launch_type: std::option::Option<crate::model::EcsServiceLaunchType>,
        pub(crate) last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) finding: std::option::Option<crate::model::EcsServiceRecommendationFinding>,
        pub(crate) finding_reason_codes: std::option::Option<std::vec::Vec<crate::model::EcsServiceRecommendationFindingReasonCode>>,
        pub(crate) service_recommendation_options: std::option::Option<std::vec::Vec<crate::model::EcsServiceRecommendationOption>>,
        pub(crate) current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of the current ECS service. </p> 
        /// <p> The following is the format of the ARN: </p> 
        /// <p> <code>arn:aws:ecs:region:aws_account_id:service/cluster-name/service-name</code> </p>
        pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the current ECS service. </p> 
        /// <p> The following is the format of the ARN: </p> 
        /// <p> <code>arn:aws:ecs:region:aws_account_id:service/cluster-name/service-name</code> </p>
        pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_arn = input; self
        }
        /// <p> The Amazon Web Services account ID of the ECS service. </p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p> The Amazon Web Services account ID of the ECS service. </p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> The configuration of the current ECS service. </p>
        pub fn current_service_configuration(mut self, input: crate::model::ServiceConfiguration) -> Self {
            self.current_service_configuration = Some(input);
            self
        }
        /// <p> The configuration of the current ECS service. </p>
        pub fn set_current_service_configuration(mut self, input: std::option::Option<crate::model::ServiceConfiguration>) -> Self {
            self.current_service_configuration = input; self
        }
        /// Appends an item to `utilization_metrics`.
        ///
        /// To override the contents of this collection use [`set_utilization_metrics`](Self::set_utilization_metrics).
        ///
        /// <p> An array of objects that describe the utilization metrics of the ECS service. </p>
        pub fn utilization_metrics(mut self, input: crate::model::EcsServiceUtilizationMetric) -> Self {
            let mut v = self.utilization_metrics.unwrap_or_default();
                            v.push(input);
                            self.utilization_metrics = Some(v);
                            self
        }
        /// <p> An array of objects that describe the utilization metrics of the ECS service. </p>
        pub fn set_utilization_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::EcsServiceUtilizationMetric>>) -> Self {
            self.utilization_metrics = input; self
        }
        /// <p> The number of days the ECS service utilization metrics were analyzed. </p>
        pub fn lookback_period_in_days(mut self, input: f64) -> Self {
            self.lookback_period_in_days = Some(input);
            self
        }
        /// <p> The number of days the ECS service utilization metrics were analyzed. </p>
        pub fn set_lookback_period_in_days(mut self, input: std::option::Option<f64>) -> Self {
            self.lookback_period_in_days = input; self
        }
        /// <p> The launch type the ECS service is using. </p> <note> 
        /// <p>Compute Optimizer only supports the Fargate launch type.</p> 
        /// </note>
        pub fn launch_type(mut self, input: crate::model::EcsServiceLaunchType) -> Self {
            self.launch_type = Some(input);
            self
        }
        /// <p> The launch type the ECS service is using. </p> <note> 
        /// <p>Compute Optimizer only supports the Fargate launch type.</p> 
        /// </note>
        pub fn set_launch_type(mut self, input: std::option::Option<crate::model::EcsServiceLaunchType>) -> Self {
            self.launch_type = input; self
        }
        /// <p> The timestamp of when the ECS service recommendation was last generated. </p>
        pub fn last_refresh_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_refresh_timestamp = Some(input);
            self
        }
        /// <p> The timestamp of when the ECS service recommendation was last generated. </p>
        pub fn set_last_refresh_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.last_refresh_timestamp = input; self
        }
        /// <p> The finding classification of an ECS service. </p> 
        /// <p>Findings for ECS services include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>Underprovisioned</code> </b>  When Compute Optimizer detects that theres not enough memory or CPU, an ECS service is considered under-provisioned. An under-provisioned ECS service might result in poor application performance.</p> </li> 
        /// <li> <p> <b> <code>Overprovisioned</code> </b>  When Compute Optimizer detects that theres excessive memory or CPU, an ECS service is considered over-provisioned. An over-provisioned ECS service might result in additional infrastructure costs. </p> </li> 
        /// <li> <p> <b> <code>Optimized</code> </b>  When both the CPU and memory of your ECS service meet the performance requirements of your workload, the service is considered optimized.</p> </li> 
        /// </ul>
        pub fn finding(mut self, input: crate::model::EcsServiceRecommendationFinding) -> Self {
            self.finding = Some(input);
            self
        }
        /// <p> The finding classification of an ECS service. </p> 
        /// <p>Findings for ECS services include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>Underprovisioned</code> </b>  When Compute Optimizer detects that theres not enough memory or CPU, an ECS service is considered under-provisioned. An under-provisioned ECS service might result in poor application performance.</p> </li> 
        /// <li> <p> <b> <code>Overprovisioned</code> </b>  When Compute Optimizer detects that theres excessive memory or CPU, an ECS service is considered over-provisioned. An over-provisioned ECS service might result in additional infrastructure costs. </p> </li> 
        /// <li> <p> <b> <code>Optimized</code> </b>  When both the CPU and memory of your ECS service meet the performance requirements of your workload, the service is considered optimized.</p> </li> 
        /// </ul>
        pub fn set_finding(mut self, input: std::option::Option<crate::model::EcsServiceRecommendationFinding>) -> Self {
            self.finding = input; self
        }
        /// Appends an item to `finding_reason_codes`.
        ///
        /// To override the contents of this collection use [`set_finding_reason_codes`](Self::set_finding_reason_codes).
        ///
        /// <p> The reason for the finding classification of an ECS service. </p> 
        /// <p>Finding reason codes for ECS services include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The ECS service CPU configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The ECS service CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period. </p> </li> 
        /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The ECS service memory configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The ECS service memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li> 
        /// </ul>
        pub fn finding_reason_codes(mut self, input: crate::model::EcsServiceRecommendationFindingReasonCode) -> Self {
            let mut v = self.finding_reason_codes.unwrap_or_default();
                            v.push(input);
                            self.finding_reason_codes = Some(v);
                            self
        }
        /// <p> The reason for the finding classification of an ECS service. </p> 
        /// <p>Finding reason codes for ECS services include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The ECS service CPU configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The ECS service CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period. </p> </li> 
        /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The ECS service memory configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The ECS service memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li> 
        /// </ul>
        pub fn set_finding_reason_codes(mut self, input: std::option::Option<std::vec::Vec<crate::model::EcsServiceRecommendationFindingReasonCode>>) -> Self {
            self.finding_reason_codes = input; self
        }
        /// Appends an item to `service_recommendation_options`.
        ///
        /// To override the contents of this collection use [`set_service_recommendation_options`](Self::set_service_recommendation_options).
        ///
        /// <p> An array of objects that describe the recommendation options for the ECS service. </p>
        pub fn service_recommendation_options(mut self, input: crate::model::EcsServiceRecommendationOption) -> Self {
            let mut v = self.service_recommendation_options.unwrap_or_default();
                            v.push(input);
                            self.service_recommendation_options = Some(v);
                            self
        }
        /// <p> An array of objects that describe the recommendation options for the ECS service. </p>
        pub fn set_service_recommendation_options(mut self, input: std::option::Option<std::vec::Vec<crate::model::EcsServiceRecommendationOption>>) -> Self {
            self.service_recommendation_options = input; self
        }
        /// <p> The risk of the current ECS service not meeting the performance needs of its workloads. The higher the risk, the more likely the current service can't meet the performance requirements of its workload. </p>
        pub fn current_performance_risk(mut self, input: crate::model::CurrentPerformanceRisk) -> Self {
            self.current_performance_risk = Some(input);
            self
        }
        /// <p> The risk of the current ECS service not meeting the performance needs of its workloads. The higher the risk, the more likely the current service can't meet the performance requirements of its workload. </p>
        pub fn set_current_performance_risk(mut self, input: std::option::Option<crate::model::CurrentPerformanceRisk>) -> Self {
            self.current_performance_risk = input; self
        }
        /// Consumes the builder and constructs a [`EcsServiceRecommendation`](crate::model::EcsServiceRecommendation).
        pub fn build(self) -> crate::model::EcsServiceRecommendation {
            crate::model::EcsServiceRecommendation {
                service_arn: self.service_arn
                ,
                account_id: self.account_id
                ,
                current_service_configuration: self.current_service_configuration
                ,
                utilization_metrics: self.utilization_metrics
                ,
                lookback_period_in_days: self.lookback_period_in_days
                    .unwrap_or_default()
                ,
                launch_type: self.launch_type
                ,
                last_refresh_timestamp: self.last_refresh_timestamp
                ,
                finding: self.finding
                ,
                finding_reason_codes: self.finding_reason_codes
                ,
                service_recommendation_options: self.service_recommendation_options
                ,
                current_performance_risk: self.current_performance_risk
                ,
            }
        }
    }
    
    
}
impl EcsServiceRecommendation {
    /// Creates a new builder-style object to manufacture [`EcsServiceRecommendation`](crate::model::EcsServiceRecommendation).
    pub fn builder() -> crate::model::ecs_service_recommendation::Builder {
        crate::model::ecs_service_recommendation::Builder::default()
    }
}

/// <p> Describes the recommendation options for an Amazon ECS service. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsServiceRecommendationOption  {
    /// <p> The memory size of the ECS service recommendation option. </p>
    #[doc(hidden)]
    pub memory: std::option::Option<i32>,
    /// <p> The CPU size of the ECS service recommendation option. </p>
    #[doc(hidden)]
    pub cpu: std::option::Option<i32>,
    /// <p>Describes the savings opportunity for recommendations of a given resource type or for the recommendation option of an individual resource.</p> 
    /// <p>Savings opportunity represents the estimated monthly savings you can achieve by implementing a given Compute Optimizer recommendation.</p> <important> 
    /// <p>Savings opportunity data requires that you opt in to Cost Explorer, as well as activate <b>Receive Amazon EC2 resource recommendations</b> in the Cost Explorer preferences page. That creates a connection between Cost Explorer and Compute Optimizer. With this connection, Cost Explorer generates savings estimates considering the price of existing resources, the price of recommended resources, and historical usage data. Estimated monthly savings reflects the projected dollar savings associated with each of the recommendations generated. For more information, see <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-enable.html">Enabling Cost Explorer</a> and <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-rightsizing.html">Optimizing your cost with Rightsizing Recommendations</a> in the <i>Cost Management User Guide</i>.</p> 
    /// </important>
    #[doc(hidden)]
    pub savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
    /// <p> An array of objects that describe the projected utilization metrics of the ECS service recommendation option. </p>
    #[doc(hidden)]
    pub projected_utilization_metrics: std::option::Option<std::vec::Vec<crate::model::EcsServiceProjectedUtilizationMetric>>,
    /// <p> The CPU and memory size recommendations for the containers within the task of your ECS service. </p>
    #[doc(hidden)]
    pub container_recommendations: std::option::Option<std::vec::Vec<crate::model::ContainerRecommendation>>,
}
impl EcsServiceRecommendationOption {
    /// <p> The memory size of the ECS service recommendation option. </p>
    pub fn memory(&self) -> std::option::Option<i32> {
        self.memory
    }
    /// <p> The CPU size of the ECS service recommendation option. </p>
    pub fn cpu(&self) -> std::option::Option<i32> {
        self.cpu
    }
    /// <p>Describes the savings opportunity for recommendations of a given resource type or for the recommendation option of an individual resource.</p> 
    /// <p>Savings opportunity represents the estimated monthly savings you can achieve by implementing a given Compute Optimizer recommendation.</p> <important> 
    /// <p>Savings opportunity data requires that you opt in to Cost Explorer, as well as activate <b>Receive Amazon EC2 resource recommendations</b> in the Cost Explorer preferences page. That creates a connection between Cost Explorer and Compute Optimizer. With this connection, Cost Explorer generates savings estimates considering the price of existing resources, the price of recommended resources, and historical usage data. Estimated monthly savings reflects the projected dollar savings associated with each of the recommendations generated. For more information, see <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-enable.html">Enabling Cost Explorer</a> and <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-rightsizing.html">Optimizing your cost with Rightsizing Recommendations</a> in the <i>Cost Management User Guide</i>.</p> 
    /// </important>
    pub fn savings_opportunity(&self) -> std::option::Option<& crate::model::SavingsOpportunity> {
        self.savings_opportunity.as_ref()
    }
    /// <p> An array of objects that describe the projected utilization metrics of the ECS service recommendation option. </p>
    pub fn projected_utilization_metrics(&self) -> std::option::Option<& [crate::model::EcsServiceProjectedUtilizationMetric]> {
        self.projected_utilization_metrics.as_deref()
    }
    /// <p> The CPU and memory size recommendations for the containers within the task of your ECS service. </p>
    pub fn container_recommendations(&self) -> std::option::Option<& [crate::model::ContainerRecommendation]> {
        self.container_recommendations.as_deref()
    }
}
/// See [`EcsServiceRecommendationOption`](crate::model::EcsServiceRecommendationOption).
pub mod ecs_service_recommendation_option {
    
    /// A builder for [`EcsServiceRecommendationOption`](crate::model::EcsServiceRecommendationOption).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) memory: std::option::Option<i32>,
        pub(crate) cpu: std::option::Option<i32>,
        pub(crate) savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
        pub(crate) projected_utilization_metrics: std::option::Option<std::vec::Vec<crate::model::EcsServiceProjectedUtilizationMetric>>,
        pub(crate) container_recommendations: std::option::Option<std::vec::Vec<crate::model::ContainerRecommendation>>,
    }
    impl Builder {
        /// <p> The memory size of the ECS service recommendation option. </p>
        pub fn memory(mut self, input: i32) -> Self {
            self.memory = Some(input);
            self
        }
        /// <p> The memory size of the ECS service recommendation option. </p>
        pub fn set_memory(mut self, input: std::option::Option<i32>) -> Self {
            self.memory = input; self
        }
        /// <p> The CPU size of the ECS service recommendation option. </p>
        pub fn cpu(mut self, input: i32) -> Self {
            self.cpu = Some(input);
            self
        }
        /// <p> The CPU size of the ECS service recommendation option. </p>
        pub fn set_cpu(mut self, input: std::option::Option<i32>) -> Self {
            self.cpu = input; self
        }
        /// <p>Describes the savings opportunity for recommendations of a given resource type or for the recommendation option of an individual resource.</p> 
        /// <p>Savings opportunity represents the estimated monthly savings you can achieve by implementing a given Compute Optimizer recommendation.</p> <important> 
        /// <p>Savings opportunity data requires that you opt in to Cost Explorer, as well as activate <b>Receive Amazon EC2 resource recommendations</b> in the Cost Explorer preferences page. That creates a connection between Cost Explorer and Compute Optimizer. With this connection, Cost Explorer generates savings estimates considering the price of existing resources, the price of recommended resources, and historical usage data. Estimated monthly savings reflects the projected dollar savings associated with each of the recommendations generated. For more information, see <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-enable.html">Enabling Cost Explorer</a> and <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-rightsizing.html">Optimizing your cost with Rightsizing Recommendations</a> in the <i>Cost Management User Guide</i>.</p> 
        /// </important>
        pub fn savings_opportunity(mut self, input: crate::model::SavingsOpportunity) -> Self {
            self.savings_opportunity = Some(input);
            self
        }
        /// <p>Describes the savings opportunity for recommendations of a given resource type or for the recommendation option of an individual resource.</p> 
        /// <p>Savings opportunity represents the estimated monthly savings you can achieve by implementing a given Compute Optimizer recommendation.</p> <important> 
        /// <p>Savings opportunity data requires that you opt in to Cost Explorer, as well as activate <b>Receive Amazon EC2 resource recommendations</b> in the Cost Explorer preferences page. That creates a connection between Cost Explorer and Compute Optimizer. With this connection, Cost Explorer generates savings estimates considering the price of existing resources, the price of recommended resources, and historical usage data. Estimated monthly savings reflects the projected dollar savings associated with each of the recommendations generated. For more information, see <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-enable.html">Enabling Cost Explorer</a> and <a href="https://docs.aws.amazon.com/cost-management/latest/userguide/ce-rightsizing.html">Optimizing your cost with Rightsizing Recommendations</a> in the <i>Cost Management User Guide</i>.</p> 
        /// </important>
        pub fn set_savings_opportunity(mut self, input: std::option::Option<crate::model::SavingsOpportunity>) -> Self {
            self.savings_opportunity = input; self
        }
        /// Appends an item to `projected_utilization_metrics`.
        ///
        /// To override the contents of this collection use [`set_projected_utilization_metrics`](Self::set_projected_utilization_metrics).
        ///
        /// <p> An array of objects that describe the projected utilization metrics of the ECS service recommendation option. </p>
        pub fn projected_utilization_metrics(mut self, input: crate::model::EcsServiceProjectedUtilizationMetric) -> Self {
            let mut v = self.projected_utilization_metrics.unwrap_or_default();
                            v.push(input);
                            self.projected_utilization_metrics = Some(v);
                            self
        }
        /// <p> An array of objects that describe the projected utilization metrics of the ECS service recommendation option. </p>
        pub fn set_projected_utilization_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::EcsServiceProjectedUtilizationMetric>>) -> Self {
            self.projected_utilization_metrics = input; self
        }
        /// Appends an item to `container_recommendations`.
        ///
        /// To override the contents of this collection use [`set_container_recommendations`](Self::set_container_recommendations).
        ///
        /// <p> The CPU and memory size recommendations for the containers within the task of your ECS service. </p>
        pub fn container_recommendations(mut self, input: crate::model::ContainerRecommendation) -> Self {
            let mut v = self.container_recommendations.unwrap_or_default();
                            v.push(input);
                            self.container_recommendations = Some(v);
                            self
        }
        /// <p> The CPU and memory size recommendations for the containers within the task of your ECS service. </p>
        pub fn set_container_recommendations(mut self, input: std::option::Option<std::vec::Vec<crate::model::ContainerRecommendation>>) -> Self {
            self.container_recommendations = input; self
        }
        /// Consumes the builder and constructs a [`EcsServiceRecommendationOption`](crate::model::EcsServiceRecommendationOption).
        pub fn build(self) -> crate::model::EcsServiceRecommendationOption {
            crate::model::EcsServiceRecommendationOption {
                memory: self.memory
                ,
                cpu: self.cpu
                ,
                savings_opportunity: self.savings_opportunity
                ,
                projected_utilization_metrics: self.projected_utilization_metrics
                ,
                container_recommendations: self.container_recommendations
                ,
            }
        }
    }
    
    
}
impl EcsServiceRecommendationOption {
    /// Creates a new builder-style object to manufacture [`EcsServiceRecommendationOption`](crate::model::EcsServiceRecommendationOption).
    pub fn builder() -> crate::model::ecs_service_recommendation_option::Builder {
        crate::model::ecs_service_recommendation_option::Builder::default()
    }
}

/// <p> The CPU and memory recommendations for a container within the tasks of your Amazon ECS service. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContainerRecommendation  {
    /// <p> The name of the container. </p>
    #[doc(hidden)]
    pub container_name: std::option::Option<std::string::String>,
    /// <p> The recommended memory size configurations for the container. </p>
    #[doc(hidden)]
    pub memory_size_configuration: std::option::Option<crate::model::MemorySizeConfiguration>,
    /// <p> The recommended number of CPU units reserved for the container. </p>
    #[doc(hidden)]
    pub cpu: std::option::Option<i32>,
}
impl ContainerRecommendation {
    /// <p> The name of the container. </p>
    pub fn container_name(&self) -> std::option::Option<& str> {
        self.container_name.as_deref()
    }
    /// <p> The recommended memory size configurations for the container. </p>
    pub fn memory_size_configuration(&self) -> std::option::Option<& crate::model::MemorySizeConfiguration> {
        self.memory_size_configuration.as_ref()
    }
    /// <p> The recommended number of CPU units reserved for the container. </p>
    pub fn cpu(&self) -> std::option::Option<i32> {
        self.cpu
    }
}
/// See [`ContainerRecommendation`](crate::model::ContainerRecommendation).
pub mod container_recommendation {
    
    /// A builder for [`ContainerRecommendation`](crate::model::ContainerRecommendation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_name: std::option::Option<std::string::String>,
        pub(crate) memory_size_configuration: std::option::Option<crate::model::MemorySizeConfiguration>,
        pub(crate) cpu: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The name of the container. </p>
        pub fn container_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_name = Some(input.into());
            self
        }
        /// <p> The name of the container. </p>
        pub fn set_container_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.container_name = input; self
        }
        /// <p> The recommended memory size configurations for the container. </p>
        pub fn memory_size_configuration(mut self, input: crate::model::MemorySizeConfiguration) -> Self {
            self.memory_size_configuration = Some(input);
            self
        }
        /// <p> The recommended memory size configurations for the container. </p>
        pub fn set_memory_size_configuration(mut self, input: std::option::Option<crate::model::MemorySizeConfiguration>) -> Self {
            self.memory_size_configuration = input; self
        }
        /// <p> The recommended number of CPU units reserved for the container. </p>
        pub fn cpu(mut self, input: i32) -> Self {
            self.cpu = Some(input);
            self
        }
        /// <p> The recommended number of CPU units reserved for the container. </p>
        pub fn set_cpu(mut self, input: std::option::Option<i32>) -> Self {
            self.cpu = input; self
        }
        /// Consumes the builder and constructs a [`ContainerRecommendation`](crate::model::ContainerRecommendation).
        pub fn build(self) -> crate::model::ContainerRecommendation {
            crate::model::ContainerRecommendation {
                container_name: self.container_name
                ,
                memory_size_configuration: self.memory_size_configuration
                ,
                cpu: self.cpu
                ,
            }
        }
    }
    
    
}
impl ContainerRecommendation {
    /// Creates a new builder-style object to manufacture [`ContainerRecommendation`](crate::model::ContainerRecommendation).
    pub fn builder() -> crate::model::container_recommendation::Builder {
        crate::model::container_recommendation::Builder::default()
    }
}

/// <p> The memory size configurations of a container. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MemorySizeConfiguration  {
    /// <p> The amount of memory in the container. </p>
    #[doc(hidden)]
    pub memory: std::option::Option<i32>,
    /// <p> The limit of memory reserve for the container. </p>
    #[doc(hidden)]
    pub memory_reservation: std::option::Option<i32>,
}
impl MemorySizeConfiguration {
    /// <p> The amount of memory in the container. </p>
    pub fn memory(&self) -> std::option::Option<i32> {
        self.memory
    }
    /// <p> The limit of memory reserve for the container. </p>
    pub fn memory_reservation(&self) -> std::option::Option<i32> {
        self.memory_reservation
    }
}
/// See [`MemorySizeConfiguration`](crate::model::MemorySizeConfiguration).
pub mod memory_size_configuration {
    
    /// A builder for [`MemorySizeConfiguration`](crate::model::MemorySizeConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) memory: std::option::Option<i32>,
        pub(crate) memory_reservation: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The amount of memory in the container. </p>
        pub fn memory(mut self, input: i32) -> Self {
            self.memory = Some(input);
            self
        }
        /// <p> The amount of memory in the container. </p>
        pub fn set_memory(mut self, input: std::option::Option<i32>) -> Self {
            self.memory = input; self
        }
        /// <p> The limit of memory reserve for the container. </p>
        pub fn memory_reservation(mut self, input: i32) -> Self {
            self.memory_reservation = Some(input);
            self
        }
        /// <p> The limit of memory reserve for the container. </p>
        pub fn set_memory_reservation(mut self, input: std::option::Option<i32>) -> Self {
            self.memory_reservation = input; self
        }
        /// Consumes the builder and constructs a [`MemorySizeConfiguration`](crate::model::MemorySizeConfiguration).
        pub fn build(self) -> crate::model::MemorySizeConfiguration {
            crate::model::MemorySizeConfiguration {
                memory: self.memory
                ,
                memory_reservation: self.memory_reservation
                ,
            }
        }
    }
    
    
}
impl MemorySizeConfiguration {
    /// Creates a new builder-style object to manufacture [`MemorySizeConfiguration`](crate::model::MemorySizeConfiguration).
    pub fn builder() -> crate::model::memory_size_configuration::Builder {
        crate::model::memory_size_configuration::Builder::default()
    }
}

/// <p> Describes the projected utilization metrics of an Amazon ECS service recommendation option. </p> 
/// <p>To determine the performance difference between your current ECS service and the recommended option, compare the utilization metric data of your service against its projected utilization metric data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsServiceProjectedUtilizationMetric  {
    /// <p> The name of the projected utilization metric. </p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>CPU</code>  The percentage of allocated compute units that are currently in use on the ECS service tasks.</p> </li> 
    /// <li> <p> <code>Memory</code>  The percentage of memory that is currently in use on the ECS service tasks.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::EcsServiceMetricName>,
    /// <p>The statistic of the projected utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    #[doc(hidden)]
    pub statistic: std::option::Option<crate::model::EcsServiceMetricStatistic>,
    /// <p> The lower bound values for the projected utilization metrics. </p>
    #[doc(hidden)]
    pub lower_bound_value: f64,
    /// <p> The upper bound values for the projected utilization metrics. </p>
    #[doc(hidden)]
    pub upper_bound_value: f64,
}
impl EcsServiceProjectedUtilizationMetric {
    /// <p> The name of the projected utilization metric. </p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>CPU</code>  The percentage of allocated compute units that are currently in use on the ECS service tasks.</p> </li> 
    /// <li> <p> <code>Memory</code>  The percentage of memory that is currently in use on the ECS service tasks.</p> </li> 
    /// </ul>
    pub fn name(&self) -> std::option::Option<& crate::model::EcsServiceMetricName> {
        self.name.as_ref()
    }
    /// <p>The statistic of the projected utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    pub fn statistic(&self) -> std::option::Option<& crate::model::EcsServiceMetricStatistic> {
        self.statistic.as_ref()
    }
    /// <p> The lower bound values for the projected utilization metrics. </p>
    pub fn lower_bound_value(&self) -> f64 {
        self.lower_bound_value
    }
    /// <p> The upper bound values for the projected utilization metrics. </p>
    pub fn upper_bound_value(&self) -> f64 {
        self.upper_bound_value
    }
}
/// See [`EcsServiceProjectedUtilizationMetric`](crate::model::EcsServiceProjectedUtilizationMetric).
pub mod ecs_service_projected_utilization_metric {
    
    /// A builder for [`EcsServiceProjectedUtilizationMetric`](crate::model::EcsServiceProjectedUtilizationMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::EcsServiceMetricName>,
        pub(crate) statistic: std::option::Option<crate::model::EcsServiceMetricStatistic>,
        pub(crate) lower_bound_value: std::option::Option<f64>,
        pub(crate) upper_bound_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> The name of the projected utilization metric. </p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>CPU</code>  The percentage of allocated compute units that are currently in use on the ECS service tasks.</p> </li> 
        /// <li> <p> <code>Memory</code>  The percentage of memory that is currently in use on the ECS service tasks.</p> </li> 
        /// </ul>
        pub fn name(mut self, input: crate::model::EcsServiceMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p> The name of the projected utilization metric. </p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>CPU</code>  The percentage of allocated compute units that are currently in use on the ECS service tasks.</p> </li> 
        /// <li> <p> <code>Memory</code>  The percentage of memory that is currently in use on the ECS service tasks.</p> </li> 
        /// </ul>
        pub fn set_name(mut self, input: std::option::Option<crate::model::EcsServiceMetricName>) -> Self {
            self.name = input; self
        }
        /// <p>The statistic of the projected utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn statistic(mut self, input: crate::model::EcsServiceMetricStatistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic of the projected utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn set_statistic(mut self, input: std::option::Option<crate::model::EcsServiceMetricStatistic>) -> Self {
            self.statistic = input; self
        }
        /// <p> The lower bound values for the projected utilization metrics. </p>
        pub fn lower_bound_value(mut self, input: f64) -> Self {
            self.lower_bound_value = Some(input);
            self
        }
        /// <p> The lower bound values for the projected utilization metrics. </p>
        pub fn set_lower_bound_value(mut self, input: std::option::Option<f64>) -> Self {
            self.lower_bound_value = input; self
        }
        /// <p> The upper bound values for the projected utilization metrics. </p>
        pub fn upper_bound_value(mut self, input: f64) -> Self {
            self.upper_bound_value = Some(input);
            self
        }
        /// <p> The upper bound values for the projected utilization metrics. </p>
        pub fn set_upper_bound_value(mut self, input: std::option::Option<f64>) -> Self {
            self.upper_bound_value = input; self
        }
        /// Consumes the builder and constructs a [`EcsServiceProjectedUtilizationMetric`](crate::model::EcsServiceProjectedUtilizationMetric).
        pub fn build(self) -> crate::model::EcsServiceProjectedUtilizationMetric {
            crate::model::EcsServiceProjectedUtilizationMetric {
                name: self.name
                ,
                statistic: self.statistic
                ,
                lower_bound_value: self.lower_bound_value
                    .unwrap_or_default()
                ,
                upper_bound_value: self.upper_bound_value
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl EcsServiceProjectedUtilizationMetric {
    /// Creates a new builder-style object to manufacture [`EcsServiceProjectedUtilizationMetric`](crate::model::EcsServiceProjectedUtilizationMetric).
    pub fn builder() -> crate::model::ecs_service_projected_utilization_metric::Builder {
        crate::model::ecs_service_projected_utilization_metric::Builder::default()
    }
}

/// When writing a match expression against `EcsServiceMetricStatistic`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let ecsservicemetricstatistic = unimplemented!();
/// match ecsservicemetricstatistic {
///     EcsServiceMetricStatistic::Average => { /* ... */ },
///     EcsServiceMetricStatistic::Maximum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ecsservicemetricstatistic` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EcsServiceMetricStatistic::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EcsServiceMetricStatistic::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EcsServiceMetricStatistic::NewFeature` is defined.
/// Specifically, when `ecsservicemetricstatistic` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EcsServiceMetricStatistic::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EcsServiceMetricStatistic {
    #[allow(missing_docs)] // documentation missing in model
    Average,
    #[allow(missing_docs)] // documentation missing in model
    Maximum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EcsServiceMetricStatistic {
    fn from(s: &str) -> Self {
        match s {
            "Average" => EcsServiceMetricStatistic::Average,
            "Maximum" => EcsServiceMetricStatistic::Maximum,
            other => EcsServiceMetricStatistic::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EcsServiceMetricStatistic {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EcsServiceMetricStatistic::from(s))
                }
            }
impl EcsServiceMetricStatistic {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EcsServiceMetricStatistic::Average => "Average",
            EcsServiceMetricStatistic::Maximum => "Maximum",
            EcsServiceMetricStatistic::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Average", "Maximum"
        ]
    }
}
impl AsRef<str> for EcsServiceMetricStatistic {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EcsServiceMetricName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let ecsservicemetricname = unimplemented!();
/// match ecsservicemetricname {
///     EcsServiceMetricName::Cpu => { /* ... */ },
///     EcsServiceMetricName::Memory => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ecsservicemetricname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EcsServiceMetricName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EcsServiceMetricName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EcsServiceMetricName::NewFeature` is defined.
/// Specifically, when `ecsservicemetricname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EcsServiceMetricName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EcsServiceMetricName {
    #[allow(missing_docs)] // documentation missing in model
    Cpu,
    #[allow(missing_docs)] // documentation missing in model
    Memory,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EcsServiceMetricName {
    fn from(s: &str) -> Self {
        match s {
            "Cpu" => EcsServiceMetricName::Cpu,
            "Memory" => EcsServiceMetricName::Memory,
            other => EcsServiceMetricName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EcsServiceMetricName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EcsServiceMetricName::from(s))
                }
            }
impl EcsServiceMetricName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EcsServiceMetricName::Cpu => "Cpu",
            EcsServiceMetricName::Memory => "Memory",
            EcsServiceMetricName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Cpu", "Memory"
        ]
    }
}
impl AsRef<str> for EcsServiceMetricName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EcsServiceRecommendationFindingReasonCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let ecsservicerecommendationfindingreasoncode = unimplemented!();
/// match ecsservicerecommendationfindingreasoncode {
///     EcsServiceRecommendationFindingReasonCode::CpuOverProvisioned => { /* ... */ },
///     EcsServiceRecommendationFindingReasonCode::CpuUnderProvisioned => { /* ... */ },
///     EcsServiceRecommendationFindingReasonCode::MemoryOverProvisioned => { /* ... */ },
///     EcsServiceRecommendationFindingReasonCode::MemoryUnderProvisioned => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ecsservicerecommendationfindingreasoncode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EcsServiceRecommendationFindingReasonCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EcsServiceRecommendationFindingReasonCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EcsServiceRecommendationFindingReasonCode::NewFeature` is defined.
/// Specifically, when `ecsservicerecommendationfindingreasoncode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EcsServiceRecommendationFindingReasonCode::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EcsServiceRecommendationFindingReasonCode {
    #[allow(missing_docs)] // documentation missing in model
    CpuOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    CpuUnderProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    MemoryOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    MemoryUnderProvisioned,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EcsServiceRecommendationFindingReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "CPUOverprovisioned" => EcsServiceRecommendationFindingReasonCode::CpuOverProvisioned,
            "CPUUnderprovisioned" => EcsServiceRecommendationFindingReasonCode::CpuUnderProvisioned,
            "MemoryOverprovisioned" => EcsServiceRecommendationFindingReasonCode::MemoryOverProvisioned,
            "MemoryUnderprovisioned" => EcsServiceRecommendationFindingReasonCode::MemoryUnderProvisioned,
            other => EcsServiceRecommendationFindingReasonCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EcsServiceRecommendationFindingReasonCode {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EcsServiceRecommendationFindingReasonCode::from(s))
                }
            }
impl EcsServiceRecommendationFindingReasonCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EcsServiceRecommendationFindingReasonCode::CpuOverProvisioned => "CPUOverprovisioned",
            EcsServiceRecommendationFindingReasonCode::CpuUnderProvisioned => "CPUUnderprovisioned",
            EcsServiceRecommendationFindingReasonCode::MemoryOverProvisioned => "MemoryOverprovisioned",
            EcsServiceRecommendationFindingReasonCode::MemoryUnderProvisioned => "MemoryUnderprovisioned",
            EcsServiceRecommendationFindingReasonCode::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CPUOverprovisioned", "CPUUnderprovisioned", "MemoryOverprovisioned", "MemoryUnderprovisioned"
        ]
    }
}
impl AsRef<str> for EcsServiceRecommendationFindingReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EcsServiceRecommendationFinding`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let ecsservicerecommendationfinding = unimplemented!();
/// match ecsservicerecommendationfinding {
///     EcsServiceRecommendationFinding::Optimized => { /* ... */ },
///     EcsServiceRecommendationFinding::OverProvisioned => { /* ... */ },
///     EcsServiceRecommendationFinding::UnderProvisioned => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ecsservicerecommendationfinding` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EcsServiceRecommendationFinding::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EcsServiceRecommendationFinding::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EcsServiceRecommendationFinding::NewFeature` is defined.
/// Specifically, when `ecsservicerecommendationfinding` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EcsServiceRecommendationFinding::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EcsServiceRecommendationFinding {
    #[allow(missing_docs)] // documentation missing in model
    Optimized,
    #[allow(missing_docs)] // documentation missing in model
    OverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    UnderProvisioned,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EcsServiceRecommendationFinding {
    fn from(s: &str) -> Self {
        match s {
            "Optimized" => EcsServiceRecommendationFinding::Optimized,
            "Overprovisioned" => EcsServiceRecommendationFinding::OverProvisioned,
            "Underprovisioned" => EcsServiceRecommendationFinding::UnderProvisioned,
            other => EcsServiceRecommendationFinding::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EcsServiceRecommendationFinding {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EcsServiceRecommendationFinding::from(s))
                }
            }
impl EcsServiceRecommendationFinding {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EcsServiceRecommendationFinding::Optimized => "Optimized",
            EcsServiceRecommendationFinding::OverProvisioned => "Overprovisioned",
            EcsServiceRecommendationFinding::UnderProvisioned => "Underprovisioned",
            EcsServiceRecommendationFinding::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Optimized", "Overprovisioned", "Underprovisioned"
        ]
    }
}
impl AsRef<str> for EcsServiceRecommendationFinding {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EcsServiceLaunchType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let ecsservicelaunchtype = unimplemented!();
/// match ecsservicelaunchtype {
///     EcsServiceLaunchType::Ec2 => { /* ... */ },
///     EcsServiceLaunchType::Fargate => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ecsservicelaunchtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EcsServiceLaunchType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EcsServiceLaunchType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EcsServiceLaunchType::NewFeature` is defined.
/// Specifically, when `ecsservicelaunchtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EcsServiceLaunchType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EcsServiceLaunchType {
    #[allow(missing_docs)] // documentation missing in model
    Ec2,
    #[allow(missing_docs)] // documentation missing in model
    Fargate,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EcsServiceLaunchType {
    fn from(s: &str) -> Self {
        match s {
            "EC2" => EcsServiceLaunchType::Ec2,
            "Fargate" => EcsServiceLaunchType::Fargate,
            other => EcsServiceLaunchType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EcsServiceLaunchType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EcsServiceLaunchType::from(s))
                }
            }
impl EcsServiceLaunchType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EcsServiceLaunchType::Ec2 => "EC2",
            EcsServiceLaunchType::Fargate => "Fargate",
            EcsServiceLaunchType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "EC2", "Fargate"
        ]
    }
}
impl AsRef<str> for EcsServiceLaunchType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Describes the utilization metric of an Amazon ECS service. </p> 
/// <p>To determine the performance difference between your current ECS service and the recommended option, compare the utilization metric data of your service against its projected utilization metric data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsServiceUtilizationMetric  {
    /// <p> The name of the utilization metric. </p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>Cpu</code>  The amount of CPU units that are used in the service.</p> </li> 
    /// <li> <p> <code>Memory</code>  The amount of memory that is used in the service.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::EcsServiceMetricName>,
    /// <p>The statistic of the utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    #[doc(hidden)]
    pub statistic: std::option::Option<crate::model::EcsServiceMetricStatistic>,
    /// <p> The value of the utilization metric. </p>
    #[doc(hidden)]
    pub value: f64,
}
impl EcsServiceUtilizationMetric {
    /// <p> The name of the utilization metric. </p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>Cpu</code>  The amount of CPU units that are used in the service.</p> </li> 
    /// <li> <p> <code>Memory</code>  The amount of memory that is used in the service.</p> </li> 
    /// </ul>
    pub fn name(&self) -> std::option::Option<& crate::model::EcsServiceMetricName> {
        self.name.as_ref()
    }
    /// <p>The statistic of the utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    pub fn statistic(&self) -> std::option::Option<& crate::model::EcsServiceMetricStatistic> {
        self.statistic.as_ref()
    }
    /// <p> The value of the utilization metric. </p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`EcsServiceUtilizationMetric`](crate::model::EcsServiceUtilizationMetric).
pub mod ecs_service_utilization_metric {
    
    /// A builder for [`EcsServiceUtilizationMetric`](crate::model::EcsServiceUtilizationMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::EcsServiceMetricName>,
        pub(crate) statistic: std::option::Option<crate::model::EcsServiceMetricStatistic>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p> The name of the utilization metric. </p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>Cpu</code>  The amount of CPU units that are used in the service.</p> </li> 
        /// <li> <p> <code>Memory</code>  The amount of memory that is used in the service.</p> </li> 
        /// </ul>
        pub fn name(mut self, input: crate::model::EcsServiceMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p> The name of the utilization metric. </p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>Cpu</code>  The amount of CPU units that are used in the service.</p> </li> 
        /// <li> <p> <code>Memory</code>  The amount of memory that is used in the service.</p> </li> 
        /// </ul>
        pub fn set_name(mut self, input: std::option::Option<crate::model::EcsServiceMetricName>) -> Self {
            self.name = input; self
        }
        /// <p>The statistic of the utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn statistic(mut self, input: crate::model::EcsServiceMetricStatistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic of the utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn set_statistic(mut self, input: std::option::Option<crate::model::EcsServiceMetricStatistic>) -> Self {
            self.statistic = input; self
        }
        /// <p> The value of the utilization metric. </p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p> The value of the utilization metric. </p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`EcsServiceUtilizationMetric`](crate::model::EcsServiceUtilizationMetric).
        pub fn build(self) -> crate::model::EcsServiceUtilizationMetric {
            crate::model::EcsServiceUtilizationMetric {
                name: self.name
                ,
                statistic: self.statistic
                ,
                value: self.value
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl EcsServiceUtilizationMetric {
    /// Creates a new builder-style object to manufacture [`EcsServiceUtilizationMetric`](crate::model::EcsServiceUtilizationMetric).
    pub fn builder() -> crate::model::ecs_service_utilization_metric::Builder {
        crate::model::ecs_service_utilization_metric::Builder::default()
    }
}

/// <p> The Amazon ECS service configurations used for recommendations. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceConfiguration  {
    /// <p> The amount of memory used by the tasks in the ECS service. </p>
    #[doc(hidden)]
    pub memory: std::option::Option<i32>,
    /// <p> The number of CPU units used by the tasks in the ECS service. </p>
    #[doc(hidden)]
    pub cpu: std::option::Option<i32>,
    /// <p> The container configurations within a task of an ECS service. </p>
    #[doc(hidden)]
    pub container_configurations: std::option::Option<std::vec::Vec<crate::model::ContainerConfiguration>>,
    /// <p> Describes the Auto Scaling configuration methods for an Amazon ECS service. This affects the generated recommendations. For example, if Auto Scaling is configured on a ECS services CPU, then Compute Optimizer doesnt generate CPU size recommendations. </p> 
    /// <p>The Auto Scaling configuration methods include:</p> 
    /// <ul> 
    /// <li> <p> <code>TARGET_TRACKING_SCALING_CPU</code>  If the ECS service is configured to use target scaling on CPU, Compute Optimizer doesn't generate CPU recommendations.</p> </li> 
    /// <li> <p> <code>TARGET_TRACKING_SCALING_MEMORY</code>  If the ECS service is configured to use target scaling on memory, Compute Optimizer doesn't generate memory recommendations.</p> </li> 
    /// </ul> 
    /// <p>For more information about step scaling and target scaling, see <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-step-scaling-policies.html"> Step scaling policies for Application Auto Scaling</a> and <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-target-tracking.html"> Target tracking scaling policies for Application Auto Scaling</a> in the <i>Application Auto Scaling User Guide</i>.</p>
    #[doc(hidden)]
    pub auto_scaling_configuration: std::option::Option<crate::model::AutoScalingConfiguration>,
    /// <p> The task definition ARN used by the tasks in the ECS service. </p>
    #[doc(hidden)]
    pub task_definition_arn: std::option::Option<std::string::String>,
}
impl ServiceConfiguration {
    /// <p> The amount of memory used by the tasks in the ECS service. </p>
    pub fn memory(&self) -> std::option::Option<i32> {
        self.memory
    }
    /// <p> The number of CPU units used by the tasks in the ECS service. </p>
    pub fn cpu(&self) -> std::option::Option<i32> {
        self.cpu
    }
    /// <p> The container configurations within a task of an ECS service. </p>
    pub fn container_configurations(&self) -> std::option::Option<& [crate::model::ContainerConfiguration]> {
        self.container_configurations.as_deref()
    }
    /// <p> Describes the Auto Scaling configuration methods for an Amazon ECS service. This affects the generated recommendations. For example, if Auto Scaling is configured on a ECS services CPU, then Compute Optimizer doesnt generate CPU size recommendations. </p> 
    /// <p>The Auto Scaling configuration methods include:</p> 
    /// <ul> 
    /// <li> <p> <code>TARGET_TRACKING_SCALING_CPU</code>  If the ECS service is configured to use target scaling on CPU, Compute Optimizer doesn't generate CPU recommendations.</p> </li> 
    /// <li> <p> <code>TARGET_TRACKING_SCALING_MEMORY</code>  If the ECS service is configured to use target scaling on memory, Compute Optimizer doesn't generate memory recommendations.</p> </li> 
    /// </ul> 
    /// <p>For more information about step scaling and target scaling, see <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-step-scaling-policies.html"> Step scaling policies for Application Auto Scaling</a> and <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-target-tracking.html"> Target tracking scaling policies for Application Auto Scaling</a> in the <i>Application Auto Scaling User Guide</i>.</p>
    pub fn auto_scaling_configuration(&self) -> std::option::Option<& crate::model::AutoScalingConfiguration> {
        self.auto_scaling_configuration.as_ref()
    }
    /// <p> The task definition ARN used by the tasks in the ECS service. </p>
    pub fn task_definition_arn(&self) -> std::option::Option<& str> {
        self.task_definition_arn.as_deref()
    }
}
/// See [`ServiceConfiguration`](crate::model::ServiceConfiguration).
pub mod service_configuration {
    
    /// A builder for [`ServiceConfiguration`](crate::model::ServiceConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) memory: std::option::Option<i32>,
        pub(crate) cpu: std::option::Option<i32>,
        pub(crate) container_configurations: std::option::Option<std::vec::Vec<crate::model::ContainerConfiguration>>,
        pub(crate) auto_scaling_configuration: std::option::Option<crate::model::AutoScalingConfiguration>,
        pub(crate) task_definition_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The amount of memory used by the tasks in the ECS service. </p>
        pub fn memory(mut self, input: i32) -> Self {
            self.memory = Some(input);
            self
        }
        /// <p> The amount of memory used by the tasks in the ECS service. </p>
        pub fn set_memory(mut self, input: std::option::Option<i32>) -> Self {
            self.memory = input; self
        }
        /// <p> The number of CPU units used by the tasks in the ECS service. </p>
        pub fn cpu(mut self, input: i32) -> Self {
            self.cpu = Some(input);
            self
        }
        /// <p> The number of CPU units used by the tasks in the ECS service. </p>
        pub fn set_cpu(mut self, input: std::option::Option<i32>) -> Self {
            self.cpu = input; self
        }
        /// Appends an item to `container_configurations`.
        ///
        /// To override the contents of this collection use [`set_container_configurations`](Self::set_container_configurations).
        ///
        /// <p> The container configurations within a task of an ECS service. </p>
        pub fn container_configurations(mut self, input: crate::model::ContainerConfiguration) -> Self {
            let mut v = self.container_configurations.unwrap_or_default();
                            v.push(input);
                            self.container_configurations = Some(v);
                            self
        }
        /// <p> The container configurations within a task of an ECS service. </p>
        pub fn set_container_configurations(mut self, input: std::option::Option<std::vec::Vec<crate::model::ContainerConfiguration>>) -> Self {
            self.container_configurations = input; self
        }
        /// <p> Describes the Auto Scaling configuration methods for an Amazon ECS service. This affects the generated recommendations. For example, if Auto Scaling is configured on a ECS services CPU, then Compute Optimizer doesnt generate CPU size recommendations. </p> 
        /// <p>The Auto Scaling configuration methods include:</p> 
        /// <ul> 
        /// <li> <p> <code>TARGET_TRACKING_SCALING_CPU</code>  If the ECS service is configured to use target scaling on CPU, Compute Optimizer doesn't generate CPU recommendations.</p> </li> 
        /// <li> <p> <code>TARGET_TRACKING_SCALING_MEMORY</code>  If the ECS service is configured to use target scaling on memory, Compute Optimizer doesn't generate memory recommendations.</p> </li> 
        /// </ul> 
        /// <p>For more information about step scaling and target scaling, see <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-step-scaling-policies.html"> Step scaling policies for Application Auto Scaling</a> and <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-target-tracking.html"> Target tracking scaling policies for Application Auto Scaling</a> in the <i>Application Auto Scaling User Guide</i>.</p>
        pub fn auto_scaling_configuration(mut self, input: crate::model::AutoScalingConfiguration) -> Self {
            self.auto_scaling_configuration = Some(input);
            self
        }
        /// <p> Describes the Auto Scaling configuration methods for an Amazon ECS service. This affects the generated recommendations. For example, if Auto Scaling is configured on a ECS services CPU, then Compute Optimizer doesnt generate CPU size recommendations. </p> 
        /// <p>The Auto Scaling configuration methods include:</p> 
        /// <ul> 
        /// <li> <p> <code>TARGET_TRACKING_SCALING_CPU</code>  If the ECS service is configured to use target scaling on CPU, Compute Optimizer doesn't generate CPU recommendations.</p> </li> 
        /// <li> <p> <code>TARGET_TRACKING_SCALING_MEMORY</code>  If the ECS service is configured to use target scaling on memory, Compute Optimizer doesn't generate memory recommendations.</p> </li> 
        /// </ul> 
        /// <p>For more information about step scaling and target scaling, see <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-step-scaling-policies.html"> Step scaling policies for Application Auto Scaling</a> and <a href="https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-target-tracking.html"> Target tracking scaling policies for Application Auto Scaling</a> in the <i>Application Auto Scaling User Guide</i>.</p>
        pub fn set_auto_scaling_configuration(mut self, input: std::option::Option<crate::model::AutoScalingConfiguration>) -> Self {
            self.auto_scaling_configuration = input; self
        }
        /// <p> The task definition ARN used by the tasks in the ECS service. </p>
        pub fn task_definition_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_definition_arn = Some(input.into());
            self
        }
        /// <p> The task definition ARN used by the tasks in the ECS service. </p>
        pub fn set_task_definition_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_definition_arn = input; self
        }
        /// Consumes the builder and constructs a [`ServiceConfiguration`](crate::model::ServiceConfiguration).
        pub fn build(self) -> crate::model::ServiceConfiguration {
            crate::model::ServiceConfiguration {
                memory: self.memory
                ,
                cpu: self.cpu
                ,
                container_configurations: self.container_configurations
                ,
                auto_scaling_configuration: self.auto_scaling_configuration
                ,
                task_definition_arn: self.task_definition_arn
                ,
            }
        }
    }
    
    
}
impl ServiceConfiguration {
    /// Creates a new builder-style object to manufacture [`ServiceConfiguration`](crate::model::ServiceConfiguration).
    pub fn builder() -> crate::model::service_configuration::Builder {
        crate::model::service_configuration::Builder::default()
    }
}

/// When writing a match expression against `AutoScalingConfiguration`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let autoscalingconfiguration = unimplemented!();
/// match autoscalingconfiguration {
///     AutoScalingConfiguration::TargetTrackingScalingCpu => { /* ... */ },
///     AutoScalingConfiguration::TargetTrackingScalingMemory => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `autoscalingconfiguration` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AutoScalingConfiguration::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AutoScalingConfiguration::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AutoScalingConfiguration::NewFeature` is defined.
/// Specifically, when `autoscalingconfiguration` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AutoScalingConfiguration::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum AutoScalingConfiguration {
    #[allow(missing_docs)] // documentation missing in model
    TargetTrackingScalingCpu,
    #[allow(missing_docs)] // documentation missing in model
    TargetTrackingScalingMemory,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for AutoScalingConfiguration {
    fn from(s: &str) -> Self {
        match s {
            "TargetTrackingScalingCpu" => AutoScalingConfiguration::TargetTrackingScalingCpu,
            "TargetTrackingScalingMemory" => AutoScalingConfiguration::TargetTrackingScalingMemory,
            other => AutoScalingConfiguration::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for AutoScalingConfiguration {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(AutoScalingConfiguration::from(s))
                }
            }
impl AutoScalingConfiguration {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutoScalingConfiguration::TargetTrackingScalingCpu => "TargetTrackingScalingCpu",
            AutoScalingConfiguration::TargetTrackingScalingMemory => "TargetTrackingScalingMemory",
            AutoScalingConfiguration::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "TargetTrackingScalingCpu", "TargetTrackingScalingMemory"
        ]
    }
}
impl AsRef<str> for AutoScalingConfiguration {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Describes the container configurations within the tasks of your Amazon ECS service. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContainerConfiguration  {
    /// <p> The name of the container. </p>
    #[doc(hidden)]
    pub container_name: std::option::Option<std::string::String>,
    /// <p> The memory size configurations for the container. </p>
    #[doc(hidden)]
    pub memory_size_configuration: std::option::Option<crate::model::MemorySizeConfiguration>,
    /// <p> The number of CPU units reserved for the container. </p>
    #[doc(hidden)]
    pub cpu: std::option::Option<i32>,
}
impl ContainerConfiguration {
    /// <p> The name of the container. </p>
    pub fn container_name(&self) -> std::option::Option<& str> {
        self.container_name.as_deref()
    }
    /// <p> The memory size configurations for the container. </p>
    pub fn memory_size_configuration(&self) -> std::option::Option<& crate::model::MemorySizeConfiguration> {
        self.memory_size_configuration.as_ref()
    }
    /// <p> The number of CPU units reserved for the container. </p>
    pub fn cpu(&self) -> std::option::Option<i32> {
        self.cpu
    }
}
/// See [`ContainerConfiguration`](crate::model::ContainerConfiguration).
pub mod container_configuration {
    
    /// A builder for [`ContainerConfiguration`](crate::model::ContainerConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) container_name: std::option::Option<std::string::String>,
        pub(crate) memory_size_configuration: std::option::Option<crate::model::MemorySizeConfiguration>,
        pub(crate) cpu: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The name of the container. </p>
        pub fn container_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_name = Some(input.into());
            self
        }
        /// <p> The name of the container. </p>
        pub fn set_container_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.container_name = input; self
        }
        /// <p> The memory size configurations for the container. </p>
        pub fn memory_size_configuration(mut self, input: crate::model::MemorySizeConfiguration) -> Self {
            self.memory_size_configuration = Some(input);
            self
        }
        /// <p> The memory size configurations for the container. </p>
        pub fn set_memory_size_configuration(mut self, input: std::option::Option<crate::model::MemorySizeConfiguration>) -> Self {
            self.memory_size_configuration = input; self
        }
        /// <p> The number of CPU units reserved for the container. </p>
        pub fn cpu(mut self, input: i32) -> Self {
            self.cpu = Some(input);
            self
        }
        /// <p> The number of CPU units reserved for the container. </p>
        pub fn set_cpu(mut self, input: std::option::Option<i32>) -> Self {
            self.cpu = input; self
        }
        /// Consumes the builder and constructs a [`ContainerConfiguration`](crate::model::ContainerConfiguration).
        pub fn build(self) -> crate::model::ContainerConfiguration {
            crate::model::ContainerConfiguration {
                container_name: self.container_name
                ,
                memory_size_configuration: self.memory_size_configuration
                ,
                cpu: self.cpu
                ,
            }
        }
    }
    
    
}
impl ContainerConfiguration {
    /// Creates a new builder-style object to manufacture [`ContainerConfiguration`](crate::model::ContainerConfiguration).
    pub fn builder() -> crate::model::container_configuration::Builder {
        crate::model::container_configuration::Builder::default()
    }
}

/// <p> Describes a filter that returns a more specific list of Amazon ECS service recommendations. Use this filter with the <code>GetECSServiceRecommendations</code> action. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsServiceRecommendationFilter  {
    /// <p> The name of the filter. </p> 
    /// <p> Specify <code>Finding</code> to return recommendations with a specific finding classification. </p> 
    /// <p> Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code. </p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::EcsServiceRecommendationFilterName>,
    /// <p> The value of the filter. </p> 
    /// <p>The valid values for this parameter are as follows:</p> 
    /// <ul> 
    /// <li> <p>If you specify the <code>name</code> parameter as <code>Finding</code>, specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code>.</p> </li> 
    /// <li> <p>If you specify the <code>name</code> parameter as <code>FindingReasonCode</code>, specify <code>CPUUnderprovisioned</code>, <code>CPUOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, or <code>MemoryOverprovisioned</code>.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl EcsServiceRecommendationFilter {
    /// <p> The name of the filter. </p> 
    /// <p> Specify <code>Finding</code> to return recommendations with a specific finding classification. </p> 
    /// <p> Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code. </p>
    pub fn name(&self) -> std::option::Option<& crate::model::EcsServiceRecommendationFilterName> {
        self.name.as_ref()
    }
    /// <p> The value of the filter. </p> 
    /// <p>The valid values for this parameter are as follows:</p> 
    /// <ul> 
    /// <li> <p>If you specify the <code>name</code> parameter as <code>Finding</code>, specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code>.</p> </li> 
    /// <li> <p>If you specify the <code>name</code> parameter as <code>FindingReasonCode</code>, specify <code>CPUUnderprovisioned</code>, <code>CPUOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, or <code>MemoryOverprovisioned</code>.</p> </li> 
    /// </ul>
    pub fn values(&self) -> std::option::Option<& [std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`EcsServiceRecommendationFilter`](crate::model::EcsServiceRecommendationFilter).
pub mod ecs_service_recommendation_filter {
    
    /// A builder for [`EcsServiceRecommendationFilter`](crate::model::EcsServiceRecommendationFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::EcsServiceRecommendationFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The name of the filter. </p> 
        /// <p> Specify <code>Finding</code> to return recommendations with a specific finding classification. </p> 
        /// <p> Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code. </p>
        pub fn name(mut self, input: crate::model::EcsServiceRecommendationFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p> The name of the filter. </p> 
        /// <p> Specify <code>Finding</code> to return recommendations with a specific finding classification. </p> 
        /// <p> Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code. </p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::EcsServiceRecommendationFilterName>) -> Self {
            self.name = input; self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p> The value of the filter. </p> 
        /// <p>The valid values for this parameter are as follows:</p> 
        /// <ul> 
        /// <li> <p>If you specify the <code>name</code> parameter as <code>Finding</code>, specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code>.</p> </li> 
        /// <li> <p>If you specify the <code>name</code> parameter as <code>FindingReasonCode</code>, specify <code>CPUUnderprovisioned</code>, <code>CPUOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, or <code>MemoryOverprovisioned</code>.</p> </li> 
        /// </ul>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
                            v.push(input.into());
                            self.values = Some(v);
                            self
        }
        /// <p> The value of the filter. </p> 
        /// <p>The valid values for this parameter are as follows:</p> 
        /// <ul> 
        /// <li> <p>If you specify the <code>name</code> parameter as <code>Finding</code>, specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code>.</p> </li> 
        /// <li> <p>If you specify the <code>name</code> parameter as <code>FindingReasonCode</code>, specify <code>CPUUnderprovisioned</code>, <code>CPUOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, or <code>MemoryOverprovisioned</code>.</p> </li> 
        /// </ul>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`EcsServiceRecommendationFilter`](crate::model::EcsServiceRecommendationFilter).
        pub fn build(self) -> crate::model::EcsServiceRecommendationFilter {
            crate::model::EcsServiceRecommendationFilter {
                name: self.name
                ,
                values: self.values
                ,
            }
        }
    }
    
    
}
impl EcsServiceRecommendationFilter {
    /// Creates a new builder-style object to manufacture [`EcsServiceRecommendationFilter`](crate::model::EcsServiceRecommendationFilter).
    pub fn builder() -> crate::model::ecs_service_recommendation_filter::Builder {
        crate::model::ecs_service_recommendation_filter::Builder::default()
    }
}

/// When writing a match expression against `EcsServiceRecommendationFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let ecsservicerecommendationfiltername = unimplemented!();
/// match ecsservicerecommendationfiltername {
///     EcsServiceRecommendationFilterName::Finding => { /* ... */ },
///     EcsServiceRecommendationFilterName::FindingReasonCode => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ecsservicerecommendationfiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EcsServiceRecommendationFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EcsServiceRecommendationFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EcsServiceRecommendationFilterName::NewFeature` is defined.
/// Specifically, when `ecsservicerecommendationfiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EcsServiceRecommendationFilterName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EcsServiceRecommendationFilterName {
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    #[allow(missing_docs)] // documentation missing in model
    FindingReasonCode,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EcsServiceRecommendationFilterName {
    fn from(s: &str) -> Self {
        match s {
            "Finding" => EcsServiceRecommendationFilterName::Finding,
            "FindingReasonCode" => EcsServiceRecommendationFilterName::FindingReasonCode,
            other => EcsServiceRecommendationFilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EcsServiceRecommendationFilterName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EcsServiceRecommendationFilterName::from(s))
                }
            }
impl EcsServiceRecommendationFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EcsServiceRecommendationFilterName::Finding => "Finding",
            EcsServiceRecommendationFilterName::FindingReasonCode => "FindingReasonCode",
            EcsServiceRecommendationFilterName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Finding", "FindingReasonCode"
        ]
    }
}
impl AsRef<str> for EcsServiceRecommendationFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Describes the projected metrics of an Amazon ECS service recommendation option. </p> 
/// <p>To determine the performance difference between your current ECS service and the recommended option, compare the metric data of your service against its projected metric data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsServiceRecommendedOptionProjectedMetric  {
    /// <p> The recommended CPU size for the ECS service. </p>
    #[doc(hidden)]
    pub recommended_cpu_units: i32,
    /// <p> The recommended memory size for the ECS service. </p>
    #[doc(hidden)]
    pub recommended_memory_size: i32,
    /// <p> An array of objects that describe the projected metric. </p>
    #[doc(hidden)]
    pub projected_metrics: std::option::Option<std::vec::Vec<crate::model::EcsServiceProjectedMetric>>,
}
impl EcsServiceRecommendedOptionProjectedMetric {
    /// <p> The recommended CPU size for the ECS service. </p>
    pub fn recommended_cpu_units(&self) -> i32 {
        self.recommended_cpu_units
    }
    /// <p> The recommended memory size for the ECS service. </p>
    pub fn recommended_memory_size(&self) -> i32 {
        self.recommended_memory_size
    }
    /// <p> An array of objects that describe the projected metric. </p>
    pub fn projected_metrics(&self) -> std::option::Option<& [crate::model::EcsServiceProjectedMetric]> {
        self.projected_metrics.as_deref()
    }
}
/// See [`EcsServiceRecommendedOptionProjectedMetric`](crate::model::EcsServiceRecommendedOptionProjectedMetric).
pub mod ecs_service_recommended_option_projected_metric {
    
    /// A builder for [`EcsServiceRecommendedOptionProjectedMetric`](crate::model::EcsServiceRecommendedOptionProjectedMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommended_cpu_units: std::option::Option<i32>,
        pub(crate) recommended_memory_size: std::option::Option<i32>,
        pub(crate) projected_metrics: std::option::Option<std::vec::Vec<crate::model::EcsServiceProjectedMetric>>,
    }
    impl Builder {
        /// <p> The recommended CPU size for the ECS service. </p>
        pub fn recommended_cpu_units(mut self, input: i32) -> Self {
            self.recommended_cpu_units = Some(input);
            self
        }
        /// <p> The recommended CPU size for the ECS service. </p>
        pub fn set_recommended_cpu_units(mut self, input: std::option::Option<i32>) -> Self {
            self.recommended_cpu_units = input; self
        }
        /// <p> The recommended memory size for the ECS service. </p>
        pub fn recommended_memory_size(mut self, input: i32) -> Self {
            self.recommended_memory_size = Some(input);
            self
        }
        /// <p> The recommended memory size for the ECS service. </p>
        pub fn set_recommended_memory_size(mut self, input: std::option::Option<i32>) -> Self {
            self.recommended_memory_size = input; self
        }
        /// Appends an item to `projected_metrics`.
        ///
        /// To override the contents of this collection use [`set_projected_metrics`](Self::set_projected_metrics).
        ///
        /// <p> An array of objects that describe the projected metric. </p>
        pub fn projected_metrics(mut self, input: crate::model::EcsServiceProjectedMetric) -> Self {
            let mut v = self.projected_metrics.unwrap_or_default();
                            v.push(input);
                            self.projected_metrics = Some(v);
                            self
        }
        /// <p> An array of objects that describe the projected metric. </p>
        pub fn set_projected_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::EcsServiceProjectedMetric>>) -> Self {
            self.projected_metrics = input; self
        }
        /// Consumes the builder and constructs a [`EcsServiceRecommendedOptionProjectedMetric`](crate::model::EcsServiceRecommendedOptionProjectedMetric).
        pub fn build(self) -> crate::model::EcsServiceRecommendedOptionProjectedMetric {
            crate::model::EcsServiceRecommendedOptionProjectedMetric {
                recommended_cpu_units: self.recommended_cpu_units
                    .unwrap_or_default()
                ,
                recommended_memory_size: self.recommended_memory_size
                    .unwrap_or_default()
                ,
                projected_metrics: self.projected_metrics
                ,
            }
        }
    }
    
    
}
impl EcsServiceRecommendedOptionProjectedMetric {
    /// Creates a new builder-style object to manufacture [`EcsServiceRecommendedOptionProjectedMetric`](crate::model::EcsServiceRecommendedOptionProjectedMetric).
    pub fn builder() -> crate::model::ecs_service_recommended_option_projected_metric::Builder {
        crate::model::ecs_service_recommended_option_projected_metric::Builder::default()
    }
}

/// <p> Describes the projected metrics of an Amazon ECS service recommendation option. </p> 
/// <p>To determine the performance difference between your current ECS service and the recommended option, compare the metric data of your service against its projected metric data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsServiceProjectedMetric  {
    /// <p> The name of the projected metric. </p> 
    /// <p>The following metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>CPU</code>  The percentage of allocated compute units that are currently in use on the ECS service tasks.</p> </li> 
    /// <li> <p> <code>Memory</code>  The percentage of memory that is currently in use on the ECS service tasks.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::EcsServiceMetricName>,
    /// <p> The timestamps of the projected metric. </p>
    #[doc(hidden)]
    pub timestamps: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
    /// <p> The upper bound values for the projected metric. </p>
    #[doc(hidden)]
    pub upper_bound_values: std::option::Option<std::vec::Vec<f64>>,
    /// <p> The lower bound values for the projected metric. </p>
    #[doc(hidden)]
    pub lower_bound_values: std::option::Option<std::vec::Vec<f64>>,
}
impl EcsServiceProjectedMetric {
    /// <p> The name of the projected metric. </p> 
    /// <p>The following metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>CPU</code>  The percentage of allocated compute units that are currently in use on the ECS service tasks.</p> </li> 
    /// <li> <p> <code>Memory</code>  The percentage of memory that is currently in use on the ECS service tasks.</p> </li> 
    /// </ul>
    pub fn name(&self) -> std::option::Option<& crate::model::EcsServiceMetricName> {
        self.name.as_ref()
    }
    /// <p> The timestamps of the projected metric. </p>
    pub fn timestamps(&self) -> std::option::Option<& [aws_smithy_types::DateTime]> {
        self.timestamps.as_deref()
    }
    /// <p> The upper bound values for the projected metric. </p>
    pub fn upper_bound_values(&self) -> std::option::Option<& [f64]> {
        self.upper_bound_values.as_deref()
    }
    /// <p> The lower bound values for the projected metric. </p>
    pub fn lower_bound_values(&self) -> std::option::Option<& [f64]> {
        self.lower_bound_values.as_deref()
    }
}
/// See [`EcsServiceProjectedMetric`](crate::model::EcsServiceProjectedMetric).
pub mod ecs_service_projected_metric {
    
    /// A builder for [`EcsServiceProjectedMetric`](crate::model::EcsServiceProjectedMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::EcsServiceMetricName>,
        pub(crate) timestamps: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
        pub(crate) upper_bound_values: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) lower_bound_values: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        /// <p> The name of the projected metric. </p> 
        /// <p>The following metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>CPU</code>  The percentage of allocated compute units that are currently in use on the ECS service tasks.</p> </li> 
        /// <li> <p> <code>Memory</code>  The percentage of memory that is currently in use on the ECS service tasks.</p> </li> 
        /// </ul>
        pub fn name(mut self, input: crate::model::EcsServiceMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p> The name of the projected metric. </p> 
        /// <p>The following metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>CPU</code>  The percentage of allocated compute units that are currently in use on the ECS service tasks.</p> </li> 
        /// <li> <p> <code>Memory</code>  The percentage of memory that is currently in use on the ECS service tasks.</p> </li> 
        /// </ul>
        pub fn set_name(mut self, input: std::option::Option<crate::model::EcsServiceMetricName>) -> Self {
            self.name = input; self
        }
        /// Appends an item to `timestamps`.
        ///
        /// To override the contents of this collection use [`set_timestamps`](Self::set_timestamps).
        ///
        /// <p> The timestamps of the projected metric. </p>
        pub fn timestamps(mut self, input: aws_smithy_types::DateTime) -> Self {
            let mut v = self.timestamps.unwrap_or_default();
                            v.push(input);
                            self.timestamps = Some(v);
                            self
        }
        /// <p> The timestamps of the projected metric. </p>
        pub fn set_timestamps(mut self, input: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>) -> Self {
            self.timestamps = input; self
        }
        /// Appends an item to `upper_bound_values`.
        ///
        /// To override the contents of this collection use [`set_upper_bound_values`](Self::set_upper_bound_values).
        ///
        /// <p> The upper bound values for the projected metric. </p>
        pub fn upper_bound_values(mut self, input: f64) -> Self {
            let mut v = self.upper_bound_values.unwrap_or_default();
                            v.push(input);
                            self.upper_bound_values = Some(v);
                            self
        }
        /// <p> The upper bound values for the projected metric. </p>
        pub fn set_upper_bound_values(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.upper_bound_values = input; self
        }
        /// Appends an item to `lower_bound_values`.
        ///
        /// To override the contents of this collection use [`set_lower_bound_values`](Self::set_lower_bound_values).
        ///
        /// <p> The lower bound values for the projected metric. </p>
        pub fn lower_bound_values(mut self, input: f64) -> Self {
            let mut v = self.lower_bound_values.unwrap_or_default();
                            v.push(input);
                            self.lower_bound_values = Some(v);
                            self
        }
        /// <p> The lower bound values for the projected metric. </p>
        pub fn set_lower_bound_values(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.lower_bound_values = input; self
        }
        /// Consumes the builder and constructs a [`EcsServiceProjectedMetric`](crate::model::EcsServiceProjectedMetric).
        pub fn build(self) -> crate::model::EcsServiceProjectedMetric {
            crate::model::EcsServiceProjectedMetric {
                name: self.name
                ,
                timestamps: self.timestamps
                ,
                upper_bound_values: self.upper_bound_values
                ,
                lower_bound_values: self.lower_bound_values
                ,
            }
        }
    }
    
    
}
impl EcsServiceProjectedMetric {
    /// Creates a new builder-style object to manufacture [`EcsServiceProjectedMetric`](crate::model::EcsServiceProjectedMetric).
    pub fn builder() -> crate::model::ecs_service_projected_metric::Builder {
        crate::model::ecs_service_projected_metric::Builder::default()
    }
}

/// When writing a match expression against `MetricStatistic`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let metricstatistic = unimplemented!();
/// match metricstatistic {
///     MetricStatistic::Average => { /* ... */ },
///     MetricStatistic::Maximum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `metricstatistic` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MetricStatistic::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MetricStatistic::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MetricStatistic::NewFeature` is defined.
/// Specifically, when `metricstatistic` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MetricStatistic::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum MetricStatistic {
    #[allow(missing_docs)] // documentation missing in model
    Average,
    #[allow(missing_docs)] // documentation missing in model
    Maximum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for MetricStatistic {
    fn from(s: &str) -> Self {
        match s {
            "Average" => MetricStatistic::Average,
            "Maximum" => MetricStatistic::Maximum,
            other => MetricStatistic::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for MetricStatistic {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(MetricStatistic::from(s))
                }
            }
impl MetricStatistic {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MetricStatistic::Average => "Average",
            MetricStatistic::Maximum => "Maximum",
            MetricStatistic::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Average", "Maximum"
        ]
    }
}
impl AsRef<str> for MetricStatistic {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a projected utilization metric of a recommendation option.</p> <note> 
/// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned when you run the <code>GetEC2RecommendationProjectedMetrics</code> action. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendedOptionProjectedMetric  {
    /// <p>The recommended instance type.</p>
    #[doc(hidden)]
    pub recommended_instance_type: std::option::Option<std::string::String>,
    /// <p>The rank of the recommendation option projected metric.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p> 
    /// <p>The projected metric rank correlates to the recommendation option rank. For example, the projected metric ranked as <code>1</code> is related to the recommendation option that is also ranked as <code>1</code> in the same response.</p>
    #[doc(hidden)]
    pub rank: i32,
    /// <p>An array of objects that describe a projected utilization metric.</p>
    #[doc(hidden)]
    pub projected_metrics: std::option::Option<std::vec::Vec<crate::model::ProjectedMetric>>,
}
impl RecommendedOptionProjectedMetric {
    /// <p>The recommended instance type.</p>
    pub fn recommended_instance_type(&self) -> std::option::Option<& str> {
        self.recommended_instance_type.as_deref()
    }
    /// <p>The rank of the recommendation option projected metric.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p> 
    /// <p>The projected metric rank correlates to the recommendation option rank. For example, the projected metric ranked as <code>1</code> is related to the recommendation option that is also ranked as <code>1</code> in the same response.</p>
    pub fn rank(&self) -> i32 {
        self.rank
    }
    /// <p>An array of objects that describe a projected utilization metric.</p>
    pub fn projected_metrics(&self) -> std::option::Option<& [crate::model::ProjectedMetric]> {
        self.projected_metrics.as_deref()
    }
}
/// See [`RecommendedOptionProjectedMetric`](crate::model::RecommendedOptionProjectedMetric).
pub mod recommended_option_projected_metric {
    
    /// A builder for [`RecommendedOptionProjectedMetric`](crate::model::RecommendedOptionProjectedMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommended_instance_type: std::option::Option<std::string::String>,
        pub(crate) rank: std::option::Option<i32>,
        pub(crate) projected_metrics: std::option::Option<std::vec::Vec<crate::model::ProjectedMetric>>,
    }
    impl Builder {
        /// <p>The recommended instance type.</p>
        pub fn recommended_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommended_instance_type = Some(input.into());
            self
        }
        /// <p>The recommended instance type.</p>
        pub fn set_recommended_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.recommended_instance_type = input; self
        }
        /// <p>The rank of the recommendation option projected metric.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p> 
        /// <p>The projected metric rank correlates to the recommendation option rank. For example, the projected metric ranked as <code>1</code> is related to the recommendation option that is also ranked as <code>1</code> in the same response.</p>
        pub fn rank(mut self, input: i32) -> Self {
            self.rank = Some(input);
            self
        }
        /// <p>The rank of the recommendation option projected metric.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p> 
        /// <p>The projected metric rank correlates to the recommendation option rank. For example, the projected metric ranked as <code>1</code> is related to the recommendation option that is also ranked as <code>1</code> in the same response.</p>
        pub fn set_rank(mut self, input: std::option::Option<i32>) -> Self {
            self.rank = input; self
        }
        /// Appends an item to `projected_metrics`.
        ///
        /// To override the contents of this collection use [`set_projected_metrics`](Self::set_projected_metrics).
        ///
        /// <p>An array of objects that describe a projected utilization metric.</p>
        pub fn projected_metrics(mut self, input: crate::model::ProjectedMetric) -> Self {
            let mut v = self.projected_metrics.unwrap_or_default();
                            v.push(input);
                            self.projected_metrics = Some(v);
                            self
        }
        /// <p>An array of objects that describe a projected utilization metric.</p>
        pub fn set_projected_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::ProjectedMetric>>) -> Self {
            self.projected_metrics = input; self
        }
        /// Consumes the builder and constructs a [`RecommendedOptionProjectedMetric`](crate::model::RecommendedOptionProjectedMetric).
        pub fn build(self) -> crate::model::RecommendedOptionProjectedMetric {
            crate::model::RecommendedOptionProjectedMetric {
                recommended_instance_type: self.recommended_instance_type
                ,
                rank: self.rank
                    .unwrap_or_default()
                ,
                projected_metrics: self.projected_metrics
                ,
            }
        }
    }
    
    
}
impl RecommendedOptionProjectedMetric {
    /// Creates a new builder-style object to manufacture [`RecommendedOptionProjectedMetric`](crate::model::RecommendedOptionProjectedMetric).
    pub fn builder() -> crate::model::recommended_option_projected_metric::Builder {
        crate::model::recommended_option_projected_metric::Builder::default()
    }
}

/// <p>Describes a projected utilization metric of a recommendation option, such as an Amazon EC2 instance. This represents the projected utilization of a recommendation option had you used that resource during the analyzed period.</p> 
/// <p>Compare the utilization metric data of your resource against its projected utilization metric data to determine the performance difference between your current resource and the recommended option.</p> <note> 
/// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned when you run the <code>GetEC2RecommendationProjectedMetrics</code> action. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProjectedMetric  {
    /// <p>The name of the projected utilization metric.</p> 
    /// <p>The following projected utilization metrics are returned:</p> 
    /// <ul> 
    /// <li> <p> <code>Cpu</code> - The projected percentage of allocated EC2 compute units that would be in use on the recommendation option had you used that resource during the analyzed period. This metric identifies the processing power required to run an application on the recommendation option.</p> <p>Depending on the instance type, tools in your operating system can show a lower percentage than CloudWatch when the instance is not allocated a full processor core.</p> <p>Units: Percent</p> </li> 
    /// <li> <p> <code>Memory</code> - The percentage of memory that would be in use on the recommendation option had you used that resource during the analyzed period. This metric identifies the amount of memory required to run an application on the recommendation option.</p> <p>Units: Percent</p> <note> 
    /// <p>The <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
    /// </note> </li> 
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::MetricName>,
    /// <p>The timestamps of the projected utilization metric.</p>
    #[doc(hidden)]
    pub timestamps: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
    /// <p>The values of the projected utilization metrics.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<f64>>,
}
impl ProjectedMetric {
    /// <p>The name of the projected utilization metric.</p> 
    /// <p>The following projected utilization metrics are returned:</p> 
    /// <ul> 
    /// <li> <p> <code>Cpu</code> - The projected percentage of allocated EC2 compute units that would be in use on the recommendation option had you used that resource during the analyzed period. This metric identifies the processing power required to run an application on the recommendation option.</p> <p>Depending on the instance type, tools in your operating system can show a lower percentage than CloudWatch when the instance is not allocated a full processor core.</p> <p>Units: Percent</p> </li> 
    /// <li> <p> <code>Memory</code> - The percentage of memory that would be in use on the recommendation option had you used that resource during the analyzed period. This metric identifies the amount of memory required to run an application on the recommendation option.</p> <p>Units: Percent</p> <note> 
    /// <p>The <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
    /// </note> </li> 
    /// </ul>
    pub fn name(&self) -> std::option::Option<& crate::model::MetricName> {
        self.name.as_ref()
    }
    /// <p>The timestamps of the projected utilization metric.</p>
    pub fn timestamps(&self) -> std::option::Option<& [aws_smithy_types::DateTime]> {
        self.timestamps.as_deref()
    }
    /// <p>The values of the projected utilization metrics.</p>
    pub fn values(&self) -> std::option::Option<& [f64]> {
        self.values.as_deref()
    }
}
/// See [`ProjectedMetric`](crate::model::ProjectedMetric).
pub mod projected_metric {
    
    /// A builder for [`ProjectedMetric`](crate::model::ProjectedMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::MetricName>,
        pub(crate) timestamps: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>,
        pub(crate) values: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        /// <p>The name of the projected utilization metric.</p> 
        /// <p>The following projected utilization metrics are returned:</p> 
        /// <ul> 
        /// <li> <p> <code>Cpu</code> - The projected percentage of allocated EC2 compute units that would be in use on the recommendation option had you used that resource during the analyzed period. This metric identifies the processing power required to run an application on the recommendation option.</p> <p>Depending on the instance type, tools in your operating system can show a lower percentage than CloudWatch when the instance is not allocated a full processor core.</p> <p>Units: Percent</p> </li> 
        /// <li> <p> <code>Memory</code> - The percentage of memory that would be in use on the recommendation option had you used that resource during the analyzed period. This metric identifies the amount of memory required to run an application on the recommendation option.</p> <p>Units: Percent</p> <note> 
        /// <p>The <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
        /// </note> </li> 
        /// </ul>
        pub fn name(mut self, input: crate::model::MetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the projected utilization metric.</p> 
        /// <p>The following projected utilization metrics are returned:</p> 
        /// <ul> 
        /// <li> <p> <code>Cpu</code> - The projected percentage of allocated EC2 compute units that would be in use on the recommendation option had you used that resource during the analyzed period. This metric identifies the processing power required to run an application on the recommendation option.</p> <p>Depending on the instance type, tools in your operating system can show a lower percentage than CloudWatch when the instance is not allocated a full processor core.</p> <p>Units: Percent</p> </li> 
        /// <li> <p> <code>Memory</code> - The percentage of memory that would be in use on the recommendation option had you used that resource during the analyzed period. This metric identifies the amount of memory required to run an application on the recommendation option.</p> <p>Units: Percent</p> <note> 
        /// <p>The <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
        /// </note> </li> 
        /// </ul>
        pub fn set_name(mut self, input: std::option::Option<crate::model::MetricName>) -> Self {
            self.name = input; self
        }
        /// Appends an item to `timestamps`.
        ///
        /// To override the contents of this collection use [`set_timestamps`](Self::set_timestamps).
        ///
        /// <p>The timestamps of the projected utilization metric.</p>
        pub fn timestamps(mut self, input: aws_smithy_types::DateTime) -> Self {
            let mut v = self.timestamps.unwrap_or_default();
                            v.push(input);
                            self.timestamps = Some(v);
                            self
        }
        /// <p>The timestamps of the projected utilization metric.</p>
        pub fn set_timestamps(mut self, input: std::option::Option<std::vec::Vec<aws_smithy_types::DateTime>>) -> Self {
            self.timestamps = input; self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values of the projected utilization metrics.</p>
        pub fn values(mut self, input: f64) -> Self {
            let mut v = self.values.unwrap_or_default();
                            v.push(input);
                            self.values = Some(v);
                            self
        }
        /// <p>The values of the projected utilization metrics.</p>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`ProjectedMetric`](crate::model::ProjectedMetric).
        pub fn build(self) -> crate::model::ProjectedMetric {
            crate::model::ProjectedMetric {
                name: self.name
                ,
                timestamps: self.timestamps
                ,
                values: self.values
                ,
            }
        }
    }
    
    
}
impl ProjectedMetric {
    /// Creates a new builder-style object to manufacture [`ProjectedMetric`](crate::model::ProjectedMetric).
    pub fn builder() -> crate::model::projected_metric::Builder {
        crate::model::projected_metric::Builder::default()
    }
}

/// When writing a match expression against `MetricName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let metricname = unimplemented!();
/// match metricname {
///     MetricName::Cpu => { /* ... */ },
///     MetricName::DiskReadBytesPerSecond => { /* ... */ },
///     MetricName::DiskReadOpsPerSecond => { /* ... */ },
///     MetricName::DiskWriteBytesPerSecond => { /* ... */ },
///     MetricName::DiskWriteOpsPerSecond => { /* ... */ },
///     MetricName::EbsReadBytesPerSecond => { /* ... */ },
///     MetricName::EbsReadOpsPerSecond => { /* ... */ },
///     MetricName::EbsWriteBytesPerSecond => { /* ... */ },
///     MetricName::EbsWriteOpsPerSecond => { /* ... */ },
///     MetricName::Memory => { /* ... */ },
///     MetricName::NetworkInBytesPerSecond => { /* ... */ },
///     MetricName::NetworkOutBytesPerSecond => { /* ... */ },
///     MetricName::NetworkPacketsInPerSecond => { /* ... */ },
///     MetricName::NetworkPacketsOutPerSecond => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `metricname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MetricName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MetricName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MetricName::NewFeature` is defined.
/// Specifically, when `metricname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MetricName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum MetricName {
    #[allow(missing_docs)] // documentation missing in model
    Cpu,
    #[allow(missing_docs)] // documentation missing in model
    DiskReadBytesPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    DiskReadOpsPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    DiskWriteBytesPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    DiskWriteOpsPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    EbsReadBytesPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    EbsReadOpsPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    EbsWriteBytesPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    EbsWriteOpsPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    Memory,
    #[allow(missing_docs)] // documentation missing in model
    NetworkInBytesPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    NetworkOutBytesPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    NetworkPacketsInPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    NetworkPacketsOutPerSecond,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for MetricName {
    fn from(s: &str) -> Self {
        match s {
            "Cpu" => MetricName::Cpu,
            "DISK_READ_BYTES_PER_SECOND" => MetricName::DiskReadBytesPerSecond,
            "DISK_READ_OPS_PER_SECOND" => MetricName::DiskReadOpsPerSecond,
            "DISK_WRITE_BYTES_PER_SECOND" => MetricName::DiskWriteBytesPerSecond,
            "DISK_WRITE_OPS_PER_SECOND" => MetricName::DiskWriteOpsPerSecond,
            "EBS_READ_BYTES_PER_SECOND" => MetricName::EbsReadBytesPerSecond,
            "EBS_READ_OPS_PER_SECOND" => MetricName::EbsReadOpsPerSecond,
            "EBS_WRITE_BYTES_PER_SECOND" => MetricName::EbsWriteBytesPerSecond,
            "EBS_WRITE_OPS_PER_SECOND" => MetricName::EbsWriteOpsPerSecond,
            "Memory" => MetricName::Memory,
            "NETWORK_IN_BYTES_PER_SECOND" => MetricName::NetworkInBytesPerSecond,
            "NETWORK_OUT_BYTES_PER_SECOND" => MetricName::NetworkOutBytesPerSecond,
            "NETWORK_PACKETS_IN_PER_SECOND" => MetricName::NetworkPacketsInPerSecond,
            "NETWORK_PACKETS_OUT_PER_SECOND" => MetricName::NetworkPacketsOutPerSecond,
            other => MetricName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for MetricName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(MetricName::from(s))
                }
            }
impl MetricName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MetricName::Cpu => "Cpu",
            MetricName::DiskReadBytesPerSecond => "DISK_READ_BYTES_PER_SECOND",
            MetricName::DiskReadOpsPerSecond => "DISK_READ_OPS_PER_SECOND",
            MetricName::DiskWriteBytesPerSecond => "DISK_WRITE_BYTES_PER_SECOND",
            MetricName::DiskWriteOpsPerSecond => "DISK_WRITE_OPS_PER_SECOND",
            MetricName::EbsReadBytesPerSecond => "EBS_READ_BYTES_PER_SECOND",
            MetricName::EbsReadOpsPerSecond => "EBS_READ_OPS_PER_SECOND",
            MetricName::EbsWriteBytesPerSecond => "EBS_WRITE_BYTES_PER_SECOND",
            MetricName::EbsWriteOpsPerSecond => "EBS_WRITE_OPS_PER_SECOND",
            MetricName::Memory => "Memory",
            MetricName::NetworkInBytesPerSecond => "NETWORK_IN_BYTES_PER_SECOND",
            MetricName::NetworkOutBytesPerSecond => "NETWORK_OUT_BYTES_PER_SECOND",
            MetricName::NetworkPacketsInPerSecond => "NETWORK_PACKETS_IN_PER_SECOND",
            MetricName::NetworkPacketsOutPerSecond => "NETWORK_PACKETS_OUT_PER_SECOND",
            MetricName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Cpu", "DISK_READ_BYTES_PER_SECOND", "DISK_READ_OPS_PER_SECOND", "DISK_WRITE_BYTES_PER_SECOND", "DISK_WRITE_OPS_PER_SECOND", "EBS_READ_BYTES_PER_SECOND", "EBS_READ_OPS_PER_SECOND", "EBS_WRITE_BYTES_PER_SECOND", "EBS_WRITE_OPS_PER_SECOND", "Memory", "NETWORK_IN_BYTES_PER_SECOND", "NETWORK_OUT_BYTES_PER_SECOND", "NETWORK_PACKETS_IN_PER_SECOND", "NETWORK_PACKETS_OUT_PER_SECOND"
        ]
    }
}
impl AsRef<str> for MetricName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the recommendation preferences to return in the response of a <code>GetAutoScalingGroupRecommendations</code>, <code>GetEC2InstanceRecommendations</code>, and <code>GetEC2RecommendationProjectedMetrics</code> request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendationPreferences  {
    /// <p>Specifies the CPU vendor and architecture for Amazon EC2 instance and Auto Scaling group recommendations.</p> 
    /// <p>For example, when you specify <code>AWS_ARM64</code> with:</p> 
    /// <ul> 
    /// <li> <p>A <code>GetEC2InstanceRecommendations</code> or <code>GetAutoScalingGroupRecommendations</code> request, Compute Optimizer returns recommendations that consist of Graviton2 instance types only.</p> </li> 
    /// <li> <p>A <code>GetEC2RecommendationProjectedMetrics</code> request, Compute Optimizer returns projected utilization metrics for Graviton2 instance type recommendations only.</p> </li> 
    /// <li> <p>A <code>ExportEC2InstanceRecommendations</code> or <code>ExportAutoScalingGroupRecommendations</code> request, Compute Optimizer exports recommendations that consist of Graviton2 instance types only.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub cpu_vendor_architectures: std::option::Option<std::vec::Vec<crate::model::CpuVendorArchitecture>>,
}
impl RecommendationPreferences {
    /// <p>Specifies the CPU vendor and architecture for Amazon EC2 instance and Auto Scaling group recommendations.</p> 
    /// <p>For example, when you specify <code>AWS_ARM64</code> with:</p> 
    /// <ul> 
    /// <li> <p>A <code>GetEC2InstanceRecommendations</code> or <code>GetAutoScalingGroupRecommendations</code> request, Compute Optimizer returns recommendations that consist of Graviton2 instance types only.</p> </li> 
    /// <li> <p>A <code>GetEC2RecommendationProjectedMetrics</code> request, Compute Optimizer returns projected utilization metrics for Graviton2 instance type recommendations only.</p> </li> 
    /// <li> <p>A <code>ExportEC2InstanceRecommendations</code> or <code>ExportAutoScalingGroupRecommendations</code> request, Compute Optimizer exports recommendations that consist of Graviton2 instance types only.</p> </li> 
    /// </ul>
    pub fn cpu_vendor_architectures(&self) -> std::option::Option<& [crate::model::CpuVendorArchitecture]> {
        self.cpu_vendor_architectures.as_deref()
    }
}
/// See [`RecommendationPreferences`](crate::model::RecommendationPreferences).
pub mod recommendation_preferences {
    
    /// A builder for [`RecommendationPreferences`](crate::model::RecommendationPreferences).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cpu_vendor_architectures: std::option::Option<std::vec::Vec<crate::model::CpuVendorArchitecture>>,
    }
    impl Builder {
        /// Appends an item to `cpu_vendor_architectures`.
        ///
        /// To override the contents of this collection use [`set_cpu_vendor_architectures`](Self::set_cpu_vendor_architectures).
        ///
        /// <p>Specifies the CPU vendor and architecture for Amazon EC2 instance and Auto Scaling group recommendations.</p> 
        /// <p>For example, when you specify <code>AWS_ARM64</code> with:</p> 
        /// <ul> 
        /// <li> <p>A <code>GetEC2InstanceRecommendations</code> or <code>GetAutoScalingGroupRecommendations</code> request, Compute Optimizer returns recommendations that consist of Graviton2 instance types only.</p> </li> 
        /// <li> <p>A <code>GetEC2RecommendationProjectedMetrics</code> request, Compute Optimizer returns projected utilization metrics for Graviton2 instance type recommendations only.</p> </li> 
        /// <li> <p>A <code>ExportEC2InstanceRecommendations</code> or <code>ExportAutoScalingGroupRecommendations</code> request, Compute Optimizer exports recommendations that consist of Graviton2 instance types only.</p> </li> 
        /// </ul>
        pub fn cpu_vendor_architectures(mut self, input: crate::model::CpuVendorArchitecture) -> Self {
            let mut v = self.cpu_vendor_architectures.unwrap_or_default();
                            v.push(input);
                            self.cpu_vendor_architectures = Some(v);
                            self
        }
        /// <p>Specifies the CPU vendor and architecture for Amazon EC2 instance and Auto Scaling group recommendations.</p> 
        /// <p>For example, when you specify <code>AWS_ARM64</code> with:</p> 
        /// <ul> 
        /// <li> <p>A <code>GetEC2InstanceRecommendations</code> or <code>GetAutoScalingGroupRecommendations</code> request, Compute Optimizer returns recommendations that consist of Graviton2 instance types only.</p> </li> 
        /// <li> <p>A <code>GetEC2RecommendationProjectedMetrics</code> request, Compute Optimizer returns projected utilization metrics for Graviton2 instance type recommendations only.</p> </li> 
        /// <li> <p>A <code>ExportEC2InstanceRecommendations</code> or <code>ExportAutoScalingGroupRecommendations</code> request, Compute Optimizer exports recommendations that consist of Graviton2 instance types only.</p> </li> 
        /// </ul>
        pub fn set_cpu_vendor_architectures(mut self, input: std::option::Option<std::vec::Vec<crate::model::CpuVendorArchitecture>>) -> Self {
            self.cpu_vendor_architectures = input; self
        }
        /// Consumes the builder and constructs a [`RecommendationPreferences`](crate::model::RecommendationPreferences).
        pub fn build(self) -> crate::model::RecommendationPreferences {
            crate::model::RecommendationPreferences {
                cpu_vendor_architectures: self.cpu_vendor_architectures
                ,
            }
        }
    }
    
    
}
impl RecommendationPreferences {
    /// Creates a new builder-style object to manufacture [`RecommendationPreferences`](crate::model::RecommendationPreferences).
    pub fn builder() -> crate::model::recommendation_preferences::Builder {
        crate::model::recommendation_preferences::Builder::default()
    }
}

/// When writing a match expression against `CpuVendorArchitecture`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let cpuvendorarchitecture = unimplemented!();
/// match cpuvendorarchitecture {
///     CpuVendorArchitecture::AwsArm64 => { /* ... */ },
///     CpuVendorArchitecture::Current => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `cpuvendorarchitecture` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CpuVendorArchitecture::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CpuVendorArchitecture::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CpuVendorArchitecture::NewFeature` is defined.
/// Specifically, when `cpuvendorarchitecture` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CpuVendorArchitecture::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum CpuVendorArchitecture {
    #[allow(missing_docs)] // documentation missing in model
    AwsArm64,
    #[allow(missing_docs)] // documentation missing in model
    Current,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for CpuVendorArchitecture {
    fn from(s: &str) -> Self {
        match s {
            "AWS_ARM64" => CpuVendorArchitecture::AwsArm64,
            "CURRENT" => CpuVendorArchitecture::Current,
            other => CpuVendorArchitecture::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for CpuVendorArchitecture {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(CpuVendorArchitecture::from(s))
                }
            }
impl CpuVendorArchitecture {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CpuVendorArchitecture::AwsArm64 => "AWS_ARM64",
            CpuVendorArchitecture::Current => "CURRENT",
            CpuVendorArchitecture::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AWS_ARM64", "CURRENT"
        ]
    }
}
impl AsRef<str> for CpuVendorArchitecture {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an Amazon EC2 instance recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceRecommendation  {
    /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
    #[doc(hidden)]
    pub instance_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the instance.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the current instance.</p>
    #[doc(hidden)]
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>The instance type of the current instance.</p>
    #[doc(hidden)]
    pub current_instance_type: std::option::Option<std::string::String>,
    /// <p>The finding classification of the instance.</p> 
    /// <p>Findings for instances include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>Underprovisioned</code> </b>An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.</p> </li> 
    /// <li> <p> <b> <code>Overprovisioned</code> </b>An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.</p> </li> 
    /// <li> <p> <b> <code>Optimized</code> </b>An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub finding: std::option::Option<crate::model::Finding>,
    /// <p>The reason for the finding classification of the instance.</p> 
    /// <p>Finding reason codes for instances include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The instances CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The instances CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The instances memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The instances memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p> <note> 
    /// <p>Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory utilization with the Amazon CloudWatch Agent</a> in the <i>Compute Optimizer User Guide</i>. On Linux instances, Compute Optimizer analyses the <code>mem_used_percent</code> metric in the <code>CWAgent</code> namespace, or the legacy <code>MemoryUtilization</code> metric in the <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses the <code>Memory % Committed Bytes In Use</code> metric in the <code>CWAgent</code> namespace.</p> 
    /// </note> </li> 
    /// <li> <p> <b> <code>EBSThroughputOverprovisioned</code> </b>  The instances EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics of EBS volumes attached to the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>EBSThroughputUnderprovisioned</code> </b>  The instances EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics of EBS volumes attached to the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>EBSIOPSOverprovisioned</code> </b>  The instances EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS volumes attached to the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>EBSIOPSUnderprovisioned</code> </b>  The instances EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS volumes attached to the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>NetworkBandwidthOverprovisioned</code> </b>  The instances network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>NetworkBandwidthUnderprovisioned</code> </b>  The instances network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p> </li> 
    /// <li> <p> <b> <code>NetworkPPSOverprovisioned</code> </b>  The instances network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>NetworkPPSUnderprovisioned</code> </b>  The instances network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>DiskIOPSOverprovisioned</code> </b>  The instances disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>DiskIOPSUnderprovisioned</code> </b>  The instances disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>DiskThroughputOverprovisioned</code> </b>  The instances disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>DiskThroughputUnderprovisioned</code> </b>  The instances disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p> </li> 
    /// </ul> <note> 
    /// <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> 
    /// </note>
    #[doc(hidden)]
    pub finding_reason_codes: std::option::Option<std::vec::Vec<crate::model::InstanceRecommendationFindingReasonCode>>,
    /// <p>An array of objects that describe the utilization metrics of the instance.</p>
    #[doc(hidden)]
    pub utilization_metrics: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>,
    /// <p>The number of days for which utilization metrics were analyzed for the instance.</p>
    #[doc(hidden)]
    pub look_back_period_in_days: f64,
    /// <p>An array of objects that describe the recommendation options for the instance.</p>
    #[doc(hidden)]
    pub recommendation_options: std::option::Option<std::vec::Vec<crate::model::InstanceRecommendationOption>>,
    /// <p>An array of objects that describe the source resource of the recommendation.</p>
    #[doc(hidden)]
    pub recommendation_sources: std::option::Option<std::vec::Vec<crate::model::RecommendationSource>>,
    /// <p>The timestamp of when the instance recommendation was last generated.</p>
    #[doc(hidden)]
    pub last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.</p>
    #[doc(hidden)]
    pub current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
    /// <p>An object that describes the effective recommendation preferences for the instance.</p>
    #[doc(hidden)]
    pub effective_recommendation_preferences: std::option::Option<crate::model::EffectiveRecommendationPreferences>,
    /// <p>The applications that might be running on the instance as inferred by Compute Optimizer.</p> 
    /// <p>Compute Optimizer can infer if one of the following applications might be running on the instance:</p> 
    /// <ul> 
    /// <li> <p> <code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instance.</p> </li> 
    /// <li> <p> <code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instance.</p> </li> 
    /// <li> <p> <code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instance.</p> </li> 
    /// <li> <p> <code>Memcached</code> - Infers that Memcached might be running on the instance.</p> </li> 
    /// <li> <p> <code>NGINX</code> - Infers that NGINX might be running on the instance.</p> </li> 
    /// <li> <p> <code>PostgreSql</code> - Infers that PostgreSQL might be running on the instance.</p> </li> 
    /// <li> <p> <code>Redis</code> - Infers that Redis might be running on the instance.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub inferred_workload_types: std::option::Option<std::vec::Vec<crate::model::InferredWorkloadType>>,
}
impl InstanceRecommendation {
    /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
    pub fn instance_arn(&self) -> std::option::Option<& str> {
        self.instance_arn.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the instance.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the current instance.</p>
    pub fn instance_name(&self) -> std::option::Option<& str> {
        self.instance_name.as_deref()
    }
    /// <p>The instance type of the current instance.</p>
    pub fn current_instance_type(&self) -> std::option::Option<& str> {
        self.current_instance_type.as_deref()
    }
    /// <p>The finding classification of the instance.</p> 
    /// <p>Findings for instances include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>Underprovisioned</code> </b>An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.</p> </li> 
    /// <li> <p> <b> <code>Overprovisioned</code> </b>An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.</p> </li> 
    /// <li> <p> <b> <code>Optimized</code> </b>An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p> </li> 
    /// </ul>
    pub fn finding(&self) -> std::option::Option<& crate::model::Finding> {
        self.finding.as_ref()
    }
    /// <p>The reason for the finding classification of the instance.</p> 
    /// <p>Finding reason codes for instances include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The instances CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The instances CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The instances memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The instances memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p> <note> 
    /// <p>Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory utilization with the Amazon CloudWatch Agent</a> in the <i>Compute Optimizer User Guide</i>. On Linux instances, Compute Optimizer analyses the <code>mem_used_percent</code> metric in the <code>CWAgent</code> namespace, or the legacy <code>MemoryUtilization</code> metric in the <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses the <code>Memory % Committed Bytes In Use</code> metric in the <code>CWAgent</code> namespace.</p> 
    /// </note> </li> 
    /// <li> <p> <b> <code>EBSThroughputOverprovisioned</code> </b>  The instances EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics of EBS volumes attached to the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>EBSThroughputUnderprovisioned</code> </b>  The instances EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics of EBS volumes attached to the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>EBSIOPSOverprovisioned</code> </b>  The instances EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS volumes attached to the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>EBSIOPSUnderprovisioned</code> </b>  The instances EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS volumes attached to the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>NetworkBandwidthOverprovisioned</code> </b>  The instances network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>NetworkBandwidthUnderprovisioned</code> </b>  The instances network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p> </li> 
    /// <li> <p> <b> <code>NetworkPPSOverprovisioned</code> </b>  The instances network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>NetworkPPSUnderprovisioned</code> </b>  The instances network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>DiskIOPSOverprovisioned</code> </b>  The instances disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>DiskIOPSUnderprovisioned</code> </b>  The instances disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>DiskThroughputOverprovisioned</code> </b>  The instances disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p> </li> 
    /// <li> <p> <b> <code>DiskThroughputUnderprovisioned</code> </b>  The instances disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p> </li> 
    /// </ul> <note> 
    /// <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> 
    /// </note>
    pub fn finding_reason_codes(&self) -> std::option::Option<& [crate::model::InstanceRecommendationFindingReasonCode]> {
        self.finding_reason_codes.as_deref()
    }
    /// <p>An array of objects that describe the utilization metrics of the instance.</p>
    pub fn utilization_metrics(&self) -> std::option::Option<& [crate::model::UtilizationMetric]> {
        self.utilization_metrics.as_deref()
    }
    /// <p>The number of days for which utilization metrics were analyzed for the instance.</p>
    pub fn look_back_period_in_days(&self) -> f64 {
        self.look_back_period_in_days
    }
    /// <p>An array of objects that describe the recommendation options for the instance.</p>
    pub fn recommendation_options(&self) -> std::option::Option<& [crate::model::InstanceRecommendationOption]> {
        self.recommendation_options.as_deref()
    }
    /// <p>An array of objects that describe the source resource of the recommendation.</p>
    pub fn recommendation_sources(&self) -> std::option::Option<& [crate::model::RecommendationSource]> {
        self.recommendation_sources.as_deref()
    }
    /// <p>The timestamp of when the instance recommendation was last generated.</p>
    pub fn last_refresh_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.last_refresh_timestamp.as_ref()
    }
    /// <p>The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.</p>
    pub fn current_performance_risk(&self) -> std::option::Option<& crate::model::CurrentPerformanceRisk> {
        self.current_performance_risk.as_ref()
    }
    /// <p>An object that describes the effective recommendation preferences for the instance.</p>
    pub fn effective_recommendation_preferences(&self) -> std::option::Option<& crate::model::EffectiveRecommendationPreferences> {
        self.effective_recommendation_preferences.as_ref()
    }
    /// <p>The applications that might be running on the instance as inferred by Compute Optimizer.</p> 
    /// <p>Compute Optimizer can infer if one of the following applications might be running on the instance:</p> 
    /// <ul> 
    /// <li> <p> <code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instance.</p> </li> 
    /// <li> <p> <code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instance.</p> </li> 
    /// <li> <p> <code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instance.</p> </li> 
    /// <li> <p> <code>Memcached</code> - Infers that Memcached might be running on the instance.</p> </li> 
    /// <li> <p> <code>NGINX</code> - Infers that NGINX might be running on the instance.</p> </li> 
    /// <li> <p> <code>PostgreSql</code> - Infers that PostgreSQL might be running on the instance.</p> </li> 
    /// <li> <p> <code>Redis</code> - Infers that Redis might be running on the instance.</p> </li> 
    /// </ul>
    pub fn inferred_workload_types(&self) -> std::option::Option<& [crate::model::InferredWorkloadType]> {
        self.inferred_workload_types.as_deref()
    }
}
/// See [`InstanceRecommendation`](crate::model::InstanceRecommendation).
pub mod instance_recommendation {
    
    /// A builder for [`InstanceRecommendation`](crate::model::InstanceRecommendation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_arn: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) current_instance_type: std::option::Option<std::string::String>,
        pub(crate) finding: std::option::Option<crate::model::Finding>,
        pub(crate) finding_reason_codes: std::option::Option<std::vec::Vec<crate::model::InstanceRecommendationFindingReasonCode>>,
        pub(crate) utilization_metrics: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>,
        pub(crate) look_back_period_in_days: std::option::Option<f64>,
        pub(crate) recommendation_options: std::option::Option<std::vec::Vec<crate::model::InstanceRecommendationOption>>,
        pub(crate) recommendation_sources: std::option::Option<std::vec::Vec<crate::model::RecommendationSource>>,
        pub(crate) last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
        pub(crate) effective_recommendation_preferences: std::option::Option<crate::model::EffectiveRecommendationPreferences>,
        pub(crate) inferred_workload_types: std::option::Option<std::vec::Vec<crate::model::InferredWorkloadType>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
        pub fn instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
        pub fn set_instance_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_arn = input; self
        }
        /// <p>The Amazon Web Services account ID of the instance.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the instance.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the current instance.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the current instance.</p>
        pub fn set_instance_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_name = input; self
        }
        /// <p>The instance type of the current instance.</p>
        pub fn current_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_instance_type = Some(input.into());
            self
        }
        /// <p>The instance type of the current instance.</p>
        pub fn set_current_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.current_instance_type = input; self
        }
        /// <p>The finding classification of the instance.</p> 
        /// <p>Findings for instances include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>Underprovisioned</code> </b>An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.</p> </li> 
        /// <li> <p> <b> <code>Overprovisioned</code> </b>An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.</p> </li> 
        /// <li> <p> <b> <code>Optimized</code> </b>An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p> </li> 
        /// </ul>
        pub fn finding(mut self, input: crate::model::Finding) -> Self {
            self.finding = Some(input);
            self
        }
        /// <p>The finding classification of the instance.</p> 
        /// <p>Findings for instances include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>Underprovisioned</code> </b>An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.</p> </li> 
        /// <li> <p> <b> <code>Overprovisioned</code> </b>An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.</p> </li> 
        /// <li> <p> <b> <code>Optimized</code> </b>An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p> </li> 
        /// </ul>
        pub fn set_finding(mut self, input: std::option::Option<crate::model::Finding>) -> Self {
            self.finding = input; self
        }
        /// Appends an item to `finding_reason_codes`.
        ///
        /// To override the contents of this collection use [`set_finding_reason_codes`](Self::set_finding_reason_codes).
        ///
        /// <p>The reason for the finding classification of the instance.</p> 
        /// <p>Finding reason codes for instances include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The instances CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The instances CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The instances memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The instances memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p> <note> 
        /// <p>Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory utilization with the Amazon CloudWatch Agent</a> in the <i>Compute Optimizer User Guide</i>. On Linux instances, Compute Optimizer analyses the <code>mem_used_percent</code> metric in the <code>CWAgent</code> namespace, or the legacy <code>MemoryUtilization</code> metric in the <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses the <code>Memory % Committed Bytes In Use</code> metric in the <code>CWAgent</code> namespace.</p> 
        /// </note> </li> 
        /// <li> <p> <b> <code>EBSThroughputOverprovisioned</code> </b>  The instances EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics of EBS volumes attached to the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>EBSThroughputUnderprovisioned</code> </b>  The instances EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics of EBS volumes attached to the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>EBSIOPSOverprovisioned</code> </b>  The instances EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS volumes attached to the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>EBSIOPSUnderprovisioned</code> </b>  The instances EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS volumes attached to the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>NetworkBandwidthOverprovisioned</code> </b>  The instances network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>NetworkBandwidthUnderprovisioned</code> </b>  The instances network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p> </li> 
        /// <li> <p> <b> <code>NetworkPPSOverprovisioned</code> </b>  The instances network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>NetworkPPSUnderprovisioned</code> </b>  The instances network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>DiskIOPSOverprovisioned</code> </b>  The instances disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>DiskIOPSUnderprovisioned</code> </b>  The instances disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>DiskThroughputOverprovisioned</code> </b>  The instances disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>DiskThroughputUnderprovisioned</code> </b>  The instances disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p> </li> 
        /// </ul> <note> 
        /// <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> 
        /// </note>
        pub fn finding_reason_codes(mut self, input: crate::model::InstanceRecommendationFindingReasonCode) -> Self {
            let mut v = self.finding_reason_codes.unwrap_or_default();
                            v.push(input);
                            self.finding_reason_codes = Some(v);
                            self
        }
        /// <p>The reason for the finding classification of the instance.</p> 
        /// <p>Finding reason codes for instances include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The instances CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The instances CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The instances memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The instances memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p> <note> 
        /// <p>Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory utilization with the Amazon CloudWatch Agent</a> in the <i>Compute Optimizer User Guide</i>. On Linux instances, Compute Optimizer analyses the <code>mem_used_percent</code> metric in the <code>CWAgent</code> namespace, or the legacy <code>MemoryUtilization</code> metric in the <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses the <code>Memory % Committed Bytes In Use</code> metric in the <code>CWAgent</code> namespace.</p> 
        /// </note> </li> 
        /// <li> <p> <b> <code>EBSThroughputOverprovisioned</code> </b>  The instances EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics of EBS volumes attached to the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>EBSThroughputUnderprovisioned</code> </b>  The instances EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metrics of EBS volumes attached to the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>EBSIOPSOverprovisioned</code> </b>  The instances EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS volumes attached to the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>EBSIOPSUnderprovisioned</code> </b>  The instances EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metric of EBS volumes attached to the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>NetworkBandwidthOverprovisioned</code> </b>  The instances network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>NetworkBandwidthUnderprovisioned</code> </b>  The instances network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p> </li> 
        /// <li> <p> <b> <code>NetworkPPSOverprovisioned</code> </b>  The instances network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>NetworkPPSUnderprovisioned</code> </b>  The instances network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>DiskIOPSOverprovisioned</code> </b>  The instances disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>DiskIOPSUnderprovisioned</code> </b>  The instances disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>DiskThroughputOverprovisioned</code> </b>  The instances disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p> </li> 
        /// <li> <p> <b> <code>DiskThroughputUnderprovisioned</code> </b>  The instances disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p> </li> 
        /// </ul> <note> 
        /// <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> 
        /// </note>
        pub fn set_finding_reason_codes(mut self, input: std::option::Option<std::vec::Vec<crate::model::InstanceRecommendationFindingReasonCode>>) -> Self {
            self.finding_reason_codes = input; self
        }
        /// Appends an item to `utilization_metrics`.
        ///
        /// To override the contents of this collection use [`set_utilization_metrics`](Self::set_utilization_metrics).
        ///
        /// <p>An array of objects that describe the utilization metrics of the instance.</p>
        pub fn utilization_metrics(mut self, input: crate::model::UtilizationMetric) -> Self {
            let mut v = self.utilization_metrics.unwrap_or_default();
                            v.push(input);
                            self.utilization_metrics = Some(v);
                            self
        }
        /// <p>An array of objects that describe the utilization metrics of the instance.</p>
        pub fn set_utilization_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>) -> Self {
            self.utilization_metrics = input; self
        }
        /// <p>The number of days for which utilization metrics were analyzed for the instance.</p>
        pub fn look_back_period_in_days(mut self, input: f64) -> Self {
            self.look_back_period_in_days = Some(input);
            self
        }
        /// <p>The number of days for which utilization metrics were analyzed for the instance.</p>
        pub fn set_look_back_period_in_days(mut self, input: std::option::Option<f64>) -> Self {
            self.look_back_period_in_days = input; self
        }
        /// Appends an item to `recommendation_options`.
        ///
        /// To override the contents of this collection use [`set_recommendation_options`](Self::set_recommendation_options).
        ///
        /// <p>An array of objects that describe the recommendation options for the instance.</p>
        pub fn recommendation_options(mut self, input: crate::model::InstanceRecommendationOption) -> Self {
            let mut v = self.recommendation_options.unwrap_or_default();
                            v.push(input);
                            self.recommendation_options = Some(v);
                            self
        }
        /// <p>An array of objects that describe the recommendation options for the instance.</p>
        pub fn set_recommendation_options(mut self, input: std::option::Option<std::vec::Vec<crate::model::InstanceRecommendationOption>>) -> Self {
            self.recommendation_options = input; self
        }
        /// Appends an item to `recommendation_sources`.
        ///
        /// To override the contents of this collection use [`set_recommendation_sources`](Self::set_recommendation_sources).
        ///
        /// <p>An array of objects that describe the source resource of the recommendation.</p>
        pub fn recommendation_sources(mut self, input: crate::model::RecommendationSource) -> Self {
            let mut v = self.recommendation_sources.unwrap_or_default();
                            v.push(input);
                            self.recommendation_sources = Some(v);
                            self
        }
        /// <p>An array of objects that describe the source resource of the recommendation.</p>
        pub fn set_recommendation_sources(mut self, input: std::option::Option<std::vec::Vec<crate::model::RecommendationSource>>) -> Self {
            self.recommendation_sources = input; self
        }
        /// <p>The timestamp of when the instance recommendation was last generated.</p>
        pub fn last_refresh_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_refresh_timestamp = Some(input);
            self
        }
        /// <p>The timestamp of when the instance recommendation was last generated.</p>
        pub fn set_last_refresh_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.last_refresh_timestamp = input; self
        }
        /// <p>The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.</p>
        pub fn current_performance_risk(mut self, input: crate::model::CurrentPerformanceRisk) -> Self {
            self.current_performance_risk = Some(input);
            self
        }
        /// <p>The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.</p>
        pub fn set_current_performance_risk(mut self, input: std::option::Option<crate::model::CurrentPerformanceRisk>) -> Self {
            self.current_performance_risk = input; self
        }
        /// <p>An object that describes the effective recommendation preferences for the instance.</p>
        pub fn effective_recommendation_preferences(mut self, input: crate::model::EffectiveRecommendationPreferences) -> Self {
            self.effective_recommendation_preferences = Some(input);
            self
        }
        /// <p>An object that describes the effective recommendation preferences for the instance.</p>
        pub fn set_effective_recommendation_preferences(mut self, input: std::option::Option<crate::model::EffectiveRecommendationPreferences>) -> Self {
            self.effective_recommendation_preferences = input; self
        }
        /// Appends an item to `inferred_workload_types`.
        ///
        /// To override the contents of this collection use [`set_inferred_workload_types`](Self::set_inferred_workload_types).
        ///
        /// <p>The applications that might be running on the instance as inferred by Compute Optimizer.</p> 
        /// <p>Compute Optimizer can infer if one of the following applications might be running on the instance:</p> 
        /// <ul> 
        /// <li> <p> <code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instance.</p> </li> 
        /// <li> <p> <code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instance.</p> </li> 
        /// <li> <p> <code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instance.</p> </li> 
        /// <li> <p> <code>Memcached</code> - Infers that Memcached might be running on the instance.</p> </li> 
        /// <li> <p> <code>NGINX</code> - Infers that NGINX might be running on the instance.</p> </li> 
        /// <li> <p> <code>PostgreSql</code> - Infers that PostgreSQL might be running on the instance.</p> </li> 
        /// <li> <p> <code>Redis</code> - Infers that Redis might be running on the instance.</p> </li> 
        /// </ul>
        pub fn inferred_workload_types(mut self, input: crate::model::InferredWorkloadType) -> Self {
            let mut v = self.inferred_workload_types.unwrap_or_default();
                            v.push(input);
                            self.inferred_workload_types = Some(v);
                            self
        }
        /// <p>The applications that might be running on the instance as inferred by Compute Optimizer.</p> 
        /// <p>Compute Optimizer can infer if one of the following applications might be running on the instance:</p> 
        /// <ul> 
        /// <li> <p> <code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instance.</p> </li> 
        /// <li> <p> <code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instance.</p> </li> 
        /// <li> <p> <code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instance.</p> </li> 
        /// <li> <p> <code>Memcached</code> - Infers that Memcached might be running on the instance.</p> </li> 
        /// <li> <p> <code>NGINX</code> - Infers that NGINX might be running on the instance.</p> </li> 
        /// <li> <p> <code>PostgreSql</code> - Infers that PostgreSQL might be running on the instance.</p> </li> 
        /// <li> <p> <code>Redis</code> - Infers that Redis might be running on the instance.</p> </li> 
        /// </ul>
        pub fn set_inferred_workload_types(mut self, input: std::option::Option<std::vec::Vec<crate::model::InferredWorkloadType>>) -> Self {
            self.inferred_workload_types = input; self
        }
        /// Consumes the builder and constructs a [`InstanceRecommendation`](crate::model::InstanceRecommendation).
        pub fn build(self) -> crate::model::InstanceRecommendation {
            crate::model::InstanceRecommendation {
                instance_arn: self.instance_arn
                ,
                account_id: self.account_id
                ,
                instance_name: self.instance_name
                ,
                current_instance_type: self.current_instance_type
                ,
                finding: self.finding
                ,
                finding_reason_codes: self.finding_reason_codes
                ,
                utilization_metrics: self.utilization_metrics
                ,
                look_back_period_in_days: self.look_back_period_in_days
                    .unwrap_or_default()
                ,
                recommendation_options: self.recommendation_options
                ,
                recommendation_sources: self.recommendation_sources
                ,
                last_refresh_timestamp: self.last_refresh_timestamp
                ,
                current_performance_risk: self.current_performance_risk
                ,
                effective_recommendation_preferences: self.effective_recommendation_preferences
                ,
                inferred_workload_types: self.inferred_workload_types
                ,
            }
        }
    }
    
    
}
impl InstanceRecommendation {
    /// Creates a new builder-style object to manufacture [`InstanceRecommendation`](crate::model::InstanceRecommendation).
    pub fn builder() -> crate::model::instance_recommendation::Builder {
        crate::model::instance_recommendation::Builder::default()
    }
}

/// When writing a match expression against `InferredWorkloadType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let inferredworkloadtype = unimplemented!();
/// match inferredworkloadtype {
///     InferredWorkloadType::AmazonEmr => { /* ... */ },
///     InferredWorkloadType::ApacheCassandra => { /* ... */ },
///     InferredWorkloadType::ApacheHadoop => { /* ... */ },
///     InferredWorkloadType::Memcached => { /* ... */ },
///     InferredWorkloadType::Nginx => { /* ... */ },
///     InferredWorkloadType::PostgreSql => { /* ... */ },
///     InferredWorkloadType::Redis => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `inferredworkloadtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InferredWorkloadType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InferredWorkloadType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InferredWorkloadType::NewFeature` is defined.
/// Specifically, when `inferredworkloadtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InferredWorkloadType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum InferredWorkloadType {
    #[allow(missing_docs)] // documentation missing in model
    AmazonEmr,
    #[allow(missing_docs)] // documentation missing in model
    ApacheCassandra,
    #[allow(missing_docs)] // documentation missing in model
    ApacheHadoop,
    #[allow(missing_docs)] // documentation missing in model
    Memcached,
    #[allow(missing_docs)] // documentation missing in model
    Nginx,
    #[allow(missing_docs)] // documentation missing in model
    PostgreSql,
    #[allow(missing_docs)] // documentation missing in model
    Redis,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for InferredWorkloadType {
    fn from(s: &str) -> Self {
        match s {
            "AmazonEmr" => InferredWorkloadType::AmazonEmr,
            "ApacheCassandra" => InferredWorkloadType::ApacheCassandra,
            "ApacheHadoop" => InferredWorkloadType::ApacheHadoop,
            "Memcached" => InferredWorkloadType::Memcached,
            "Nginx" => InferredWorkloadType::Nginx,
            "PostgreSql" => InferredWorkloadType::PostgreSql,
            "Redis" => InferredWorkloadType::Redis,
            other => InferredWorkloadType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for InferredWorkloadType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(InferredWorkloadType::from(s))
                }
            }
impl InferredWorkloadType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InferredWorkloadType::AmazonEmr => "AmazonEmr",
            InferredWorkloadType::ApacheCassandra => "ApacheCassandra",
            InferredWorkloadType::ApacheHadoop => "ApacheHadoop",
            InferredWorkloadType::Memcached => "Memcached",
            InferredWorkloadType::Nginx => "Nginx",
            InferredWorkloadType::PostgreSql => "PostgreSql",
            InferredWorkloadType::Redis => "Redis",
            InferredWorkloadType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AmazonEmr", "ApacheCassandra", "ApacheHadoop", "Memcached", "Nginx", "PostgreSql", "Redis"
        ]
    }
}
impl AsRef<str> for InferredWorkloadType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the effective recommendation preferences for a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EffectiveRecommendationPreferences  {
    /// <p>Describes the CPU vendor and architecture for an instance or Auto Scaling group recommendations.</p> 
    /// <p>For example, when you specify <code>AWS_ARM64</code> with:</p> 
    /// <ul> 
    /// <li> <p>A <code>GetEC2InstanceRecommendations</code> or <code>GetAutoScalingGroupRecommendations</code> request, Compute Optimizer returns recommendations that consist of Graviton2 instance types only.</p> </li> 
    /// <li> <p>A <code>GetEC2RecommendationProjectedMetrics</code> request, Compute Optimizer returns projected utilization metrics for Graviton2 instance type recommendations only.</p> </li> 
    /// <li> <p>A <code>ExportEC2InstanceRecommendations</code> or <code>ExportAutoScalingGroupRecommendations</code> request, Compute Optimizer exports recommendations that consist of Graviton2 instance types only.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub cpu_vendor_architectures: std::option::Option<std::vec::Vec<crate::model::CpuVendorArchitecture>>,
    /// <p>Describes the activation status of the enhanced infrastructure metrics preference.</p> 
    /// <p>A status of <code>Active</code> confirms that the preference is applied in the latest recommendation refresh, and a status of <code>Inactive</code> confirms that it's not yet applied to recommendations.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
    #[doc(hidden)]
    pub enhanced_infrastructure_metrics: std::option::Option<crate::model::EnhancedInfrastructureMetrics>,
    /// <p>Describes the activation status of the inferred workload types preference.</p> 
    /// <p>A status of <code>Active</code> confirms that the preference is applied in the latest recommendation refresh. A status of <code>Inactive</code> confirms that it's not yet applied to recommendations.</p>
    #[doc(hidden)]
    pub inferred_workload_types: std::option::Option<crate::model::InferredWorkloadTypesPreference>,
    /// <p> An object that describes the external metrics recommendation preference. </p> 
    /// <p> If the preference is applied in the latest recommendation refresh, an object with a valid <code>source</code> value appears in the response. If the preference isn't applied to the recommendations already, then this object doesn't appear in the response. </p>
    #[doc(hidden)]
    pub external_metrics_preference: std::option::Option<crate::model::ExternalMetricsPreference>,
}
impl EffectiveRecommendationPreferences {
    /// <p>Describes the CPU vendor and architecture for an instance or Auto Scaling group recommendations.</p> 
    /// <p>For example, when you specify <code>AWS_ARM64</code> with:</p> 
    /// <ul> 
    /// <li> <p>A <code>GetEC2InstanceRecommendations</code> or <code>GetAutoScalingGroupRecommendations</code> request, Compute Optimizer returns recommendations that consist of Graviton2 instance types only.</p> </li> 
    /// <li> <p>A <code>GetEC2RecommendationProjectedMetrics</code> request, Compute Optimizer returns projected utilization metrics for Graviton2 instance type recommendations only.</p> </li> 
    /// <li> <p>A <code>ExportEC2InstanceRecommendations</code> or <code>ExportAutoScalingGroupRecommendations</code> request, Compute Optimizer exports recommendations that consist of Graviton2 instance types only.</p> </li> 
    /// </ul>
    pub fn cpu_vendor_architectures(&self) -> std::option::Option<& [crate::model::CpuVendorArchitecture]> {
        self.cpu_vendor_architectures.as_deref()
    }
    /// <p>Describes the activation status of the enhanced infrastructure metrics preference.</p> 
    /// <p>A status of <code>Active</code> confirms that the preference is applied in the latest recommendation refresh, and a status of <code>Inactive</code> confirms that it's not yet applied to recommendations.</p> 
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
    pub fn enhanced_infrastructure_metrics(&self) -> std::option::Option<& crate::model::EnhancedInfrastructureMetrics> {
        self.enhanced_infrastructure_metrics.as_ref()
    }
    /// <p>Describes the activation status of the inferred workload types preference.</p> 
    /// <p>A status of <code>Active</code> confirms that the preference is applied in the latest recommendation refresh. A status of <code>Inactive</code> confirms that it's not yet applied to recommendations.</p>
    pub fn inferred_workload_types(&self) -> std::option::Option<& crate::model::InferredWorkloadTypesPreference> {
        self.inferred_workload_types.as_ref()
    }
    /// <p> An object that describes the external metrics recommendation preference. </p> 
    /// <p> If the preference is applied in the latest recommendation refresh, an object with a valid <code>source</code> value appears in the response. If the preference isn't applied to the recommendations already, then this object doesn't appear in the response. </p>
    pub fn external_metrics_preference(&self) -> std::option::Option<& crate::model::ExternalMetricsPreference> {
        self.external_metrics_preference.as_ref()
    }
}
/// See [`EffectiveRecommendationPreferences`](crate::model::EffectiveRecommendationPreferences).
pub mod effective_recommendation_preferences {
    
    /// A builder for [`EffectiveRecommendationPreferences`](crate::model::EffectiveRecommendationPreferences).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cpu_vendor_architectures: std::option::Option<std::vec::Vec<crate::model::CpuVendorArchitecture>>,
        pub(crate) enhanced_infrastructure_metrics: std::option::Option<crate::model::EnhancedInfrastructureMetrics>,
        pub(crate) inferred_workload_types: std::option::Option<crate::model::InferredWorkloadTypesPreference>,
        pub(crate) external_metrics_preference: std::option::Option<crate::model::ExternalMetricsPreference>,
    }
    impl Builder {
        /// Appends an item to `cpu_vendor_architectures`.
        ///
        /// To override the contents of this collection use [`set_cpu_vendor_architectures`](Self::set_cpu_vendor_architectures).
        ///
        /// <p>Describes the CPU vendor and architecture for an instance or Auto Scaling group recommendations.</p> 
        /// <p>For example, when you specify <code>AWS_ARM64</code> with:</p> 
        /// <ul> 
        /// <li> <p>A <code>GetEC2InstanceRecommendations</code> or <code>GetAutoScalingGroupRecommendations</code> request, Compute Optimizer returns recommendations that consist of Graviton2 instance types only.</p> </li> 
        /// <li> <p>A <code>GetEC2RecommendationProjectedMetrics</code> request, Compute Optimizer returns projected utilization metrics for Graviton2 instance type recommendations only.</p> </li> 
        /// <li> <p>A <code>ExportEC2InstanceRecommendations</code> or <code>ExportAutoScalingGroupRecommendations</code> request, Compute Optimizer exports recommendations that consist of Graviton2 instance types only.</p> </li> 
        /// </ul>
        pub fn cpu_vendor_architectures(mut self, input: crate::model::CpuVendorArchitecture) -> Self {
            let mut v = self.cpu_vendor_architectures.unwrap_or_default();
                            v.push(input);
                            self.cpu_vendor_architectures = Some(v);
                            self
        }
        /// <p>Describes the CPU vendor and architecture for an instance or Auto Scaling group recommendations.</p> 
        /// <p>For example, when you specify <code>AWS_ARM64</code> with:</p> 
        /// <ul> 
        /// <li> <p>A <code>GetEC2InstanceRecommendations</code> or <code>GetAutoScalingGroupRecommendations</code> request, Compute Optimizer returns recommendations that consist of Graviton2 instance types only.</p> </li> 
        /// <li> <p>A <code>GetEC2RecommendationProjectedMetrics</code> request, Compute Optimizer returns projected utilization metrics for Graviton2 instance type recommendations only.</p> </li> 
        /// <li> <p>A <code>ExportEC2InstanceRecommendations</code> or <code>ExportAutoScalingGroupRecommendations</code> request, Compute Optimizer exports recommendations that consist of Graviton2 instance types only.</p> </li> 
        /// </ul>
        pub fn set_cpu_vendor_architectures(mut self, input: std::option::Option<std::vec::Vec<crate::model::CpuVendorArchitecture>>) -> Self {
            self.cpu_vendor_architectures = input; self
        }
        /// <p>Describes the activation status of the enhanced infrastructure metrics preference.</p> 
        /// <p>A status of <code>Active</code> confirms that the preference is applied in the latest recommendation refresh, and a status of <code>Inactive</code> confirms that it's not yet applied to recommendations.</p> 
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
        pub fn enhanced_infrastructure_metrics(mut self, input: crate::model::EnhancedInfrastructureMetrics) -> Self {
            self.enhanced_infrastructure_metrics = Some(input);
            self
        }
        /// <p>Describes the activation status of the enhanced infrastructure metrics preference.</p> 
        /// <p>A status of <code>Active</code> confirms that the preference is applied in the latest recommendation refresh, and a status of <code>Inactive</code> confirms that it's not yet applied to recommendations.</p> 
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/enhanced-infrastructure-metrics.html">Enhanced infrastructure metrics</a> in the <i>Compute Optimizer User Guide</i>.</p>
        pub fn set_enhanced_infrastructure_metrics(mut self, input: std::option::Option<crate::model::EnhancedInfrastructureMetrics>) -> Self {
            self.enhanced_infrastructure_metrics = input; self
        }
        /// <p>Describes the activation status of the inferred workload types preference.</p> 
        /// <p>A status of <code>Active</code> confirms that the preference is applied in the latest recommendation refresh. A status of <code>Inactive</code> confirms that it's not yet applied to recommendations.</p>
        pub fn inferred_workload_types(mut self, input: crate::model::InferredWorkloadTypesPreference) -> Self {
            self.inferred_workload_types = Some(input);
            self
        }
        /// <p>Describes the activation status of the inferred workload types preference.</p> 
        /// <p>A status of <code>Active</code> confirms that the preference is applied in the latest recommendation refresh. A status of <code>Inactive</code> confirms that it's not yet applied to recommendations.</p>
        pub fn set_inferred_workload_types(mut self, input: std::option::Option<crate::model::InferredWorkloadTypesPreference>) -> Self {
            self.inferred_workload_types = input; self
        }
        /// <p> An object that describes the external metrics recommendation preference. </p> 
        /// <p> If the preference is applied in the latest recommendation refresh, an object with a valid <code>source</code> value appears in the response. If the preference isn't applied to the recommendations already, then this object doesn't appear in the response. </p>
        pub fn external_metrics_preference(mut self, input: crate::model::ExternalMetricsPreference) -> Self {
            self.external_metrics_preference = Some(input);
            self
        }
        /// <p> An object that describes the external metrics recommendation preference. </p> 
        /// <p> If the preference is applied in the latest recommendation refresh, an object with a valid <code>source</code> value appears in the response. If the preference isn't applied to the recommendations already, then this object doesn't appear in the response. </p>
        pub fn set_external_metrics_preference(mut self, input: std::option::Option<crate::model::ExternalMetricsPreference>) -> Self {
            self.external_metrics_preference = input; self
        }
        /// Consumes the builder and constructs a [`EffectiveRecommendationPreferences`](crate::model::EffectiveRecommendationPreferences).
        pub fn build(self) -> crate::model::EffectiveRecommendationPreferences {
            crate::model::EffectiveRecommendationPreferences {
                cpu_vendor_architectures: self.cpu_vendor_architectures
                ,
                enhanced_infrastructure_metrics: self.enhanced_infrastructure_metrics
                ,
                inferred_workload_types: self.inferred_workload_types
                ,
                external_metrics_preference: self.external_metrics_preference
                ,
            }
        }
    }
    
    
}
impl EffectiveRecommendationPreferences {
    /// Creates a new builder-style object to manufacture [`EffectiveRecommendationPreferences`](crate::model::EffectiveRecommendationPreferences).
    pub fn builder() -> crate::model::effective_recommendation_preferences::Builder {
        crate::model::effective_recommendation_preferences::Builder::default()
    }
}

/// <p>Describes the source of a recommendation, such as an Amazon EC2 instance or Auto Scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendationSource  {
    /// <p>The Amazon Resource Name (ARN) of the recommendation source.</p>
    #[doc(hidden)]
    pub recommendation_source_arn: std::option::Option<std::string::String>,
    /// <p>The resource type of the recommendation source.</p>
    #[doc(hidden)]
    pub recommendation_source_type: std::option::Option<crate::model::RecommendationSourceType>,
}
impl RecommendationSource {
    /// <p>The Amazon Resource Name (ARN) of the recommendation source.</p>
    pub fn recommendation_source_arn(&self) -> std::option::Option<& str> {
        self.recommendation_source_arn.as_deref()
    }
    /// <p>The resource type of the recommendation source.</p>
    pub fn recommendation_source_type(&self) -> std::option::Option<& crate::model::RecommendationSourceType> {
        self.recommendation_source_type.as_ref()
    }
}
/// See [`RecommendationSource`](crate::model::RecommendationSource).
pub mod recommendation_source {
    
    /// A builder for [`RecommendationSource`](crate::model::RecommendationSource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation_source_arn: std::option::Option<std::string::String>,
        pub(crate) recommendation_source_type: std::option::Option<crate::model::RecommendationSourceType>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the recommendation source.</p>
        pub fn recommendation_source_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation_source_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the recommendation source.</p>
        pub fn set_recommendation_source_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.recommendation_source_arn = input; self
        }
        /// <p>The resource type of the recommendation source.</p>
        pub fn recommendation_source_type(mut self, input: crate::model::RecommendationSourceType) -> Self {
            self.recommendation_source_type = Some(input);
            self
        }
        /// <p>The resource type of the recommendation source.</p>
        pub fn set_recommendation_source_type(mut self, input: std::option::Option<crate::model::RecommendationSourceType>) -> Self {
            self.recommendation_source_type = input; self
        }
        /// Consumes the builder and constructs a [`RecommendationSource`](crate::model::RecommendationSource).
        pub fn build(self) -> crate::model::RecommendationSource {
            crate::model::RecommendationSource {
                recommendation_source_arn: self.recommendation_source_arn
                ,
                recommendation_source_type: self.recommendation_source_type
                ,
            }
        }
    }
    
    
}
impl RecommendationSource {
    /// Creates a new builder-style object to manufacture [`RecommendationSource`](crate::model::RecommendationSource).
    pub fn builder() -> crate::model::recommendation_source::Builder {
        crate::model::recommendation_source::Builder::default()
    }
}

/// <p>Describes a recommendation option for an Amazon EC2 instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceRecommendationOption  {
    /// <p>The instance type of the instance recommendation.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>An array of objects that describe the projected utilization metrics of the instance recommendation option.</p> <note> 
    /// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
    /// </note>
    #[doc(hidden)]
    pub projected_utilization_metrics: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>,
    /// <p>Describes the configuration differences between the current instance and the recommended instance type. You should consider the configuration differences before migrating your workloads from the current instance to the recommended instance type. The <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html">Change the instance type guide for Linux</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-resize.html">Change the instance type guide for Windows</a> provide general guidance for getting started with an instance migration.</p> 
    /// <p>Platform differences include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>Hypervisor</code> </b>  The hypervisor of the recommended instance type is different than that of the current instance. For example, the recommended instance type uses a Nitro hypervisor and the current instance uses a Xen hypervisor. The differences that you should consider between these hypervisors are covered in the <a href="http://aws.amazon.com/ec2/faqs/#Nitro_Hypervisor">Nitro Hypervisor</a> section of the Amazon EC2 frequently asked questions. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>NetworkInterface</code> </b>  The network interface of the recommended instance type is different than that of the current instance. For example, the recommended instance type supports enhanced networking and the current instance might not. To enable enhanced networking for the recommended instance type, you must install the Elastic Network Adapter (ENA) driver or the Intel 82599 Virtual Function driver. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking.html">Enhanced networking on Linux</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/enhanced-networking.html">Enhanced networking on Windows</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>StorageInterface</code> </b>  The storage interface of the recommended instance type is different than that of the current instance. For example, the recommended instance type uses an NVMe storage interface and the current instance does not. To access NVMe volumes for the recommended instance type, you will need to install or upgrade the NVMe driver. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe on Linux instances</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe on Windows instances</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>InstanceStoreAvailability</code> </b>  The recommended instance type does not support instance store volumes and the current instance does. Before migrating, you might need to back up the data on your instance store volumes if you want to preserve them. For more information, see <a href="https://aws.amazon.com/premiumsupport/knowledge-center/back-up-instance-store-ebs/">How do I back up an instance store volume on my Amazon EC2 instance to Amazon EBS?</a> in the <i>Amazon Web Services Premium Support Knowledge Base</i>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html">Amazon EC2 instance store</a> in the <i>Amazon EC2 User Guide for Linux</i>, or see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/InstanceStorage.html">Amazon EC2 instance store</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>VirtualizationType</code> </b>  The recommended instance type uses the hardware virtual machine (HVM) virtualization type and the current instance uses the paravirtual (PV) virtualization type. For more information about the differences between these virtualization types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/virtualization_types.html">Linux AMI virtualization types</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/windows-ami-version-history.html#virtualization-types">Windows AMI virtualization types</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>Architecture</code> </b>  The CPU architecture between the recommended instance type and the current instance is different. For example, the recommended instance type might use an Arm CPU architecture and the current instance type might use a different one, such as x86. Before migrating, you should consider recompiling the software on your instance for the new architecture. Alternatively, you might switch to an Amazon Machine Image (AMI) that supports the new architecture. For more information about the CPU architecture for each instance type, see <a href="http://aws.amazon.com/ec2/instance-types/">Amazon EC2 Instance Types</a>.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub platform_differences: std::option::Option<std::vec::Vec<crate::model::PlatformDifference>>,
    /// <p>The performance risk of the instance recommendation option.</p> 
    /// <p>Performance risk indicates the likelihood of the recommended instance type not meeting the resource needs of your workload. Compute Optimizer calculates an individual performance risk score for each specification of the recommended instance, including CPU, memory, EBS throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS. The performance risk of the recommended instance is calculated as the maximum performance risk score across the analyzed resource specifications.</p> 
    /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
    #[doc(hidden)]
    pub performance_risk: f64,
    /// <p>The rank of the instance recommendation option.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p>
    #[doc(hidden)]
    pub rank: i32,
    /// <p>An object that describes the savings opportunity for the instance recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    #[doc(hidden)]
    pub savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
    /// <p>The level of effort required to migrate from the current instance type to the recommended instance type.</p> 
    /// <p>For example, the migration effort is <code>Low</code> if Amazon EMR is the inferred workload type and an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>Medium</code> if a workload type couldn't be inferred but an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>VeryLow</code> if both the current and recommended instance types are of the same CPU architecture.</p>
    #[doc(hidden)]
    pub migration_effort: std::option::Option<crate::model::MigrationEffort>,
}
impl InstanceRecommendationOption {
    /// <p>The instance type of the instance recommendation.</p>
    pub fn instance_type(&self) -> std::option::Option<& str> {
        self.instance_type.as_deref()
    }
    /// <p>An array of objects that describe the projected utilization metrics of the instance recommendation option.</p> <note> 
    /// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
    /// </note>
    pub fn projected_utilization_metrics(&self) -> std::option::Option<& [crate::model::UtilizationMetric]> {
        self.projected_utilization_metrics.as_deref()
    }
    /// <p>Describes the configuration differences between the current instance and the recommended instance type. You should consider the configuration differences before migrating your workloads from the current instance to the recommended instance type. The <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html">Change the instance type guide for Linux</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-resize.html">Change the instance type guide for Windows</a> provide general guidance for getting started with an instance migration.</p> 
    /// <p>Platform differences include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>Hypervisor</code> </b>  The hypervisor of the recommended instance type is different than that of the current instance. For example, the recommended instance type uses a Nitro hypervisor and the current instance uses a Xen hypervisor. The differences that you should consider between these hypervisors are covered in the <a href="http://aws.amazon.com/ec2/faqs/#Nitro_Hypervisor">Nitro Hypervisor</a> section of the Amazon EC2 frequently asked questions. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>NetworkInterface</code> </b>  The network interface of the recommended instance type is different than that of the current instance. For example, the recommended instance type supports enhanced networking and the current instance might not. To enable enhanced networking for the recommended instance type, you must install the Elastic Network Adapter (ENA) driver or the Intel 82599 Virtual Function driver. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking.html">Enhanced networking on Linux</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/enhanced-networking.html">Enhanced networking on Windows</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>StorageInterface</code> </b>  The storage interface of the recommended instance type is different than that of the current instance. For example, the recommended instance type uses an NVMe storage interface and the current instance does not. To access NVMe volumes for the recommended instance type, you will need to install or upgrade the NVMe driver. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe on Linux instances</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe on Windows instances</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>InstanceStoreAvailability</code> </b>  The recommended instance type does not support instance store volumes and the current instance does. Before migrating, you might need to back up the data on your instance store volumes if you want to preserve them. For more information, see <a href="https://aws.amazon.com/premiumsupport/knowledge-center/back-up-instance-store-ebs/">How do I back up an instance store volume on my Amazon EC2 instance to Amazon EBS?</a> in the <i>Amazon Web Services Premium Support Knowledge Base</i>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html">Amazon EC2 instance store</a> in the <i>Amazon EC2 User Guide for Linux</i>, or see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/InstanceStorage.html">Amazon EC2 instance store</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>VirtualizationType</code> </b>  The recommended instance type uses the hardware virtual machine (HVM) virtualization type and the current instance uses the paravirtual (PV) virtualization type. For more information about the differences between these virtualization types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/virtualization_types.html">Linux AMI virtualization types</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/windows-ami-version-history.html#virtualization-types">Windows AMI virtualization types</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
    /// <li> <p> <b> <code>Architecture</code> </b>  The CPU architecture between the recommended instance type and the current instance is different. For example, the recommended instance type might use an Arm CPU architecture and the current instance type might use a different one, such as x86. Before migrating, you should consider recompiling the software on your instance for the new architecture. Alternatively, you might switch to an Amazon Machine Image (AMI) that supports the new architecture. For more information about the CPU architecture for each instance type, see <a href="http://aws.amazon.com/ec2/instance-types/">Amazon EC2 Instance Types</a>.</p> </li> 
    /// </ul>
    pub fn platform_differences(&self) -> std::option::Option<& [crate::model::PlatformDifference]> {
        self.platform_differences.as_deref()
    }
    /// <p>The performance risk of the instance recommendation option.</p> 
    /// <p>Performance risk indicates the likelihood of the recommended instance type not meeting the resource needs of your workload. Compute Optimizer calculates an individual performance risk score for each specification of the recommended instance, including CPU, memory, EBS throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS. The performance risk of the recommended instance is calculated as the maximum performance risk score across the analyzed resource specifications.</p> 
    /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
    pub fn performance_risk(&self) -> f64 {
        self.performance_risk
    }
    /// <p>The rank of the instance recommendation option.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p>
    pub fn rank(&self) -> i32 {
        self.rank
    }
    /// <p>An object that describes the savings opportunity for the instance recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    pub fn savings_opportunity(&self) -> std::option::Option<& crate::model::SavingsOpportunity> {
        self.savings_opportunity.as_ref()
    }
    /// <p>The level of effort required to migrate from the current instance type to the recommended instance type.</p> 
    /// <p>For example, the migration effort is <code>Low</code> if Amazon EMR is the inferred workload type and an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>Medium</code> if a workload type couldn't be inferred but an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>VeryLow</code> if both the current and recommended instance types are of the same CPU architecture.</p>
    pub fn migration_effort(&self) -> std::option::Option<& crate::model::MigrationEffort> {
        self.migration_effort.as_ref()
    }
}
/// See [`InstanceRecommendationOption`](crate::model::InstanceRecommendationOption).
pub mod instance_recommendation_option {
    
    /// A builder for [`InstanceRecommendationOption`](crate::model::InstanceRecommendationOption).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) projected_utilization_metrics: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>,
        pub(crate) platform_differences: std::option::Option<std::vec::Vec<crate::model::PlatformDifference>>,
        pub(crate) performance_risk: std::option::Option<f64>,
        pub(crate) rank: std::option::Option<i32>,
        pub(crate) savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
        pub(crate) migration_effort: std::option::Option<crate::model::MigrationEffort>,
    }
    impl Builder {
        /// <p>The instance type of the instance recommendation.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type of the instance recommendation.</p>
        pub fn set_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_type = input; self
        }
        /// Appends an item to `projected_utilization_metrics`.
        ///
        /// To override the contents of this collection use [`set_projected_utilization_metrics`](Self::set_projected_utilization_metrics).
        ///
        /// <p>An array of objects that describe the projected utilization metrics of the instance recommendation option.</p> <note> 
        /// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
        /// </note>
        pub fn projected_utilization_metrics(mut self, input: crate::model::UtilizationMetric) -> Self {
            let mut v = self.projected_utilization_metrics.unwrap_or_default();
                            v.push(input);
                            self.projected_utilization_metrics = Some(v);
                            self
        }
        /// <p>An array of objects that describe the projected utilization metrics of the instance recommendation option.</p> <note> 
        /// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
        /// </note>
        pub fn set_projected_utilization_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>) -> Self {
            self.projected_utilization_metrics = input; self
        }
        /// Appends an item to `platform_differences`.
        ///
        /// To override the contents of this collection use [`set_platform_differences`](Self::set_platform_differences).
        ///
        /// <p>Describes the configuration differences between the current instance and the recommended instance type. You should consider the configuration differences before migrating your workloads from the current instance to the recommended instance type. The <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html">Change the instance type guide for Linux</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-resize.html">Change the instance type guide for Windows</a> provide general guidance for getting started with an instance migration.</p> 
        /// <p>Platform differences include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>Hypervisor</code> </b>  The hypervisor of the recommended instance type is different than that of the current instance. For example, the recommended instance type uses a Nitro hypervisor and the current instance uses a Xen hypervisor. The differences that you should consider between these hypervisors are covered in the <a href="http://aws.amazon.com/ec2/faqs/#Nitro_Hypervisor">Nitro Hypervisor</a> section of the Amazon EC2 frequently asked questions. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>NetworkInterface</code> </b>  The network interface of the recommended instance type is different than that of the current instance. For example, the recommended instance type supports enhanced networking and the current instance might not. To enable enhanced networking for the recommended instance type, you must install the Elastic Network Adapter (ENA) driver or the Intel 82599 Virtual Function driver. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking.html">Enhanced networking on Linux</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/enhanced-networking.html">Enhanced networking on Windows</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>StorageInterface</code> </b>  The storage interface of the recommended instance type is different than that of the current instance. For example, the recommended instance type uses an NVMe storage interface and the current instance does not. To access NVMe volumes for the recommended instance type, you will need to install or upgrade the NVMe driver. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe on Linux instances</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe on Windows instances</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>InstanceStoreAvailability</code> </b>  The recommended instance type does not support instance store volumes and the current instance does. Before migrating, you might need to back up the data on your instance store volumes if you want to preserve them. For more information, see <a href="https://aws.amazon.com/premiumsupport/knowledge-center/back-up-instance-store-ebs/">How do I back up an instance store volume on my Amazon EC2 instance to Amazon EBS?</a> in the <i>Amazon Web Services Premium Support Knowledge Base</i>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html">Amazon EC2 instance store</a> in the <i>Amazon EC2 User Guide for Linux</i>, or see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/InstanceStorage.html">Amazon EC2 instance store</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>VirtualizationType</code> </b>  The recommended instance type uses the hardware virtual machine (HVM) virtualization type and the current instance uses the paravirtual (PV) virtualization type. For more information about the differences between these virtualization types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/virtualization_types.html">Linux AMI virtualization types</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/windows-ami-version-history.html#virtualization-types">Windows AMI virtualization types</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>Architecture</code> </b>  The CPU architecture between the recommended instance type and the current instance is different. For example, the recommended instance type might use an Arm CPU architecture and the current instance type might use a different one, such as x86. Before migrating, you should consider recompiling the software on your instance for the new architecture. Alternatively, you might switch to an Amazon Machine Image (AMI) that supports the new architecture. For more information about the CPU architecture for each instance type, see <a href="http://aws.amazon.com/ec2/instance-types/">Amazon EC2 Instance Types</a>.</p> </li> 
        /// </ul>
        pub fn platform_differences(mut self, input: crate::model::PlatformDifference) -> Self {
            let mut v = self.platform_differences.unwrap_or_default();
                            v.push(input);
                            self.platform_differences = Some(v);
                            self
        }
        /// <p>Describes the configuration differences between the current instance and the recommended instance type. You should consider the configuration differences before migrating your workloads from the current instance to the recommended instance type. The <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html">Change the instance type guide for Linux</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-resize.html">Change the instance type guide for Windows</a> provide general guidance for getting started with an instance migration.</p> 
        /// <p>Platform differences include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>Hypervisor</code> </b>  The hypervisor of the recommended instance type is different than that of the current instance. For example, the recommended instance type uses a Nitro hypervisor and the current instance uses a Xen hypervisor. The differences that you should consider between these hypervisors are covered in the <a href="http://aws.amazon.com/ec2/faqs/#Nitro_Hypervisor">Nitro Hypervisor</a> section of the Amazon EC2 frequently asked questions. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>NetworkInterface</code> </b>  The network interface of the recommended instance type is different than that of the current instance. For example, the recommended instance type supports enhanced networking and the current instance might not. To enable enhanced networking for the recommended instance type, you must install the Elastic Network Adapter (ENA) driver or the Intel 82599 Virtual Function driver. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/enhanced-networking.html">Enhanced networking on Linux</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/enhanced-networking.html">Enhanced networking on Windows</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>StorageInterface</code> </b>  The storage interface of the recommended instance type is different than that of the current instance. For example, the recommended instance type uses an NVMe storage interface and the current instance does not. To access NVMe volumes for the recommended instance type, you will need to install or upgrade the NVMe driver. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe on Linux instances</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/nvme-ebs-volumes.html">Amazon EBS and NVMe on Windows instances</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>InstanceStoreAvailability</code> </b>  The recommended instance type does not support instance store volumes and the current instance does. Before migrating, you might need to back up the data on your instance store volumes if you want to preserve them. For more information, see <a href="https://aws.amazon.com/premiumsupport/knowledge-center/back-up-instance-store-ebs/">How do I back up an instance store volume on my Amazon EC2 instance to Amazon EBS?</a> in the <i>Amazon Web Services Premium Support Knowledge Base</i>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html">Amazon EC2 instance store</a> in the <i>Amazon EC2 User Guide for Linux</i>, or see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instance-types.html#instance-networking-storage">Networking and storage features</a> and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/InstanceStorage.html">Amazon EC2 instance store</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>VirtualizationType</code> </b>  The recommended instance type uses the hardware virtual machine (HVM) virtualization type and the current instance uses the paravirtual (PV) virtualization type. For more information about the differences between these virtualization types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/virtualization_types.html">Linux AMI virtualization types</a> in the <i>Amazon EC2 User Guide for Linux</i>, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/windows-ami-version-history.html#virtualization-types">Windows AMI virtualization types</a> in the <i>Amazon EC2 User Guide for Windows</i>.</p> </li> 
        /// <li> <p> <b> <code>Architecture</code> </b>  The CPU architecture between the recommended instance type and the current instance is different. For example, the recommended instance type might use an Arm CPU architecture and the current instance type might use a different one, such as x86. Before migrating, you should consider recompiling the software on your instance for the new architecture. Alternatively, you might switch to an Amazon Machine Image (AMI) that supports the new architecture. For more information about the CPU architecture for each instance type, see <a href="http://aws.amazon.com/ec2/instance-types/">Amazon EC2 Instance Types</a>.</p> </li> 
        /// </ul>
        pub fn set_platform_differences(mut self, input: std::option::Option<std::vec::Vec<crate::model::PlatformDifference>>) -> Self {
            self.platform_differences = input; self
        }
        /// <p>The performance risk of the instance recommendation option.</p> 
        /// <p>Performance risk indicates the likelihood of the recommended instance type not meeting the resource needs of your workload. Compute Optimizer calculates an individual performance risk score for each specification of the recommended instance, including CPU, memory, EBS throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS. The performance risk of the recommended instance is calculated as the maximum performance risk score across the analyzed resource specifications.</p> 
        /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
        pub fn performance_risk(mut self, input: f64) -> Self {
            self.performance_risk = Some(input);
            self
        }
        /// <p>The performance risk of the instance recommendation option.</p> 
        /// <p>Performance risk indicates the likelihood of the recommended instance type not meeting the resource needs of your workload. Compute Optimizer calculates an individual performance risk score for each specification of the recommended instance, including CPU, memory, EBS throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS. The performance risk of the recommended instance is calculated as the maximum performance risk score across the analyzed resource specifications.</p> 
        /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
        pub fn set_performance_risk(mut self, input: std::option::Option<f64>) -> Self {
            self.performance_risk = input; self
        }
        /// <p>The rank of the instance recommendation option.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p>
        pub fn rank(mut self, input: i32) -> Self {
            self.rank = Some(input);
            self
        }
        /// <p>The rank of the instance recommendation option.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p>
        pub fn set_rank(mut self, input: std::option::Option<i32>) -> Self {
            self.rank = input; self
        }
        /// <p>An object that describes the savings opportunity for the instance recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn savings_opportunity(mut self, input: crate::model::SavingsOpportunity) -> Self {
            self.savings_opportunity = Some(input);
            self
        }
        /// <p>An object that describes the savings opportunity for the instance recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn set_savings_opportunity(mut self, input: std::option::Option<crate::model::SavingsOpportunity>) -> Self {
            self.savings_opportunity = input; self
        }
        /// <p>The level of effort required to migrate from the current instance type to the recommended instance type.</p> 
        /// <p>For example, the migration effort is <code>Low</code> if Amazon EMR is the inferred workload type and an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>Medium</code> if a workload type couldn't be inferred but an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>VeryLow</code> if both the current and recommended instance types are of the same CPU architecture.</p>
        pub fn migration_effort(mut self, input: crate::model::MigrationEffort) -> Self {
            self.migration_effort = Some(input);
            self
        }
        /// <p>The level of effort required to migrate from the current instance type to the recommended instance type.</p> 
        /// <p>For example, the migration effort is <code>Low</code> if Amazon EMR is the inferred workload type and an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>Medium</code> if a workload type couldn't be inferred but an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>VeryLow</code> if both the current and recommended instance types are of the same CPU architecture.</p>
        pub fn set_migration_effort(mut self, input: std::option::Option<crate::model::MigrationEffort>) -> Self {
            self.migration_effort = input; self
        }
        /// Consumes the builder and constructs a [`InstanceRecommendationOption`](crate::model::InstanceRecommendationOption).
        pub fn build(self) -> crate::model::InstanceRecommendationOption {
            crate::model::InstanceRecommendationOption {
                instance_type: self.instance_type
                ,
                projected_utilization_metrics: self.projected_utilization_metrics
                ,
                platform_differences: self.platform_differences
                ,
                performance_risk: self.performance_risk
                    .unwrap_or_default()
                ,
                rank: self.rank
                    .unwrap_or_default()
                ,
                savings_opportunity: self.savings_opportunity
                ,
                migration_effort: self.migration_effort
                ,
            }
        }
    }
    
    
}
impl InstanceRecommendationOption {
    /// Creates a new builder-style object to manufacture [`InstanceRecommendationOption`](crate::model::InstanceRecommendationOption).
    pub fn builder() -> crate::model::instance_recommendation_option::Builder {
        crate::model::instance_recommendation_option::Builder::default()
    }
}

/// When writing a match expression against `MigrationEffort`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let migrationeffort = unimplemented!();
/// match migrationeffort {
///     MigrationEffort::High => { /* ... */ },
///     MigrationEffort::Low => { /* ... */ },
///     MigrationEffort::Medium => { /* ... */ },
///     MigrationEffort::VeryLow => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `migrationeffort` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MigrationEffort::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MigrationEffort::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MigrationEffort::NewFeature` is defined.
/// Specifically, when `migrationeffort` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MigrationEffort::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum MigrationEffort {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    VeryLow,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for MigrationEffort {
    fn from(s: &str) -> Self {
        match s {
            "High" => MigrationEffort::High,
            "Low" => MigrationEffort::Low,
            "Medium" => MigrationEffort::Medium,
            "VeryLow" => MigrationEffort::VeryLow,
            other => MigrationEffort::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for MigrationEffort {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(MigrationEffort::from(s))
                }
            }
impl MigrationEffort {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MigrationEffort::High => "High",
            MigrationEffort::Low => "Low",
            MigrationEffort::Medium => "Medium",
            MigrationEffort::VeryLow => "VeryLow",
            MigrationEffort::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "High", "Low", "Medium", "VeryLow"
        ]
    }
}
impl AsRef<str> for MigrationEffort {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PlatformDifference`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let platformdifference = unimplemented!();
/// match platformdifference {
///     PlatformDifference::Architecture => { /* ... */ },
///     PlatformDifference::Hypervisor => { /* ... */ },
///     PlatformDifference::InstanceStoreAvailability => { /* ... */ },
///     PlatformDifference::NetworkInterface => { /* ... */ },
///     PlatformDifference::StorageInterface => { /* ... */ },
///     PlatformDifference::VirtualizationType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `platformdifference` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PlatformDifference::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PlatformDifference::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PlatformDifference::NewFeature` is defined.
/// Specifically, when `platformdifference` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PlatformDifference::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum PlatformDifference {
    #[allow(missing_docs)] // documentation missing in model
    Architecture,
    #[allow(missing_docs)] // documentation missing in model
    Hypervisor,
    #[allow(missing_docs)] // documentation missing in model
    InstanceStoreAvailability,
    #[allow(missing_docs)] // documentation missing in model
    NetworkInterface,
    #[allow(missing_docs)] // documentation missing in model
    StorageInterface,
    #[allow(missing_docs)] // documentation missing in model
    VirtualizationType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for PlatformDifference {
    fn from(s: &str) -> Self {
        match s {
            "Architecture" => PlatformDifference::Architecture,
            "Hypervisor" => PlatformDifference::Hypervisor,
            "InstanceStoreAvailability" => PlatformDifference::InstanceStoreAvailability,
            "NetworkInterface" => PlatformDifference::NetworkInterface,
            "StorageInterface" => PlatformDifference::StorageInterface,
            "VirtualizationType" => PlatformDifference::VirtualizationType,
            other => PlatformDifference::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for PlatformDifference {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(PlatformDifference::from(s))
                }
            }
impl PlatformDifference {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PlatformDifference::Architecture => "Architecture",
            PlatformDifference::Hypervisor => "Hypervisor",
            PlatformDifference::InstanceStoreAvailability => "InstanceStoreAvailability",
            PlatformDifference::NetworkInterface => "NetworkInterface",
            PlatformDifference::StorageInterface => "StorageInterface",
            PlatformDifference::VirtualizationType => "VirtualizationType",
            PlatformDifference::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Architecture", "Hypervisor", "InstanceStoreAvailability", "NetworkInterface", "StorageInterface", "VirtualizationType"
        ]
    }
}
impl AsRef<str> for PlatformDifference {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a utilization metric of a resource, such as an Amazon EC2 instance.</p> 
/// <p>Compare the utilization metric data of your resource against its projected utilization metric data to determine the performance difference between your current resource and the recommended option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UtilizationMetric  {
    /// <p>The name of the utilization metric.</p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>Cpu</code> - The percentage of allocated EC2 compute units that are currently in use on the instance. This metric identifies the processing power required to run an application on the instance.</p> <p>Depending on the instance type, tools in your operating system can show a lower percentage than CloudWatch when the instance is not allocated a full processor core.</p> <p>Units: Percent</p> </li> 
    /// <li> <p> <code>Memory</code> - The percentage of memory that is currently in use on the instance. This metric identifies the amount of memory required to run an application on the instance.</p> <p>Units: Percent</p> <note> 
    /// <p>The <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
    /// </note> </li> 
    /// <li> <p> <code>EBS_READ_OPS_PER_SECOND</code> - The completed read operations from all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Count</p> </li> 
    /// <li> <p> <code>EBS_WRITE_OPS_PER_SECOND</code> - The completed write operations to all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Count</p> </li> 
    /// <li> <p> <code>EBS_READ_BYTES_PER_SECOND</code> - The bytes read from all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
    /// <li> <p> <code>EBS_WRITE_BYTES_PER_SECOND</code> - The bytes written to all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
    /// <li> <p> <code>DISK_READ_OPS_PER_SECOND</code> - The completed read operations from all instance store volumes available to the instance in a specified period of time.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
    /// <li> <p> <code>DISK_WRITE_OPS_PER_SECOND</code> - The completed write operations from all instance store volumes available to the instance in a specified period of time.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
    /// <li> <p> <code>DISK_READ_BYTES_PER_SECOND</code> - The bytes read from all instance store volumes available to the instance. This metric is used to determine the volume of the data the application reads from the disk of the instance. This can be used to determine the speed of the application.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
    /// <li> <p> <code>DISK_WRITE_BYTES_PER_SECOND</code> - The bytes written to all instance store volumes available to the instance. This metric is used to determine the volume of the data the application writes onto the disk of the instance. This can be used to determine the speed of the application.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
    /// <li> <p> <code>NETWORK_IN_BYTES_PER_SECOND</code> - The number of bytes received by the instance on all network interfaces. This metric identifies the volume of incoming network traffic to a single instance.</p> </li> 
    /// <li> <p> <code>NETWORK_OUT_BYTES_PER_SECOND</code> - The number of bytes sent out by the instance on all network interfaces. This metric identifies the volume of outgoing network traffic from a single instance.</p> </li> 
    /// <li> <p> <code>NETWORK_PACKETS_IN_PER_SECOND</code> - The number of packets received by the instance on all network interfaces. This metric identifies the volume of incoming traffic in terms of the number of packets on a single instance.</p> </li> 
    /// <li> <p> <code>NETWORK_PACKETS_OUT_PER_SECOND</code> - The number of packets sent out by the instance on all network interfaces. This metric identifies the volume of outgoing traffic in terms of the number of packets on a single instance.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::MetricName>,
    /// <p>The statistic of the utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    #[doc(hidden)]
    pub statistic: std::option::Option<crate::model::MetricStatistic>,
    /// <p>The value of the utilization metric.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl UtilizationMetric {
    /// <p>The name of the utilization metric.</p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>Cpu</code> - The percentage of allocated EC2 compute units that are currently in use on the instance. This metric identifies the processing power required to run an application on the instance.</p> <p>Depending on the instance type, tools in your operating system can show a lower percentage than CloudWatch when the instance is not allocated a full processor core.</p> <p>Units: Percent</p> </li> 
    /// <li> <p> <code>Memory</code> - The percentage of memory that is currently in use on the instance. This metric identifies the amount of memory required to run an application on the instance.</p> <p>Units: Percent</p> <note> 
    /// <p>The <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
    /// </note> </li> 
    /// <li> <p> <code>EBS_READ_OPS_PER_SECOND</code> - The completed read operations from all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Count</p> </li> 
    /// <li> <p> <code>EBS_WRITE_OPS_PER_SECOND</code> - The completed write operations to all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Count</p> </li> 
    /// <li> <p> <code>EBS_READ_BYTES_PER_SECOND</code> - The bytes read from all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
    /// <li> <p> <code>EBS_WRITE_BYTES_PER_SECOND</code> - The bytes written to all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
    /// <li> <p> <code>DISK_READ_OPS_PER_SECOND</code> - The completed read operations from all instance store volumes available to the instance in a specified period of time.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
    /// <li> <p> <code>DISK_WRITE_OPS_PER_SECOND</code> - The completed write operations from all instance store volumes available to the instance in a specified period of time.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
    /// <li> <p> <code>DISK_READ_BYTES_PER_SECOND</code> - The bytes read from all instance store volumes available to the instance. This metric is used to determine the volume of the data the application reads from the disk of the instance. This can be used to determine the speed of the application.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
    /// <li> <p> <code>DISK_WRITE_BYTES_PER_SECOND</code> - The bytes written to all instance store volumes available to the instance. This metric is used to determine the volume of the data the application writes onto the disk of the instance. This can be used to determine the speed of the application.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
    /// <li> <p> <code>NETWORK_IN_BYTES_PER_SECOND</code> - The number of bytes received by the instance on all network interfaces. This metric identifies the volume of incoming network traffic to a single instance.</p> </li> 
    /// <li> <p> <code>NETWORK_OUT_BYTES_PER_SECOND</code> - The number of bytes sent out by the instance on all network interfaces. This metric identifies the volume of outgoing network traffic from a single instance.</p> </li> 
    /// <li> <p> <code>NETWORK_PACKETS_IN_PER_SECOND</code> - The number of packets received by the instance on all network interfaces. This metric identifies the volume of incoming traffic in terms of the number of packets on a single instance.</p> </li> 
    /// <li> <p> <code>NETWORK_PACKETS_OUT_PER_SECOND</code> - The number of packets sent out by the instance on all network interfaces. This metric identifies the volume of outgoing traffic in terms of the number of packets on a single instance.</p> </li> 
    /// </ul>
    pub fn name(&self) -> std::option::Option<& crate::model::MetricName> {
        self.name.as_ref()
    }
    /// <p>The statistic of the utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    pub fn statistic(&self) -> std::option::Option<& crate::model::MetricStatistic> {
        self.statistic.as_ref()
    }
    /// <p>The value of the utilization metric.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`UtilizationMetric`](crate::model::UtilizationMetric).
pub mod utilization_metric {
    
    /// A builder for [`UtilizationMetric`](crate::model::UtilizationMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::MetricName>,
        pub(crate) statistic: std::option::Option<crate::model::MetricStatistic>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the utilization metric.</p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>Cpu</code> - The percentage of allocated EC2 compute units that are currently in use on the instance. This metric identifies the processing power required to run an application on the instance.</p> <p>Depending on the instance type, tools in your operating system can show a lower percentage than CloudWatch when the instance is not allocated a full processor core.</p> <p>Units: Percent</p> </li> 
        /// <li> <p> <code>Memory</code> - The percentage of memory that is currently in use on the instance. This metric identifies the amount of memory required to run an application on the instance.</p> <p>Units: Percent</p> <note> 
        /// <p>The <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
        /// </note> </li> 
        /// <li> <p> <code>EBS_READ_OPS_PER_SECOND</code> - The completed read operations from all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Count</p> </li> 
        /// <li> <p> <code>EBS_WRITE_OPS_PER_SECOND</code> - The completed write operations to all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Count</p> </li> 
        /// <li> <p> <code>EBS_READ_BYTES_PER_SECOND</code> - The bytes read from all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
        /// <li> <p> <code>EBS_WRITE_BYTES_PER_SECOND</code> - The bytes written to all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
        /// <li> <p> <code>DISK_READ_OPS_PER_SECOND</code> - The completed read operations from all instance store volumes available to the instance in a specified period of time.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
        /// <li> <p> <code>DISK_WRITE_OPS_PER_SECOND</code> - The completed write operations from all instance store volumes available to the instance in a specified period of time.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
        /// <li> <p> <code>DISK_READ_BYTES_PER_SECOND</code> - The bytes read from all instance store volumes available to the instance. This metric is used to determine the volume of the data the application reads from the disk of the instance. This can be used to determine the speed of the application.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
        /// <li> <p> <code>DISK_WRITE_BYTES_PER_SECOND</code> - The bytes written to all instance store volumes available to the instance. This metric is used to determine the volume of the data the application writes onto the disk of the instance. This can be used to determine the speed of the application.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
        /// <li> <p> <code>NETWORK_IN_BYTES_PER_SECOND</code> - The number of bytes received by the instance on all network interfaces. This metric identifies the volume of incoming network traffic to a single instance.</p> </li> 
        /// <li> <p> <code>NETWORK_OUT_BYTES_PER_SECOND</code> - The number of bytes sent out by the instance on all network interfaces. This metric identifies the volume of outgoing network traffic from a single instance.</p> </li> 
        /// <li> <p> <code>NETWORK_PACKETS_IN_PER_SECOND</code> - The number of packets received by the instance on all network interfaces. This metric identifies the volume of incoming traffic in terms of the number of packets on a single instance.</p> </li> 
        /// <li> <p> <code>NETWORK_PACKETS_OUT_PER_SECOND</code> - The number of packets sent out by the instance on all network interfaces. This metric identifies the volume of outgoing traffic in terms of the number of packets on a single instance.</p> </li> 
        /// </ul>
        pub fn name(mut self, input: crate::model::MetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the utilization metric.</p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>Cpu</code> - The percentage of allocated EC2 compute units that are currently in use on the instance. This metric identifies the processing power required to run an application on the instance.</p> <p>Depending on the instance type, tools in your operating system can show a lower percentage than CloudWatch when the instance is not allocated a full processor core.</p> <p>Units: Percent</p> </li> 
        /// <li> <p> <code>Memory</code> - The percentage of memory that is currently in use on the instance. This metric identifies the amount of memory required to run an application on the instance.</p> <p>Units: Percent</p> <note> 
        /// <p>The <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
        /// </note> </li> 
        /// <li> <p> <code>EBS_READ_OPS_PER_SECOND</code> - The completed read operations from all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Count</p> </li> 
        /// <li> <p> <code>EBS_WRITE_OPS_PER_SECOND</code> - The completed write operations to all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Count</p> </li> 
        /// <li> <p> <code>EBS_READ_BYTES_PER_SECOND</code> - The bytes read from all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
        /// <li> <p> <code>EBS_WRITE_BYTES_PER_SECOND</code> - The bytes written to all EBS volumes attached to the instance in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
        /// <li> <p> <code>DISK_READ_OPS_PER_SECOND</code> - The completed read operations from all instance store volumes available to the instance in a specified period of time.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
        /// <li> <p> <code>DISK_WRITE_OPS_PER_SECOND</code> - The completed write operations from all instance store volumes available to the instance in a specified period of time.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
        /// <li> <p> <code>DISK_READ_BYTES_PER_SECOND</code> - The bytes read from all instance store volumes available to the instance. This metric is used to determine the volume of the data the application reads from the disk of the instance. This can be used to determine the speed of the application.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
        /// <li> <p> <code>DISK_WRITE_BYTES_PER_SECOND</code> - The bytes written to all instance store volumes available to the instance. This metric is used to determine the volume of the data the application writes onto the disk of the instance. This can be used to determine the speed of the application.</p> <p>If there are no instance store volumes, either the value is <code>0</code> or the metric is not reported.</p> </li> 
        /// <li> <p> <code>NETWORK_IN_BYTES_PER_SECOND</code> - The number of bytes received by the instance on all network interfaces. This metric identifies the volume of incoming network traffic to a single instance.</p> </li> 
        /// <li> <p> <code>NETWORK_OUT_BYTES_PER_SECOND</code> - The number of bytes sent out by the instance on all network interfaces. This metric identifies the volume of outgoing network traffic from a single instance.</p> </li> 
        /// <li> <p> <code>NETWORK_PACKETS_IN_PER_SECOND</code> - The number of packets received by the instance on all network interfaces. This metric identifies the volume of incoming traffic in terms of the number of packets on a single instance.</p> </li> 
        /// <li> <p> <code>NETWORK_PACKETS_OUT_PER_SECOND</code> - The number of packets sent out by the instance on all network interfaces. This metric identifies the volume of outgoing traffic in terms of the number of packets on a single instance.</p> </li> 
        /// </ul>
        pub fn set_name(mut self, input: std::option::Option<crate::model::MetricName>) -> Self {
            self.name = input; self
        }
        /// <p>The statistic of the utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn statistic(mut self, input: crate::model::MetricStatistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic of the utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn set_statistic(mut self, input: std::option::Option<crate::model::MetricStatistic>) -> Self {
            self.statistic = input; self
        }
        /// <p>The value of the utilization metric.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the utilization metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`UtilizationMetric`](crate::model::UtilizationMetric).
        pub fn build(self) -> crate::model::UtilizationMetric {
            crate::model::UtilizationMetric {
                name: self.name
                ,
                statistic: self.statistic
                ,
                value: self.value
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl UtilizationMetric {
    /// Creates a new builder-style object to manufacture [`UtilizationMetric`](crate::model::UtilizationMetric).
    pub fn builder() -> crate::model::utilization_metric::Builder {
        crate::model::utilization_metric::Builder::default()
    }
}

/// When writing a match expression against `InstanceRecommendationFindingReasonCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let instancerecommendationfindingreasoncode = unimplemented!();
/// match instancerecommendationfindingreasoncode {
///     InstanceRecommendationFindingReasonCode::CpuOverProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::CpuUnderProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::DiskIopsOverProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::DiskIopsUnderProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::DiskThroughputOverProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::DiskThroughputUnderProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::EbsIopsOverProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::EbsIopsUnderProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::EbsThroughputOverProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::EbsThroughputUnderProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::MemoryOverProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::MemoryUnderProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::NetworkBandwidthOverProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::NetworkBandwidthUnderProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::NetworkPpsOverProvisioned => { /* ... */ },
///     InstanceRecommendationFindingReasonCode::NetworkPpsUnderProvisioned => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `instancerecommendationfindingreasoncode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InstanceRecommendationFindingReasonCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InstanceRecommendationFindingReasonCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InstanceRecommendationFindingReasonCode::NewFeature` is defined.
/// Specifically, when `instancerecommendationfindingreasoncode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InstanceRecommendationFindingReasonCode::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum InstanceRecommendationFindingReasonCode {
    #[allow(missing_docs)] // documentation missing in model
    CpuOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    CpuUnderProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    DiskIopsOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    DiskIopsUnderProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    DiskThroughputOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    DiskThroughputUnderProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    EbsIopsOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    EbsIopsUnderProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    EbsThroughputOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    EbsThroughputUnderProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    MemoryOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    MemoryUnderProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    NetworkBandwidthOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    NetworkBandwidthUnderProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    NetworkPpsOverProvisioned,
    #[allow(missing_docs)] // documentation missing in model
    NetworkPpsUnderProvisioned,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for InstanceRecommendationFindingReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "CPUOverprovisioned" => InstanceRecommendationFindingReasonCode::CpuOverProvisioned,
            "CPUUnderprovisioned" => InstanceRecommendationFindingReasonCode::CpuUnderProvisioned,
            "DiskIOPSOverprovisioned" => InstanceRecommendationFindingReasonCode::DiskIopsOverProvisioned,
            "DiskIOPSUnderprovisioned" => InstanceRecommendationFindingReasonCode::DiskIopsUnderProvisioned,
            "DiskThroughputOverprovisioned" => InstanceRecommendationFindingReasonCode::DiskThroughputOverProvisioned,
            "DiskThroughputUnderprovisioned" => InstanceRecommendationFindingReasonCode::DiskThroughputUnderProvisioned,
            "EBSIOPSOverprovisioned" => InstanceRecommendationFindingReasonCode::EbsIopsOverProvisioned,
            "EBSIOPSUnderprovisioned" => InstanceRecommendationFindingReasonCode::EbsIopsUnderProvisioned,
            "EBSThroughputOverprovisioned" => InstanceRecommendationFindingReasonCode::EbsThroughputOverProvisioned,
            "EBSThroughputUnderprovisioned" => InstanceRecommendationFindingReasonCode::EbsThroughputUnderProvisioned,
            "MemoryOverprovisioned" => InstanceRecommendationFindingReasonCode::MemoryOverProvisioned,
            "MemoryUnderprovisioned" => InstanceRecommendationFindingReasonCode::MemoryUnderProvisioned,
            "NetworkBandwidthOverprovisioned" => InstanceRecommendationFindingReasonCode::NetworkBandwidthOverProvisioned,
            "NetworkBandwidthUnderprovisioned" => InstanceRecommendationFindingReasonCode::NetworkBandwidthUnderProvisioned,
            "NetworkPPSOverprovisioned" => InstanceRecommendationFindingReasonCode::NetworkPpsOverProvisioned,
            "NetworkPPSUnderprovisioned" => InstanceRecommendationFindingReasonCode::NetworkPpsUnderProvisioned,
            other => InstanceRecommendationFindingReasonCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for InstanceRecommendationFindingReasonCode {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(InstanceRecommendationFindingReasonCode::from(s))
                }
            }
impl InstanceRecommendationFindingReasonCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InstanceRecommendationFindingReasonCode::CpuOverProvisioned => "CPUOverprovisioned",
            InstanceRecommendationFindingReasonCode::CpuUnderProvisioned => "CPUUnderprovisioned",
            InstanceRecommendationFindingReasonCode::DiskIopsOverProvisioned => "DiskIOPSOverprovisioned",
            InstanceRecommendationFindingReasonCode::DiskIopsUnderProvisioned => "DiskIOPSUnderprovisioned",
            InstanceRecommendationFindingReasonCode::DiskThroughputOverProvisioned => "DiskThroughputOverprovisioned",
            InstanceRecommendationFindingReasonCode::DiskThroughputUnderProvisioned => "DiskThroughputUnderprovisioned",
            InstanceRecommendationFindingReasonCode::EbsIopsOverProvisioned => "EBSIOPSOverprovisioned",
            InstanceRecommendationFindingReasonCode::EbsIopsUnderProvisioned => "EBSIOPSUnderprovisioned",
            InstanceRecommendationFindingReasonCode::EbsThroughputOverProvisioned => "EBSThroughputOverprovisioned",
            InstanceRecommendationFindingReasonCode::EbsThroughputUnderProvisioned => "EBSThroughputUnderprovisioned",
            InstanceRecommendationFindingReasonCode::MemoryOverProvisioned => "MemoryOverprovisioned",
            InstanceRecommendationFindingReasonCode::MemoryUnderProvisioned => "MemoryUnderprovisioned",
            InstanceRecommendationFindingReasonCode::NetworkBandwidthOverProvisioned => "NetworkBandwidthOverprovisioned",
            InstanceRecommendationFindingReasonCode::NetworkBandwidthUnderProvisioned => "NetworkBandwidthUnderprovisioned",
            InstanceRecommendationFindingReasonCode::NetworkPpsOverProvisioned => "NetworkPPSOverprovisioned",
            InstanceRecommendationFindingReasonCode::NetworkPpsUnderProvisioned => "NetworkPPSUnderprovisioned",
            InstanceRecommendationFindingReasonCode::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CPUOverprovisioned", "CPUUnderprovisioned", "DiskIOPSOverprovisioned", "DiskIOPSUnderprovisioned", "DiskThroughputOverprovisioned", "DiskThroughputUnderprovisioned", "EBSIOPSOverprovisioned", "EBSIOPSUnderprovisioned", "EBSThroughputOverprovisioned", "EBSThroughputUnderprovisioned", "MemoryOverprovisioned", "MemoryUnderprovisioned", "NetworkBandwidthOverprovisioned", "NetworkBandwidthUnderprovisioned", "NetworkPPSOverprovisioned", "NetworkPPSUnderprovisioned"
        ]
    }
}
impl AsRef<str> for InstanceRecommendationFindingReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a filter that returns a more specific list of recommendations. Use this filter with the <code>GetAutoScalingGroupRecommendations</code> and <code>GetEC2InstanceRecommendations</code> actions.</p> 
/// <p>You can use <code>EBSFilter</code> with the <code>GetEBSVolumeRecommendations</code> action, <code>LambdaFunctionRecommendationFilter</code> with the <code>GetLambdaFunctionRecommendations</code> action, and <code>JobFilter</code> with the <code>DescribeRecommendationExportJobs</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Filter  {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>Underprovisioned</code>).</p> 
    /// <p>Specify <code>RecommendationSourceType</code> to return recommendations of a specific resource type (for example, <code>Ec2Instance</code>).</p> 
    /// <p>Specify <code>FindingReasonCodes</code> to return recommendations with a specific finding reason code (for example, <code>CPUUnderprovisioned</code>).</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::FilterName>,
    /// <p>The value of the filter.</p> 
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter and the resource type that you wish to filter results for:</p> 
    /// <ul> 
    /// <li> <p>Specify <code>Optimized</code> or <code>NotOptimized</code> if you specify the <code>name</code> parameter as <code>Finding</code> and you want to filter results for Auto Scaling groups.</p> </li> 
    /// <li> <p>Specify <code>Underprovisioned</code>, <code>Overprovisioned</code>, or <code>Optimized</code> if you specify the <code>name</code> parameter as <code>Finding</code> and you want to filter results for EC2 instances.</p> </li> 
    /// <li> <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you specify the <code>name</code> parameter as <code>RecommendationSourceType</code>.</p> </li> 
    /// <li> <p>Specify one of the following options if you specify the <code>name</code> parameter as <code>FindingReasonCodes</code>:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The instances CPU configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The instances CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance.</p> </li> 
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The instances memory configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The instances memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance.</p> </li> 
    /// <li> <p> <b> <code>EBSThroughputOverprovisioned</code> </b>  The instances EBS throughput configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>EBSThroughputUnderprovisioned</code> </b>  The instances EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance.</p> </li> 
    /// <li> <p> <b> <code>EBSIOPSOverprovisioned</code> </b>  The instances EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>EBSIOPSUnderprovisioned</code> </b>  The instances EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance.</p> </li> 
    /// <li> <p> <b> <code>NetworkBandwidthOverprovisioned</code> </b>  The instances network bandwidth configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>NetworkBandwidthUnderprovisioned</code> </b>  The instances network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p> </li> 
    /// <li> <p> <b> <code>NetworkPPSOverprovisioned</code> </b>  The instances network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>NetworkPPSUnderprovisioned</code> </b>  The instances network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance.</p> </li> 
    /// <li> <p> <b> <code>DiskIOPSOverprovisioned</code> </b>  The instances disk IOPS configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>DiskIOPSUnderprovisioned</code> </b>  The instances disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance.</p> </li> 
    /// <li> <p> <b> <code>DiskThroughputOverprovisioned</code> </b>  The instances disk throughput configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>DiskThroughputUnderprovisioned</code> </b>  The instances disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance.</p> </li> 
    /// </ul> </li> 
    /// </ul>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl Filter {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>Underprovisioned</code>).</p> 
    /// <p>Specify <code>RecommendationSourceType</code> to return recommendations of a specific resource type (for example, <code>Ec2Instance</code>).</p> 
    /// <p>Specify <code>FindingReasonCodes</code> to return recommendations with a specific finding reason code (for example, <code>CPUUnderprovisioned</code>).</p>
    pub fn name(&self) -> std::option::Option<& crate::model::FilterName> {
        self.name.as_ref()
    }
    /// <p>The value of the filter.</p> 
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter and the resource type that you wish to filter results for:</p> 
    /// <ul> 
    /// <li> <p>Specify <code>Optimized</code> or <code>NotOptimized</code> if you specify the <code>name</code> parameter as <code>Finding</code> and you want to filter results for Auto Scaling groups.</p> </li> 
    /// <li> <p>Specify <code>Underprovisioned</code>, <code>Overprovisioned</code>, or <code>Optimized</code> if you specify the <code>name</code> parameter as <code>Finding</code> and you want to filter results for EC2 instances.</p> </li> 
    /// <li> <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you specify the <code>name</code> parameter as <code>RecommendationSourceType</code>.</p> </li> 
    /// <li> <p>Specify one of the following options if you specify the <code>name</code> parameter as <code>FindingReasonCodes</code>:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The instances CPU configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The instances CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance.</p> </li> 
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The instances memory configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The instances memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance.</p> </li> 
    /// <li> <p> <b> <code>EBSThroughputOverprovisioned</code> </b>  The instances EBS throughput configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>EBSThroughputUnderprovisioned</code> </b>  The instances EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance.</p> </li> 
    /// <li> <p> <b> <code>EBSIOPSOverprovisioned</code> </b>  The instances EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>EBSIOPSUnderprovisioned</code> </b>  The instances EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance.</p> </li> 
    /// <li> <p> <b> <code>NetworkBandwidthOverprovisioned</code> </b>  The instances network bandwidth configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>NetworkBandwidthUnderprovisioned</code> </b>  The instances network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p> </li> 
    /// <li> <p> <b> <code>NetworkPPSOverprovisioned</code> </b>  The instances network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>NetworkPPSUnderprovisioned</code> </b>  The instances network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance.</p> </li> 
    /// <li> <p> <b> <code>DiskIOPSOverprovisioned</code> </b>  The instances disk IOPS configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>DiskIOPSUnderprovisioned</code> </b>  The instances disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance.</p> </li> 
    /// <li> <p> <b> <code>DiskThroughputOverprovisioned</code> </b>  The instances disk throughput configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
    /// <li> <p> <b> <code>DiskThroughputUnderprovisioned</code> </b>  The instances disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance.</p> </li> 
    /// </ul> </li> 
    /// </ul>
    pub fn values(&self) -> std::option::Option<& [std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`Filter`](crate::model::Filter).
pub mod filter {
    
    /// A builder for [`Filter`](crate::model::Filter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::FilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>Underprovisioned</code>).</p> 
        /// <p>Specify <code>RecommendationSourceType</code> to return recommendations of a specific resource type (for example, <code>Ec2Instance</code>).</p> 
        /// <p>Specify <code>FindingReasonCodes</code> to return recommendations with a specific finding reason code (for example, <code>CPUUnderprovisioned</code>).</p>
        pub fn name(mut self, input: crate::model::FilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>Underprovisioned</code>).</p> 
        /// <p>Specify <code>RecommendationSourceType</code> to return recommendations of a specific resource type (for example, <code>Ec2Instance</code>).</p> 
        /// <p>Specify <code>FindingReasonCodes</code> to return recommendations with a specific finding reason code (for example, <code>CPUUnderprovisioned</code>).</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::FilterName>) -> Self {
            self.name = input; self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value of the filter.</p> 
        /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter and the resource type that you wish to filter results for:</p> 
        /// <ul> 
        /// <li> <p>Specify <code>Optimized</code> or <code>NotOptimized</code> if you specify the <code>name</code> parameter as <code>Finding</code> and you want to filter results for Auto Scaling groups.</p> </li> 
        /// <li> <p>Specify <code>Underprovisioned</code>, <code>Overprovisioned</code>, or <code>Optimized</code> if you specify the <code>name</code> parameter as <code>Finding</code> and you want to filter results for EC2 instances.</p> </li> 
        /// <li> <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you specify the <code>name</code> parameter as <code>RecommendationSourceType</code>.</p> </li> 
        /// <li> <p>Specify one of the following options if you specify the <code>name</code> parameter as <code>FindingReasonCodes</code>:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The instances CPU configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The instances CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance.</p> </li> 
        /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The instances memory configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The instances memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance.</p> </li> 
        /// <li> <p> <b> <code>EBSThroughputOverprovisioned</code> </b>  The instances EBS throughput configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>EBSThroughputUnderprovisioned</code> </b>  The instances EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance.</p> </li> 
        /// <li> <p> <b> <code>EBSIOPSOverprovisioned</code> </b>  The instances EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>EBSIOPSUnderprovisioned</code> </b>  The instances EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance.</p> </li> 
        /// <li> <p> <b> <code>NetworkBandwidthOverprovisioned</code> </b>  The instances network bandwidth configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>NetworkBandwidthUnderprovisioned</code> </b>  The instances network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p> </li> 
        /// <li> <p> <b> <code>NetworkPPSOverprovisioned</code> </b>  The instances network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>NetworkPPSUnderprovisioned</code> </b>  The instances network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance.</p> </li> 
        /// <li> <p> <b> <code>DiskIOPSOverprovisioned</code> </b>  The instances disk IOPS configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>DiskIOPSUnderprovisioned</code> </b>  The instances disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance.</p> </li> 
        /// <li> <p> <b> <code>DiskThroughputOverprovisioned</code> </b>  The instances disk throughput configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>DiskThroughputUnderprovisioned</code> </b>  The instances disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance.</p> </li> 
        /// </ul> </li> 
        /// </ul>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
                            v.push(input.into());
                            self.values = Some(v);
                            self
        }
        /// <p>The value of the filter.</p> 
        /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter and the resource type that you wish to filter results for:</p> 
        /// <ul> 
        /// <li> <p>Specify <code>Optimized</code> or <code>NotOptimized</code> if you specify the <code>name</code> parameter as <code>Finding</code> and you want to filter results for Auto Scaling groups.</p> </li> 
        /// <li> <p>Specify <code>Underprovisioned</code>, <code>Overprovisioned</code>, or <code>Optimized</code> if you specify the <code>name</code> parameter as <code>Finding</code> and you want to filter results for EC2 instances.</p> </li> 
        /// <li> <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you specify the <code>name</code> parameter as <code>RecommendationSourceType</code>.</p> </li> 
        /// <li> <p>Specify one of the following options if you specify the <code>name</code> parameter as <code>FindingReasonCodes</code>:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>CPUOverprovisioned</code> </b>  The instances CPU configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b>  The instances CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance.</p> </li> 
        /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b>  The instances memory configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b>  The instances memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance.</p> </li> 
        /// <li> <p> <b> <code>EBSThroughputOverprovisioned</code> </b>  The instances EBS throughput configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>EBSThroughputUnderprovisioned</code> </b>  The instances EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance.</p> </li> 
        /// <li> <p> <b> <code>EBSIOPSOverprovisioned</code> </b>  The instances EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>EBSIOPSUnderprovisioned</code> </b>  The instances EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance.</p> </li> 
        /// <li> <p> <b> <code>NetworkBandwidthOverprovisioned</code> </b>  The instances network bandwidth configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>NetworkBandwidthUnderprovisioned</code> </b>  The instances network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p> </li> 
        /// <li> <p> <b> <code>NetworkPPSOverprovisioned</code> </b>  The instances network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>NetworkPPSUnderprovisioned</code> </b>  The instances network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance.</p> </li> 
        /// <li> <p> <b> <code>DiskIOPSOverprovisioned</code> </b>  The instances disk IOPS configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>DiskIOPSUnderprovisioned</code> </b>  The instances disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance.</p> </li> 
        /// <li> <p> <b> <code>DiskThroughputOverprovisioned</code> </b>  The instances disk throughput configuration can be sized down while still meeting the performance requirements of your workload.</p> </li> 
        /// <li> <p> <b> <code>DiskThroughputUnderprovisioned</code> </b>  The instances disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance.</p> </li> 
        /// </ul> </li> 
        /// </ul>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter).
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name
                ,
                values: self.values
                ,
            }
        }
    }
    
    
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter).
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// When writing a match expression against `FilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let filtername = unimplemented!();
/// match filtername {
///     FilterName::Finding => { /* ... */ },
///     FilterName::FindingReasonCodes => { /* ... */ },
///     FilterName::RecommendationSourceType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `filtername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FilterName::NewFeature` is defined.
/// Specifically, when `filtername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FilterName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum FilterName {
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    #[allow(missing_docs)] // documentation missing in model
    FindingReasonCodes,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationSourceType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for FilterName {
    fn from(s: &str) -> Self {
        match s {
            "Finding" => FilterName::Finding,
            "FindingReasonCodes" => FilterName::FindingReasonCodes,
            "RecommendationSourceType" => FilterName::RecommendationSourceType,
            other => FilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for FilterName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(FilterName::from(s))
                }
            }
impl FilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterName::Finding => "Finding",
            FilterName::FindingReasonCodes => "FindingReasonCodes",
            FilterName::RecommendationSourceType => "RecommendationSourceType",
            FilterName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Finding", "FindingReasonCodes", "RecommendationSourceType"
        ]
    }
}
impl AsRef<str> for FilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an Amazon Elastic Block Store (Amazon EBS) volume recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VolumeRecommendation  {
    /// <p>The Amazon Resource Name (ARN) of the current volume.</p>
    #[doc(hidden)]
    pub volume_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the volume.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>An array of objects that describe the current configuration of the volume.</p>
    #[doc(hidden)]
    pub current_configuration: std::option::Option<crate::model::VolumeConfiguration>,
    /// <p>The finding classification of the volume.</p> 
    /// <p>Findings for volumes include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>NotOptimized</code> </b>A volume is considered not optimized when Compute Optimizer identifies a recommendation that can provide better performance for your workload.</p> </li> 
    /// <li> <p> <b> <code>Optimized</code> </b>An volume is considered optimized when Compute Optimizer determines that the volume is correctly provisioned to run your workload based on the chosen volume type. For optimized resources, Compute Optimizer might recommend a new generation volume type.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub finding: std::option::Option<crate::model::EbsFinding>,
    /// <p>An array of objects that describe the utilization metrics of the volume.</p>
    #[doc(hidden)]
    pub utilization_metrics: std::option::Option<std::vec::Vec<crate::model::EbsUtilizationMetric>>,
    /// <p>The number of days for which utilization metrics were analyzed for the volume.</p>
    #[doc(hidden)]
    pub look_back_period_in_days: f64,
    /// <p>An array of objects that describe the recommendation options for the volume.</p>
    #[doc(hidden)]
    pub volume_recommendation_options: std::option::Option<std::vec::Vec<crate::model::VolumeRecommendationOption>>,
    /// <p>The timestamp of when the volume recommendation was last generated.</p>
    #[doc(hidden)]
    pub last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The risk of the current EBS volume not meeting the performance needs of its workloads. The higher the risk, the more likely the current EBS volume doesn't have sufficient capacity.</p>
    #[doc(hidden)]
    pub current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
}
impl VolumeRecommendation {
    /// <p>The Amazon Resource Name (ARN) of the current volume.</p>
    pub fn volume_arn(&self) -> std::option::Option<& str> {
        self.volume_arn.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the volume.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>An array of objects that describe the current configuration of the volume.</p>
    pub fn current_configuration(&self) -> std::option::Option<& crate::model::VolumeConfiguration> {
        self.current_configuration.as_ref()
    }
    /// <p>The finding classification of the volume.</p> 
    /// <p>Findings for volumes include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>NotOptimized</code> </b>A volume is considered not optimized when Compute Optimizer identifies a recommendation that can provide better performance for your workload.</p> </li> 
    /// <li> <p> <b> <code>Optimized</code> </b>An volume is considered optimized when Compute Optimizer determines that the volume is correctly provisioned to run your workload based on the chosen volume type. For optimized resources, Compute Optimizer might recommend a new generation volume type.</p> </li> 
    /// </ul>
    pub fn finding(&self) -> std::option::Option<& crate::model::EbsFinding> {
        self.finding.as_ref()
    }
    /// <p>An array of objects that describe the utilization metrics of the volume.</p>
    pub fn utilization_metrics(&self) -> std::option::Option<& [crate::model::EbsUtilizationMetric]> {
        self.utilization_metrics.as_deref()
    }
    /// <p>The number of days for which utilization metrics were analyzed for the volume.</p>
    pub fn look_back_period_in_days(&self) -> f64 {
        self.look_back_period_in_days
    }
    /// <p>An array of objects that describe the recommendation options for the volume.</p>
    pub fn volume_recommendation_options(&self) -> std::option::Option<& [crate::model::VolumeRecommendationOption]> {
        self.volume_recommendation_options.as_deref()
    }
    /// <p>The timestamp of when the volume recommendation was last generated.</p>
    pub fn last_refresh_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.last_refresh_timestamp.as_ref()
    }
    /// <p>The risk of the current EBS volume not meeting the performance needs of its workloads. The higher the risk, the more likely the current EBS volume doesn't have sufficient capacity.</p>
    pub fn current_performance_risk(&self) -> std::option::Option<& crate::model::CurrentPerformanceRisk> {
        self.current_performance_risk.as_ref()
    }
}
/// See [`VolumeRecommendation`](crate::model::VolumeRecommendation).
pub mod volume_recommendation {
    
    /// A builder for [`VolumeRecommendation`](crate::model::VolumeRecommendation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_arn: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) current_configuration: std::option::Option<crate::model::VolumeConfiguration>,
        pub(crate) finding: std::option::Option<crate::model::EbsFinding>,
        pub(crate) utilization_metrics: std::option::Option<std::vec::Vec<crate::model::EbsUtilizationMetric>>,
        pub(crate) look_back_period_in_days: std::option::Option<f64>,
        pub(crate) volume_recommendation_options: std::option::Option<std::vec::Vec<crate::model::VolumeRecommendationOption>>,
        pub(crate) last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the current volume.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the current volume.</p>
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_arn = input; self
        }
        /// <p>The Amazon Web Services account ID of the volume.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the volume.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>An array of objects that describe the current configuration of the volume.</p>
        pub fn current_configuration(mut self, input: crate::model::VolumeConfiguration) -> Self {
            self.current_configuration = Some(input);
            self
        }
        /// <p>An array of objects that describe the current configuration of the volume.</p>
        pub fn set_current_configuration(mut self, input: std::option::Option<crate::model::VolumeConfiguration>) -> Self {
            self.current_configuration = input; self
        }
        /// <p>The finding classification of the volume.</p> 
        /// <p>Findings for volumes include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>NotOptimized</code> </b>A volume is considered not optimized when Compute Optimizer identifies a recommendation that can provide better performance for your workload.</p> </li> 
        /// <li> <p> <b> <code>Optimized</code> </b>An volume is considered optimized when Compute Optimizer determines that the volume is correctly provisioned to run your workload based on the chosen volume type. For optimized resources, Compute Optimizer might recommend a new generation volume type.</p> </li> 
        /// </ul>
        pub fn finding(mut self, input: crate::model::EbsFinding) -> Self {
            self.finding = Some(input);
            self
        }
        /// <p>The finding classification of the volume.</p> 
        /// <p>Findings for volumes include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>NotOptimized</code> </b>A volume is considered not optimized when Compute Optimizer identifies a recommendation that can provide better performance for your workload.</p> </li> 
        /// <li> <p> <b> <code>Optimized</code> </b>An volume is considered optimized when Compute Optimizer determines that the volume is correctly provisioned to run your workload based on the chosen volume type. For optimized resources, Compute Optimizer might recommend a new generation volume type.</p> </li> 
        /// </ul>
        pub fn set_finding(mut self, input: std::option::Option<crate::model::EbsFinding>) -> Self {
            self.finding = input; self
        }
        /// Appends an item to `utilization_metrics`.
        ///
        /// To override the contents of this collection use [`set_utilization_metrics`](Self::set_utilization_metrics).
        ///
        /// <p>An array of objects that describe the utilization metrics of the volume.</p>
        pub fn utilization_metrics(mut self, input: crate::model::EbsUtilizationMetric) -> Self {
            let mut v = self.utilization_metrics.unwrap_or_default();
                            v.push(input);
                            self.utilization_metrics = Some(v);
                            self
        }
        /// <p>An array of objects that describe the utilization metrics of the volume.</p>
        pub fn set_utilization_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::EbsUtilizationMetric>>) -> Self {
            self.utilization_metrics = input; self
        }
        /// <p>The number of days for which utilization metrics were analyzed for the volume.</p>
        pub fn look_back_period_in_days(mut self, input: f64) -> Self {
            self.look_back_period_in_days = Some(input);
            self
        }
        /// <p>The number of days for which utilization metrics were analyzed for the volume.</p>
        pub fn set_look_back_period_in_days(mut self, input: std::option::Option<f64>) -> Self {
            self.look_back_period_in_days = input; self
        }
        /// Appends an item to `volume_recommendation_options`.
        ///
        /// To override the contents of this collection use [`set_volume_recommendation_options`](Self::set_volume_recommendation_options).
        ///
        /// <p>An array of objects that describe the recommendation options for the volume.</p>
        pub fn volume_recommendation_options(mut self, input: crate::model::VolumeRecommendationOption) -> Self {
            let mut v = self.volume_recommendation_options.unwrap_or_default();
                            v.push(input);
                            self.volume_recommendation_options = Some(v);
                            self
        }
        /// <p>An array of objects that describe the recommendation options for the volume.</p>
        pub fn set_volume_recommendation_options(mut self, input: std::option::Option<std::vec::Vec<crate::model::VolumeRecommendationOption>>) -> Self {
            self.volume_recommendation_options = input; self
        }
        /// <p>The timestamp of when the volume recommendation was last generated.</p>
        pub fn last_refresh_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_refresh_timestamp = Some(input);
            self
        }
        /// <p>The timestamp of when the volume recommendation was last generated.</p>
        pub fn set_last_refresh_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.last_refresh_timestamp = input; self
        }
        /// <p>The risk of the current EBS volume not meeting the performance needs of its workloads. The higher the risk, the more likely the current EBS volume doesn't have sufficient capacity.</p>
        pub fn current_performance_risk(mut self, input: crate::model::CurrentPerformanceRisk) -> Self {
            self.current_performance_risk = Some(input);
            self
        }
        /// <p>The risk of the current EBS volume not meeting the performance needs of its workloads. The higher the risk, the more likely the current EBS volume doesn't have sufficient capacity.</p>
        pub fn set_current_performance_risk(mut self, input: std::option::Option<crate::model::CurrentPerformanceRisk>) -> Self {
            self.current_performance_risk = input; self
        }
        /// Consumes the builder and constructs a [`VolumeRecommendation`](crate::model::VolumeRecommendation).
        pub fn build(self) -> crate::model::VolumeRecommendation {
            crate::model::VolumeRecommendation {
                volume_arn: self.volume_arn
                ,
                account_id: self.account_id
                ,
                current_configuration: self.current_configuration
                ,
                finding: self.finding
                ,
                utilization_metrics: self.utilization_metrics
                ,
                look_back_period_in_days: self.look_back_period_in_days
                    .unwrap_or_default()
                ,
                volume_recommendation_options: self.volume_recommendation_options
                ,
                last_refresh_timestamp: self.last_refresh_timestamp
                ,
                current_performance_risk: self.current_performance_risk
                ,
            }
        }
    }
    
    
}
impl VolumeRecommendation {
    /// Creates a new builder-style object to manufacture [`VolumeRecommendation`](crate::model::VolumeRecommendation).
    pub fn builder() -> crate::model::volume_recommendation::Builder {
        crate::model::volume_recommendation::Builder::default()
    }
}

/// <p>Describes a recommendation option for an Amazon Elastic Block Store (Amazon EBS) instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VolumeRecommendationOption  {
    /// <p>An array of objects that describe a volume configuration.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::VolumeConfiguration>,
    /// <p>The performance risk of the volume recommendation option.</p> 
    /// <p>Performance risk is the likelihood of the recommended volume type meeting the performance requirement of your workload.</p> 
    /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
    #[doc(hidden)]
    pub performance_risk: f64,
    /// <p>The rank of the volume recommendation option.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p>
    #[doc(hidden)]
    pub rank: i32,
    /// <p>An object that describes the savings opportunity for the EBS volume recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    #[doc(hidden)]
    pub savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
}
impl VolumeRecommendationOption {
    /// <p>An array of objects that describe a volume configuration.</p>
    pub fn configuration(&self) -> std::option::Option<& crate::model::VolumeConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>The performance risk of the volume recommendation option.</p> 
    /// <p>Performance risk is the likelihood of the recommended volume type meeting the performance requirement of your workload.</p> 
    /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
    pub fn performance_risk(&self) -> f64 {
        self.performance_risk
    }
    /// <p>The rank of the volume recommendation option.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p>
    pub fn rank(&self) -> i32 {
        self.rank
    }
    /// <p>An object that describes the savings opportunity for the EBS volume recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    pub fn savings_opportunity(&self) -> std::option::Option<& crate::model::SavingsOpportunity> {
        self.savings_opportunity.as_ref()
    }
}
/// See [`VolumeRecommendationOption`](crate::model::VolumeRecommendationOption).
pub mod volume_recommendation_option {
    
    /// A builder for [`VolumeRecommendationOption`](crate::model::VolumeRecommendationOption).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration: std::option::Option<crate::model::VolumeConfiguration>,
        pub(crate) performance_risk: std::option::Option<f64>,
        pub(crate) rank: std::option::Option<i32>,
        pub(crate) savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
    }
    impl Builder {
        /// <p>An array of objects that describe a volume configuration.</p>
        pub fn configuration(mut self, input: crate::model::VolumeConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>An array of objects that describe a volume configuration.</p>
        pub fn set_configuration(mut self, input: std::option::Option<crate::model::VolumeConfiguration>) -> Self {
            self.configuration = input; self
        }
        /// <p>The performance risk of the volume recommendation option.</p> 
        /// <p>Performance risk is the likelihood of the recommended volume type meeting the performance requirement of your workload.</p> 
        /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
        pub fn performance_risk(mut self, input: f64) -> Self {
            self.performance_risk = Some(input);
            self
        }
        /// <p>The performance risk of the volume recommendation option.</p> 
        /// <p>Performance risk is the likelihood of the recommended volume type meeting the performance requirement of your workload.</p> 
        /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
        pub fn set_performance_risk(mut self, input: std::option::Option<f64>) -> Self {
            self.performance_risk = input; self
        }
        /// <p>The rank of the volume recommendation option.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p>
        pub fn rank(mut self, input: i32) -> Self {
            self.rank = Some(input);
            self
        }
        /// <p>The rank of the volume recommendation option.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p>
        pub fn set_rank(mut self, input: std::option::Option<i32>) -> Self {
            self.rank = input; self
        }
        /// <p>An object that describes the savings opportunity for the EBS volume recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn savings_opportunity(mut self, input: crate::model::SavingsOpportunity) -> Self {
            self.savings_opportunity = Some(input);
            self
        }
        /// <p>An object that describes the savings opportunity for the EBS volume recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn set_savings_opportunity(mut self, input: std::option::Option<crate::model::SavingsOpportunity>) -> Self {
            self.savings_opportunity = input; self
        }
        /// Consumes the builder and constructs a [`VolumeRecommendationOption`](crate::model::VolumeRecommendationOption).
        pub fn build(self) -> crate::model::VolumeRecommendationOption {
            crate::model::VolumeRecommendationOption {
                configuration: self.configuration
                ,
                performance_risk: self.performance_risk
                    .unwrap_or_default()
                ,
                rank: self.rank
                    .unwrap_or_default()
                ,
                savings_opportunity: self.savings_opportunity
                ,
            }
        }
    }
    
    
}
impl VolumeRecommendationOption {
    /// Creates a new builder-style object to manufacture [`VolumeRecommendationOption`](crate::model::VolumeRecommendationOption).
    pub fn builder() -> crate::model::volume_recommendation_option::Builder {
        crate::model::volume_recommendation_option::Builder::default()
    }
}

/// <p>Describes the configuration of an Amazon Elastic Block Store (Amazon EBS) volume.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VolumeConfiguration  {
    /// <p>The volume type.</p> 
    /// <p>This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> or <code>io2</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p>
    #[doc(hidden)]
    pub volume_type: std::option::Option<std::string::String>,
    /// <p>The size of the volume, in GiB.</p>
    #[doc(hidden)]
    pub volume_size: i32,
    /// <p>The baseline IOPS of the volume.</p>
    #[doc(hidden)]
    pub volume_baseline_iops: i32,
    /// <p>The burst IOPS of the volume.</p>
    #[doc(hidden)]
    pub volume_burst_iops: i32,
    /// <p>The baseline throughput of the volume.</p>
    #[doc(hidden)]
    pub volume_baseline_throughput: i32,
    /// <p>The burst throughput of the volume.</p>
    #[doc(hidden)]
    pub volume_burst_throughput: i32,
}
impl VolumeConfiguration {
    /// <p>The volume type.</p> 
    /// <p>This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> or <code>io2</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p>
    pub fn volume_type(&self) -> std::option::Option<& str> {
        self.volume_type.as_deref()
    }
    /// <p>The size of the volume, in GiB.</p>
    pub fn volume_size(&self) -> i32 {
        self.volume_size
    }
    /// <p>The baseline IOPS of the volume.</p>
    pub fn volume_baseline_iops(&self) -> i32 {
        self.volume_baseline_iops
    }
    /// <p>The burst IOPS of the volume.</p>
    pub fn volume_burst_iops(&self) -> i32 {
        self.volume_burst_iops
    }
    /// <p>The baseline throughput of the volume.</p>
    pub fn volume_baseline_throughput(&self) -> i32 {
        self.volume_baseline_throughput
    }
    /// <p>The burst throughput of the volume.</p>
    pub fn volume_burst_throughput(&self) -> i32 {
        self.volume_burst_throughput
    }
}
/// See [`VolumeConfiguration`](crate::model::VolumeConfiguration).
pub mod volume_configuration {
    
    /// A builder for [`VolumeConfiguration`](crate::model::VolumeConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_type: std::option::Option<std::string::String>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) volume_baseline_iops: std::option::Option<i32>,
        pub(crate) volume_burst_iops: std::option::Option<i32>,
        pub(crate) volume_baseline_throughput: std::option::Option<i32>,
        pub(crate) volume_burst_throughput: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The volume type.</p> 
        /// <p>This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> or <code>io2</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p>
        pub fn volume_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_type = Some(input.into());
            self
        }
        /// <p>The volume type.</p> 
        /// <p>This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> or <code>io2</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p>
        pub fn set_volume_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_type = input; self
        }
        /// <p>The size of the volume, in GiB.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        /// <p>The size of the volume, in GiB.</p>
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input; self
        }
        /// <p>The baseline IOPS of the volume.</p>
        pub fn volume_baseline_iops(mut self, input: i32) -> Self {
            self.volume_baseline_iops = Some(input);
            self
        }
        /// <p>The baseline IOPS of the volume.</p>
        pub fn set_volume_baseline_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_baseline_iops = input; self
        }
        /// <p>The burst IOPS of the volume.</p>
        pub fn volume_burst_iops(mut self, input: i32) -> Self {
            self.volume_burst_iops = Some(input);
            self
        }
        /// <p>The burst IOPS of the volume.</p>
        pub fn set_volume_burst_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_burst_iops = input; self
        }
        /// <p>The baseline throughput of the volume.</p>
        pub fn volume_baseline_throughput(mut self, input: i32) -> Self {
            self.volume_baseline_throughput = Some(input);
            self
        }
        /// <p>The baseline throughput of the volume.</p>
        pub fn set_volume_baseline_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_baseline_throughput = input; self
        }
        /// <p>The burst throughput of the volume.</p>
        pub fn volume_burst_throughput(mut self, input: i32) -> Self {
            self.volume_burst_throughput = Some(input);
            self
        }
        /// <p>The burst throughput of the volume.</p>
        pub fn set_volume_burst_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_burst_throughput = input; self
        }
        /// Consumes the builder and constructs a [`VolumeConfiguration`](crate::model::VolumeConfiguration).
        pub fn build(self) -> crate::model::VolumeConfiguration {
            crate::model::VolumeConfiguration {
                volume_type: self.volume_type
                ,
                volume_size: self.volume_size
                    .unwrap_or_default()
                ,
                volume_baseline_iops: self.volume_baseline_iops
                    .unwrap_or_default()
                ,
                volume_burst_iops: self.volume_burst_iops
                    .unwrap_or_default()
                ,
                volume_baseline_throughput: self.volume_baseline_throughput
                    .unwrap_or_default()
                ,
                volume_burst_throughput: self.volume_burst_throughput
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl VolumeConfiguration {
    /// Creates a new builder-style object to manufacture [`VolumeConfiguration`](crate::model::VolumeConfiguration).
    pub fn builder() -> crate::model::volume_configuration::Builder {
        crate::model::volume_configuration::Builder::default()
    }
}

/// <p>Describes a utilization metric of an Amazon Elastic Block Store (Amazon EBS) volume.</p> 
/// <p>Compare the utilization metric data of your resource against its projected utilization metric data to determine the performance difference between your current resource and the recommended option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EbsUtilizationMetric  {
    /// <p>The name of the utilization metric.</p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>VolumeReadOpsPerSecond</code> - The completed read operations per second from the volume in a specified period of time.</p> <p>Unit: Count</p> </li> 
    /// <li> <p> <code>VolumeWriteOpsPerSecond</code> - The completed write operations per second to the volume in a specified period of time.</p> <p>Unit: Count</p> </li> 
    /// <li> <p> <code>VolumeReadBytesPerSecond</code> - The bytes read per second from the volume in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
    /// <li> <p> <code>VolumeWriteBytesPerSecond</code> - The bytes written to the volume in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::EbsMetricName>,
    /// <p>The statistic of the utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    #[doc(hidden)]
    pub statistic: std::option::Option<crate::model::MetricStatistic>,
    /// <p>The value of the utilization metric.</p>
    #[doc(hidden)]
    pub value: f64,
}
impl EbsUtilizationMetric {
    /// <p>The name of the utilization metric.</p> 
    /// <p>The following utilization metrics are available:</p> 
    /// <ul> 
    /// <li> <p> <code>VolumeReadOpsPerSecond</code> - The completed read operations per second from the volume in a specified period of time.</p> <p>Unit: Count</p> </li> 
    /// <li> <p> <code>VolumeWriteOpsPerSecond</code> - The completed write operations per second to the volume in a specified period of time.</p> <p>Unit: Count</p> </li> 
    /// <li> <p> <code>VolumeReadBytesPerSecond</code> - The bytes read per second from the volume in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
    /// <li> <p> <code>VolumeWriteBytesPerSecond</code> - The bytes written to the volume in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
    /// </ul>
    pub fn name(&self) -> std::option::Option<& crate::model::EbsMetricName> {
        self.name.as_ref()
    }
    /// <p>The statistic of the utilization metric.</p> 
    /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
    /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
    pub fn statistic(&self) -> std::option::Option<& crate::model::MetricStatistic> {
        self.statistic.as_ref()
    }
    /// <p>The value of the utilization metric.</p>
    pub fn value(&self) -> f64 {
        self.value
    }
}
/// See [`EbsUtilizationMetric`](crate::model::EbsUtilizationMetric).
pub mod ebs_utilization_metric {
    
    /// A builder for [`EbsUtilizationMetric`](crate::model::EbsUtilizationMetric).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::EbsMetricName>,
        pub(crate) statistic: std::option::Option<crate::model::MetricStatistic>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The name of the utilization metric.</p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>VolumeReadOpsPerSecond</code> - The completed read operations per second from the volume in a specified period of time.</p> <p>Unit: Count</p> </li> 
        /// <li> <p> <code>VolumeWriteOpsPerSecond</code> - The completed write operations per second to the volume in a specified period of time.</p> <p>Unit: Count</p> </li> 
        /// <li> <p> <code>VolumeReadBytesPerSecond</code> - The bytes read per second from the volume in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
        /// <li> <p> <code>VolumeWriteBytesPerSecond</code> - The bytes written to the volume in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
        /// </ul>
        pub fn name(mut self, input: crate::model::EbsMetricName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the utilization metric.</p> 
        /// <p>The following utilization metrics are available:</p> 
        /// <ul> 
        /// <li> <p> <code>VolumeReadOpsPerSecond</code> - The completed read operations per second from the volume in a specified period of time.</p> <p>Unit: Count</p> </li> 
        /// <li> <p> <code>VolumeWriteOpsPerSecond</code> - The completed write operations per second to the volume in a specified period of time.</p> <p>Unit: Count</p> </li> 
        /// <li> <p> <code>VolumeReadBytesPerSecond</code> - The bytes read per second from the volume in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
        /// <li> <p> <code>VolumeWriteBytesPerSecond</code> - The bytes written to the volume in a specified period of time.</p> <p>Unit: Bytes</p> </li> 
        /// </ul>
        pub fn set_name(mut self, input: std::option::Option<crate::model::EbsMetricName>) -> Self {
            self.name = input; self
        }
        /// <p>The statistic of the utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn statistic(mut self, input: crate::model::MetricStatistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic of the utilization metric.</p> 
        /// <p>The Compute Optimizer API, Command Line Interface (CLI), and SDKs return utilization metrics using only the <code>Maximum</code> statistic, which is the highest value observed during the specified period.</p> 
        /// <p>The Compute Optimizer console displays graphs for some utilization metrics using the <code>Average</code> statistic, which is the value of <code>Sum</code> / <code>SampleCount</code> during the specified period. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/viewing-recommendations.html">Viewing resource recommendations</a> in the <i>Compute Optimizer User Guide</i>. You can also get averaged utilization metric data for your resources using Amazon CloudWatch. For more information, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User Guide</a>.</p>
        pub fn set_statistic(mut self, input: std::option::Option<crate::model::MetricStatistic>) -> Self {
            self.statistic = input; self
        }
        /// <p>The value of the utilization metric.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the utilization metric.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`EbsUtilizationMetric`](crate::model::EbsUtilizationMetric).
        pub fn build(self) -> crate::model::EbsUtilizationMetric {
            crate::model::EbsUtilizationMetric {
                name: self.name
                ,
                statistic: self.statistic
                ,
                value: self.value
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl EbsUtilizationMetric {
    /// Creates a new builder-style object to manufacture [`EbsUtilizationMetric`](crate::model::EbsUtilizationMetric).
    pub fn builder() -> crate::model::ebs_utilization_metric::Builder {
        crate::model::ebs_utilization_metric::Builder::default()
    }
}

/// When writing a match expression against `EbsMetricName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let ebsmetricname = unimplemented!();
/// match ebsmetricname {
///     EbsMetricName::VolumeReadBytesPerSecond => { /* ... */ },
///     EbsMetricName::VolumeReadOpsPerSecond => { /* ... */ },
///     EbsMetricName::VolumeWriteBytesPerSecond => { /* ... */ },
///     EbsMetricName::VolumeWriteOpsPerSecond => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ebsmetricname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EbsMetricName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EbsMetricName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EbsMetricName::NewFeature` is defined.
/// Specifically, when `ebsmetricname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EbsMetricName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EbsMetricName {
    #[allow(missing_docs)] // documentation missing in model
    VolumeReadBytesPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    VolumeReadOpsPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    VolumeWriteBytesPerSecond,
    #[allow(missing_docs)] // documentation missing in model
    VolumeWriteOpsPerSecond,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EbsMetricName {
    fn from(s: &str) -> Self {
        match s {
            "VolumeReadBytesPerSecond" => EbsMetricName::VolumeReadBytesPerSecond,
            "VolumeReadOpsPerSecond" => EbsMetricName::VolumeReadOpsPerSecond,
            "VolumeWriteBytesPerSecond" => EbsMetricName::VolumeWriteBytesPerSecond,
            "VolumeWriteOpsPerSecond" => EbsMetricName::VolumeWriteOpsPerSecond,
            other => EbsMetricName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EbsMetricName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EbsMetricName::from(s))
                }
            }
impl EbsMetricName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EbsMetricName::VolumeReadBytesPerSecond => "VolumeReadBytesPerSecond",
            EbsMetricName::VolumeReadOpsPerSecond => "VolumeReadOpsPerSecond",
            EbsMetricName::VolumeWriteBytesPerSecond => "VolumeWriteBytesPerSecond",
            EbsMetricName::VolumeWriteOpsPerSecond => "VolumeWriteOpsPerSecond",
            EbsMetricName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "VolumeReadBytesPerSecond", "VolumeReadOpsPerSecond", "VolumeWriteBytesPerSecond", "VolumeWriteOpsPerSecond"
        ]
    }
}
impl AsRef<str> for EbsMetricName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EbsFinding`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let ebsfinding = unimplemented!();
/// match ebsfinding {
///     EbsFinding::NotOptimized => { /* ... */ },
///     EbsFinding::Optimized => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ebsfinding` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EbsFinding::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EbsFinding::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EbsFinding::NewFeature` is defined.
/// Specifically, when `ebsfinding` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EbsFinding::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EbsFinding {
    #[allow(missing_docs)] // documentation missing in model
    NotOptimized,
    #[allow(missing_docs)] // documentation missing in model
    Optimized,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EbsFinding {
    fn from(s: &str) -> Self {
        match s {
            "NotOptimized" => EbsFinding::NotOptimized,
            "Optimized" => EbsFinding::Optimized,
            other => EbsFinding::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EbsFinding {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EbsFinding::from(s))
                }
            }
impl EbsFinding {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EbsFinding::NotOptimized => "NotOptimized",
            EbsFinding::Optimized => "Optimized",
            EbsFinding::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "NotOptimized", "Optimized"
        ]
    }
}
impl AsRef<str> for EbsFinding {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a filter that returns a more specific list of Amazon Elastic Block Store (Amazon EBS) volume recommendations. Use this filter with the <code>GetEBSVolumeRecommendations</code> action.</p> 
/// <p>You can use <code>LambdaFunctionRecommendationFilter</code> with the <code>GetLambdaFunctionRecommendations</code> action, <code>JobFilter</code> with the <code>DescribeRecommendationExportJobs</code> action, and <code>Filter</code> with the <code>GetAutoScalingGroupRecommendations</code> and <code>GetEC2InstanceRecommendations</code> actions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EbsFilter  {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::EbsFilterName>,
    /// <p>The value of the filter.</p> 
    /// <p>The valid values are <code>Optimized</code>, or <code>NotOptimized</code>.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl EbsFilter {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p>
    pub fn name(&self) -> std::option::Option<& crate::model::EbsFilterName> {
        self.name.as_ref()
    }
    /// <p>The value of the filter.</p> 
    /// <p>The valid values are <code>Optimized</code>, or <code>NotOptimized</code>.</p>
    pub fn values(&self) -> std::option::Option<& [std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`EbsFilter`](crate::model::EbsFilter).
pub mod ebs_filter {
    
    /// A builder for [`EbsFilter`](crate::model::EbsFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::EbsFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p>
        pub fn name(mut self, input: crate::model::EbsFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::EbsFilterName>) -> Self {
            self.name = input; self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value of the filter.</p> 
        /// <p>The valid values are <code>Optimized</code>, or <code>NotOptimized</code>.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
                            v.push(input.into());
                            self.values = Some(v);
                            self
        }
        /// <p>The value of the filter.</p> 
        /// <p>The valid values are <code>Optimized</code>, or <code>NotOptimized</code>.</p>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`EbsFilter`](crate::model::EbsFilter).
        pub fn build(self) -> crate::model::EbsFilter {
            crate::model::EbsFilter {
                name: self.name
                ,
                values: self.values
                ,
            }
        }
    }
    
    
}
impl EbsFilter {
    /// Creates a new builder-style object to manufacture [`EbsFilter`](crate::model::EbsFilter).
    pub fn builder() -> crate::model::ebs_filter::Builder {
        crate::model::ebs_filter::Builder::default()
    }
}

/// When writing a match expression against `EbsFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let ebsfiltername = unimplemented!();
/// match ebsfiltername {
///     EbsFilterName::Finding => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ebsfiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EbsFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EbsFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EbsFilterName::NewFeature` is defined.
/// Specifically, when `ebsfiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EbsFilterName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum EbsFilterName {
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for EbsFilterName {
    fn from(s: &str) -> Self {
        match s {
            "Finding" => EbsFilterName::Finding,
            other => EbsFilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for EbsFilterName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(EbsFilterName::from(s))
                }
            }
impl EbsFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EbsFilterName::Finding => "Finding",
            EbsFilterName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Finding"
        ]
    }
}
impl AsRef<str> for EbsFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an Auto Scaling group recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoScalingGroupRecommendation  {
    /// <p>The Amazon Web Services account ID of the Auto Scaling group.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Auto Scaling group.</p>
    #[doc(hidden)]
    pub auto_scaling_group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the Auto Scaling group.</p>
    #[doc(hidden)]
    pub auto_scaling_group_name: std::option::Option<std::string::String>,
    /// <p>The finding classification of the Auto Scaling group.</p> 
    /// <p>Findings for Auto Scaling groups include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>NotOptimized</code> </b>An Auto Scaling group is considered not optimized when Compute Optimizer identifies a recommendation that can provide better performance for your workload.</p> </li> 
    /// <li> <p> <b> <code>Optimized</code> </b>An Auto Scaling group is considered optimized when Compute Optimizer determines that the group is correctly provisioned to run your workload based on the chosen instance type. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub finding: std::option::Option<crate::model::Finding>,
    /// <p>An array of objects that describe the utilization metrics of the Auto Scaling group.</p>
    #[doc(hidden)]
    pub utilization_metrics: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>,
    /// <p>The number of days for which utilization metrics were analyzed for the Auto Scaling group.</p>
    #[doc(hidden)]
    pub look_back_period_in_days: f64,
    /// <p>An array of objects that describe the current configuration of the Auto Scaling group.</p>
    #[doc(hidden)]
    pub current_configuration: std::option::Option<crate::model::AutoScalingGroupConfiguration>,
    /// <p>An array of objects that describe the recommendation options for the Auto Scaling group.</p>
    #[doc(hidden)]
    pub recommendation_options: std::option::Option<std::vec::Vec<crate::model::AutoScalingGroupRecommendationOption>>,
    /// <p>The timestamp of when the Auto Scaling group recommendation was last generated.</p>
    #[doc(hidden)]
    pub last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The risk of the current Auto Scaling group not meeting the performance needs of its workloads. The higher the risk, the more likely the current Auto Scaling group configuration has insufficient capacity and cannot meet workload requirements.</p>
    #[doc(hidden)]
    pub current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
    /// <p>An object that describes the effective recommendation preferences for the Auto Scaling group.</p>
    #[doc(hidden)]
    pub effective_recommendation_preferences: std::option::Option<crate::model::EffectiveRecommendationPreferences>,
    /// <p>The applications that might be running on the instances in the Auto Scaling group as inferred by Compute Optimizer.</p> 
    /// <p>Compute Optimizer can infer if one of the following applications might be running on the instances:</p> 
    /// <ul> 
    /// <li> <p> <code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instances.</p> </li> 
    /// <li> <p> <code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instances.</p> </li> 
    /// <li> <p> <code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instances.</p> </li> 
    /// <li> <p> <code>Memcached</code> - Infers that Memcached might be running on the instances.</p> </li> 
    /// <li> <p> <code>NGINX</code> - Infers that NGINX might be running on the instances.</p> </li> 
    /// <li> <p> <code>PostgreSql</code> - Infers that PostgreSQL might be running on the instances.</p> </li> 
    /// <li> <p> <code>Redis</code> - Infers that Redis might be running on the instances.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub inferred_workload_types: std::option::Option<std::vec::Vec<crate::model::InferredWorkloadType>>,
}
impl AutoScalingGroupRecommendation {
    /// <p>The Amazon Web Services account ID of the Auto Scaling group.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Auto Scaling group.</p>
    pub fn auto_scaling_group_arn(&self) -> std::option::Option<& str> {
        self.auto_scaling_group_arn.as_deref()
    }
    /// <p>The name of the Auto Scaling group.</p>
    pub fn auto_scaling_group_name(&self) -> std::option::Option<& str> {
        self.auto_scaling_group_name.as_deref()
    }
    /// <p>The finding classification of the Auto Scaling group.</p> 
    /// <p>Findings for Auto Scaling groups include:</p> 
    /// <ul> 
    /// <li> <p> <b> <code>NotOptimized</code> </b>An Auto Scaling group is considered not optimized when Compute Optimizer identifies a recommendation that can provide better performance for your workload.</p> </li> 
    /// <li> <p> <b> <code>Optimized</code> </b>An Auto Scaling group is considered optimized when Compute Optimizer determines that the group is correctly provisioned to run your workload based on the chosen instance type. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p> </li> 
    /// </ul>
    pub fn finding(&self) -> std::option::Option<& crate::model::Finding> {
        self.finding.as_ref()
    }
    /// <p>An array of objects that describe the utilization metrics of the Auto Scaling group.</p>
    pub fn utilization_metrics(&self) -> std::option::Option<& [crate::model::UtilizationMetric]> {
        self.utilization_metrics.as_deref()
    }
    /// <p>The number of days for which utilization metrics were analyzed for the Auto Scaling group.</p>
    pub fn look_back_period_in_days(&self) -> f64 {
        self.look_back_period_in_days
    }
    /// <p>An array of objects that describe the current configuration of the Auto Scaling group.</p>
    pub fn current_configuration(&self) -> std::option::Option<& crate::model::AutoScalingGroupConfiguration> {
        self.current_configuration.as_ref()
    }
    /// <p>An array of objects that describe the recommendation options for the Auto Scaling group.</p>
    pub fn recommendation_options(&self) -> std::option::Option<& [crate::model::AutoScalingGroupRecommendationOption]> {
        self.recommendation_options.as_deref()
    }
    /// <p>The timestamp of when the Auto Scaling group recommendation was last generated.</p>
    pub fn last_refresh_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.last_refresh_timestamp.as_ref()
    }
    /// <p>The risk of the current Auto Scaling group not meeting the performance needs of its workloads. The higher the risk, the more likely the current Auto Scaling group configuration has insufficient capacity and cannot meet workload requirements.</p>
    pub fn current_performance_risk(&self) -> std::option::Option<& crate::model::CurrentPerformanceRisk> {
        self.current_performance_risk.as_ref()
    }
    /// <p>An object that describes the effective recommendation preferences for the Auto Scaling group.</p>
    pub fn effective_recommendation_preferences(&self) -> std::option::Option<& crate::model::EffectiveRecommendationPreferences> {
        self.effective_recommendation_preferences.as_ref()
    }
    /// <p>The applications that might be running on the instances in the Auto Scaling group as inferred by Compute Optimizer.</p> 
    /// <p>Compute Optimizer can infer if one of the following applications might be running on the instances:</p> 
    /// <ul> 
    /// <li> <p> <code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instances.</p> </li> 
    /// <li> <p> <code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instances.</p> </li> 
    /// <li> <p> <code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instances.</p> </li> 
    /// <li> <p> <code>Memcached</code> - Infers that Memcached might be running on the instances.</p> </li> 
    /// <li> <p> <code>NGINX</code> - Infers that NGINX might be running on the instances.</p> </li> 
    /// <li> <p> <code>PostgreSql</code> - Infers that PostgreSQL might be running on the instances.</p> </li> 
    /// <li> <p> <code>Redis</code> - Infers that Redis might be running on the instances.</p> </li> 
    /// </ul>
    pub fn inferred_workload_types(&self) -> std::option::Option<& [crate::model::InferredWorkloadType]> {
        self.inferred_workload_types.as_deref()
    }
}
/// See [`AutoScalingGroupRecommendation`](crate::model::AutoScalingGroupRecommendation).
pub mod auto_scaling_group_recommendation {
    
    /// A builder for [`AutoScalingGroupRecommendation`](crate::model::AutoScalingGroupRecommendation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group_arn: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group_name: std::option::Option<std::string::String>,
        pub(crate) finding: std::option::Option<crate::model::Finding>,
        pub(crate) utilization_metrics: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>,
        pub(crate) look_back_period_in_days: std::option::Option<f64>,
        pub(crate) current_configuration: std::option::Option<crate::model::AutoScalingGroupConfiguration>,
        pub(crate) recommendation_options: std::option::Option<std::vec::Vec<crate::model::AutoScalingGroupRecommendationOption>>,
        pub(crate) last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) current_performance_risk: std::option::Option<crate::model::CurrentPerformanceRisk>,
        pub(crate) effective_recommendation_preferences: std::option::Option<crate::model::EffectiveRecommendationPreferences>,
        pub(crate) inferred_workload_types: std::option::Option<std::vec::Vec<crate::model::InferredWorkloadType>>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account ID of the Auto Scaling group.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the Auto Scaling group.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the Auto Scaling group.</p>
        pub fn auto_scaling_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Auto Scaling group.</p>
        pub fn set_auto_scaling_group_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.auto_scaling_group_arn = input; self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_name = Some(input.into());
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn set_auto_scaling_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.auto_scaling_group_name = input; self
        }
        /// <p>The finding classification of the Auto Scaling group.</p> 
        /// <p>Findings for Auto Scaling groups include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>NotOptimized</code> </b>An Auto Scaling group is considered not optimized when Compute Optimizer identifies a recommendation that can provide better performance for your workload.</p> </li> 
        /// <li> <p> <b> <code>Optimized</code> </b>An Auto Scaling group is considered optimized when Compute Optimizer determines that the group is correctly provisioned to run your workload based on the chosen instance type. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p> </li> 
        /// </ul>
        pub fn finding(mut self, input: crate::model::Finding) -> Self {
            self.finding = Some(input);
            self
        }
        /// <p>The finding classification of the Auto Scaling group.</p> 
        /// <p>Findings for Auto Scaling groups include:</p> 
        /// <ul> 
        /// <li> <p> <b> <code>NotOptimized</code> </b>An Auto Scaling group is considered not optimized when Compute Optimizer identifies a recommendation that can provide better performance for your workload.</p> </li> 
        /// <li> <p> <b> <code>Optimized</code> </b>An Auto Scaling group is considered optimized when Compute Optimizer determines that the group is correctly provisioned to run your workload based on the chosen instance type. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p> </li> 
        /// </ul>
        pub fn set_finding(mut self, input: std::option::Option<crate::model::Finding>) -> Self {
            self.finding = input; self
        }
        /// Appends an item to `utilization_metrics`.
        ///
        /// To override the contents of this collection use [`set_utilization_metrics`](Self::set_utilization_metrics).
        ///
        /// <p>An array of objects that describe the utilization metrics of the Auto Scaling group.</p>
        pub fn utilization_metrics(mut self, input: crate::model::UtilizationMetric) -> Self {
            let mut v = self.utilization_metrics.unwrap_or_default();
                            v.push(input);
                            self.utilization_metrics = Some(v);
                            self
        }
        /// <p>An array of objects that describe the utilization metrics of the Auto Scaling group.</p>
        pub fn set_utilization_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>) -> Self {
            self.utilization_metrics = input; self
        }
        /// <p>The number of days for which utilization metrics were analyzed for the Auto Scaling group.</p>
        pub fn look_back_period_in_days(mut self, input: f64) -> Self {
            self.look_back_period_in_days = Some(input);
            self
        }
        /// <p>The number of days for which utilization metrics were analyzed for the Auto Scaling group.</p>
        pub fn set_look_back_period_in_days(mut self, input: std::option::Option<f64>) -> Self {
            self.look_back_period_in_days = input; self
        }
        /// <p>An array of objects that describe the current configuration of the Auto Scaling group.</p>
        pub fn current_configuration(mut self, input: crate::model::AutoScalingGroupConfiguration) -> Self {
            self.current_configuration = Some(input);
            self
        }
        /// <p>An array of objects that describe the current configuration of the Auto Scaling group.</p>
        pub fn set_current_configuration(mut self, input: std::option::Option<crate::model::AutoScalingGroupConfiguration>) -> Self {
            self.current_configuration = input; self
        }
        /// Appends an item to `recommendation_options`.
        ///
        /// To override the contents of this collection use [`set_recommendation_options`](Self::set_recommendation_options).
        ///
        /// <p>An array of objects that describe the recommendation options for the Auto Scaling group.</p>
        pub fn recommendation_options(mut self, input: crate::model::AutoScalingGroupRecommendationOption) -> Self {
            let mut v = self.recommendation_options.unwrap_or_default();
                            v.push(input);
                            self.recommendation_options = Some(v);
                            self
        }
        /// <p>An array of objects that describe the recommendation options for the Auto Scaling group.</p>
        pub fn set_recommendation_options(mut self, input: std::option::Option<std::vec::Vec<crate::model::AutoScalingGroupRecommendationOption>>) -> Self {
            self.recommendation_options = input; self
        }
        /// <p>The timestamp of when the Auto Scaling group recommendation was last generated.</p>
        pub fn last_refresh_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_refresh_timestamp = Some(input);
            self
        }
        /// <p>The timestamp of when the Auto Scaling group recommendation was last generated.</p>
        pub fn set_last_refresh_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.last_refresh_timestamp = input; self
        }
        /// <p>The risk of the current Auto Scaling group not meeting the performance needs of its workloads. The higher the risk, the more likely the current Auto Scaling group configuration has insufficient capacity and cannot meet workload requirements.</p>
        pub fn current_performance_risk(mut self, input: crate::model::CurrentPerformanceRisk) -> Self {
            self.current_performance_risk = Some(input);
            self
        }
        /// <p>The risk of the current Auto Scaling group not meeting the performance needs of its workloads. The higher the risk, the more likely the current Auto Scaling group configuration has insufficient capacity and cannot meet workload requirements.</p>
        pub fn set_current_performance_risk(mut self, input: std::option::Option<crate::model::CurrentPerformanceRisk>) -> Self {
            self.current_performance_risk = input; self
        }
        /// <p>An object that describes the effective recommendation preferences for the Auto Scaling group.</p>
        pub fn effective_recommendation_preferences(mut self, input: crate::model::EffectiveRecommendationPreferences) -> Self {
            self.effective_recommendation_preferences = Some(input);
            self
        }
        /// <p>An object that describes the effective recommendation preferences for the Auto Scaling group.</p>
        pub fn set_effective_recommendation_preferences(mut self, input: std::option::Option<crate::model::EffectiveRecommendationPreferences>) -> Self {
            self.effective_recommendation_preferences = input; self
        }
        /// Appends an item to `inferred_workload_types`.
        ///
        /// To override the contents of this collection use [`set_inferred_workload_types`](Self::set_inferred_workload_types).
        ///
        /// <p>The applications that might be running on the instances in the Auto Scaling group as inferred by Compute Optimizer.</p> 
        /// <p>Compute Optimizer can infer if one of the following applications might be running on the instances:</p> 
        /// <ul> 
        /// <li> <p> <code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instances.</p> </li> 
        /// <li> <p> <code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instances.</p> </li> 
        /// <li> <p> <code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instances.</p> </li> 
        /// <li> <p> <code>Memcached</code> - Infers that Memcached might be running on the instances.</p> </li> 
        /// <li> <p> <code>NGINX</code> - Infers that NGINX might be running on the instances.</p> </li> 
        /// <li> <p> <code>PostgreSql</code> - Infers that PostgreSQL might be running on the instances.</p> </li> 
        /// <li> <p> <code>Redis</code> - Infers that Redis might be running on the instances.</p> </li> 
        /// </ul>
        pub fn inferred_workload_types(mut self, input: crate::model::InferredWorkloadType) -> Self {
            let mut v = self.inferred_workload_types.unwrap_or_default();
                            v.push(input);
                            self.inferred_workload_types = Some(v);
                            self
        }
        /// <p>The applications that might be running on the instances in the Auto Scaling group as inferred by Compute Optimizer.</p> 
        /// <p>Compute Optimizer can infer if one of the following applications might be running on the instances:</p> 
        /// <ul> 
        /// <li> <p> <code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instances.</p> </li> 
        /// <li> <p> <code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instances.</p> </li> 
        /// <li> <p> <code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instances.</p> </li> 
        /// <li> <p> <code>Memcached</code> - Infers that Memcached might be running on the instances.</p> </li> 
        /// <li> <p> <code>NGINX</code> - Infers that NGINX might be running on the instances.</p> </li> 
        /// <li> <p> <code>PostgreSql</code> - Infers that PostgreSQL might be running on the instances.</p> </li> 
        /// <li> <p> <code>Redis</code> - Infers that Redis might be running on the instances.</p> </li> 
        /// </ul>
        pub fn set_inferred_workload_types(mut self, input: std::option::Option<std::vec::Vec<crate::model::InferredWorkloadType>>) -> Self {
            self.inferred_workload_types = input; self
        }
        /// Consumes the builder and constructs a [`AutoScalingGroupRecommendation`](crate::model::AutoScalingGroupRecommendation).
        pub fn build(self) -> crate::model::AutoScalingGroupRecommendation {
            crate::model::AutoScalingGroupRecommendation {
                account_id: self.account_id
                ,
                auto_scaling_group_arn: self.auto_scaling_group_arn
                ,
                auto_scaling_group_name: self.auto_scaling_group_name
                ,
                finding: self.finding
                ,
                utilization_metrics: self.utilization_metrics
                ,
                look_back_period_in_days: self.look_back_period_in_days
                    .unwrap_or_default()
                ,
                current_configuration: self.current_configuration
                ,
                recommendation_options: self.recommendation_options
                ,
                last_refresh_timestamp: self.last_refresh_timestamp
                ,
                current_performance_risk: self.current_performance_risk
                ,
                effective_recommendation_preferences: self.effective_recommendation_preferences
                ,
                inferred_workload_types: self.inferred_workload_types
                ,
            }
        }
    }
    
    
}
impl AutoScalingGroupRecommendation {
    /// Creates a new builder-style object to manufacture [`AutoScalingGroupRecommendation`](crate::model::AutoScalingGroupRecommendation).
    pub fn builder() -> crate::model::auto_scaling_group_recommendation::Builder {
        crate::model::auto_scaling_group_recommendation::Builder::default()
    }
}

/// <p>Describes a recommendation option for an Auto Scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoScalingGroupRecommendationOption  {
    /// <p>An array of objects that describe an Auto Scaling group configuration.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::AutoScalingGroupConfiguration>,
    /// <p>An array of objects that describe the projected utilization metrics of the Auto Scaling group recommendation option.</p> <note> 
    /// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
    /// </note>
    #[doc(hidden)]
    pub projected_utilization_metrics: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>,
    /// <p>The performance risk of the Auto Scaling group configuration recommendation.</p> 
    /// <p>Performance risk indicates the likelihood of the recommended instance type not meeting the resource needs of your workload. Compute Optimizer calculates an individual performance risk score for each specification of the recommended instance, including CPU, memory, EBS throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS. The performance risk of the recommended instance is calculated as the maximum performance risk score across the analyzed resource specifications.</p> 
    /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
    #[doc(hidden)]
    pub performance_risk: f64,
    /// <p>The rank of the Auto Scaling group recommendation option.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p>
    #[doc(hidden)]
    pub rank: i32,
    /// <p>An object that describes the savings opportunity for the Auto Scaling group recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    #[doc(hidden)]
    pub savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
    /// <p>The level of effort required to migrate from the current instance type to the recommended instance type.</p> 
    /// <p>For example, the migration effort is <code>Low</code> if Amazon EMR is the inferred workload type and an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>Medium</code> if a workload type couldn't be inferred but an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>VeryLow</code> if both the current and recommended instance types are of the same CPU architecture.</p>
    #[doc(hidden)]
    pub migration_effort: std::option::Option<crate::model::MigrationEffort>,
}
impl AutoScalingGroupRecommendationOption {
    /// <p>An array of objects that describe an Auto Scaling group configuration.</p>
    pub fn configuration(&self) -> std::option::Option<& crate::model::AutoScalingGroupConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>An array of objects that describe the projected utilization metrics of the Auto Scaling group recommendation option.</p> <note> 
    /// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
    /// </note>
    pub fn projected_utilization_metrics(&self) -> std::option::Option<& [crate::model::UtilizationMetric]> {
        self.projected_utilization_metrics.as_deref()
    }
    /// <p>The performance risk of the Auto Scaling group configuration recommendation.</p> 
    /// <p>Performance risk indicates the likelihood of the recommended instance type not meeting the resource needs of your workload. Compute Optimizer calculates an individual performance risk score for each specification of the recommended instance, including CPU, memory, EBS throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS. The performance risk of the recommended instance is calculated as the maximum performance risk score across the analyzed resource specifications.</p> 
    /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
    pub fn performance_risk(&self) -> f64 {
        self.performance_risk
    }
    /// <p>The rank of the Auto Scaling group recommendation option.</p> 
    /// <p>The top recommendation option is ranked as <code>1</code>.</p>
    pub fn rank(&self) -> i32 {
        self.rank
    }
    /// <p>An object that describes the savings opportunity for the Auto Scaling group recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
    pub fn savings_opportunity(&self) -> std::option::Option<& crate::model::SavingsOpportunity> {
        self.savings_opportunity.as_ref()
    }
    /// <p>The level of effort required to migrate from the current instance type to the recommended instance type.</p> 
    /// <p>For example, the migration effort is <code>Low</code> if Amazon EMR is the inferred workload type and an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>Medium</code> if a workload type couldn't be inferred but an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>VeryLow</code> if both the current and recommended instance types are of the same CPU architecture.</p>
    pub fn migration_effort(&self) -> std::option::Option<& crate::model::MigrationEffort> {
        self.migration_effort.as_ref()
    }
}
/// See [`AutoScalingGroupRecommendationOption`](crate::model::AutoScalingGroupRecommendationOption).
pub mod auto_scaling_group_recommendation_option {
    
    /// A builder for [`AutoScalingGroupRecommendationOption`](crate::model::AutoScalingGroupRecommendationOption).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration: std::option::Option<crate::model::AutoScalingGroupConfiguration>,
        pub(crate) projected_utilization_metrics: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>,
        pub(crate) performance_risk: std::option::Option<f64>,
        pub(crate) rank: std::option::Option<i32>,
        pub(crate) savings_opportunity: std::option::Option<crate::model::SavingsOpportunity>,
        pub(crate) migration_effort: std::option::Option<crate::model::MigrationEffort>,
    }
    impl Builder {
        /// <p>An array of objects that describe an Auto Scaling group configuration.</p>
        pub fn configuration(mut self, input: crate::model::AutoScalingGroupConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>An array of objects that describe an Auto Scaling group configuration.</p>
        pub fn set_configuration(mut self, input: std::option::Option<crate::model::AutoScalingGroupConfiguration>) -> Self {
            self.configuration = input; self
        }
        /// Appends an item to `projected_utilization_metrics`.
        ///
        /// To override the contents of this collection use [`set_projected_utilization_metrics`](Self::set_projected_utilization_metrics).
        ///
        /// <p>An array of objects that describe the projected utilization metrics of the Auto Scaling group recommendation option.</p> <note> 
        /// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
        /// </note>
        pub fn projected_utilization_metrics(mut self, input: crate::model::UtilizationMetric) -> Self {
            let mut v = self.projected_utilization_metrics.unwrap_or_default();
                            v.push(input);
                            self.projected_utilization_metrics = Some(v);
                            self
        }
        /// <p>An array of objects that describe the projected utilization metrics of the Auto Scaling group recommendation option.</p> <note> 
        /// <p>The <code>Cpu</code> and <code>Memory</code> metrics are the only projected utilization metrics returned. Additionally, the <code>Memory</code> metric is returned only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling Memory Utilization with the CloudWatch Agent</a>.</p> 
        /// </note>
        pub fn set_projected_utilization_metrics(mut self, input: std::option::Option<std::vec::Vec<crate::model::UtilizationMetric>>) -> Self {
            self.projected_utilization_metrics = input; self
        }
        /// <p>The performance risk of the Auto Scaling group configuration recommendation.</p> 
        /// <p>Performance risk indicates the likelihood of the recommended instance type not meeting the resource needs of your workload. Compute Optimizer calculates an individual performance risk score for each specification of the recommended instance, including CPU, memory, EBS throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS. The performance risk of the recommended instance is calculated as the maximum performance risk score across the analyzed resource specifications.</p> 
        /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
        pub fn performance_risk(mut self, input: f64) -> Self {
            self.performance_risk = Some(input);
            self
        }
        /// <p>The performance risk of the Auto Scaling group configuration recommendation.</p> 
        /// <p>Performance risk indicates the likelihood of the recommended instance type not meeting the resource needs of your workload. Compute Optimizer calculates an individual performance risk score for each specification of the recommended instance, including CPU, memory, EBS throughput, EBS IOPS, disk throughput, disk IOPS, network throughput, and network PPS. The performance risk of the recommended instance is calculated as the maximum performance risk score across the analyzed resource specifications.</p> 
        /// <p>The value ranges from <code>0</code> - <code>4</code>, with <code>0</code> meaning that the recommended resource is predicted to always provide enough hardware capability. The higher the performance risk is, the more likely you should validate whether the recommendation will meet the performance requirements of your workload before migrating your resource.</p>
        pub fn set_performance_risk(mut self, input: std::option::Option<f64>) -> Self {
            self.performance_risk = input; self
        }
        /// <p>The rank of the Auto Scaling group recommendation option.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p>
        pub fn rank(mut self, input: i32) -> Self {
            self.rank = Some(input);
            self
        }
        /// <p>The rank of the Auto Scaling group recommendation option.</p> 
        /// <p>The top recommendation option is ranked as <code>1</code>.</p>
        pub fn set_rank(mut self, input: std::option::Option<i32>) -> Self {
            self.rank = input; self
        }
        /// <p>An object that describes the savings opportunity for the Auto Scaling group recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn savings_opportunity(mut self, input: crate::model::SavingsOpportunity) -> Self {
            self.savings_opportunity = Some(input);
            self
        }
        /// <p>An object that describes the savings opportunity for the Auto Scaling group recommendation option. Savings opportunity includes the estimated monthly savings amount and percentage.</p>
        pub fn set_savings_opportunity(mut self, input: std::option::Option<crate::model::SavingsOpportunity>) -> Self {
            self.savings_opportunity = input; self
        }
        /// <p>The level of effort required to migrate from the current instance type to the recommended instance type.</p> 
        /// <p>For example, the migration effort is <code>Low</code> if Amazon EMR is the inferred workload type and an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>Medium</code> if a workload type couldn't be inferred but an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>VeryLow</code> if both the current and recommended instance types are of the same CPU architecture.</p>
        pub fn migration_effort(mut self, input: crate::model::MigrationEffort) -> Self {
            self.migration_effort = Some(input);
            self
        }
        /// <p>The level of effort required to migrate from the current instance type to the recommended instance type.</p> 
        /// <p>For example, the migration effort is <code>Low</code> if Amazon EMR is the inferred workload type and an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>Medium</code> if a workload type couldn't be inferred but an Amazon Web Services Graviton instance type is recommended. The migration effort is <code>VeryLow</code> if both the current and recommended instance types are of the same CPU architecture.</p>
        pub fn set_migration_effort(mut self, input: std::option::Option<crate::model::MigrationEffort>) -> Self {
            self.migration_effort = input; self
        }
        /// Consumes the builder and constructs a [`AutoScalingGroupRecommendationOption`](crate::model::AutoScalingGroupRecommendationOption).
        pub fn build(self) -> crate::model::AutoScalingGroupRecommendationOption {
            crate::model::AutoScalingGroupRecommendationOption {
                configuration: self.configuration
                ,
                projected_utilization_metrics: self.projected_utilization_metrics
                ,
                performance_risk: self.performance_risk
                    .unwrap_or_default()
                ,
                rank: self.rank
                    .unwrap_or_default()
                ,
                savings_opportunity: self.savings_opportunity
                ,
                migration_effort: self.migration_effort
                ,
            }
        }
    }
    
    
}
impl AutoScalingGroupRecommendationOption {
    /// Creates a new builder-style object to manufacture [`AutoScalingGroupRecommendationOption`](crate::model::AutoScalingGroupRecommendationOption).
    pub fn builder() -> crate::model::auto_scaling_group_recommendation_option::Builder {
        crate::model::auto_scaling_group_recommendation_option::Builder::default()
    }
}

/// <p>Describes the configuration of an Auto Scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoScalingGroupConfiguration  {
    /// <p>The desired capacity, or number of instances, for the Auto Scaling group.</p>
    #[doc(hidden)]
    pub desired_capacity: i32,
    /// <p>The minimum size, or minimum number of instances, for the Auto Scaling group.</p>
    #[doc(hidden)]
    pub min_size: i32,
    /// <p>The maximum size, or maximum number of instances, for the Auto Scaling group.</p>
    #[doc(hidden)]
    pub max_size: i32,
    /// <p>The instance type for the Auto Scaling group.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<std::string::String>,
}
impl AutoScalingGroupConfiguration {
    /// <p>The desired capacity, or number of instances, for the Auto Scaling group.</p>
    pub fn desired_capacity(&self) -> i32 {
        self.desired_capacity
    }
    /// <p>The minimum size, or minimum number of instances, for the Auto Scaling group.</p>
    pub fn min_size(&self) -> i32 {
        self.min_size
    }
    /// <p>The maximum size, or maximum number of instances, for the Auto Scaling group.</p>
    pub fn max_size(&self) -> i32 {
        self.max_size
    }
    /// <p>The instance type for the Auto Scaling group.</p>
    pub fn instance_type(&self) -> std::option::Option<& str> {
        self.instance_type.as_deref()
    }
}
/// See [`AutoScalingGroupConfiguration`](crate::model::AutoScalingGroupConfiguration).
pub mod auto_scaling_group_configuration {
    
    /// A builder for [`AutoScalingGroupConfiguration`](crate::model::AutoScalingGroupConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) desired_capacity: std::option::Option<i32>,
        pub(crate) min_size: std::option::Option<i32>,
        pub(crate) max_size: std::option::Option<i32>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The desired capacity, or number of instances, for the Auto Scaling group.</p>
        pub fn desired_capacity(mut self, input: i32) -> Self {
            self.desired_capacity = Some(input);
            self
        }
        /// <p>The desired capacity, or number of instances, for the Auto Scaling group.</p>
        pub fn set_desired_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_capacity = input; self
        }
        /// <p>The minimum size, or minimum number of instances, for the Auto Scaling group.</p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.min_size = Some(input);
            self
        }
        /// <p>The minimum size, or minimum number of instances, for the Auto Scaling group.</p>
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.min_size = input; self
        }
        /// <p>The maximum size, or maximum number of instances, for the Auto Scaling group.</p>
        pub fn max_size(mut self, input: i32) -> Self {
            self.max_size = Some(input);
            self
        }
        /// <p>The maximum size, or maximum number of instances, for the Auto Scaling group.</p>
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.max_size = input; self
        }
        /// <p>The instance type for the Auto Scaling group.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type for the Auto Scaling group.</p>
        pub fn set_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_type = input; self
        }
        /// Consumes the builder and constructs a [`AutoScalingGroupConfiguration`](crate::model::AutoScalingGroupConfiguration).
        pub fn build(self) -> crate::model::AutoScalingGroupConfiguration {
            crate::model::AutoScalingGroupConfiguration {
                desired_capacity: self.desired_capacity
                    .unwrap_or_default()
                ,
                min_size: self.min_size
                    .unwrap_or_default()
                ,
                max_size: self.max_size
                    .unwrap_or_default()
                ,
                instance_type: self.instance_type
                ,
            }
        }
    }
    
    
}
impl AutoScalingGroupConfiguration {
    /// Creates a new builder-style object to manufacture [`AutoScalingGroupConfiguration`](crate::model::AutoScalingGroupConfiguration).
    pub fn builder() -> crate::model::auto_scaling_group_configuration::Builder {
        crate::model::auto_scaling_group_configuration::Builder::default()
    }
}

/// <p>Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a recommendations export file, and its associated metadata file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Destination  {
    /// <p>The name of the Amazon S3 bucket used as the destination of an export file.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket key of an export file.</p> 
    /// <p>The key uniquely identifies the object, or export file, in the S3 bucket.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket key of a metadata file.</p> 
    /// <p>The key uniquely identifies the object, or metadata file, in the S3 bucket.</p>
    #[doc(hidden)]
    pub metadata_key: std::option::Option<std::string::String>,
}
impl S3Destination {
    /// <p>The name of the Amazon S3 bucket used as the destination of an export file.</p>
    pub fn bucket(&self) -> std::option::Option<& str> {
        self.bucket.as_deref()
    }
    /// <p>The Amazon S3 bucket key of an export file.</p> 
    /// <p>The key uniquely identifies the object, or export file, in the S3 bucket.</p>
    pub fn key(&self) -> std::option::Option<& str> {
        self.key.as_deref()
    }
    /// <p>The Amazon S3 bucket key of a metadata file.</p> 
    /// <p>The key uniquely identifies the object, or metadata file, in the S3 bucket.</p>
    pub fn metadata_key(&self) -> std::option::Option<& str> {
        self.metadata_key.as_deref()
    }
}
/// See [`S3Destination`](crate::model::S3Destination).
pub mod s3_destination {
    
    /// A builder for [`S3Destination`](crate::model::S3Destination).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) metadata_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket used as the destination of an export file.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket used as the destination of an export file.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input; self
        }
        /// <p>The Amazon S3 bucket key of an export file.</p> 
        /// <p>The key uniquely identifies the object, or export file, in the S3 bucket.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket key of an export file.</p> 
        /// <p>The key uniquely identifies the object, or export file, in the S3 bucket.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input; self
        }
        /// <p>The Amazon S3 bucket key of a metadata file.</p> 
        /// <p>The key uniquely identifies the object, or metadata file, in the S3 bucket.</p>
        pub fn metadata_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_key = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket key of a metadata file.</p> 
        /// <p>The key uniquely identifies the object, or metadata file, in the S3 bucket.</p>
        pub fn set_metadata_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata_key = input; self
        }
        /// Consumes the builder and constructs a [`S3Destination`](crate::model::S3Destination).
        pub fn build(self) -> crate::model::S3Destination {
            crate::model::S3Destination {
                bucket: self.bucket
                ,
                key: self.key
                ,
                metadata_key: self.metadata_key
                ,
            }
        }
    }
    
    
}
impl S3Destination {
    /// Creates a new builder-style object to manufacture [`S3Destination`](crate::model::S3Destination).
    pub fn builder() -> crate::model::s3_destination::Builder {
        crate::model::s3_destination::Builder::default()
    }
}

/// When writing a match expression against `FileFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let fileformat = unimplemented!();
/// match fileformat {
///     FileFormat::Csv => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fileformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FileFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FileFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FileFormat::NewFeature` is defined.
/// Specifically, when `fileformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FileFormat::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum FileFormat {
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for FileFormat {
    fn from(s: &str) -> Self {
        match s {
            "Csv" => FileFormat::Csv,
            other => FileFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for FileFormat {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(FileFormat::from(s))
                }
            }
impl FileFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FileFormat::Csv => "Csv",
            FileFormat::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Csv"
        ]
    }
}
impl AsRef<str> for FileFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and key prefix for a recommendations export job.</p> 
/// <p>You must create the destination Amazon S3 bucket for your recommendations export before you create the export job. Compute Optimizer does not create the S3 bucket for you. After you create the S3 bucket, ensure that it has the required permission policy to allow Compute Optimizer to write the export file to it. If you plan to specify an object prefix when you create the export job, you must include the object prefix in the policy that you add to the S3 bucket. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/create-s3-bucket-policy-for-compute-optimizer.html">Amazon S3 Bucket Policy for Compute Optimizer</a> in the <i>Compute Optimizer User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3DestinationConfig  {
    /// <p>The name of the Amazon S3 bucket to use as the destination for an export job.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket prefix for an export job.</p>
    #[doc(hidden)]
    pub key_prefix: std::option::Option<std::string::String>,
}
impl S3DestinationConfig {
    /// <p>The name of the Amazon S3 bucket to use as the destination for an export job.</p>
    pub fn bucket(&self) -> std::option::Option<& str> {
        self.bucket.as_deref()
    }
    /// <p>The Amazon S3 bucket prefix for an export job.</p>
    pub fn key_prefix(&self) -> std::option::Option<& str> {
        self.key_prefix.as_deref()
    }
}
/// See [`S3DestinationConfig`](crate::model::S3DestinationConfig).
pub mod s3_destination_config {
    
    /// A builder for [`S3DestinationConfig`](crate::model::S3DestinationConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket to use as the destination for an export job.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket to use as the destination for an export job.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input; self
        }
        /// <p>The Amazon S3 bucket prefix for an export job.</p>
        pub fn key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_prefix = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket prefix for an export job.</p>
        pub fn set_key_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_prefix = input; self
        }
        /// Consumes the builder and constructs a [`S3DestinationConfig`](crate::model::S3DestinationConfig).
        pub fn build(self) -> crate::model::S3DestinationConfig {
            crate::model::S3DestinationConfig {
                bucket: self.bucket
                ,
                key_prefix: self.key_prefix
                ,
            }
        }
    }
    
    
}
impl S3DestinationConfig {
    /// Creates a new builder-style object to manufacture [`S3DestinationConfig`](crate::model::S3DestinationConfig).
    pub fn builder() -> crate::model::s3_destination_config::Builder {
        crate::model::s3_destination_config::Builder::default()
    }
}

/// When writing a match expression against `ExportableLambdaFunctionField`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let exportablelambdafunctionfield = unimplemented!();
/// match exportablelambdafunctionfield {
///     ExportableLambdaFunctionField::AccountId => { /* ... */ },
///     ExportableLambdaFunctionField::CurrentConfigurationMemorySize => { /* ... */ },
///     ExportableLambdaFunctionField::CurrentConfigurationTimeout => { /* ... */ },
///     ExportableLambdaFunctionField::CurrentCostAverage => { /* ... */ },
///     ExportableLambdaFunctionField::CurrentCostTotal => { /* ... */ },
///     ExportableLambdaFunctionField::CurrentPerformanceRisk => { /* ... */ },
///     ExportableLambdaFunctionField::Finding => { /* ... */ },
///     ExportableLambdaFunctionField::FindingReasonCodes => { /* ... */ },
///     ExportableLambdaFunctionField::FunctionArn => { /* ... */ },
///     ExportableLambdaFunctionField::FunctionVersion => { /* ... */ },
///     ExportableLambdaFunctionField::LastRefreshTimestamp => { /* ... */ },
///     ExportableLambdaFunctionField::LookbackPeriodInDays => { /* ... */ },
///     ExportableLambdaFunctionField::NumberOfInvocations => { /* ... */ },
///     ExportableLambdaFunctionField::RecommendationOptionsConfigurationMemorySize => { /* ... */ },
///     ExportableLambdaFunctionField::RecommendationOptionsCostHigh => { /* ... */ },
///     ExportableLambdaFunctionField::RecommendationOptionsCostLow => { /* ... */ },
///     ExportableLambdaFunctionField::RecommendationOptionsEstimatedMonthlySavingsCurrency => { /* ... */ },
///     ExportableLambdaFunctionField::RecommendationOptionsEstimatedMonthlySavingsValue => { /* ... */ },
///     ExportableLambdaFunctionField::RecommendationOptionsProjectedUtilizationMetricsDurationExpected => { /* ... */ },
///     ExportableLambdaFunctionField::RecommendationOptionsProjectedUtilizationMetricsDurationLowerBound => { /* ... */ },
///     ExportableLambdaFunctionField::RecommendationOptionsProjectedUtilizationMetricsDurationUpperBound => { /* ... */ },
///     ExportableLambdaFunctionField::RecommendationOptionsSavingsOpportunityPercentage => { /* ... */ },
///     ExportableLambdaFunctionField::UtilizationMetricsDurationAverage => { /* ... */ },
///     ExportableLambdaFunctionField::UtilizationMetricsDurationMaximum => { /* ... */ },
///     ExportableLambdaFunctionField::UtilizationMetricsMemoryAverage => { /* ... */ },
///     ExportableLambdaFunctionField::UtilizationMetricsMemoryMaximum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `exportablelambdafunctionfield` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExportableLambdaFunctionField::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExportableLambdaFunctionField::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExportableLambdaFunctionField::NewFeature` is defined.
/// Specifically, when `exportablelambdafunctionfield` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExportableLambdaFunctionField::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ExportableLambdaFunctionField {
    #[allow(missing_docs)] // documentation missing in model
    AccountId,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationMemorySize,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationTimeout,
    #[allow(missing_docs)] // documentation missing in model
    CurrentCostAverage,
    #[allow(missing_docs)] // documentation missing in model
    CurrentCostTotal,
    #[allow(missing_docs)] // documentation missing in model
    CurrentPerformanceRisk,
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    #[allow(missing_docs)] // documentation missing in model
    FindingReasonCodes,
    #[allow(missing_docs)] // documentation missing in model
    FunctionArn,
    #[allow(missing_docs)] // documentation missing in model
    FunctionVersion,
    #[allow(missing_docs)] // documentation missing in model
    LastRefreshTimestamp,
    #[allow(missing_docs)] // documentation missing in model
    LookbackPeriodInDays,
    #[allow(missing_docs)] // documentation missing in model
    NumberOfInvocations,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationMemorySize,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsCostHigh,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsCostLow,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsCurrency,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsValue,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsProjectedUtilizationMetricsDurationExpected,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsProjectedUtilizationMetricsDurationLowerBound,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsProjectedUtilizationMetricsDurationUpperBound,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsSavingsOpportunityPercentage,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDurationAverage,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDurationMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsMemoryAverage,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsMemoryMaximum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ExportableLambdaFunctionField {
    fn from(s: &str) -> Self {
        match s {
            "AccountId" => ExportableLambdaFunctionField::AccountId,
            "CurrentConfigurationMemorySize" => ExportableLambdaFunctionField::CurrentConfigurationMemorySize,
            "CurrentConfigurationTimeout" => ExportableLambdaFunctionField::CurrentConfigurationTimeout,
            "CurrentCostAverage" => ExportableLambdaFunctionField::CurrentCostAverage,
            "CurrentCostTotal" => ExportableLambdaFunctionField::CurrentCostTotal,
            "CurrentPerformanceRisk" => ExportableLambdaFunctionField::CurrentPerformanceRisk,
            "Finding" => ExportableLambdaFunctionField::Finding,
            "FindingReasonCodes" => ExportableLambdaFunctionField::FindingReasonCodes,
            "FunctionArn" => ExportableLambdaFunctionField::FunctionArn,
            "FunctionVersion" => ExportableLambdaFunctionField::FunctionVersion,
            "LastRefreshTimestamp" => ExportableLambdaFunctionField::LastRefreshTimestamp,
            "LookbackPeriodInDays" => ExportableLambdaFunctionField::LookbackPeriodInDays,
            "NumberOfInvocations" => ExportableLambdaFunctionField::NumberOfInvocations,
            "RecommendationOptionsConfigurationMemorySize" => ExportableLambdaFunctionField::RecommendationOptionsConfigurationMemorySize,
            "RecommendationOptionsCostHigh" => ExportableLambdaFunctionField::RecommendationOptionsCostHigh,
            "RecommendationOptionsCostLow" => ExportableLambdaFunctionField::RecommendationOptionsCostLow,
            "RecommendationOptionsEstimatedMonthlySavingsCurrency" => ExportableLambdaFunctionField::RecommendationOptionsEstimatedMonthlySavingsCurrency,
            "RecommendationOptionsEstimatedMonthlySavingsValue" => ExportableLambdaFunctionField::RecommendationOptionsEstimatedMonthlySavingsValue,
            "RecommendationOptionsProjectedUtilizationMetricsDurationExpected" => ExportableLambdaFunctionField::RecommendationOptionsProjectedUtilizationMetricsDurationExpected,
            "RecommendationOptionsProjectedUtilizationMetricsDurationLowerBound" => ExportableLambdaFunctionField::RecommendationOptionsProjectedUtilizationMetricsDurationLowerBound,
            "RecommendationOptionsProjectedUtilizationMetricsDurationUpperBound" => ExportableLambdaFunctionField::RecommendationOptionsProjectedUtilizationMetricsDurationUpperBound,
            "RecommendationOptionsSavingsOpportunityPercentage" => ExportableLambdaFunctionField::RecommendationOptionsSavingsOpportunityPercentage,
            "UtilizationMetricsDurationAverage" => ExportableLambdaFunctionField::UtilizationMetricsDurationAverage,
            "UtilizationMetricsDurationMaximum" => ExportableLambdaFunctionField::UtilizationMetricsDurationMaximum,
            "UtilizationMetricsMemoryAverage" => ExportableLambdaFunctionField::UtilizationMetricsMemoryAverage,
            "UtilizationMetricsMemoryMaximum" => ExportableLambdaFunctionField::UtilizationMetricsMemoryMaximum,
            other => ExportableLambdaFunctionField::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ExportableLambdaFunctionField {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ExportableLambdaFunctionField::from(s))
                }
            }
impl ExportableLambdaFunctionField {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExportableLambdaFunctionField::AccountId => "AccountId",
            ExportableLambdaFunctionField::CurrentConfigurationMemorySize => "CurrentConfigurationMemorySize",
            ExportableLambdaFunctionField::CurrentConfigurationTimeout => "CurrentConfigurationTimeout",
            ExportableLambdaFunctionField::CurrentCostAverage => "CurrentCostAverage",
            ExportableLambdaFunctionField::CurrentCostTotal => "CurrentCostTotal",
            ExportableLambdaFunctionField::CurrentPerformanceRisk => "CurrentPerformanceRisk",
            ExportableLambdaFunctionField::Finding => "Finding",
            ExportableLambdaFunctionField::FindingReasonCodes => "FindingReasonCodes",
            ExportableLambdaFunctionField::FunctionArn => "FunctionArn",
            ExportableLambdaFunctionField::FunctionVersion => "FunctionVersion",
            ExportableLambdaFunctionField::LastRefreshTimestamp => "LastRefreshTimestamp",
            ExportableLambdaFunctionField::LookbackPeriodInDays => "LookbackPeriodInDays",
            ExportableLambdaFunctionField::NumberOfInvocations => "NumberOfInvocations",
            ExportableLambdaFunctionField::RecommendationOptionsConfigurationMemorySize => "RecommendationOptionsConfigurationMemorySize",
            ExportableLambdaFunctionField::RecommendationOptionsCostHigh => "RecommendationOptionsCostHigh",
            ExportableLambdaFunctionField::RecommendationOptionsCostLow => "RecommendationOptionsCostLow",
            ExportableLambdaFunctionField::RecommendationOptionsEstimatedMonthlySavingsCurrency => "RecommendationOptionsEstimatedMonthlySavingsCurrency",
            ExportableLambdaFunctionField::RecommendationOptionsEstimatedMonthlySavingsValue => "RecommendationOptionsEstimatedMonthlySavingsValue",
            ExportableLambdaFunctionField::RecommendationOptionsProjectedUtilizationMetricsDurationExpected => "RecommendationOptionsProjectedUtilizationMetricsDurationExpected",
            ExportableLambdaFunctionField::RecommendationOptionsProjectedUtilizationMetricsDurationLowerBound => "RecommendationOptionsProjectedUtilizationMetricsDurationLowerBound",
            ExportableLambdaFunctionField::RecommendationOptionsProjectedUtilizationMetricsDurationUpperBound => "RecommendationOptionsProjectedUtilizationMetricsDurationUpperBound",
            ExportableLambdaFunctionField::RecommendationOptionsSavingsOpportunityPercentage => "RecommendationOptionsSavingsOpportunityPercentage",
            ExportableLambdaFunctionField::UtilizationMetricsDurationAverage => "UtilizationMetricsDurationAverage",
            ExportableLambdaFunctionField::UtilizationMetricsDurationMaximum => "UtilizationMetricsDurationMaximum",
            ExportableLambdaFunctionField::UtilizationMetricsMemoryAverage => "UtilizationMetricsMemoryAverage",
            ExportableLambdaFunctionField::UtilizationMetricsMemoryMaximum => "UtilizationMetricsMemoryMaximum",
            ExportableLambdaFunctionField::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccountId", "CurrentConfigurationMemorySize", "CurrentConfigurationTimeout", "CurrentCostAverage", "CurrentCostTotal", "CurrentPerformanceRisk", "Finding", "FindingReasonCodes", "FunctionArn", "FunctionVersion", "LastRefreshTimestamp", "LookbackPeriodInDays", "NumberOfInvocations", "RecommendationOptionsConfigurationMemorySize", "RecommendationOptionsCostHigh", "RecommendationOptionsCostLow", "RecommendationOptionsEstimatedMonthlySavingsCurrency", "RecommendationOptionsEstimatedMonthlySavingsValue", "RecommendationOptionsProjectedUtilizationMetricsDurationExpected", "RecommendationOptionsProjectedUtilizationMetricsDurationLowerBound", "RecommendationOptionsProjectedUtilizationMetricsDurationUpperBound", "RecommendationOptionsSavingsOpportunityPercentage", "UtilizationMetricsDurationAverage", "UtilizationMetricsDurationMaximum", "UtilizationMetricsMemoryAverage", "UtilizationMetricsMemoryMaximum"
        ]
    }
}
impl AsRef<str> for ExportableLambdaFunctionField {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ExportableEcsServiceField`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let exportableecsservicefield = unimplemented!();
/// match exportableecsservicefield {
///     ExportableEcsServiceField::AccountId => { /* ... */ },
///     ExportableEcsServiceField::CurrentPerformanceRisk => { /* ... */ },
///     ExportableEcsServiceField::CurrentServiceConfigurationAutoScalingConfiguration => { /* ... */ },
///     ExportableEcsServiceField::CurrentServiceConfigurationCpu => { /* ... */ },
///     ExportableEcsServiceField::CurrentServiceConfigurationMemory => { /* ... */ },
///     ExportableEcsServiceField::CurrentServiceConfigurationTaskDefinitionArn => { /* ... */ },
///     ExportableEcsServiceField::CurrentServiceContainerConfigurations => { /* ... */ },
///     ExportableEcsServiceField::Finding => { /* ... */ },
///     ExportableEcsServiceField::FindingReasonCodes => { /* ... */ },
///     ExportableEcsServiceField::LastRefreshTimestamp => { /* ... */ },
///     ExportableEcsServiceField::LaunchType => { /* ... */ },
///     ExportableEcsServiceField::LookbackPeriodInDays => { /* ... */ },
///     ExportableEcsServiceField::RecommendationOptionsContainerRecommendations => { /* ... */ },
///     ExportableEcsServiceField::RecommendationOptionsCpu => { /* ... */ },
///     ExportableEcsServiceField::RecommendationOptionsEstimatedMonthlySavingsCurrency => { /* ... */ },
///     ExportableEcsServiceField::RecommendationOptionsEstimatedMonthlySavingsValue => { /* ... */ },
///     ExportableEcsServiceField::RecommendationOptionsMemory => { /* ... */ },
///     ExportableEcsServiceField::RecommendationOptionsProjectedUtilizationMetricsCpuMaximum => { /* ... */ },
///     ExportableEcsServiceField::RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum => { /* ... */ },
///     ExportableEcsServiceField::RecommendationOptionsSavingsOpportunityPercentage => { /* ... */ },
///     ExportableEcsServiceField::ServiceArn => { /* ... */ },
///     ExportableEcsServiceField::UtilizationMetricsCpuMaximum => { /* ... */ },
///     ExportableEcsServiceField::UtilizationMetricsMemoryMaximum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `exportableecsservicefield` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExportableEcsServiceField::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExportableEcsServiceField::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExportableEcsServiceField::NewFeature` is defined.
/// Specifically, when `exportableecsservicefield` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExportableEcsServiceField::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ExportableEcsServiceField {
    #[allow(missing_docs)] // documentation missing in model
    AccountId,
    #[allow(missing_docs)] // documentation missing in model
    CurrentPerformanceRisk,
    #[allow(missing_docs)] // documentation missing in model
    CurrentServiceConfigurationAutoScalingConfiguration,
    #[allow(missing_docs)] // documentation missing in model
    CurrentServiceConfigurationCpu,
    #[allow(missing_docs)] // documentation missing in model
    CurrentServiceConfigurationMemory,
    #[allow(missing_docs)] // documentation missing in model
    CurrentServiceConfigurationTaskDefinitionArn,
    #[allow(missing_docs)] // documentation missing in model
    CurrentServiceContainerConfigurations,
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    #[allow(missing_docs)] // documentation missing in model
    FindingReasonCodes,
    #[allow(missing_docs)] // documentation missing in model
    LastRefreshTimestamp,
    #[allow(missing_docs)] // documentation missing in model
    LaunchType,
    #[allow(missing_docs)] // documentation missing in model
    LookbackPeriodInDays,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsContainerRecommendations,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsCpu,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsCurrency,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsValue,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsMemory,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsProjectedUtilizationMetricsCpuMaximum,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsSavingsOpportunityPercentage,
    #[allow(missing_docs)] // documentation missing in model
    ServiceArn,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsCpuMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsMemoryMaximum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ExportableEcsServiceField {
    fn from(s: &str) -> Self {
        match s {
            "AccountId" => ExportableEcsServiceField::AccountId,
            "CurrentPerformanceRisk" => ExportableEcsServiceField::CurrentPerformanceRisk,
            "CurrentServiceConfigurationAutoScalingConfiguration" => ExportableEcsServiceField::CurrentServiceConfigurationAutoScalingConfiguration,
            "CurrentServiceConfigurationCpu" => ExportableEcsServiceField::CurrentServiceConfigurationCpu,
            "CurrentServiceConfigurationMemory" => ExportableEcsServiceField::CurrentServiceConfigurationMemory,
            "CurrentServiceConfigurationTaskDefinitionArn" => ExportableEcsServiceField::CurrentServiceConfigurationTaskDefinitionArn,
            "CurrentServiceContainerConfigurations" => ExportableEcsServiceField::CurrentServiceContainerConfigurations,
            "Finding" => ExportableEcsServiceField::Finding,
            "FindingReasonCodes" => ExportableEcsServiceField::FindingReasonCodes,
            "LastRefreshTimestamp" => ExportableEcsServiceField::LastRefreshTimestamp,
            "LaunchType" => ExportableEcsServiceField::LaunchType,
            "LookbackPeriodInDays" => ExportableEcsServiceField::LookbackPeriodInDays,
            "RecommendationOptionsContainerRecommendations" => ExportableEcsServiceField::RecommendationOptionsContainerRecommendations,
            "RecommendationOptionsCpu" => ExportableEcsServiceField::RecommendationOptionsCpu,
            "RecommendationOptionsEstimatedMonthlySavingsCurrency" => ExportableEcsServiceField::RecommendationOptionsEstimatedMonthlySavingsCurrency,
            "RecommendationOptionsEstimatedMonthlySavingsValue" => ExportableEcsServiceField::RecommendationOptionsEstimatedMonthlySavingsValue,
            "RecommendationOptionsMemory" => ExportableEcsServiceField::RecommendationOptionsMemory,
            "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum" => ExportableEcsServiceField::RecommendationOptionsProjectedUtilizationMetricsCpuMaximum,
            "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum" => ExportableEcsServiceField::RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum,
            "RecommendationOptionsSavingsOpportunityPercentage" => ExportableEcsServiceField::RecommendationOptionsSavingsOpportunityPercentage,
            "ServiceArn" => ExportableEcsServiceField::ServiceArn,
            "UtilizationMetricsCpuMaximum" => ExportableEcsServiceField::UtilizationMetricsCpuMaximum,
            "UtilizationMetricsMemoryMaximum" => ExportableEcsServiceField::UtilizationMetricsMemoryMaximum,
            other => ExportableEcsServiceField::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ExportableEcsServiceField {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ExportableEcsServiceField::from(s))
                }
            }
impl ExportableEcsServiceField {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExportableEcsServiceField::AccountId => "AccountId",
            ExportableEcsServiceField::CurrentPerformanceRisk => "CurrentPerformanceRisk",
            ExportableEcsServiceField::CurrentServiceConfigurationAutoScalingConfiguration => "CurrentServiceConfigurationAutoScalingConfiguration",
            ExportableEcsServiceField::CurrentServiceConfigurationCpu => "CurrentServiceConfigurationCpu",
            ExportableEcsServiceField::CurrentServiceConfigurationMemory => "CurrentServiceConfigurationMemory",
            ExportableEcsServiceField::CurrentServiceConfigurationTaskDefinitionArn => "CurrentServiceConfigurationTaskDefinitionArn",
            ExportableEcsServiceField::CurrentServiceContainerConfigurations => "CurrentServiceContainerConfigurations",
            ExportableEcsServiceField::Finding => "Finding",
            ExportableEcsServiceField::FindingReasonCodes => "FindingReasonCodes",
            ExportableEcsServiceField::LastRefreshTimestamp => "LastRefreshTimestamp",
            ExportableEcsServiceField::LaunchType => "LaunchType",
            ExportableEcsServiceField::LookbackPeriodInDays => "LookbackPeriodInDays",
            ExportableEcsServiceField::RecommendationOptionsContainerRecommendations => "RecommendationOptionsContainerRecommendations",
            ExportableEcsServiceField::RecommendationOptionsCpu => "RecommendationOptionsCpu",
            ExportableEcsServiceField::RecommendationOptionsEstimatedMonthlySavingsCurrency => "RecommendationOptionsEstimatedMonthlySavingsCurrency",
            ExportableEcsServiceField::RecommendationOptionsEstimatedMonthlySavingsValue => "RecommendationOptionsEstimatedMonthlySavingsValue",
            ExportableEcsServiceField::RecommendationOptionsMemory => "RecommendationOptionsMemory",
            ExportableEcsServiceField::RecommendationOptionsProjectedUtilizationMetricsCpuMaximum => "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum",
            ExportableEcsServiceField::RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum => "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum",
            ExportableEcsServiceField::RecommendationOptionsSavingsOpportunityPercentage => "RecommendationOptionsSavingsOpportunityPercentage",
            ExportableEcsServiceField::ServiceArn => "ServiceArn",
            ExportableEcsServiceField::UtilizationMetricsCpuMaximum => "UtilizationMetricsCpuMaximum",
            ExportableEcsServiceField::UtilizationMetricsMemoryMaximum => "UtilizationMetricsMemoryMaximum",
            ExportableEcsServiceField::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccountId", "CurrentPerformanceRisk", "CurrentServiceConfigurationAutoScalingConfiguration", "CurrentServiceConfigurationCpu", "CurrentServiceConfigurationMemory", "CurrentServiceConfigurationTaskDefinitionArn", "CurrentServiceContainerConfigurations", "Finding", "FindingReasonCodes", "LastRefreshTimestamp", "LaunchType", "LookbackPeriodInDays", "RecommendationOptionsContainerRecommendations", "RecommendationOptionsCpu", "RecommendationOptionsEstimatedMonthlySavingsCurrency", "RecommendationOptionsEstimatedMonthlySavingsValue", "RecommendationOptionsMemory", "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum", "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum", "RecommendationOptionsSavingsOpportunityPercentage", "ServiceArn", "UtilizationMetricsCpuMaximum", "UtilizationMetricsMemoryMaximum"
        ]
    }
}
impl AsRef<str> for ExportableEcsServiceField {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ExportableInstanceField`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let exportableinstancefield = unimplemented!();
/// match exportableinstancefield {
///     ExportableInstanceField::AccountId => { /* ... */ },
///     ExportableInstanceField::CurrentInstanceType => { /* ... */ },
///     ExportableInstanceField::CurrentMemory => { /* ... */ },
///     ExportableInstanceField::CurrentNetwork => { /* ... */ },
///     ExportableInstanceField::CurrentOnDemandPrice => { /* ... */ },
///     ExportableInstanceField::CurrentPerformanceRisk => { /* ... */ },
///     ExportableInstanceField::CurrentStandardOneYearNoUpfrontReservedPrice => { /* ... */ },
///     ExportableInstanceField::CurrentStandardThreeYearNoUpfrontReservedPrice => { /* ... */ },
///     ExportableInstanceField::CurrentStorage => { /* ... */ },
///     ExportableInstanceField::CurrentVcpus => { /* ... */ },
///     ExportableInstanceField::EffectiveRecommendationPreferencesCpuVendorArchitectures => { /* ... */ },
///     ExportableInstanceField::EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics => { /* ... */ },
///     ExportableInstanceField::EffectiveRecommendationPreferencesExternalMetricsSource => { /* ... */ },
///     ExportableInstanceField::EffectiveRecommendationPreferencesInferredWorkloadTypes => { /* ... */ },
///     ExportableInstanceField::Finding => { /* ... */ },
///     ExportableInstanceField::FindingReasonCodes => { /* ... */ },
///     ExportableInstanceField::InferredWorkloadTypes => { /* ... */ },
///     ExportableInstanceField::InstanceArn => { /* ... */ },
///     ExportableInstanceField::InstanceName => { /* ... */ },
///     ExportableInstanceField::LastRefreshTimestamp => { /* ... */ },
///     ExportableInstanceField::LookbackPeriodInDays => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsEstimatedMonthlySavingsCurrency => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsEstimatedMonthlySavingsValue => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsInstanceType => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsMemory => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsMigrationEffort => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsNetwork => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsOnDemandPrice => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsPerformanceRisk => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsPlatformDifferences => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsProjectedUtilizationMetricsCpuMaximum => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsSavingsOpportunityPercentage => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsStandardOneYearNoUpfrontReservedPrice => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsStorage => { /* ... */ },
///     ExportableInstanceField::RecommendationOptionsVcpus => { /* ... */ },
///     ExportableInstanceField::RecommendationsSourcesRecommendationSourceArn => { /* ... */ },
///     ExportableInstanceField::RecommendationsSourcesRecommendationSourceType => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsCpuMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsDiskReadBytesPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsDiskReadOpsPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsDiskWriteBytesPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsDiskWriteOpsPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsEbsReadBytesPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsEbsReadOpsPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsEbsWriteBytesPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsEbsWriteOpsPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsMemoryMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsNetworkInBytesPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsNetworkOutBytesPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsNetworkPacketsInPerSecondMaximum => { /* ... */ },
///     ExportableInstanceField::UtilizationMetricsNetworkPacketsOutPerSecondMaximum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `exportableinstancefield` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExportableInstanceField::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExportableInstanceField::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExportableInstanceField::NewFeature` is defined.
/// Specifically, when `exportableinstancefield` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExportableInstanceField::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ExportableInstanceField {
    #[allow(missing_docs)] // documentation missing in model
    AccountId,
    #[allow(missing_docs)] // documentation missing in model
    CurrentInstanceType,
    #[allow(missing_docs)] // documentation missing in model
    CurrentMemory,
    #[allow(missing_docs)] // documentation missing in model
    CurrentNetwork,
    #[allow(missing_docs)] // documentation missing in model
    CurrentOnDemandPrice,
    #[allow(missing_docs)] // documentation missing in model
    CurrentPerformanceRisk,
    #[allow(missing_docs)] // documentation missing in model
    CurrentStandardOneYearNoUpfrontReservedPrice,
    #[allow(missing_docs)] // documentation missing in model
    CurrentStandardThreeYearNoUpfrontReservedPrice,
    #[allow(missing_docs)] // documentation missing in model
    CurrentStorage,
    #[allow(missing_docs)] // documentation missing in model
    CurrentVcpus,
    #[allow(missing_docs)] // documentation missing in model
    EffectiveRecommendationPreferencesCpuVendorArchitectures,
    #[allow(missing_docs)] // documentation missing in model
    EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics,
    #[allow(missing_docs)] // documentation missing in model
    EffectiveRecommendationPreferencesExternalMetricsSource,
    #[allow(missing_docs)] // documentation missing in model
    EffectiveRecommendationPreferencesInferredWorkloadTypes,
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    #[allow(missing_docs)] // documentation missing in model
    FindingReasonCodes,
    #[allow(missing_docs)] // documentation missing in model
    InferredWorkloadTypes,
    #[allow(missing_docs)] // documentation missing in model
    InstanceArn,
    #[allow(missing_docs)] // documentation missing in model
    InstanceName,
    #[allow(missing_docs)] // documentation missing in model
    LastRefreshTimestamp,
    #[allow(missing_docs)] // documentation missing in model
    LookbackPeriodInDays,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsCurrency,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsValue,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsInstanceType,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsMemory,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsMigrationEffort,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsNetwork,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsOnDemandPrice,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsPerformanceRisk,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsPlatformDifferences,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsProjectedUtilizationMetricsCpuMaximum,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsSavingsOpportunityPercentage,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsStandardOneYearNoUpfrontReservedPrice,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsStorage,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsVcpus,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationsSourcesRecommendationSourceArn,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationsSourcesRecommendationSourceType,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsCpuMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDiskReadBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDiskReadOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDiskWriteBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDiskWriteOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsEbsReadBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsEbsReadOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsEbsWriteBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsEbsWriteOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsMemoryMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsNetworkInBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsNetworkOutBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsNetworkPacketsInPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsNetworkPacketsOutPerSecondMaximum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ExportableInstanceField {
    fn from(s: &str) -> Self {
        match s {
            "AccountId" => ExportableInstanceField::AccountId,
            "CurrentInstanceType" => ExportableInstanceField::CurrentInstanceType,
            "CurrentMemory" => ExportableInstanceField::CurrentMemory,
            "CurrentNetwork" => ExportableInstanceField::CurrentNetwork,
            "CurrentOnDemandPrice" => ExportableInstanceField::CurrentOnDemandPrice,
            "CurrentPerformanceRisk" => ExportableInstanceField::CurrentPerformanceRisk,
            "CurrentStandardOneYearNoUpfrontReservedPrice" => ExportableInstanceField::CurrentStandardOneYearNoUpfrontReservedPrice,
            "CurrentStandardThreeYearNoUpfrontReservedPrice" => ExportableInstanceField::CurrentStandardThreeYearNoUpfrontReservedPrice,
            "CurrentStorage" => ExportableInstanceField::CurrentStorage,
            "CurrentVCpus" => ExportableInstanceField::CurrentVcpus,
            "EffectiveRecommendationPreferencesCpuVendorArchitectures" => ExportableInstanceField::EffectiveRecommendationPreferencesCpuVendorArchitectures,
            "EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics" => ExportableInstanceField::EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics,
            "EffectiveRecommendationPreferencesExternalMetricsSource" => ExportableInstanceField::EffectiveRecommendationPreferencesExternalMetricsSource,
            "EffectiveRecommendationPreferencesInferredWorkloadTypes" => ExportableInstanceField::EffectiveRecommendationPreferencesInferredWorkloadTypes,
            "Finding" => ExportableInstanceField::Finding,
            "FindingReasonCodes" => ExportableInstanceField::FindingReasonCodes,
            "InferredWorkloadTypes" => ExportableInstanceField::InferredWorkloadTypes,
            "InstanceArn" => ExportableInstanceField::InstanceArn,
            "InstanceName" => ExportableInstanceField::InstanceName,
            "LastRefreshTimestamp" => ExportableInstanceField::LastRefreshTimestamp,
            "LookbackPeriodInDays" => ExportableInstanceField::LookbackPeriodInDays,
            "RecommendationOptionsEstimatedMonthlySavingsCurrency" => ExportableInstanceField::RecommendationOptionsEstimatedMonthlySavingsCurrency,
            "RecommendationOptionsEstimatedMonthlySavingsValue" => ExportableInstanceField::RecommendationOptionsEstimatedMonthlySavingsValue,
            "RecommendationOptionsInstanceType" => ExportableInstanceField::RecommendationOptionsInstanceType,
            "RecommendationOptionsMemory" => ExportableInstanceField::RecommendationOptionsMemory,
            "RecommendationOptionsMigrationEffort" => ExportableInstanceField::RecommendationOptionsMigrationEffort,
            "RecommendationOptionsNetwork" => ExportableInstanceField::RecommendationOptionsNetwork,
            "RecommendationOptionsOnDemandPrice" => ExportableInstanceField::RecommendationOptionsOnDemandPrice,
            "RecommendationOptionsPerformanceRisk" => ExportableInstanceField::RecommendationOptionsPerformanceRisk,
            "RecommendationOptionsPlatformDifferences" => ExportableInstanceField::RecommendationOptionsPlatformDifferences,
            "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum" => ExportableInstanceField::RecommendationOptionsProjectedUtilizationMetricsCpuMaximum,
            "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum" => ExportableInstanceField::RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum,
            "RecommendationOptionsSavingsOpportunityPercentage" => ExportableInstanceField::RecommendationOptionsSavingsOpportunityPercentage,
            "RecommendationOptionsStandardOneYearNoUpfrontReservedPrice" => ExportableInstanceField::RecommendationOptionsStandardOneYearNoUpfrontReservedPrice,
            "RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice" => ExportableInstanceField::RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice,
            "RecommendationOptionsStorage" => ExportableInstanceField::RecommendationOptionsStorage,
            "RecommendationOptionsVcpus" => ExportableInstanceField::RecommendationOptionsVcpus,
            "RecommendationsSourcesRecommendationSourceArn" => ExportableInstanceField::RecommendationsSourcesRecommendationSourceArn,
            "RecommendationsSourcesRecommendationSourceType" => ExportableInstanceField::RecommendationsSourcesRecommendationSourceType,
            "UtilizationMetricsCpuMaximum" => ExportableInstanceField::UtilizationMetricsCpuMaximum,
            "UtilizationMetricsDiskReadBytesPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsDiskReadBytesPerSecondMaximum,
            "UtilizationMetricsDiskReadOpsPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsDiskReadOpsPerSecondMaximum,
            "UtilizationMetricsDiskWriteBytesPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsDiskWriteBytesPerSecondMaximum,
            "UtilizationMetricsDiskWriteOpsPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsDiskWriteOpsPerSecondMaximum,
            "UtilizationMetricsEbsReadBytesPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsEbsReadBytesPerSecondMaximum,
            "UtilizationMetricsEbsReadOpsPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsEbsReadOpsPerSecondMaximum,
            "UtilizationMetricsEbsWriteBytesPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsEbsWriteBytesPerSecondMaximum,
            "UtilizationMetricsEbsWriteOpsPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsEbsWriteOpsPerSecondMaximum,
            "UtilizationMetricsMemoryMaximum" => ExportableInstanceField::UtilizationMetricsMemoryMaximum,
            "UtilizationMetricsNetworkInBytesPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsNetworkInBytesPerSecondMaximum,
            "UtilizationMetricsNetworkOutBytesPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsNetworkOutBytesPerSecondMaximum,
            "UtilizationMetricsNetworkPacketsInPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsNetworkPacketsInPerSecondMaximum,
            "UtilizationMetricsNetworkPacketsOutPerSecondMaximum" => ExportableInstanceField::UtilizationMetricsNetworkPacketsOutPerSecondMaximum,
            other => ExportableInstanceField::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ExportableInstanceField {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ExportableInstanceField::from(s))
                }
            }
impl ExportableInstanceField {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExportableInstanceField::AccountId => "AccountId",
            ExportableInstanceField::CurrentInstanceType => "CurrentInstanceType",
            ExportableInstanceField::CurrentMemory => "CurrentMemory",
            ExportableInstanceField::CurrentNetwork => "CurrentNetwork",
            ExportableInstanceField::CurrentOnDemandPrice => "CurrentOnDemandPrice",
            ExportableInstanceField::CurrentPerformanceRisk => "CurrentPerformanceRisk",
            ExportableInstanceField::CurrentStandardOneYearNoUpfrontReservedPrice => "CurrentStandardOneYearNoUpfrontReservedPrice",
            ExportableInstanceField::CurrentStandardThreeYearNoUpfrontReservedPrice => "CurrentStandardThreeYearNoUpfrontReservedPrice",
            ExportableInstanceField::CurrentStorage => "CurrentStorage",
            ExportableInstanceField::CurrentVcpus => "CurrentVCpus",
            ExportableInstanceField::EffectiveRecommendationPreferencesCpuVendorArchitectures => "EffectiveRecommendationPreferencesCpuVendorArchitectures",
            ExportableInstanceField::EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics => "EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics",
            ExportableInstanceField::EffectiveRecommendationPreferencesExternalMetricsSource => "EffectiveRecommendationPreferencesExternalMetricsSource",
            ExportableInstanceField::EffectiveRecommendationPreferencesInferredWorkloadTypes => "EffectiveRecommendationPreferencesInferredWorkloadTypes",
            ExportableInstanceField::Finding => "Finding",
            ExportableInstanceField::FindingReasonCodes => "FindingReasonCodes",
            ExportableInstanceField::InferredWorkloadTypes => "InferredWorkloadTypes",
            ExportableInstanceField::InstanceArn => "InstanceArn",
            ExportableInstanceField::InstanceName => "InstanceName",
            ExportableInstanceField::LastRefreshTimestamp => "LastRefreshTimestamp",
            ExportableInstanceField::LookbackPeriodInDays => "LookbackPeriodInDays",
            ExportableInstanceField::RecommendationOptionsEstimatedMonthlySavingsCurrency => "RecommendationOptionsEstimatedMonthlySavingsCurrency",
            ExportableInstanceField::RecommendationOptionsEstimatedMonthlySavingsValue => "RecommendationOptionsEstimatedMonthlySavingsValue",
            ExportableInstanceField::RecommendationOptionsInstanceType => "RecommendationOptionsInstanceType",
            ExportableInstanceField::RecommendationOptionsMemory => "RecommendationOptionsMemory",
            ExportableInstanceField::RecommendationOptionsMigrationEffort => "RecommendationOptionsMigrationEffort",
            ExportableInstanceField::RecommendationOptionsNetwork => "RecommendationOptionsNetwork",
            ExportableInstanceField::RecommendationOptionsOnDemandPrice => "RecommendationOptionsOnDemandPrice",
            ExportableInstanceField::RecommendationOptionsPerformanceRisk => "RecommendationOptionsPerformanceRisk",
            ExportableInstanceField::RecommendationOptionsPlatformDifferences => "RecommendationOptionsPlatformDifferences",
            ExportableInstanceField::RecommendationOptionsProjectedUtilizationMetricsCpuMaximum => "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum",
            ExportableInstanceField::RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum => "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum",
            ExportableInstanceField::RecommendationOptionsSavingsOpportunityPercentage => "RecommendationOptionsSavingsOpportunityPercentage",
            ExportableInstanceField::RecommendationOptionsStandardOneYearNoUpfrontReservedPrice => "RecommendationOptionsStandardOneYearNoUpfrontReservedPrice",
            ExportableInstanceField::RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice => "RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice",
            ExportableInstanceField::RecommendationOptionsStorage => "RecommendationOptionsStorage",
            ExportableInstanceField::RecommendationOptionsVcpus => "RecommendationOptionsVcpus",
            ExportableInstanceField::RecommendationsSourcesRecommendationSourceArn => "RecommendationsSourcesRecommendationSourceArn",
            ExportableInstanceField::RecommendationsSourcesRecommendationSourceType => "RecommendationsSourcesRecommendationSourceType",
            ExportableInstanceField::UtilizationMetricsCpuMaximum => "UtilizationMetricsCpuMaximum",
            ExportableInstanceField::UtilizationMetricsDiskReadBytesPerSecondMaximum => "UtilizationMetricsDiskReadBytesPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsDiskReadOpsPerSecondMaximum => "UtilizationMetricsDiskReadOpsPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsDiskWriteBytesPerSecondMaximum => "UtilizationMetricsDiskWriteBytesPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsDiskWriteOpsPerSecondMaximum => "UtilizationMetricsDiskWriteOpsPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsEbsReadBytesPerSecondMaximum => "UtilizationMetricsEbsReadBytesPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsEbsReadOpsPerSecondMaximum => "UtilizationMetricsEbsReadOpsPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsEbsWriteBytesPerSecondMaximum => "UtilizationMetricsEbsWriteBytesPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsEbsWriteOpsPerSecondMaximum => "UtilizationMetricsEbsWriteOpsPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsMemoryMaximum => "UtilizationMetricsMemoryMaximum",
            ExportableInstanceField::UtilizationMetricsNetworkInBytesPerSecondMaximum => "UtilizationMetricsNetworkInBytesPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsNetworkOutBytesPerSecondMaximum => "UtilizationMetricsNetworkOutBytesPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsNetworkPacketsInPerSecondMaximum => "UtilizationMetricsNetworkPacketsInPerSecondMaximum",
            ExportableInstanceField::UtilizationMetricsNetworkPacketsOutPerSecondMaximum => "UtilizationMetricsNetworkPacketsOutPerSecondMaximum",
            ExportableInstanceField::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccountId", "CurrentInstanceType", "CurrentMemory", "CurrentNetwork", "CurrentOnDemandPrice", "CurrentPerformanceRisk", "CurrentStandardOneYearNoUpfrontReservedPrice", "CurrentStandardThreeYearNoUpfrontReservedPrice", "CurrentStorage", "CurrentVCpus", "EffectiveRecommendationPreferencesCpuVendorArchitectures", "EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics", "EffectiveRecommendationPreferencesExternalMetricsSource", "EffectiveRecommendationPreferencesInferredWorkloadTypes", "Finding", "FindingReasonCodes", "InferredWorkloadTypes", "InstanceArn", "InstanceName", "LastRefreshTimestamp", "LookbackPeriodInDays", "RecommendationOptionsEstimatedMonthlySavingsCurrency", "RecommendationOptionsEstimatedMonthlySavingsValue", "RecommendationOptionsInstanceType", "RecommendationOptionsMemory", "RecommendationOptionsMigrationEffort", "RecommendationOptionsNetwork", "RecommendationOptionsOnDemandPrice", "RecommendationOptionsPerformanceRisk", "RecommendationOptionsPlatformDifferences", "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum", "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum", "RecommendationOptionsSavingsOpportunityPercentage", "RecommendationOptionsStandardOneYearNoUpfrontReservedPrice", "RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice", "RecommendationOptionsStorage", "RecommendationOptionsVcpus", "RecommendationsSourcesRecommendationSourceArn", "RecommendationsSourcesRecommendationSourceType", "UtilizationMetricsCpuMaximum", "UtilizationMetricsDiskReadBytesPerSecondMaximum", "UtilizationMetricsDiskReadOpsPerSecondMaximum", "UtilizationMetricsDiskWriteBytesPerSecondMaximum", "UtilizationMetricsDiskWriteOpsPerSecondMaximum", "UtilizationMetricsEbsReadBytesPerSecondMaximum", "UtilizationMetricsEbsReadOpsPerSecondMaximum", "UtilizationMetricsEbsWriteBytesPerSecondMaximum", "UtilizationMetricsEbsWriteOpsPerSecondMaximum", "UtilizationMetricsMemoryMaximum", "UtilizationMetricsNetworkInBytesPerSecondMaximum", "UtilizationMetricsNetworkOutBytesPerSecondMaximum", "UtilizationMetricsNetworkPacketsInPerSecondMaximum", "UtilizationMetricsNetworkPacketsOutPerSecondMaximum"
        ]
    }
}
impl AsRef<str> for ExportableInstanceField {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ExportableVolumeField`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let exportablevolumefield = unimplemented!();
/// match exportablevolumefield {
///     ExportableVolumeField::AccountId => { /* ... */ },
///     ExportableVolumeField::CurrentConfigurationVolumeBaselineIops => { /* ... */ },
///     ExportableVolumeField::CurrentConfigurationVolumeBaselineThroughput => { /* ... */ },
///     ExportableVolumeField::CurrentConfigurationVolumeBurstIops => { /* ... */ },
///     ExportableVolumeField::CurrentConfigurationVolumeBurstThroughput => { /* ... */ },
///     ExportableVolumeField::CurrentConfigurationVolumeSize => { /* ... */ },
///     ExportableVolumeField::CurrentConfigurationVolumeType => { /* ... */ },
///     ExportableVolumeField::CurrentMonthlyPrice => { /* ... */ },
///     ExportableVolumeField::CurrentPerformanceRisk => { /* ... */ },
///     ExportableVolumeField::Finding => { /* ... */ },
///     ExportableVolumeField::LastRefreshTimestamp => { /* ... */ },
///     ExportableVolumeField::LookbackPeriodInDays => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsConfigurationVolumeBaselineIops => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsConfigurationVolumeBaselineThroughput => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsConfigurationVolumeBurstIops => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsConfigurationVolumeBurstThroughput => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsConfigurationVolumeSize => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsConfigurationVolumeType => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsEstimatedMonthlySavingsCurrency => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsEstimatedMonthlySavingsValue => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsMonthlyPrice => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsPerformanceRisk => { /* ... */ },
///     ExportableVolumeField::RecommendationOptionsSavingsOpportunityPercentage => { /* ... */ },
///     ExportableVolumeField::UtilizationMetricsVolumeReadBytesPerSecondMaximum => { /* ... */ },
///     ExportableVolumeField::UtilizationMetricsVolumeReadOpsPerSecondMaximum => { /* ... */ },
///     ExportableVolumeField::UtilizationMetricsVolumeWriteBytesPerSecondMaximum => { /* ... */ },
///     ExportableVolumeField::UtilizationMetricsVolumeWriteOpsPerSecondMaximum => { /* ... */ },
///     ExportableVolumeField::VolumeArn => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `exportablevolumefield` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExportableVolumeField::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExportableVolumeField::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExportableVolumeField::NewFeature` is defined.
/// Specifically, when `exportablevolumefield` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExportableVolumeField::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ExportableVolumeField {
    #[allow(missing_docs)] // documentation missing in model
    AccountId,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationVolumeBaselineIops,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationVolumeBaselineThroughput,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationVolumeBurstIops,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationVolumeBurstThroughput,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationVolumeSize,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationVolumeType,
    #[allow(missing_docs)] // documentation missing in model
    CurrentMonthlyPrice,
    #[allow(missing_docs)] // documentation missing in model
    CurrentPerformanceRisk,
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    #[allow(missing_docs)] // documentation missing in model
    LastRefreshTimestamp,
    #[allow(missing_docs)] // documentation missing in model
    LookbackPeriodInDays,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationVolumeBaselineIops,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationVolumeBaselineThroughput,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationVolumeBurstIops,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationVolumeBurstThroughput,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationVolumeSize,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationVolumeType,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsCurrency,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsValue,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsMonthlyPrice,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsPerformanceRisk,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsSavingsOpportunityPercentage,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsVolumeReadBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsVolumeReadOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsVolumeWriteBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsVolumeWriteOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    VolumeArn,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ExportableVolumeField {
    fn from(s: &str) -> Self {
        match s {
            "AccountId" => ExportableVolumeField::AccountId,
            "CurrentConfigurationVolumeBaselineIOPS" => ExportableVolumeField::CurrentConfigurationVolumeBaselineIops,
            "CurrentConfigurationVolumeBaselineThroughput" => ExportableVolumeField::CurrentConfigurationVolumeBaselineThroughput,
            "CurrentConfigurationVolumeBurstIOPS" => ExportableVolumeField::CurrentConfigurationVolumeBurstIops,
            "CurrentConfigurationVolumeBurstThroughput" => ExportableVolumeField::CurrentConfigurationVolumeBurstThroughput,
            "CurrentConfigurationVolumeSize" => ExportableVolumeField::CurrentConfigurationVolumeSize,
            "CurrentConfigurationVolumeType" => ExportableVolumeField::CurrentConfigurationVolumeType,
            "CurrentMonthlyPrice" => ExportableVolumeField::CurrentMonthlyPrice,
            "CurrentPerformanceRisk" => ExportableVolumeField::CurrentPerformanceRisk,
            "Finding" => ExportableVolumeField::Finding,
            "LastRefreshTimestamp" => ExportableVolumeField::LastRefreshTimestamp,
            "LookbackPeriodInDays" => ExportableVolumeField::LookbackPeriodInDays,
            "RecommendationOptionsConfigurationVolumeBaselineIOPS" => ExportableVolumeField::RecommendationOptionsConfigurationVolumeBaselineIops,
            "RecommendationOptionsConfigurationVolumeBaselineThroughput" => ExportableVolumeField::RecommendationOptionsConfigurationVolumeBaselineThroughput,
            "RecommendationOptionsConfigurationVolumeBurstIOPS" => ExportableVolumeField::RecommendationOptionsConfigurationVolumeBurstIops,
            "RecommendationOptionsConfigurationVolumeBurstThroughput" => ExportableVolumeField::RecommendationOptionsConfigurationVolumeBurstThroughput,
            "RecommendationOptionsConfigurationVolumeSize" => ExportableVolumeField::RecommendationOptionsConfigurationVolumeSize,
            "RecommendationOptionsConfigurationVolumeType" => ExportableVolumeField::RecommendationOptionsConfigurationVolumeType,
            "RecommendationOptionsEstimatedMonthlySavingsCurrency" => ExportableVolumeField::RecommendationOptionsEstimatedMonthlySavingsCurrency,
            "RecommendationOptionsEstimatedMonthlySavingsValue" => ExportableVolumeField::RecommendationOptionsEstimatedMonthlySavingsValue,
            "RecommendationOptionsMonthlyPrice" => ExportableVolumeField::RecommendationOptionsMonthlyPrice,
            "RecommendationOptionsPerformanceRisk" => ExportableVolumeField::RecommendationOptionsPerformanceRisk,
            "RecommendationOptionsSavingsOpportunityPercentage" => ExportableVolumeField::RecommendationOptionsSavingsOpportunityPercentage,
            "UtilizationMetricsVolumeReadBytesPerSecondMaximum" => ExportableVolumeField::UtilizationMetricsVolumeReadBytesPerSecondMaximum,
            "UtilizationMetricsVolumeReadOpsPerSecondMaximum" => ExportableVolumeField::UtilizationMetricsVolumeReadOpsPerSecondMaximum,
            "UtilizationMetricsVolumeWriteBytesPerSecondMaximum" => ExportableVolumeField::UtilizationMetricsVolumeWriteBytesPerSecondMaximum,
            "UtilizationMetricsVolumeWriteOpsPerSecondMaximum" => ExportableVolumeField::UtilizationMetricsVolumeWriteOpsPerSecondMaximum,
            "VolumeArn" => ExportableVolumeField::VolumeArn,
            other => ExportableVolumeField::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ExportableVolumeField {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ExportableVolumeField::from(s))
                }
            }
impl ExportableVolumeField {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExportableVolumeField::AccountId => "AccountId",
            ExportableVolumeField::CurrentConfigurationVolumeBaselineIops => "CurrentConfigurationVolumeBaselineIOPS",
            ExportableVolumeField::CurrentConfigurationVolumeBaselineThroughput => "CurrentConfigurationVolumeBaselineThroughput",
            ExportableVolumeField::CurrentConfigurationVolumeBurstIops => "CurrentConfigurationVolumeBurstIOPS",
            ExportableVolumeField::CurrentConfigurationVolumeBurstThroughput => "CurrentConfigurationVolumeBurstThroughput",
            ExportableVolumeField::CurrentConfigurationVolumeSize => "CurrentConfigurationVolumeSize",
            ExportableVolumeField::CurrentConfigurationVolumeType => "CurrentConfigurationVolumeType",
            ExportableVolumeField::CurrentMonthlyPrice => "CurrentMonthlyPrice",
            ExportableVolumeField::CurrentPerformanceRisk => "CurrentPerformanceRisk",
            ExportableVolumeField::Finding => "Finding",
            ExportableVolumeField::LastRefreshTimestamp => "LastRefreshTimestamp",
            ExportableVolumeField::LookbackPeriodInDays => "LookbackPeriodInDays",
            ExportableVolumeField::RecommendationOptionsConfigurationVolumeBaselineIops => "RecommendationOptionsConfigurationVolumeBaselineIOPS",
            ExportableVolumeField::RecommendationOptionsConfigurationVolumeBaselineThroughput => "RecommendationOptionsConfigurationVolumeBaselineThroughput",
            ExportableVolumeField::RecommendationOptionsConfigurationVolumeBurstIops => "RecommendationOptionsConfigurationVolumeBurstIOPS",
            ExportableVolumeField::RecommendationOptionsConfigurationVolumeBurstThroughput => "RecommendationOptionsConfigurationVolumeBurstThroughput",
            ExportableVolumeField::RecommendationOptionsConfigurationVolumeSize => "RecommendationOptionsConfigurationVolumeSize",
            ExportableVolumeField::RecommendationOptionsConfigurationVolumeType => "RecommendationOptionsConfigurationVolumeType",
            ExportableVolumeField::RecommendationOptionsEstimatedMonthlySavingsCurrency => "RecommendationOptionsEstimatedMonthlySavingsCurrency",
            ExportableVolumeField::RecommendationOptionsEstimatedMonthlySavingsValue => "RecommendationOptionsEstimatedMonthlySavingsValue",
            ExportableVolumeField::RecommendationOptionsMonthlyPrice => "RecommendationOptionsMonthlyPrice",
            ExportableVolumeField::RecommendationOptionsPerformanceRisk => "RecommendationOptionsPerformanceRisk",
            ExportableVolumeField::RecommendationOptionsSavingsOpportunityPercentage => "RecommendationOptionsSavingsOpportunityPercentage",
            ExportableVolumeField::UtilizationMetricsVolumeReadBytesPerSecondMaximum => "UtilizationMetricsVolumeReadBytesPerSecondMaximum",
            ExportableVolumeField::UtilizationMetricsVolumeReadOpsPerSecondMaximum => "UtilizationMetricsVolumeReadOpsPerSecondMaximum",
            ExportableVolumeField::UtilizationMetricsVolumeWriteBytesPerSecondMaximum => "UtilizationMetricsVolumeWriteBytesPerSecondMaximum",
            ExportableVolumeField::UtilizationMetricsVolumeWriteOpsPerSecondMaximum => "UtilizationMetricsVolumeWriteOpsPerSecondMaximum",
            ExportableVolumeField::VolumeArn => "VolumeArn",
            ExportableVolumeField::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccountId", "CurrentConfigurationVolumeBaselineIOPS", "CurrentConfigurationVolumeBaselineThroughput", "CurrentConfigurationVolumeBurstIOPS", "CurrentConfigurationVolumeBurstThroughput", "CurrentConfigurationVolumeSize", "CurrentConfigurationVolumeType", "CurrentMonthlyPrice", "CurrentPerformanceRisk", "Finding", "LastRefreshTimestamp", "LookbackPeriodInDays", "RecommendationOptionsConfigurationVolumeBaselineIOPS", "RecommendationOptionsConfigurationVolumeBaselineThroughput", "RecommendationOptionsConfigurationVolumeBurstIOPS", "RecommendationOptionsConfigurationVolumeBurstThroughput", "RecommendationOptionsConfigurationVolumeSize", "RecommendationOptionsConfigurationVolumeType", "RecommendationOptionsEstimatedMonthlySavingsCurrency", "RecommendationOptionsEstimatedMonthlySavingsValue", "RecommendationOptionsMonthlyPrice", "RecommendationOptionsPerformanceRisk", "RecommendationOptionsSavingsOpportunityPercentage", "UtilizationMetricsVolumeReadBytesPerSecondMaximum", "UtilizationMetricsVolumeReadOpsPerSecondMaximum", "UtilizationMetricsVolumeWriteBytesPerSecondMaximum", "UtilizationMetricsVolumeWriteOpsPerSecondMaximum", "VolumeArn"
        ]
    }
}
impl AsRef<str> for ExportableVolumeField {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ExportableAutoScalingGroupField`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let exportableautoscalinggroupfield = unimplemented!();
/// match exportableautoscalinggroupfield {
///     ExportableAutoScalingGroupField::AccountId => { /* ... */ },
///     ExportableAutoScalingGroupField::AutoScalingGroupArn => { /* ... */ },
///     ExportableAutoScalingGroupField::AutoScalingGroupName => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentConfigurationDesiredCapacity => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentConfigurationInstanceType => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentConfigurationMaxSize => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentConfigurationMinSize => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentMemory => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentNetwork => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentOnDemandPrice => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentPerformanceRisk => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentStandardOneYearNoUpfrontReservedPrice => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentStandardThreeYearNoUpfrontReservedPrice => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentStorage => { /* ... */ },
///     ExportableAutoScalingGroupField::CurrentVcpus => { /* ... */ },
///     ExportableAutoScalingGroupField::EffectiveRecommendationPreferencesCpuVendorArchitectures => { /* ... */ },
///     ExportableAutoScalingGroupField::EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics => { /* ... */ },
///     ExportableAutoScalingGroupField::EffectiveRecommendationPreferencesInferredWorkloadTypes => { /* ... */ },
///     ExportableAutoScalingGroupField::Finding => { /* ... */ },
///     ExportableAutoScalingGroupField::InferredWorkloadTypes => { /* ... */ },
///     ExportableAutoScalingGroupField::LastRefreshTimestamp => { /* ... */ },
///     ExportableAutoScalingGroupField::LookbackPeriodInDays => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsConfigurationDesiredCapacity => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsConfigurationInstanceType => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsConfigurationMaxSize => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsConfigurationMinSize => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsEstimatedMonthlySavingsCurrency => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsEstimatedMonthlySavingsValue => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsMemory => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsMigrationEffort => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsNetwork => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsOnDemandPrice => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsPerformanceRisk => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsProjectedUtilizationMetricsCpuMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsSavingsOpportunityPercentage => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsStandardOneYearNoUpfrontReservedPrice => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsStorage => { /* ... */ },
///     ExportableAutoScalingGroupField::RecommendationOptionsVcpus => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsCpuMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsDiskReadBytesPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsDiskReadOpsPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsDiskWriteBytesPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsDiskWriteOpsPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsEbsReadBytesPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsEbsReadOpsPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsEbsWriteBytesPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsEbsWriteOpsPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsMemoryMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsNetworkInBytesPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsNetworkOutBytesPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsNetworkPacketsInPerSecondMaximum => { /* ... */ },
///     ExportableAutoScalingGroupField::UtilizationMetricsNetworkPacketsOutPerSecondMaximum => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `exportableautoscalinggroupfield` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExportableAutoScalingGroupField::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExportableAutoScalingGroupField::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExportableAutoScalingGroupField::NewFeature` is defined.
/// Specifically, when `exportableautoscalinggroupfield` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExportableAutoScalingGroupField::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ExportableAutoScalingGroupField {
    #[allow(missing_docs)] // documentation missing in model
    AccountId,
    #[allow(missing_docs)] // documentation missing in model
    AutoScalingGroupArn,
    #[allow(missing_docs)] // documentation missing in model
    AutoScalingGroupName,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationDesiredCapacity,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationInstanceType,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationMaxSize,
    #[allow(missing_docs)] // documentation missing in model
    CurrentConfigurationMinSize,
    #[allow(missing_docs)] // documentation missing in model
    CurrentMemory,
    #[allow(missing_docs)] // documentation missing in model
    CurrentNetwork,
    #[allow(missing_docs)] // documentation missing in model
    CurrentOnDemandPrice,
    #[allow(missing_docs)] // documentation missing in model
    CurrentPerformanceRisk,
    #[allow(missing_docs)] // documentation missing in model
    CurrentStandardOneYearNoUpfrontReservedPrice,
    #[allow(missing_docs)] // documentation missing in model
    CurrentStandardThreeYearNoUpfrontReservedPrice,
    #[allow(missing_docs)] // documentation missing in model
    CurrentStorage,
    #[allow(missing_docs)] // documentation missing in model
    CurrentVcpus,
    #[allow(missing_docs)] // documentation missing in model
    EffectiveRecommendationPreferencesCpuVendorArchitectures,
    #[allow(missing_docs)] // documentation missing in model
    EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics,
    #[allow(missing_docs)] // documentation missing in model
    EffectiveRecommendationPreferencesInferredWorkloadTypes,
    #[allow(missing_docs)] // documentation missing in model
    Finding,
    #[allow(missing_docs)] // documentation missing in model
    InferredWorkloadTypes,
    #[allow(missing_docs)] // documentation missing in model
    LastRefreshTimestamp,
    #[allow(missing_docs)] // documentation missing in model
    LookbackPeriodInDays,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationDesiredCapacity,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationInstanceType,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationMaxSize,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsConfigurationMinSize,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsCurrency,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsEstimatedMonthlySavingsValue,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsMemory,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsMigrationEffort,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsNetwork,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsOnDemandPrice,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsPerformanceRisk,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsProjectedUtilizationMetricsCpuMaximum,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsSavingsOpportunityPercentage,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsStandardOneYearNoUpfrontReservedPrice,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsStorage,
    #[allow(missing_docs)] // documentation missing in model
    RecommendationOptionsVcpus,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsCpuMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDiskReadBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDiskReadOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDiskWriteBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsDiskWriteOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsEbsReadBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsEbsReadOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsEbsWriteBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsEbsWriteOpsPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsMemoryMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsNetworkInBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsNetworkOutBytesPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsNetworkPacketsInPerSecondMaximum,
    #[allow(missing_docs)] // documentation missing in model
    UtilizationMetricsNetworkPacketsOutPerSecondMaximum,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ExportableAutoScalingGroupField {
    fn from(s: &str) -> Self {
        match s {
            "AccountId" => ExportableAutoScalingGroupField::AccountId,
            "AutoScalingGroupArn" => ExportableAutoScalingGroupField::AutoScalingGroupArn,
            "AutoScalingGroupName" => ExportableAutoScalingGroupField::AutoScalingGroupName,
            "CurrentConfigurationDesiredCapacity" => ExportableAutoScalingGroupField::CurrentConfigurationDesiredCapacity,
            "CurrentConfigurationInstanceType" => ExportableAutoScalingGroupField::CurrentConfigurationInstanceType,
            "CurrentConfigurationMaxSize" => ExportableAutoScalingGroupField::CurrentConfigurationMaxSize,
            "CurrentConfigurationMinSize" => ExportableAutoScalingGroupField::CurrentConfigurationMinSize,
            "CurrentMemory" => ExportableAutoScalingGroupField::CurrentMemory,
            "CurrentNetwork" => ExportableAutoScalingGroupField::CurrentNetwork,
            "CurrentOnDemandPrice" => ExportableAutoScalingGroupField::CurrentOnDemandPrice,
            "CurrentPerformanceRisk" => ExportableAutoScalingGroupField::CurrentPerformanceRisk,
            "CurrentStandardOneYearNoUpfrontReservedPrice" => ExportableAutoScalingGroupField::CurrentStandardOneYearNoUpfrontReservedPrice,
            "CurrentStandardThreeYearNoUpfrontReservedPrice" => ExportableAutoScalingGroupField::CurrentStandardThreeYearNoUpfrontReservedPrice,
            "CurrentStorage" => ExportableAutoScalingGroupField::CurrentStorage,
            "CurrentVCpus" => ExportableAutoScalingGroupField::CurrentVcpus,
            "EffectiveRecommendationPreferencesCpuVendorArchitectures" => ExportableAutoScalingGroupField::EffectiveRecommendationPreferencesCpuVendorArchitectures,
            "EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics" => ExportableAutoScalingGroupField::EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics,
            "EffectiveRecommendationPreferencesInferredWorkloadTypes" => ExportableAutoScalingGroupField::EffectiveRecommendationPreferencesInferredWorkloadTypes,
            "Finding" => ExportableAutoScalingGroupField::Finding,
            "InferredWorkloadTypes" => ExportableAutoScalingGroupField::InferredWorkloadTypes,
            "LastRefreshTimestamp" => ExportableAutoScalingGroupField::LastRefreshTimestamp,
            "LookbackPeriodInDays" => ExportableAutoScalingGroupField::LookbackPeriodInDays,
            "RecommendationOptionsConfigurationDesiredCapacity" => ExportableAutoScalingGroupField::RecommendationOptionsConfigurationDesiredCapacity,
            "RecommendationOptionsConfigurationInstanceType" => ExportableAutoScalingGroupField::RecommendationOptionsConfigurationInstanceType,
            "RecommendationOptionsConfigurationMaxSize" => ExportableAutoScalingGroupField::RecommendationOptionsConfigurationMaxSize,
            "RecommendationOptionsConfigurationMinSize" => ExportableAutoScalingGroupField::RecommendationOptionsConfigurationMinSize,
            "RecommendationOptionsEstimatedMonthlySavingsCurrency" => ExportableAutoScalingGroupField::RecommendationOptionsEstimatedMonthlySavingsCurrency,
            "RecommendationOptionsEstimatedMonthlySavingsValue" => ExportableAutoScalingGroupField::RecommendationOptionsEstimatedMonthlySavingsValue,
            "RecommendationOptionsMemory" => ExportableAutoScalingGroupField::RecommendationOptionsMemory,
            "RecommendationOptionsMigrationEffort" => ExportableAutoScalingGroupField::RecommendationOptionsMigrationEffort,
            "RecommendationOptionsNetwork" => ExportableAutoScalingGroupField::RecommendationOptionsNetwork,
            "RecommendationOptionsOnDemandPrice" => ExportableAutoScalingGroupField::RecommendationOptionsOnDemandPrice,
            "RecommendationOptionsPerformanceRisk" => ExportableAutoScalingGroupField::RecommendationOptionsPerformanceRisk,
            "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum" => ExportableAutoScalingGroupField::RecommendationOptionsProjectedUtilizationMetricsCpuMaximum,
            "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum" => ExportableAutoScalingGroupField::RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum,
            "RecommendationOptionsSavingsOpportunityPercentage" => ExportableAutoScalingGroupField::RecommendationOptionsSavingsOpportunityPercentage,
            "RecommendationOptionsStandardOneYearNoUpfrontReservedPrice" => ExportableAutoScalingGroupField::RecommendationOptionsStandardOneYearNoUpfrontReservedPrice,
            "RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice" => ExportableAutoScalingGroupField::RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice,
            "RecommendationOptionsStorage" => ExportableAutoScalingGroupField::RecommendationOptionsStorage,
            "RecommendationOptionsVcpus" => ExportableAutoScalingGroupField::RecommendationOptionsVcpus,
            "UtilizationMetricsCpuMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsCpuMaximum,
            "UtilizationMetricsDiskReadBytesPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsDiskReadBytesPerSecondMaximum,
            "UtilizationMetricsDiskReadOpsPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsDiskReadOpsPerSecondMaximum,
            "UtilizationMetricsDiskWriteBytesPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsDiskWriteBytesPerSecondMaximum,
            "UtilizationMetricsDiskWriteOpsPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsDiskWriteOpsPerSecondMaximum,
            "UtilizationMetricsEbsReadBytesPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsEbsReadBytesPerSecondMaximum,
            "UtilizationMetricsEbsReadOpsPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsEbsReadOpsPerSecondMaximum,
            "UtilizationMetricsEbsWriteBytesPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsEbsWriteBytesPerSecondMaximum,
            "UtilizationMetricsEbsWriteOpsPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsEbsWriteOpsPerSecondMaximum,
            "UtilizationMetricsMemoryMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsMemoryMaximum,
            "UtilizationMetricsNetworkInBytesPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsNetworkInBytesPerSecondMaximum,
            "UtilizationMetricsNetworkOutBytesPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsNetworkOutBytesPerSecondMaximum,
            "UtilizationMetricsNetworkPacketsInPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsNetworkPacketsInPerSecondMaximum,
            "UtilizationMetricsNetworkPacketsOutPerSecondMaximum" => ExportableAutoScalingGroupField::UtilizationMetricsNetworkPacketsOutPerSecondMaximum,
            other => ExportableAutoScalingGroupField::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ExportableAutoScalingGroupField {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ExportableAutoScalingGroupField::from(s))
                }
            }
impl ExportableAutoScalingGroupField {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExportableAutoScalingGroupField::AccountId => "AccountId",
            ExportableAutoScalingGroupField::AutoScalingGroupArn => "AutoScalingGroupArn",
            ExportableAutoScalingGroupField::AutoScalingGroupName => "AutoScalingGroupName",
            ExportableAutoScalingGroupField::CurrentConfigurationDesiredCapacity => "CurrentConfigurationDesiredCapacity",
            ExportableAutoScalingGroupField::CurrentConfigurationInstanceType => "CurrentConfigurationInstanceType",
            ExportableAutoScalingGroupField::CurrentConfigurationMaxSize => "CurrentConfigurationMaxSize",
            ExportableAutoScalingGroupField::CurrentConfigurationMinSize => "CurrentConfigurationMinSize",
            ExportableAutoScalingGroupField::CurrentMemory => "CurrentMemory",
            ExportableAutoScalingGroupField::CurrentNetwork => "CurrentNetwork",
            ExportableAutoScalingGroupField::CurrentOnDemandPrice => "CurrentOnDemandPrice",
            ExportableAutoScalingGroupField::CurrentPerformanceRisk => "CurrentPerformanceRisk",
            ExportableAutoScalingGroupField::CurrentStandardOneYearNoUpfrontReservedPrice => "CurrentStandardOneYearNoUpfrontReservedPrice",
            ExportableAutoScalingGroupField::CurrentStandardThreeYearNoUpfrontReservedPrice => "CurrentStandardThreeYearNoUpfrontReservedPrice",
            ExportableAutoScalingGroupField::CurrentStorage => "CurrentStorage",
            ExportableAutoScalingGroupField::CurrentVcpus => "CurrentVCpus",
            ExportableAutoScalingGroupField::EffectiveRecommendationPreferencesCpuVendorArchitectures => "EffectiveRecommendationPreferencesCpuVendorArchitectures",
            ExportableAutoScalingGroupField::EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics => "EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics",
            ExportableAutoScalingGroupField::EffectiveRecommendationPreferencesInferredWorkloadTypes => "EffectiveRecommendationPreferencesInferredWorkloadTypes",
            ExportableAutoScalingGroupField::Finding => "Finding",
            ExportableAutoScalingGroupField::InferredWorkloadTypes => "InferredWorkloadTypes",
            ExportableAutoScalingGroupField::LastRefreshTimestamp => "LastRefreshTimestamp",
            ExportableAutoScalingGroupField::LookbackPeriodInDays => "LookbackPeriodInDays",
            ExportableAutoScalingGroupField::RecommendationOptionsConfigurationDesiredCapacity => "RecommendationOptionsConfigurationDesiredCapacity",
            ExportableAutoScalingGroupField::RecommendationOptionsConfigurationInstanceType => "RecommendationOptionsConfigurationInstanceType",
            ExportableAutoScalingGroupField::RecommendationOptionsConfigurationMaxSize => "RecommendationOptionsConfigurationMaxSize",
            ExportableAutoScalingGroupField::RecommendationOptionsConfigurationMinSize => "RecommendationOptionsConfigurationMinSize",
            ExportableAutoScalingGroupField::RecommendationOptionsEstimatedMonthlySavingsCurrency => "RecommendationOptionsEstimatedMonthlySavingsCurrency",
            ExportableAutoScalingGroupField::RecommendationOptionsEstimatedMonthlySavingsValue => "RecommendationOptionsEstimatedMonthlySavingsValue",
            ExportableAutoScalingGroupField::RecommendationOptionsMemory => "RecommendationOptionsMemory",
            ExportableAutoScalingGroupField::RecommendationOptionsMigrationEffort => "RecommendationOptionsMigrationEffort",
            ExportableAutoScalingGroupField::RecommendationOptionsNetwork => "RecommendationOptionsNetwork",
            ExportableAutoScalingGroupField::RecommendationOptionsOnDemandPrice => "RecommendationOptionsOnDemandPrice",
            ExportableAutoScalingGroupField::RecommendationOptionsPerformanceRisk => "RecommendationOptionsPerformanceRisk",
            ExportableAutoScalingGroupField::RecommendationOptionsProjectedUtilizationMetricsCpuMaximum => "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum",
            ExportableAutoScalingGroupField::RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum => "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum",
            ExportableAutoScalingGroupField::RecommendationOptionsSavingsOpportunityPercentage => "RecommendationOptionsSavingsOpportunityPercentage",
            ExportableAutoScalingGroupField::RecommendationOptionsStandardOneYearNoUpfrontReservedPrice => "RecommendationOptionsStandardOneYearNoUpfrontReservedPrice",
            ExportableAutoScalingGroupField::RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice => "RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice",
            ExportableAutoScalingGroupField::RecommendationOptionsStorage => "RecommendationOptionsStorage",
            ExportableAutoScalingGroupField::RecommendationOptionsVcpus => "RecommendationOptionsVcpus",
            ExportableAutoScalingGroupField::UtilizationMetricsCpuMaximum => "UtilizationMetricsCpuMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsDiskReadBytesPerSecondMaximum => "UtilizationMetricsDiskReadBytesPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsDiskReadOpsPerSecondMaximum => "UtilizationMetricsDiskReadOpsPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsDiskWriteBytesPerSecondMaximum => "UtilizationMetricsDiskWriteBytesPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsDiskWriteOpsPerSecondMaximum => "UtilizationMetricsDiskWriteOpsPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsEbsReadBytesPerSecondMaximum => "UtilizationMetricsEbsReadBytesPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsEbsReadOpsPerSecondMaximum => "UtilizationMetricsEbsReadOpsPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsEbsWriteBytesPerSecondMaximum => "UtilizationMetricsEbsWriteBytesPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsEbsWriteOpsPerSecondMaximum => "UtilizationMetricsEbsWriteOpsPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsMemoryMaximum => "UtilizationMetricsMemoryMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsNetworkInBytesPerSecondMaximum => "UtilizationMetricsNetworkInBytesPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsNetworkOutBytesPerSecondMaximum => "UtilizationMetricsNetworkOutBytesPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsNetworkPacketsInPerSecondMaximum => "UtilizationMetricsNetworkPacketsInPerSecondMaximum",
            ExportableAutoScalingGroupField::UtilizationMetricsNetworkPacketsOutPerSecondMaximum => "UtilizationMetricsNetworkPacketsOutPerSecondMaximum",
            ExportableAutoScalingGroupField::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccountId", "AutoScalingGroupArn", "AutoScalingGroupName", "CurrentConfigurationDesiredCapacity", "CurrentConfigurationInstanceType", "CurrentConfigurationMaxSize", "CurrentConfigurationMinSize", "CurrentMemory", "CurrentNetwork", "CurrentOnDemandPrice", "CurrentPerformanceRisk", "CurrentStandardOneYearNoUpfrontReservedPrice", "CurrentStandardThreeYearNoUpfrontReservedPrice", "CurrentStorage", "CurrentVCpus", "EffectiveRecommendationPreferencesCpuVendorArchitectures", "EffectiveRecommendationPreferencesEnhancedInfrastructureMetrics", "EffectiveRecommendationPreferencesInferredWorkloadTypes", "Finding", "InferredWorkloadTypes", "LastRefreshTimestamp", "LookbackPeriodInDays", "RecommendationOptionsConfigurationDesiredCapacity", "RecommendationOptionsConfigurationInstanceType", "RecommendationOptionsConfigurationMaxSize", "RecommendationOptionsConfigurationMinSize", "RecommendationOptionsEstimatedMonthlySavingsCurrency", "RecommendationOptionsEstimatedMonthlySavingsValue", "RecommendationOptionsMemory", "RecommendationOptionsMigrationEffort", "RecommendationOptionsNetwork", "RecommendationOptionsOnDemandPrice", "RecommendationOptionsPerformanceRisk", "RecommendationOptionsProjectedUtilizationMetricsCpuMaximum", "RecommendationOptionsProjectedUtilizationMetricsMemoryMaximum", "RecommendationOptionsSavingsOpportunityPercentage", "RecommendationOptionsStandardOneYearNoUpfrontReservedPrice", "RecommendationOptionsStandardThreeYearNoUpfrontReservedPrice", "RecommendationOptionsStorage", "RecommendationOptionsVcpus", "UtilizationMetricsCpuMaximum", "UtilizationMetricsDiskReadBytesPerSecondMaximum", "UtilizationMetricsDiskReadOpsPerSecondMaximum", "UtilizationMetricsDiskWriteBytesPerSecondMaximum", "UtilizationMetricsDiskWriteOpsPerSecondMaximum", "UtilizationMetricsEbsReadBytesPerSecondMaximum", "UtilizationMetricsEbsReadOpsPerSecondMaximum", "UtilizationMetricsEbsWriteBytesPerSecondMaximum", "UtilizationMetricsEbsWriteOpsPerSecondMaximum", "UtilizationMetricsMemoryMaximum", "UtilizationMetricsNetworkInBytesPerSecondMaximum", "UtilizationMetricsNetworkOutBytesPerSecondMaximum", "UtilizationMetricsNetworkPacketsInPerSecondMaximum", "UtilizationMetricsNetworkPacketsOutPerSecondMaximum"
        ]
    }
}
impl AsRef<str> for ExportableAutoScalingGroupField {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a recommendation export job.</p> 
/// <p>Use the <code>DescribeRecommendationExportJobs</code> action to view your recommendation export jobs.</p> 
/// <p>Use the <code>ExportAutoScalingGroupRecommendations</code> or <code>ExportEC2InstanceRecommendations</code> actions to request an export of your recommendations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendationExportJob  {
    /// <p>The identification number of the export job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>An object that describes the destination of the export file.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<crate::model::ExportDestination>,
    /// <p>The resource type of the exported recommendations.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The status of the export job.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::JobStatus>,
    /// <p>The timestamp of when the export job was created.</p>
    #[doc(hidden)]
    pub creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp of when the export job was last updated.</p>
    #[doc(hidden)]
    pub last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The reason for an export job failure.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
}
impl RecommendationExportJob {
    /// <p>The identification number of the export job.</p>
    pub fn job_id(&self) -> std::option::Option<& str> {
        self.job_id.as_deref()
    }
    /// <p>An object that describes the destination of the export file.</p>
    pub fn destination(&self) -> std::option::Option<& crate::model::ExportDestination> {
        self.destination.as_ref()
    }
    /// <p>The resource type of the exported recommendations.</p>
    pub fn resource_type(&self) -> std::option::Option<& crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The status of the export job.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::JobStatus> {
        self.status.as_ref()
    }
    /// <p>The timestamp of when the export job was created.</p>
    pub fn creation_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.creation_timestamp.as_ref()
    }
    /// <p>The timestamp of when the export job was last updated.</p>
    pub fn last_updated_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.last_updated_timestamp.as_ref()
    }
    /// <p>The reason for an export job failure.</p>
    pub fn failure_reason(&self) -> std::option::Option<& str> {
        self.failure_reason.as_deref()
    }
}
/// See [`RecommendationExportJob`](crate::model::RecommendationExportJob).
pub mod recommendation_export_job {
    
    /// A builder for [`RecommendationExportJob`](crate::model::RecommendationExportJob).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) destination: std::option::Option<crate::model::ExportDestination>,
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) status: std::option::Option<crate::model::JobStatus>,
        pub(crate) creation_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identification number of the export job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identification number of the export job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input; self
        }
        /// <p>An object that describes the destination of the export file.</p>
        pub fn destination(mut self, input: crate::model::ExportDestination) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>An object that describes the destination of the export file.</p>
        pub fn set_destination(mut self, input: std::option::Option<crate::model::ExportDestination>) -> Self {
            self.destination = input; self
        }
        /// <p>The resource type of the exported recommendations.</p>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type of the exported recommendations.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<crate::model::ResourceType>) -> Self {
            self.resource_type = input; self
        }
        /// <p>The status of the export job.</p>
        pub fn status(mut self, input: crate::model::JobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the export job.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::JobStatus>) -> Self {
            self.status = input; self
        }
        /// <p>The timestamp of when the export job was created.</p>
        pub fn creation_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_timestamp = Some(input);
            self
        }
        /// <p>The timestamp of when the export job was created.</p>
        pub fn set_creation_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.creation_timestamp = input; self
        }
        /// <p>The timestamp of when the export job was last updated.</p>
        pub fn last_updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_timestamp = Some(input);
            self
        }
        /// <p>The timestamp of when the export job was last updated.</p>
        pub fn set_last_updated_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.last_updated_timestamp = input; self
        }
        /// <p>The reason for an export job failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason for an export job failure.</p>
        pub fn set_failure_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.failure_reason = input; self
        }
        /// Consumes the builder and constructs a [`RecommendationExportJob`](crate::model::RecommendationExportJob).
        pub fn build(self) -> crate::model::RecommendationExportJob {
            crate::model::RecommendationExportJob {
                job_id: self.job_id
                ,
                destination: self.destination
                ,
                resource_type: self.resource_type
                ,
                status: self.status
                ,
                creation_timestamp: self.creation_timestamp
                ,
                last_updated_timestamp: self.last_updated_timestamp
                ,
                failure_reason: self.failure_reason
                ,
            }
        }
    }
    
    
}
impl RecommendationExportJob {
    /// Creates a new builder-style object to manufacture [`RecommendationExportJob`](crate::model::RecommendationExportJob).
    pub fn builder() -> crate::model::recommendation_export_job::Builder {
        crate::model::recommendation_export_job::Builder::default()
    }
}

/// When writing a match expression against `JobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let jobstatus = unimplemented!();
/// match jobstatus {
///     JobStatus::Complete => { /* ... */ },
///     JobStatus::Failed => { /* ... */ },
///     JobStatus::InProgress => { /* ... */ },
///     JobStatus::Queued => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobStatus::NewFeature` is defined.
/// Specifically, when `jobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobStatus::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum JobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Complete,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Queued,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for JobStatus {
    fn from(s: &str) -> Self {
        match s {
            "Complete" => JobStatus::Complete,
            "Failed" => JobStatus::Failed,
            "InProgress" => JobStatus::InProgress,
            "Queued" => JobStatus::Queued,
            other => JobStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for JobStatus {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(JobStatus::from(s))
                }
            }
impl JobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobStatus::Complete => "Complete",
            JobStatus::Failed => "Failed",
            JobStatus::InProgress => "InProgress",
            JobStatus::Queued => "Queued",
            JobStatus::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Complete", "Failed", "InProgress", "Queued"
        ]
    }
}
impl AsRef<str> for JobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the destination of the recommendations export and metadata files.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExportDestination  {
    /// <p>An object that describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a recommendations export file, and its associated metadata file.</p>
    #[doc(hidden)]
    pub s3: std::option::Option<crate::model::S3Destination>,
}
impl ExportDestination {
    /// <p>An object that describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a recommendations export file, and its associated metadata file.</p>
    pub fn s3(&self) -> std::option::Option<& crate::model::S3Destination> {
        self.s3.as_ref()
    }
}
/// See [`ExportDestination`](crate::model::ExportDestination).
pub mod export_destination {
    
    /// A builder for [`ExportDestination`](crate::model::ExportDestination).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3: std::option::Option<crate::model::S3Destination>,
    }
    impl Builder {
        /// <p>An object that describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a recommendations export file, and its associated metadata file.</p>
        pub fn s3(mut self, input: crate::model::S3Destination) -> Self {
            self.s3 = Some(input);
            self
        }
        /// <p>An object that describes the destination Amazon Simple Storage Service (Amazon S3) bucket name and object keys of a recommendations export file, and its associated metadata file.</p>
        pub fn set_s3(mut self, input: std::option::Option<crate::model::S3Destination>) -> Self {
            self.s3 = input; self
        }
        /// Consumes the builder and constructs a [`ExportDestination`](crate::model::ExportDestination).
        pub fn build(self) -> crate::model::ExportDestination {
            crate::model::ExportDestination {
                s3: self.s3
                ,
            }
        }
    }
    
    
}
impl ExportDestination {
    /// Creates a new builder-style object to manufacture [`ExportDestination`](crate::model::ExportDestination).
    pub fn builder() -> crate::model::export_destination::Builder {
        crate::model::export_destination::Builder::default()
    }
}

/// <p>Describes a filter that returns a more specific list of recommendation export jobs. Use this filter with the <code>DescribeRecommendationExportJobs</code> action.</p> 
/// <p>You can use <code>EBSFilter</code> with the <code>GetEBSVolumeRecommendations</code> action, <code>LambdaFunctionRecommendationFilter</code> with the <code>GetLambdaFunctionRecommendations</code> action, and <code>Filter</code> with the <code>GetAutoScalingGroupRecommendations</code> and <code>GetEC2InstanceRecommendations</code> actions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobFilter  {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>ResourceType</code> to return export jobs of a specific resource type (for example, <code>Ec2Instance</code>).</p> 
    /// <p>Specify <code>JobStatus</code> to return export jobs with a specific status (e.g, <code>Complete</code>).</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::JobFilterName>,
    /// <p>The value of the filter.</p> 
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p> 
    /// <ul> 
    /// <li> <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you specify the <code>name</code> parameter as <code>ResourceType</code>. There is no filter for EBS volumes because volume recommendations cannot be exported at this time.</p> </li> 
    /// <li> <p>Specify <code>Queued</code>, <code>InProgress</code>, <code>Complete</code>, or <code>Failed</code> if you specify the <code>name</code> parameter as <code>JobStatus</code>.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl JobFilter {
    /// <p>The name of the filter.</p> 
    /// <p>Specify <code>ResourceType</code> to return export jobs of a specific resource type (for example, <code>Ec2Instance</code>).</p> 
    /// <p>Specify <code>JobStatus</code> to return export jobs with a specific status (e.g, <code>Complete</code>).</p>
    pub fn name(&self) -> std::option::Option<& crate::model::JobFilterName> {
        self.name.as_ref()
    }
    /// <p>The value of the filter.</p> 
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p> 
    /// <ul> 
    /// <li> <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you specify the <code>name</code> parameter as <code>ResourceType</code>. There is no filter for EBS volumes because volume recommendations cannot be exported at this time.</p> </li> 
    /// <li> <p>Specify <code>Queued</code>, <code>InProgress</code>, <code>Complete</code>, or <code>Failed</code> if you specify the <code>name</code> parameter as <code>JobStatus</code>.</p> </li> 
    /// </ul>
    pub fn values(&self) -> std::option::Option<& [std::string::String]> {
        self.values.as_deref()
    }
}
/// See [`JobFilter`](crate::model::JobFilter).
pub mod job_filter {
    
    /// A builder for [`JobFilter`](crate::model::JobFilter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::JobFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>ResourceType</code> to return export jobs of a specific resource type (for example, <code>Ec2Instance</code>).</p> 
        /// <p>Specify <code>JobStatus</code> to return export jobs with a specific status (e.g, <code>Complete</code>).</p>
        pub fn name(mut self, input: crate::model::JobFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the filter.</p> 
        /// <p>Specify <code>ResourceType</code> to return export jobs of a specific resource type (for example, <code>Ec2Instance</code>).</p> 
        /// <p>Specify <code>JobStatus</code> to return export jobs with a specific status (e.g, <code>Complete</code>).</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::JobFilterName>) -> Self {
            self.name = input; self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The value of the filter.</p> 
        /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p> 
        /// <ul> 
        /// <li> <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you specify the <code>name</code> parameter as <code>ResourceType</code>. There is no filter for EBS volumes because volume recommendations cannot be exported at this time.</p> </li> 
        /// <li> <p>Specify <code>Queued</code>, <code>InProgress</code>, <code>Complete</code>, or <code>Failed</code> if you specify the <code>name</code> parameter as <code>JobStatus</code>.</p> </li> 
        /// </ul>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
                            v.push(input.into());
                            self.values = Some(v);
                            self
        }
        /// <p>The value of the filter.</p> 
        /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p> 
        /// <ul> 
        /// <li> <p>Specify <code>Ec2Instance</code> or <code>AutoScalingGroup</code> if you specify the <code>name</code> parameter as <code>ResourceType</code>. There is no filter for EBS volumes because volume recommendations cannot be exported at this time.</p> </li> 
        /// <li> <p>Specify <code>Queued</code>, <code>InProgress</code>, <code>Complete</code>, or <code>Failed</code> if you specify the <code>name</code> parameter as <code>JobStatus</code>.</p> </li> 
        /// </ul>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`JobFilter`](crate::model::JobFilter).
        pub fn build(self) -> crate::model::JobFilter {
            crate::model::JobFilter {
                name: self.name
                ,
                values: self.values
                ,
            }
        }
    }
    
    
}
impl JobFilter {
    /// Creates a new builder-style object to manufacture [`JobFilter`](crate::model::JobFilter).
    pub fn builder() -> crate::model::job_filter::Builder {
        crate::model::job_filter::Builder::default()
    }
}

/// When writing a match expression against `JobFilterName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let jobfiltername = unimplemented!();
/// match jobfiltername {
///     JobFilterName::JobStatus => { /* ... */ },
///     JobFilterName::ResourceType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobfiltername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobFilterName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobFilterName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobFilterName::NewFeature` is defined.
/// Specifically, when `jobfiltername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobFilterName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum JobFilterName {
    #[allow(missing_docs)] // documentation missing in model
    JobStatus,
    #[allow(missing_docs)] // documentation missing in model
    ResourceType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for JobFilterName {
    fn from(s: &str) -> Self {
        match s {
            "JobStatus" => JobFilterName::JobStatus,
            "ResourceType" => JobFilterName::ResourceType,
            other => JobFilterName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for JobFilterName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(JobFilterName::from(s))
                }
            }
impl JobFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobFilterName::JobStatus => "JobStatus",
            JobFilterName::ResourceType => "ResourceType",
            JobFilterName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "JobStatus", "ResourceType"
        ]
    }
}
impl AsRef<str> for JobFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RecommendationPreferenceName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let recommendationpreferencename = unimplemented!();
/// match recommendationpreferencename {
///     RecommendationPreferenceName::EnhancedInfrastructureMetrics => { /* ... */ },
///     RecommendationPreferenceName::ExternalMetricsPreference => { /* ... */ },
///     RecommendationPreferenceName::InferredWorkloadTypes => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recommendationpreferencename` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecommendationPreferenceName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecommendationPreferenceName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecommendationPreferenceName::NewFeature` is defined.
/// Specifically, when `recommendationpreferencename` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecommendationPreferenceName::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum RecommendationPreferenceName {
    #[allow(missing_docs)] // documentation missing in model
    EnhancedInfrastructureMetrics,
    #[allow(missing_docs)] // documentation missing in model
    ExternalMetricsPreference,
    #[allow(missing_docs)] // documentation missing in model
    InferredWorkloadTypes,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for RecommendationPreferenceName {
    fn from(s: &str) -> Self {
        match s {
            "EnhancedInfrastructureMetrics" => RecommendationPreferenceName::EnhancedInfrastructureMetrics,
            "ExternalMetricsPreference" => RecommendationPreferenceName::ExternalMetricsPreference,
            "InferredWorkloadTypes" => RecommendationPreferenceName::InferredWorkloadTypes,
            other => RecommendationPreferenceName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for RecommendationPreferenceName {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(RecommendationPreferenceName::from(s))
                }
            }
impl RecommendationPreferenceName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecommendationPreferenceName::EnhancedInfrastructureMetrics => "EnhancedInfrastructureMetrics",
            RecommendationPreferenceName::ExternalMetricsPreference => "ExternalMetricsPreference",
            RecommendationPreferenceName::InferredWorkloadTypes => "InferredWorkloadTypes",
            RecommendationPreferenceName::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "EnhancedInfrastructureMetrics", "ExternalMetricsPreference", "InferredWorkloadTypes"
        ]
    }
}
impl AsRef<str> for RecommendationPreferenceName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

