// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes an Amazon EC2 instance recommendation.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InstanceRecommendation {
    /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
    pub instance_arn: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Web Services account ID of the instance.</p>
    pub account_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the current instance.</p>
    pub instance_name: ::std::option::Option<::std::string::String>,
    /// <p>The instance type of the current instance.</p>
    pub current_instance_type: ::std::option::Option<::std::string::String>,
    /// <p>The finding classification of the instance.</p>
    /// <p>Findings for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>Underprovisioned</code> </b>—An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.</p></li>
    /// <li>
    /// <p><b> <code>Overprovisioned</code> </b>—An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.</p></li>
    /// <li>
    /// <p><b> <code>Optimized</code> </b>—An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p></li>
    /// </ul>
    pub finding: ::std::option::Option<crate::types::Finding>,
    /// <p>The reason for the finding classification of the instance.</p>
    /// <p>Finding reason codes for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>CPUOverprovisioned</code> </b> — The instance’s CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>CPUUnderprovisioned</code> </b> — The instance’s CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryOverprovisioned</code> </b> — The instance’s memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryUnderprovisioned</code> </b> — The instance’s memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p><note>
    /// <p>Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory utilization with the Amazon CloudWatch Agent</a> in the <i>Compute Optimizer User Guide</i>. On Linux instances, Compute Optimizer analyses the <code>mem_used_percent</code> metric in the <code>CWAgent</code> namespace, or the legacy <code>MemoryUtilization</code> metric in the <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses the <code>Memory % Committed Bytes In Use</code> metric in the <code>CWAgent</code> namespace.</p>
    /// </note></li>
    /// <li>
    /// <p><b> <code>EBSThroughputOverprovisioned</code> </b> — The instance’s EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSThroughputUnderprovisioned</code> </b> — The instance’s EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSOverprovisioned</code> </b> — The instance’s EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSUnderprovisioned</code> </b> — The instance’s EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthOverprovisioned</code> </b> — The instance’s network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthUnderprovisioned</code> </b> — The instance’s network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSOverprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSUnderprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSOverprovisioned</code> </b> — The instance’s disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSUnderprovisioned</code> </b> — The instance’s disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputOverprovisioned</code> </b> — The instance’s disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputUnderprovisioned</code> </b> — The instance’s disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// </ul><note>
    /// <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    /// </note>
    pub finding_reason_codes: ::std::option::Option<::std::vec::Vec<crate::types::InstanceRecommendationFindingReasonCode>>,
    /// <p>An array of objects that describe the utilization metrics of the instance.</p>
    pub utilization_metrics: ::std::option::Option<::std::vec::Vec<crate::types::UtilizationMetric>>,
    /// <p>The number of days for which utilization metrics were analyzed for the instance.</p>
    pub look_back_period_in_days: f64,
    /// <p>An array of objects that describe the recommendation options for the instance.</p>
    pub recommendation_options: ::std::option::Option<::std::vec::Vec<crate::types::InstanceRecommendationOption>>,
    /// <p>An array of objects that describe the source resource of the recommendation.</p>
    pub recommendation_sources: ::std::option::Option<::std::vec::Vec<crate::types::RecommendationSource>>,
    /// <p>The timestamp of when the instance recommendation was last generated.</p>
    pub last_refresh_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.</p>
    pub current_performance_risk: ::std::option::Option<crate::types::CurrentPerformanceRisk>,
    /// <p>An object that describes the effective recommendation preferences for the instance.</p>
    pub effective_recommendation_preferences: ::std::option::Option<crate::types::EffectiveRecommendationPreferences>,
    /// <p>The applications that might be running on the instance as inferred by Compute Optimizer.</p>
    /// <p>Compute Optimizer can infer if one of the following applications might be running on the instance:</p>
    /// <ul>
    /// <li>
    /// <p><code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Memcached</code> - Infers that Memcached might be running on the instance.</p></li>
    /// <li>
    /// <p><code>NGINX</code> - Infers that NGINX might be running on the instance.</p></li>
    /// <li>
    /// <p><code>PostgreSql</code> - Infers that PostgreSQL might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Redis</code> - Infers that Redis might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Kafka</code> - Infers that Kafka might be running on the instance.</p></li>
    /// <li>
    /// <p><code>SQLServer</code> - Infers that SQLServer might be running on the instance.</p></li>
    /// </ul>
    pub inferred_workload_types: ::std::option::Option<::std::vec::Vec<crate::types::InferredWorkloadType>>,
    /// <p>The state of the instance when the recommendation was generated.</p>
    pub instance_state: ::std::option::Option<crate::types::InstanceState>,
    /// <p>A list of tags assigned to your Amazon EC2 instance recommendations.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>An object that describes Compute Optimizer's integration status with your external metrics provider.</p>
    pub external_metric_status: ::std::option::Option<crate::types::ExternalMetricStatus>,
    /// <p>Describes the GPU accelerator settings for the current instance type.</p>
    pub current_instance_gpu_info: ::std::option::Option<crate::types::GpuInfo>,
    /// <p>Describes if an Amazon EC2 instance is idle.</p>
    pub idle: ::std::option::Option<crate::types::InstanceIdle>,
}
impl InstanceRecommendation {
    /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
    pub fn instance_arn(&self) -> ::std::option::Option<&str> {
        self.instance_arn.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the instance.</p>
    pub fn account_id(&self) -> ::std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the current instance.</p>
    pub fn instance_name(&self) -> ::std::option::Option<&str> {
        self.instance_name.as_deref()
    }
    /// <p>The instance type of the current instance.</p>
    pub fn current_instance_type(&self) -> ::std::option::Option<&str> {
        self.current_instance_type.as_deref()
    }
    /// <p>The finding classification of the instance.</p>
    /// <p>Findings for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>Underprovisioned</code> </b>—An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.</p></li>
    /// <li>
    /// <p><b> <code>Overprovisioned</code> </b>—An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.</p></li>
    /// <li>
    /// <p><b> <code>Optimized</code> </b>—An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p></li>
    /// </ul>
    pub fn finding(&self) -> ::std::option::Option<&crate::types::Finding> {
        self.finding.as_ref()
    }
    /// <p>The reason for the finding classification of the instance.</p>
    /// <p>Finding reason codes for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>CPUOverprovisioned</code> </b> — The instance’s CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>CPUUnderprovisioned</code> </b> — The instance’s CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryOverprovisioned</code> </b> — The instance’s memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryUnderprovisioned</code> </b> — The instance’s memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p><note>
    /// <p>Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory utilization with the Amazon CloudWatch Agent</a> in the <i>Compute Optimizer User Guide</i>. On Linux instances, Compute Optimizer analyses the <code>mem_used_percent</code> metric in the <code>CWAgent</code> namespace, or the legacy <code>MemoryUtilization</code> metric in the <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses the <code>Memory % Committed Bytes In Use</code> metric in the <code>CWAgent</code> namespace.</p>
    /// </note></li>
    /// <li>
    /// <p><b> <code>EBSThroughputOverprovisioned</code> </b> — The instance’s EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSThroughputUnderprovisioned</code> </b> — The instance’s EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSOverprovisioned</code> </b> — The instance’s EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSUnderprovisioned</code> </b> — The instance’s EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthOverprovisioned</code> </b> — The instance’s network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthUnderprovisioned</code> </b> — The instance’s network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSOverprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSUnderprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSOverprovisioned</code> </b> — The instance’s disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSUnderprovisioned</code> </b> — The instance’s disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputOverprovisioned</code> </b> — The instance’s disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputUnderprovisioned</code> </b> — The instance’s disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// </ul><note>
    /// <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    /// </note>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.finding_reason_codes.is_none()`.
    pub fn finding_reason_codes(&self) -> &[crate::types::InstanceRecommendationFindingReasonCode] {
        self.finding_reason_codes.as_deref().unwrap_or_default()
    }
    /// <p>An array of objects that describe the utilization metrics of the instance.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.utilization_metrics.is_none()`.
    pub fn utilization_metrics(&self) -> &[crate::types::UtilizationMetric] {
        self.utilization_metrics.as_deref().unwrap_or_default()
    }
    /// <p>The number of days for which utilization metrics were analyzed for the instance.</p>
    pub fn look_back_period_in_days(&self) -> f64 {
        self.look_back_period_in_days
    }
    /// <p>An array of objects that describe the recommendation options for the instance.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.recommendation_options.is_none()`.
    pub fn recommendation_options(&self) -> &[crate::types::InstanceRecommendationOption] {
        self.recommendation_options.as_deref().unwrap_or_default()
    }
    /// <p>An array of objects that describe the source resource of the recommendation.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.recommendation_sources.is_none()`.
    pub fn recommendation_sources(&self) -> &[crate::types::RecommendationSource] {
        self.recommendation_sources.as_deref().unwrap_or_default()
    }
    /// <p>The timestamp of when the instance recommendation was last generated.</p>
    pub fn last_refresh_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_refresh_timestamp.as_ref()
    }
    /// <p>The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.</p>
    pub fn current_performance_risk(&self) -> ::std::option::Option<&crate::types::CurrentPerformanceRisk> {
        self.current_performance_risk.as_ref()
    }
    /// <p>An object that describes the effective recommendation preferences for the instance.</p>
    pub fn effective_recommendation_preferences(&self) -> ::std::option::Option<&crate::types::EffectiveRecommendationPreferences> {
        self.effective_recommendation_preferences.as_ref()
    }
    /// <p>The applications that might be running on the instance as inferred by Compute Optimizer.</p>
    /// <p>Compute Optimizer can infer if one of the following applications might be running on the instance:</p>
    /// <ul>
    /// <li>
    /// <p><code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Memcached</code> - Infers that Memcached might be running on the instance.</p></li>
    /// <li>
    /// <p><code>NGINX</code> - Infers that NGINX might be running on the instance.</p></li>
    /// <li>
    /// <p><code>PostgreSql</code> - Infers that PostgreSQL might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Redis</code> - Infers that Redis might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Kafka</code> - Infers that Kafka might be running on the instance.</p></li>
    /// <li>
    /// <p><code>SQLServer</code> - Infers that SQLServer might be running on the instance.</p></li>
    /// </ul>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.inferred_workload_types.is_none()`.
    pub fn inferred_workload_types(&self) -> &[crate::types::InferredWorkloadType] {
        self.inferred_workload_types.as_deref().unwrap_or_default()
    }
    /// <p>The state of the instance when the recommendation was generated.</p>
    pub fn instance_state(&self) -> ::std::option::Option<&crate::types::InstanceState> {
        self.instance_state.as_ref()
    }
    /// <p>A list of tags assigned to your Amazon EC2 instance recommendations.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>An object that describes Compute Optimizer's integration status with your external metrics provider.</p>
    pub fn external_metric_status(&self) -> ::std::option::Option<&crate::types::ExternalMetricStatus> {
        self.external_metric_status.as_ref()
    }
    /// <p>Describes the GPU accelerator settings for the current instance type.</p>
    pub fn current_instance_gpu_info(&self) -> ::std::option::Option<&crate::types::GpuInfo> {
        self.current_instance_gpu_info.as_ref()
    }
    /// <p>Describes if an Amazon EC2 instance is idle.</p>
    pub fn idle(&self) -> ::std::option::Option<&crate::types::InstanceIdle> {
        self.idle.as_ref()
    }
}
impl InstanceRecommendation {
    /// Creates a new builder-style object to manufacture [`InstanceRecommendation`](crate::types::InstanceRecommendation).
    pub fn builder() -> crate::types::builders::InstanceRecommendationBuilder {
        crate::types::builders::InstanceRecommendationBuilder::default()
    }
}

/// A builder for [`InstanceRecommendation`](crate::types::InstanceRecommendation).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct InstanceRecommendationBuilder {
    pub(crate) instance_arn: ::std::option::Option<::std::string::String>,
    pub(crate) account_id: ::std::option::Option<::std::string::String>,
    pub(crate) instance_name: ::std::option::Option<::std::string::String>,
    pub(crate) current_instance_type: ::std::option::Option<::std::string::String>,
    pub(crate) finding: ::std::option::Option<crate::types::Finding>,
    pub(crate) finding_reason_codes: ::std::option::Option<::std::vec::Vec<crate::types::InstanceRecommendationFindingReasonCode>>,
    pub(crate) utilization_metrics: ::std::option::Option<::std::vec::Vec<crate::types::UtilizationMetric>>,
    pub(crate) look_back_period_in_days: ::std::option::Option<f64>,
    pub(crate) recommendation_options: ::std::option::Option<::std::vec::Vec<crate::types::InstanceRecommendationOption>>,
    pub(crate) recommendation_sources: ::std::option::Option<::std::vec::Vec<crate::types::RecommendationSource>>,
    pub(crate) last_refresh_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) current_performance_risk: ::std::option::Option<crate::types::CurrentPerformanceRisk>,
    pub(crate) effective_recommendation_preferences: ::std::option::Option<crate::types::EffectiveRecommendationPreferences>,
    pub(crate) inferred_workload_types: ::std::option::Option<::std::vec::Vec<crate::types::InferredWorkloadType>>,
    pub(crate) instance_state: ::std::option::Option<crate::types::InstanceState>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) external_metric_status: ::std::option::Option<crate::types::ExternalMetricStatus>,
    pub(crate) current_instance_gpu_info: ::std::option::Option<crate::types::GpuInfo>,
    pub(crate) idle: ::std::option::Option<crate::types::InstanceIdle>,
}
impl InstanceRecommendationBuilder {
    /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
    pub fn instance_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.instance_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
    pub fn set_instance_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.instance_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the current instance.</p>
    pub fn get_instance_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.instance_arn
    }
    /// <p>The Amazon Web Services account ID of the instance.</p>
    pub fn account_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.account_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Web Services account ID of the instance.</p>
    pub fn set_account_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.account_id = input;
        self
    }
    /// <p>The Amazon Web Services account ID of the instance.</p>
    pub fn get_account_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.account_id
    }
    /// <p>The name of the current instance.</p>
    pub fn instance_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.instance_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the current instance.</p>
    pub fn set_instance_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.instance_name = input;
        self
    }
    /// <p>The name of the current instance.</p>
    pub fn get_instance_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.instance_name
    }
    /// <p>The instance type of the current instance.</p>
    pub fn current_instance_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.current_instance_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The instance type of the current instance.</p>
    pub fn set_current_instance_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.current_instance_type = input;
        self
    }
    /// <p>The instance type of the current instance.</p>
    pub fn get_current_instance_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.current_instance_type
    }
    /// <p>The finding classification of the instance.</p>
    /// <p>Findings for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>Underprovisioned</code> </b>—An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.</p></li>
    /// <li>
    /// <p><b> <code>Overprovisioned</code> </b>—An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.</p></li>
    /// <li>
    /// <p><b> <code>Optimized</code> </b>—An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p></li>
    /// </ul>
    pub fn finding(mut self, input: crate::types::Finding) -> Self {
        self.finding = ::std::option::Option::Some(input);
        self
    }
    /// <p>The finding classification of the instance.</p>
    /// <p>Findings for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>Underprovisioned</code> </b>—An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.</p></li>
    /// <li>
    /// <p><b> <code>Overprovisioned</code> </b>—An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.</p></li>
    /// <li>
    /// <p><b> <code>Optimized</code> </b>—An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p></li>
    /// </ul>
    pub fn set_finding(mut self, input: ::std::option::Option<crate::types::Finding>) -> Self {
        self.finding = input;
        self
    }
    /// <p>The finding classification of the instance.</p>
    /// <p>Findings for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>Underprovisioned</code> </b>—An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.</p></li>
    /// <li>
    /// <p><b> <code>Overprovisioned</code> </b>—An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.</p></li>
    /// <li>
    /// <p><b> <code>Optimized</code> </b>—An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.</p></li>
    /// </ul>
    pub fn get_finding(&self) -> &::std::option::Option<crate::types::Finding> {
        &self.finding
    }
    /// Appends an item to `finding_reason_codes`.
    ///
    /// To override the contents of this collection use [`set_finding_reason_codes`](Self::set_finding_reason_codes).
    ///
    /// <p>The reason for the finding classification of the instance.</p>
    /// <p>Finding reason codes for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>CPUOverprovisioned</code> </b> — The instance’s CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>CPUUnderprovisioned</code> </b> — The instance’s CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryOverprovisioned</code> </b> — The instance’s memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryUnderprovisioned</code> </b> — The instance’s memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p><note>
    /// <p>Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory utilization with the Amazon CloudWatch Agent</a> in the <i>Compute Optimizer User Guide</i>. On Linux instances, Compute Optimizer analyses the <code>mem_used_percent</code> metric in the <code>CWAgent</code> namespace, or the legacy <code>MemoryUtilization</code> metric in the <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses the <code>Memory % Committed Bytes In Use</code> metric in the <code>CWAgent</code> namespace.</p>
    /// </note></li>
    /// <li>
    /// <p><b> <code>EBSThroughputOverprovisioned</code> </b> — The instance’s EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSThroughputUnderprovisioned</code> </b> — The instance’s EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSOverprovisioned</code> </b> — The instance’s EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSUnderprovisioned</code> </b> — The instance’s EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthOverprovisioned</code> </b> — The instance’s network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthUnderprovisioned</code> </b> — The instance’s network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSOverprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSUnderprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSOverprovisioned</code> </b> — The instance’s disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSUnderprovisioned</code> </b> — The instance’s disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputOverprovisioned</code> </b> — The instance’s disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputUnderprovisioned</code> </b> — The instance’s disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// </ul><note>
    /// <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    /// </note>
    pub fn finding_reason_codes(mut self, input: crate::types::InstanceRecommendationFindingReasonCode) -> Self {
        let mut v = self.finding_reason_codes.unwrap_or_default();
        v.push(input);
        self.finding_reason_codes = ::std::option::Option::Some(v);
        self
    }
    /// <p>The reason for the finding classification of the instance.</p>
    /// <p>Finding reason codes for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>CPUOverprovisioned</code> </b> — The instance’s CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>CPUUnderprovisioned</code> </b> — The instance’s CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryOverprovisioned</code> </b> — The instance’s memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryUnderprovisioned</code> </b> — The instance’s memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p><note>
    /// <p>Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory utilization with the Amazon CloudWatch Agent</a> in the <i>Compute Optimizer User Guide</i>. On Linux instances, Compute Optimizer analyses the <code>mem_used_percent</code> metric in the <code>CWAgent</code> namespace, or the legacy <code>MemoryUtilization</code> metric in the <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses the <code>Memory % Committed Bytes In Use</code> metric in the <code>CWAgent</code> namespace.</p>
    /// </note></li>
    /// <li>
    /// <p><b> <code>EBSThroughputOverprovisioned</code> </b> — The instance’s EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSThroughputUnderprovisioned</code> </b> — The instance’s EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSOverprovisioned</code> </b> — The instance’s EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSUnderprovisioned</code> </b> — The instance’s EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthOverprovisioned</code> </b> — The instance’s network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthUnderprovisioned</code> </b> — The instance’s network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSOverprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSUnderprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSOverprovisioned</code> </b> — The instance’s disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSUnderprovisioned</code> </b> — The instance’s disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputOverprovisioned</code> </b> — The instance’s disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputUnderprovisioned</code> </b> — The instance’s disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// </ul><note>
    /// <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    /// </note>
    pub fn set_finding_reason_codes(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::InstanceRecommendationFindingReasonCode>>,
    ) -> Self {
        self.finding_reason_codes = input;
        self
    }
    /// <p>The reason for the finding classification of the instance.</p>
    /// <p>Finding reason codes for instances include:</p>
    /// <ul>
    /// <li>
    /// <p><b> <code>CPUOverprovisioned</code> </b> — The instance’s CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>CPUUnderprovisioned</code> </b> — The instance’s CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the <code>CPUUtilization</code> metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryOverprovisioned</code> </b> — The instance’s memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>MemoryUnderprovisioned</code> </b> — The instance’s memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.</p><note>
    /// <p>Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see <a href="https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent">Enabling memory utilization with the Amazon CloudWatch Agent</a> in the <i>Compute Optimizer User Guide</i>. On Linux instances, Compute Optimizer analyses the <code>mem_used_percent</code> metric in the <code>CWAgent</code> namespace, or the legacy <code>MemoryUtilization</code> metric in the <code>System/Linux</code> namespace. On Windows instances, Compute Optimizer analyses the <code>Memory % Committed Bytes In Use</code> metric in the <code>CWAgent</code> namespace.</p>
    /// </note></li>
    /// <li>
    /// <p><b> <code>EBSThroughputOverprovisioned</code> </b> — The instance’s EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSThroughputUnderprovisioned</code> </b> — The instance’s EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the <code>VolumeReadBytes</code> and <code>VolumeWriteBytes</code> metrics of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSOverprovisioned</code> </b> — The instance’s EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>EBSIOPSUnderprovisioned</code> </b> — The instance’s EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the <code>VolumeReadOps</code> and <code>VolumeWriteOps</code> metric of EBS volumes attached to the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthOverprovisioned</code> </b> — The instance’s network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkBandwidthUnderprovisioned</code> </b> — The instance’s network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the <code>NetworkIn</code> and <code>NetworkOut</code> metrics of the current instance during the look-back period. This finding reason happens when the <code>NetworkIn</code> or <code>NetworkOut</code> performance of an instance is impacted.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSOverprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>NetworkPPSUnderprovisioned</code> </b> — The instance’s network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the <code>NetworkPacketsIn</code> and <code>NetworkPacketsIn</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSOverprovisioned</code> </b> — The instance’s disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskIOPSUnderprovisioned</code> </b> — The instance’s disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the <code>DiskReadOps</code> and <code>DiskWriteOps</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputOverprovisioned</code> </b> — The instance’s disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// <li>
    /// <p><b> <code>DiskThroughputUnderprovisioned</code> </b> — The instance’s disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the <code>DiskReadBytes</code> and <code>DiskWriteBytes</code> metrics of the current instance during the look-back period.</p></li>
    /// </ul><note>
    /// <p>For more information about instance metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html">List the available CloudWatch metrics for your instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For more information about EBS volume metrics, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html">Amazon CloudWatch metrics for Amazon EBS</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    /// </note>
    pub fn get_finding_reason_codes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::InstanceRecommendationFindingReasonCode>> {
        &self.finding_reason_codes
    }
    /// Appends an item to `utilization_metrics`.
    ///
    /// To override the contents of this collection use [`set_utilization_metrics`](Self::set_utilization_metrics).
    ///
    /// <p>An array of objects that describe the utilization metrics of the instance.</p>
    pub fn utilization_metrics(mut self, input: crate::types::UtilizationMetric) -> Self {
        let mut v = self.utilization_metrics.unwrap_or_default();
        v.push(input);
        self.utilization_metrics = ::std::option::Option::Some(v);
        self
    }
    /// <p>An array of objects that describe the utilization metrics of the instance.</p>
    pub fn set_utilization_metrics(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::UtilizationMetric>>) -> Self {
        self.utilization_metrics = input;
        self
    }
    /// <p>An array of objects that describe the utilization metrics of the instance.</p>
    pub fn get_utilization_metrics(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::UtilizationMetric>> {
        &self.utilization_metrics
    }
    /// <p>The number of days for which utilization metrics were analyzed for the instance.</p>
    pub fn look_back_period_in_days(mut self, input: f64) -> Self {
        self.look_back_period_in_days = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of days for which utilization metrics were analyzed for the instance.</p>
    pub fn set_look_back_period_in_days(mut self, input: ::std::option::Option<f64>) -> Self {
        self.look_back_period_in_days = input;
        self
    }
    /// <p>The number of days for which utilization metrics were analyzed for the instance.</p>
    pub fn get_look_back_period_in_days(&self) -> &::std::option::Option<f64> {
        &self.look_back_period_in_days
    }
    /// Appends an item to `recommendation_options`.
    ///
    /// To override the contents of this collection use [`set_recommendation_options`](Self::set_recommendation_options).
    ///
    /// <p>An array of objects that describe the recommendation options for the instance.</p>
    pub fn recommendation_options(mut self, input: crate::types::InstanceRecommendationOption) -> Self {
        let mut v = self.recommendation_options.unwrap_or_default();
        v.push(input);
        self.recommendation_options = ::std::option::Option::Some(v);
        self
    }
    /// <p>An array of objects that describe the recommendation options for the instance.</p>
    pub fn set_recommendation_options(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::InstanceRecommendationOption>>) -> Self {
        self.recommendation_options = input;
        self
    }
    /// <p>An array of objects that describe the recommendation options for the instance.</p>
    pub fn get_recommendation_options(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::InstanceRecommendationOption>> {
        &self.recommendation_options
    }
    /// Appends an item to `recommendation_sources`.
    ///
    /// To override the contents of this collection use [`set_recommendation_sources`](Self::set_recommendation_sources).
    ///
    /// <p>An array of objects that describe the source resource of the recommendation.</p>
    pub fn recommendation_sources(mut self, input: crate::types::RecommendationSource) -> Self {
        let mut v = self.recommendation_sources.unwrap_or_default();
        v.push(input);
        self.recommendation_sources = ::std::option::Option::Some(v);
        self
    }
    /// <p>An array of objects that describe the source resource of the recommendation.</p>
    pub fn set_recommendation_sources(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RecommendationSource>>) -> Self {
        self.recommendation_sources = input;
        self
    }
    /// <p>An array of objects that describe the source resource of the recommendation.</p>
    pub fn get_recommendation_sources(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RecommendationSource>> {
        &self.recommendation_sources
    }
    /// <p>The timestamp of when the instance recommendation was last generated.</p>
    pub fn last_refresh_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_refresh_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp of when the instance recommendation was last generated.</p>
    pub fn set_last_refresh_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_refresh_timestamp = input;
        self
    }
    /// <p>The timestamp of when the instance recommendation was last generated.</p>
    pub fn get_last_refresh_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_refresh_timestamp
    }
    /// <p>The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.</p>
    pub fn current_performance_risk(mut self, input: crate::types::CurrentPerformanceRisk) -> Self {
        self.current_performance_risk = ::std::option::Option::Some(input);
        self
    }
    /// <p>The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.</p>
    pub fn set_current_performance_risk(mut self, input: ::std::option::Option<crate::types::CurrentPerformanceRisk>) -> Self {
        self.current_performance_risk = input;
        self
    }
    /// <p>The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.</p>
    pub fn get_current_performance_risk(&self) -> &::std::option::Option<crate::types::CurrentPerformanceRisk> {
        &self.current_performance_risk
    }
    /// <p>An object that describes the effective recommendation preferences for the instance.</p>
    pub fn effective_recommendation_preferences(mut self, input: crate::types::EffectiveRecommendationPreferences) -> Self {
        self.effective_recommendation_preferences = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object that describes the effective recommendation preferences for the instance.</p>
    pub fn set_effective_recommendation_preferences(
        mut self,
        input: ::std::option::Option<crate::types::EffectiveRecommendationPreferences>,
    ) -> Self {
        self.effective_recommendation_preferences = input;
        self
    }
    /// <p>An object that describes the effective recommendation preferences for the instance.</p>
    pub fn get_effective_recommendation_preferences(&self) -> &::std::option::Option<crate::types::EffectiveRecommendationPreferences> {
        &self.effective_recommendation_preferences
    }
    /// Appends an item to `inferred_workload_types`.
    ///
    /// To override the contents of this collection use [`set_inferred_workload_types`](Self::set_inferred_workload_types).
    ///
    /// <p>The applications that might be running on the instance as inferred by Compute Optimizer.</p>
    /// <p>Compute Optimizer can infer if one of the following applications might be running on the instance:</p>
    /// <ul>
    /// <li>
    /// <p><code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Memcached</code> - Infers that Memcached might be running on the instance.</p></li>
    /// <li>
    /// <p><code>NGINX</code> - Infers that NGINX might be running on the instance.</p></li>
    /// <li>
    /// <p><code>PostgreSql</code> - Infers that PostgreSQL might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Redis</code> - Infers that Redis might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Kafka</code> - Infers that Kafka might be running on the instance.</p></li>
    /// <li>
    /// <p><code>SQLServer</code> - Infers that SQLServer might be running on the instance.</p></li>
    /// </ul>
    pub fn inferred_workload_types(mut self, input: crate::types::InferredWorkloadType) -> Self {
        let mut v = self.inferred_workload_types.unwrap_or_default();
        v.push(input);
        self.inferred_workload_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>The applications that might be running on the instance as inferred by Compute Optimizer.</p>
    /// <p>Compute Optimizer can infer if one of the following applications might be running on the instance:</p>
    /// <ul>
    /// <li>
    /// <p><code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Memcached</code> - Infers that Memcached might be running on the instance.</p></li>
    /// <li>
    /// <p><code>NGINX</code> - Infers that NGINX might be running on the instance.</p></li>
    /// <li>
    /// <p><code>PostgreSql</code> - Infers that PostgreSQL might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Redis</code> - Infers that Redis might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Kafka</code> - Infers that Kafka might be running on the instance.</p></li>
    /// <li>
    /// <p><code>SQLServer</code> - Infers that SQLServer might be running on the instance.</p></li>
    /// </ul>
    pub fn set_inferred_workload_types(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::InferredWorkloadType>>) -> Self {
        self.inferred_workload_types = input;
        self
    }
    /// <p>The applications that might be running on the instance as inferred by Compute Optimizer.</p>
    /// <p>Compute Optimizer can infer if one of the following applications might be running on the instance:</p>
    /// <ul>
    /// <li>
    /// <p><code>AmazonEmr</code> - Infers that Amazon EMR might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheCassandra</code> - Infers that Apache Cassandra might be running on the instance.</p></li>
    /// <li>
    /// <p><code>ApacheHadoop</code> - Infers that Apache Hadoop might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Memcached</code> - Infers that Memcached might be running on the instance.</p></li>
    /// <li>
    /// <p><code>NGINX</code> - Infers that NGINX might be running on the instance.</p></li>
    /// <li>
    /// <p><code>PostgreSql</code> - Infers that PostgreSQL might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Redis</code> - Infers that Redis might be running on the instance.</p></li>
    /// <li>
    /// <p><code>Kafka</code> - Infers that Kafka might be running on the instance.</p></li>
    /// <li>
    /// <p><code>SQLServer</code> - Infers that SQLServer might be running on the instance.</p></li>
    /// </ul>
    pub fn get_inferred_workload_types(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::InferredWorkloadType>> {
        &self.inferred_workload_types
    }
    /// <p>The state of the instance when the recommendation was generated.</p>
    pub fn instance_state(mut self, input: crate::types::InstanceState) -> Self {
        self.instance_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The state of the instance when the recommendation was generated.</p>
    pub fn set_instance_state(mut self, input: ::std::option::Option<crate::types::InstanceState>) -> Self {
        self.instance_state = input;
        self
    }
    /// <p>The state of the instance when the recommendation was generated.</p>
    pub fn get_instance_state(&self) -> &::std::option::Option<crate::types::InstanceState> {
        &self.instance_state
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of tags assigned to your Amazon EC2 instance recommendations.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of tags assigned to your Amazon EC2 instance recommendations.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>A list of tags assigned to your Amazon EC2 instance recommendations.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>An object that describes Compute Optimizer's integration status with your external metrics provider.</p>
    pub fn external_metric_status(mut self, input: crate::types::ExternalMetricStatus) -> Self {
        self.external_metric_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>An object that describes Compute Optimizer's integration status with your external metrics provider.</p>
    pub fn set_external_metric_status(mut self, input: ::std::option::Option<crate::types::ExternalMetricStatus>) -> Self {
        self.external_metric_status = input;
        self
    }
    /// <p>An object that describes Compute Optimizer's integration status with your external metrics provider.</p>
    pub fn get_external_metric_status(&self) -> &::std::option::Option<crate::types::ExternalMetricStatus> {
        &self.external_metric_status
    }
    /// <p>Describes the GPU accelerator settings for the current instance type.</p>
    pub fn current_instance_gpu_info(mut self, input: crate::types::GpuInfo) -> Self {
        self.current_instance_gpu_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the GPU accelerator settings for the current instance type.</p>
    pub fn set_current_instance_gpu_info(mut self, input: ::std::option::Option<crate::types::GpuInfo>) -> Self {
        self.current_instance_gpu_info = input;
        self
    }
    /// <p>Describes the GPU accelerator settings for the current instance type.</p>
    pub fn get_current_instance_gpu_info(&self) -> &::std::option::Option<crate::types::GpuInfo> {
        &self.current_instance_gpu_info
    }
    /// <p>Describes if an Amazon EC2 instance is idle.</p>
    pub fn idle(mut self, input: crate::types::InstanceIdle) -> Self {
        self.idle = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes if an Amazon EC2 instance is idle.</p>
    pub fn set_idle(mut self, input: ::std::option::Option<crate::types::InstanceIdle>) -> Self {
        self.idle = input;
        self
    }
    /// <p>Describes if an Amazon EC2 instance is idle.</p>
    pub fn get_idle(&self) -> &::std::option::Option<crate::types::InstanceIdle> {
        &self.idle
    }
    /// Consumes the builder and constructs a [`InstanceRecommendation`](crate::types::InstanceRecommendation).
    pub fn build(self) -> crate::types::InstanceRecommendation {
        crate::types::InstanceRecommendation {
            instance_arn: self.instance_arn,
            account_id: self.account_id,
            instance_name: self.instance_name,
            current_instance_type: self.current_instance_type,
            finding: self.finding,
            finding_reason_codes: self.finding_reason_codes,
            utilization_metrics: self.utilization_metrics,
            look_back_period_in_days: self.look_back_period_in_days.unwrap_or_default(),
            recommendation_options: self.recommendation_options,
            recommendation_sources: self.recommendation_sources,
            last_refresh_timestamp: self.last_refresh_timestamp,
            current_performance_risk: self.current_performance_risk,
            effective_recommendation_preferences: self.effective_recommendation_preferences,
            inferred_workload_types: self.inferred_workload_types,
            instance_state: self.instance_state,
            tags: self.tags,
            external_metric_status: self.external_metric_status,
            current_instance_gpu_info: self.current_instance_gpu_info,
            idle: self.idle,
        }
    }
}
