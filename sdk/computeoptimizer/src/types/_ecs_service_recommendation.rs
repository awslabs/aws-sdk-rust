// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p> Describes an Amazon ECS service recommendation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsServiceRecommendation {
    /// <p> The Amazon Resource Name (ARN) of the current ECS service. </p>
    /// <p> The following is the format of the ARN: </p>
    /// <p> <code>arn:aws:ecs:region:aws_account_id:service/cluster-name/service-name</code> </p>
    #[doc(hidden)]
    pub service_arn: std::option::Option<std::string::String>,
    /// <p> The Amazon Web Services account ID of the ECS service. </p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> The configuration of the current ECS service. </p>
    #[doc(hidden)]
    pub current_service_configuration: std::option::Option<crate::types::ServiceConfiguration>,
    /// <p> An array of objects that describe the utilization metrics of the ECS service. </p>
    #[doc(hidden)]
    pub utilization_metrics:
        std::option::Option<std::vec::Vec<crate::types::EcsServiceUtilizationMetric>>,
    /// <p> The number of days the ECS service utilization metrics were analyzed. </p>
    #[doc(hidden)]
    pub lookback_period_in_days: f64,
    /// <p> The launch type the ECS service is using. </p> <note>
    /// <p>Compute Optimizer only supports the Fargate launch type.</p>
    /// </note>
    #[doc(hidden)]
    pub launch_type: std::option::Option<crate::types::EcsServiceLaunchType>,
    /// <p> The timestamp of when the ECS service recommendation was last generated. </p>
    #[doc(hidden)]
    pub last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> The finding classification of an ECS service. </p>
    /// <p>Findings for ECS services include:</p>
    /// <ul>
    /// <li> <p> <b> <code>Underprovisioned</code> </b> — When Compute Optimizer detects that there’s not enough memory or CPU, an ECS service is considered under-provisioned. An under-provisioned ECS service might result in poor application performance.</p> </li>
    /// <li> <p> <b> <code>Overprovisioned</code> </b> — When Compute Optimizer detects that there’s excessive memory or CPU, an ECS service is considered over-provisioned. An over-provisioned ECS service might result in additional infrastructure costs. </p> </li>
    /// <li> <p> <b> <code>Optimized</code> </b> — When both the CPU and memory of your ECS service meet the performance requirements of your workload, the service is considered optimized.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub finding: std::option::Option<crate::types::EcsServiceRecommendationFinding>,
    /// <p> The reason for the finding classification of an ECS service. </p>
    /// <p>Finding reason codes for ECS services include:</p>
    /// <ul>
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b> — The ECS service CPU configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b> — The ECS service CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period. </p> </li>
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b> — The ECS service memory configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b> — The ECS service memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub finding_reason_codes:
        std::option::Option<std::vec::Vec<crate::types::EcsServiceRecommendationFindingReasonCode>>,
    /// <p> An array of objects that describe the recommendation options for the ECS service. </p>
    #[doc(hidden)]
    pub service_recommendation_options:
        std::option::Option<std::vec::Vec<crate::types::EcsServiceRecommendationOption>>,
    /// <p> The risk of the current ECS service not meeting the performance needs of its workloads. The higher the risk, the more likely the current service can't meet the performance requirements of its workload. </p>
    #[doc(hidden)]
    pub current_performance_risk: std::option::Option<crate::types::CurrentPerformanceRisk>,
}
impl EcsServiceRecommendation {
    /// <p> The Amazon Resource Name (ARN) of the current ECS service. </p>
    /// <p> The following is the format of the ARN: </p>
    /// <p> <code>arn:aws:ecs:region:aws_account_id:service/cluster-name/service-name</code> </p>
    pub fn service_arn(&self) -> std::option::Option<&str> {
        self.service_arn.as_deref()
    }
    /// <p> The Amazon Web Services account ID of the ECS service. </p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p> The configuration of the current ECS service. </p>
    pub fn current_service_configuration(
        &self,
    ) -> std::option::Option<&crate::types::ServiceConfiguration> {
        self.current_service_configuration.as_ref()
    }
    /// <p> An array of objects that describe the utilization metrics of the ECS service. </p>
    pub fn utilization_metrics(
        &self,
    ) -> std::option::Option<&[crate::types::EcsServiceUtilizationMetric]> {
        self.utilization_metrics.as_deref()
    }
    /// <p> The number of days the ECS service utilization metrics were analyzed. </p>
    pub fn lookback_period_in_days(&self) -> f64 {
        self.lookback_period_in_days
    }
    /// <p> The launch type the ECS service is using. </p> <note>
    /// <p>Compute Optimizer only supports the Fargate launch type.</p>
    /// </note>
    pub fn launch_type(&self) -> std::option::Option<&crate::types::EcsServiceLaunchType> {
        self.launch_type.as_ref()
    }
    /// <p> The timestamp of when the ECS service recommendation was last generated. </p>
    pub fn last_refresh_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_refresh_timestamp.as_ref()
    }
    /// <p> The finding classification of an ECS service. </p>
    /// <p>Findings for ECS services include:</p>
    /// <ul>
    /// <li> <p> <b> <code>Underprovisioned</code> </b> — When Compute Optimizer detects that there’s not enough memory or CPU, an ECS service is considered under-provisioned. An under-provisioned ECS service might result in poor application performance.</p> </li>
    /// <li> <p> <b> <code>Overprovisioned</code> </b> — When Compute Optimizer detects that there’s excessive memory or CPU, an ECS service is considered over-provisioned. An over-provisioned ECS service might result in additional infrastructure costs. </p> </li>
    /// <li> <p> <b> <code>Optimized</code> </b> — When both the CPU and memory of your ECS service meet the performance requirements of your workload, the service is considered optimized.</p> </li>
    /// </ul>
    pub fn finding(&self) -> std::option::Option<&crate::types::EcsServiceRecommendationFinding> {
        self.finding.as_ref()
    }
    /// <p> The reason for the finding classification of an ECS service. </p>
    /// <p>Finding reason codes for ECS services include:</p>
    /// <ul>
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b> — The ECS service CPU configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b> — The ECS service CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period. </p> </li>
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b> — The ECS service memory configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b> — The ECS service memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// </ul>
    pub fn finding_reason_codes(
        &self,
    ) -> std::option::Option<&[crate::types::EcsServiceRecommendationFindingReasonCode]> {
        self.finding_reason_codes.as_deref()
    }
    /// <p> An array of objects that describe the recommendation options for the ECS service. </p>
    pub fn service_recommendation_options(
        &self,
    ) -> std::option::Option<&[crate::types::EcsServiceRecommendationOption]> {
        self.service_recommendation_options.as_deref()
    }
    /// <p> The risk of the current ECS service not meeting the performance needs of its workloads. The higher the risk, the more likely the current service can't meet the performance requirements of its workload. </p>
    pub fn current_performance_risk(
        &self,
    ) -> std::option::Option<&crate::types::CurrentPerformanceRisk> {
        self.current_performance_risk.as_ref()
    }
}
impl EcsServiceRecommendation {
    /// Creates a new builder-style object to manufacture [`EcsServiceRecommendation`](crate::types::EcsServiceRecommendation).
    pub fn builder() -> crate::types::builders::EcsServiceRecommendationBuilder {
        crate::types::builders::EcsServiceRecommendationBuilder::default()
    }
}

/// A builder for [`EcsServiceRecommendation`](crate::types::EcsServiceRecommendation).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct EcsServiceRecommendationBuilder {
    pub(crate) service_arn: std::option::Option<std::string::String>,
    pub(crate) account_id: std::option::Option<std::string::String>,
    pub(crate) current_service_configuration:
        std::option::Option<crate::types::ServiceConfiguration>,
    pub(crate) utilization_metrics:
        std::option::Option<std::vec::Vec<crate::types::EcsServiceUtilizationMetric>>,
    pub(crate) lookback_period_in_days: std::option::Option<f64>,
    pub(crate) launch_type: std::option::Option<crate::types::EcsServiceLaunchType>,
    pub(crate) last_refresh_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) finding: std::option::Option<crate::types::EcsServiceRecommendationFinding>,
    pub(crate) finding_reason_codes:
        std::option::Option<std::vec::Vec<crate::types::EcsServiceRecommendationFindingReasonCode>>,
    pub(crate) service_recommendation_options:
        std::option::Option<std::vec::Vec<crate::types::EcsServiceRecommendationOption>>,
    pub(crate) current_performance_risk: std::option::Option<crate::types::CurrentPerformanceRisk>,
}
impl EcsServiceRecommendationBuilder {
    /// <p> The Amazon Resource Name (ARN) of the current ECS service. </p>
    /// <p> The following is the format of the ARN: </p>
    /// <p> <code>arn:aws:ecs:region:aws_account_id:service/cluster-name/service-name</code> </p>
    pub fn service_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_arn = Some(input.into());
        self
    }
    /// <p> The Amazon Resource Name (ARN) of the current ECS service. </p>
    /// <p> The following is the format of the ARN: </p>
    /// <p> <code>arn:aws:ecs:region:aws_account_id:service/cluster-name/service-name</code> </p>
    pub fn set_service_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.service_arn = input;
        self
    }
    /// <p> The Amazon Web Services account ID of the ECS service. </p>
    pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.account_id = Some(input.into());
        self
    }
    /// <p> The Amazon Web Services account ID of the ECS service. </p>
    pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.account_id = input;
        self
    }
    /// <p> The configuration of the current ECS service. </p>
    pub fn current_service_configuration(
        mut self,
        input: crate::types::ServiceConfiguration,
    ) -> Self {
        self.current_service_configuration = Some(input);
        self
    }
    /// <p> The configuration of the current ECS service. </p>
    pub fn set_current_service_configuration(
        mut self,
        input: std::option::Option<crate::types::ServiceConfiguration>,
    ) -> Self {
        self.current_service_configuration = input;
        self
    }
    /// Appends an item to `utilization_metrics`.
    ///
    /// To override the contents of this collection use [`set_utilization_metrics`](Self::set_utilization_metrics).
    ///
    /// <p> An array of objects that describe the utilization metrics of the ECS service. </p>
    pub fn utilization_metrics(mut self, input: crate::types::EcsServiceUtilizationMetric) -> Self {
        let mut v = self.utilization_metrics.unwrap_or_default();
        v.push(input);
        self.utilization_metrics = Some(v);
        self
    }
    /// <p> An array of objects that describe the utilization metrics of the ECS service. </p>
    pub fn set_utilization_metrics(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::EcsServiceUtilizationMetric>>,
    ) -> Self {
        self.utilization_metrics = input;
        self
    }
    /// <p> The number of days the ECS service utilization metrics were analyzed. </p>
    pub fn lookback_period_in_days(mut self, input: f64) -> Self {
        self.lookback_period_in_days = Some(input);
        self
    }
    /// <p> The number of days the ECS service utilization metrics were analyzed. </p>
    pub fn set_lookback_period_in_days(mut self, input: std::option::Option<f64>) -> Self {
        self.lookback_period_in_days = input;
        self
    }
    /// <p> The launch type the ECS service is using. </p> <note>
    /// <p>Compute Optimizer only supports the Fargate launch type.</p>
    /// </note>
    pub fn launch_type(mut self, input: crate::types::EcsServiceLaunchType) -> Self {
        self.launch_type = Some(input);
        self
    }
    /// <p> The launch type the ECS service is using. </p> <note>
    /// <p>Compute Optimizer only supports the Fargate launch type.</p>
    /// </note>
    pub fn set_launch_type(
        mut self,
        input: std::option::Option<crate::types::EcsServiceLaunchType>,
    ) -> Self {
        self.launch_type = input;
        self
    }
    /// <p> The timestamp of when the ECS service recommendation was last generated. </p>
    pub fn last_refresh_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.last_refresh_timestamp = Some(input);
        self
    }
    /// <p> The timestamp of when the ECS service recommendation was last generated. </p>
    pub fn set_last_refresh_timestamp(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.last_refresh_timestamp = input;
        self
    }
    /// <p> The finding classification of an ECS service. </p>
    /// <p>Findings for ECS services include:</p>
    /// <ul>
    /// <li> <p> <b> <code>Underprovisioned</code> </b> — When Compute Optimizer detects that there’s not enough memory or CPU, an ECS service is considered under-provisioned. An under-provisioned ECS service might result in poor application performance.</p> </li>
    /// <li> <p> <b> <code>Overprovisioned</code> </b> — When Compute Optimizer detects that there’s excessive memory or CPU, an ECS service is considered over-provisioned. An over-provisioned ECS service might result in additional infrastructure costs. </p> </li>
    /// <li> <p> <b> <code>Optimized</code> </b> — When both the CPU and memory of your ECS service meet the performance requirements of your workload, the service is considered optimized.</p> </li>
    /// </ul>
    pub fn finding(mut self, input: crate::types::EcsServiceRecommendationFinding) -> Self {
        self.finding = Some(input);
        self
    }
    /// <p> The finding classification of an ECS service. </p>
    /// <p>Findings for ECS services include:</p>
    /// <ul>
    /// <li> <p> <b> <code>Underprovisioned</code> </b> — When Compute Optimizer detects that there’s not enough memory or CPU, an ECS service is considered under-provisioned. An under-provisioned ECS service might result in poor application performance.</p> </li>
    /// <li> <p> <b> <code>Overprovisioned</code> </b> — When Compute Optimizer detects that there’s excessive memory or CPU, an ECS service is considered over-provisioned. An over-provisioned ECS service might result in additional infrastructure costs. </p> </li>
    /// <li> <p> <b> <code>Optimized</code> </b> — When both the CPU and memory of your ECS service meet the performance requirements of your workload, the service is considered optimized.</p> </li>
    /// </ul>
    pub fn set_finding(
        mut self,
        input: std::option::Option<crate::types::EcsServiceRecommendationFinding>,
    ) -> Self {
        self.finding = input;
        self
    }
    /// Appends an item to `finding_reason_codes`.
    ///
    /// To override the contents of this collection use [`set_finding_reason_codes`](Self::set_finding_reason_codes).
    ///
    /// <p> The reason for the finding classification of an ECS service. </p>
    /// <p>Finding reason codes for ECS services include:</p>
    /// <ul>
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b> — The ECS service CPU configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b> — The ECS service CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period. </p> </li>
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b> — The ECS service memory configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b> — The ECS service memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// </ul>
    pub fn finding_reason_codes(
        mut self,
        input: crate::types::EcsServiceRecommendationFindingReasonCode,
    ) -> Self {
        let mut v = self.finding_reason_codes.unwrap_or_default();
        v.push(input);
        self.finding_reason_codes = Some(v);
        self
    }
    /// <p> The reason for the finding classification of an ECS service. </p>
    /// <p>Finding reason codes for ECS services include:</p>
    /// <ul>
    /// <li> <p> <b> <code>CPUUnderprovisioned</code> </b> — The ECS service CPU configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// <li> <p> <b> <code>CPUOverprovisioned</code> </b> — The ECS service CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>CPUUtilization</code> metric of the current service during the look-back period. </p> </li>
    /// <li> <p> <b> <code>MemoryUnderprovisioned</code> </b> — The ECS service memory configuration can be sized up to enhance the performance of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// <li> <p> <b> <code>MemoryOverprovisioned</code> </b> — The ECS service memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the <code>MemoryUtilization</code> metric of the current service during the look-back period.</p> </li>
    /// </ul>
    pub fn set_finding_reason_codes(
        mut self,
        input: std::option::Option<
            std::vec::Vec<crate::types::EcsServiceRecommendationFindingReasonCode>,
        >,
    ) -> Self {
        self.finding_reason_codes = input;
        self
    }
    /// Appends an item to `service_recommendation_options`.
    ///
    /// To override the contents of this collection use [`set_service_recommendation_options`](Self::set_service_recommendation_options).
    ///
    /// <p> An array of objects that describe the recommendation options for the ECS service. </p>
    pub fn service_recommendation_options(
        mut self,
        input: crate::types::EcsServiceRecommendationOption,
    ) -> Self {
        let mut v = self.service_recommendation_options.unwrap_or_default();
        v.push(input);
        self.service_recommendation_options = Some(v);
        self
    }
    /// <p> An array of objects that describe the recommendation options for the ECS service. </p>
    pub fn set_service_recommendation_options(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::EcsServiceRecommendationOption>>,
    ) -> Self {
        self.service_recommendation_options = input;
        self
    }
    /// <p> The risk of the current ECS service not meeting the performance needs of its workloads. The higher the risk, the more likely the current service can't meet the performance requirements of its workload. </p>
    pub fn current_performance_risk(mut self, input: crate::types::CurrentPerformanceRisk) -> Self {
        self.current_performance_risk = Some(input);
        self
    }
    /// <p> The risk of the current ECS service not meeting the performance needs of its workloads. The higher the risk, the more likely the current service can't meet the performance requirements of its workload. </p>
    pub fn set_current_performance_risk(
        mut self,
        input: std::option::Option<crate::types::CurrentPerformanceRisk>,
    ) -> Self {
        self.current_performance_risk = input;
        self
    }
    /// Consumes the builder and constructs a [`EcsServiceRecommendation`](crate::types::EcsServiceRecommendation).
    pub fn build(self) -> crate::types::EcsServiceRecommendation {
        crate::types::EcsServiceRecommendation {
            service_arn: self.service_arn,
            account_id: self.account_id,
            current_service_configuration: self.current_service_configuration,
            utilization_metrics: self.utilization_metrics,
            lookback_period_in_days: self.lookback_period_in_days.unwrap_or_default(),
            launch_type: self.launch_type,
            last_refresh_timestamp: self.last_refresh_timestamp,
            finding: self.finding,
            finding_reason_codes: self.finding_reason_codes,
            service_recommendation_options: self.service_recommendation_options,
            current_performance_risk: self.current_performance_risk,
        }
    }
}
