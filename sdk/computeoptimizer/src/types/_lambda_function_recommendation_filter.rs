// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a filter that returns a more specific list of Lambda function recommendations. Use this filter with the <code>GetLambdaFunctionRecommendations</code> action.</p>
/// <p>You can use <code>EBSFilter</code> with the <code>GetEBSVolumeRecommendations</code> action, <code>JobFilter</code> with the <code>DescribeRecommendationExportJobs</code> action, and <code>Filter</code> with the <code>GetAutoScalingGroupRecommendations</code> and <code>GetEC2InstanceRecommendations</code> actions.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct LambdaFunctionRecommendationFilter {
    /// <p>The name of the filter.</p>
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p>
    /// <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code (for example, <code>MemoryUnderprovisioned</code>).</p>
    /// <p>You can filter your Lambda function recommendations by <code>tag:key</code> and <code>tag-key</code> tags.</p>
    /// <p>A <code>tag:key</code> is a key and value combination of a tag assigned to your Lambda function recommendations. Use the tag key in the filter name and the tag value as the filter value. For example, to find all Lambda function recommendations that have a tag with the key of <code>Owner</code> and the value of <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
    /// <p>A <code>tag-key</code> is the key of a tag assigned to your Lambda function recommendations. Use this filter to find all of your Lambda function recommendations that have a tag with a specific key. This doesn’t consider the tag value. For example, you can find your Lambda function recommendations with a tag key value of <code>Owner</code> or without any tag keys assigned.</p>
    pub name: ::std::option::Option<crate::types::LambdaFunctionRecommendationFilterName>,
    /// <p>The value of the filter.</p>
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p>
    /// <ul>
    /// <li>
    /// <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code> if you specify the <code>name</code> parameter as <code>Finding</code>.</p></li>
    /// <li>
    /// <p>Specify <code>MemoryOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or <code>Inconclusive</code> if you specify the <code>name</code> parameter as <code>FindingReasonCode</code>.</p></li>
    /// </ul>
    pub values: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl LambdaFunctionRecommendationFilter {
    /// <p>The name of the filter.</p>
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p>
    /// <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code (for example, <code>MemoryUnderprovisioned</code>).</p>
    /// <p>You can filter your Lambda function recommendations by <code>tag:key</code> and <code>tag-key</code> tags.</p>
    /// <p>A <code>tag:key</code> is a key and value combination of a tag assigned to your Lambda function recommendations. Use the tag key in the filter name and the tag value as the filter value. For example, to find all Lambda function recommendations that have a tag with the key of <code>Owner</code> and the value of <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
    /// <p>A <code>tag-key</code> is the key of a tag assigned to your Lambda function recommendations. Use this filter to find all of your Lambda function recommendations that have a tag with a specific key. This doesn’t consider the tag value. For example, you can find your Lambda function recommendations with a tag key value of <code>Owner</code> or without any tag keys assigned.</p>
    pub fn name(&self) -> ::std::option::Option<&crate::types::LambdaFunctionRecommendationFilterName> {
        self.name.as_ref()
    }
    /// <p>The value of the filter.</p>
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p>
    /// <ul>
    /// <li>
    /// <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code> if you specify the <code>name</code> parameter as <code>Finding</code>.</p></li>
    /// <li>
    /// <p>Specify <code>MemoryOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or <code>Inconclusive</code> if you specify the <code>name</code> parameter as <code>FindingReasonCode</code>.</p></li>
    /// </ul>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.values.is_none()`.
    pub fn values(&self) -> &[::std::string::String] {
        self.values.as_deref().unwrap_or_default()
    }
}
impl LambdaFunctionRecommendationFilter {
    /// Creates a new builder-style object to manufacture [`LambdaFunctionRecommendationFilter`](crate::types::LambdaFunctionRecommendationFilter).
    pub fn builder() -> crate::types::builders::LambdaFunctionRecommendationFilterBuilder {
        crate::types::builders::LambdaFunctionRecommendationFilterBuilder::default()
    }
}

/// A builder for [`LambdaFunctionRecommendationFilter`](crate::types::LambdaFunctionRecommendationFilter).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct LambdaFunctionRecommendationFilterBuilder {
    pub(crate) name: ::std::option::Option<crate::types::LambdaFunctionRecommendationFilterName>,
    pub(crate) values: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl LambdaFunctionRecommendationFilterBuilder {
    /// <p>The name of the filter.</p>
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p>
    /// <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code (for example, <code>MemoryUnderprovisioned</code>).</p>
    /// <p>You can filter your Lambda function recommendations by <code>tag:key</code> and <code>tag-key</code> tags.</p>
    /// <p>A <code>tag:key</code> is a key and value combination of a tag assigned to your Lambda function recommendations. Use the tag key in the filter name and the tag value as the filter value. For example, to find all Lambda function recommendations that have a tag with the key of <code>Owner</code> and the value of <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
    /// <p>A <code>tag-key</code> is the key of a tag assigned to your Lambda function recommendations. Use this filter to find all of your Lambda function recommendations that have a tag with a specific key. This doesn’t consider the tag value. For example, you can find your Lambda function recommendations with a tag key value of <code>Owner</code> or without any tag keys assigned.</p>
    pub fn name(mut self, input: crate::types::LambdaFunctionRecommendationFilterName) -> Self {
        self.name = ::std::option::Option::Some(input);
        self
    }
    /// <p>The name of the filter.</p>
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p>
    /// <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code (for example, <code>MemoryUnderprovisioned</code>).</p>
    /// <p>You can filter your Lambda function recommendations by <code>tag:key</code> and <code>tag-key</code> tags.</p>
    /// <p>A <code>tag:key</code> is a key and value combination of a tag assigned to your Lambda function recommendations. Use the tag key in the filter name and the tag value as the filter value. For example, to find all Lambda function recommendations that have a tag with the key of <code>Owner</code> and the value of <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
    /// <p>A <code>tag-key</code> is the key of a tag assigned to your Lambda function recommendations. Use this filter to find all of your Lambda function recommendations that have a tag with a specific key. This doesn’t consider the tag value. For example, you can find your Lambda function recommendations with a tag key value of <code>Owner</code> or without any tag keys assigned.</p>
    pub fn set_name(mut self, input: ::std::option::Option<crate::types::LambdaFunctionRecommendationFilterName>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the filter.</p>
    /// <p>Specify <code>Finding</code> to return recommendations with a specific finding classification (for example, <code>NotOptimized</code>).</p>
    /// <p>Specify <code>FindingReasonCode</code> to return recommendations with a specific finding reason code (for example, <code>MemoryUnderprovisioned</code>).</p>
    /// <p>You can filter your Lambda function recommendations by <code>tag:key</code> and <code>tag-key</code> tags.</p>
    /// <p>A <code>tag:key</code> is a key and value combination of a tag assigned to your Lambda function recommendations. Use the tag key in the filter name and the tag value as the filter value. For example, to find all Lambda function recommendations that have a tag with the key of <code>Owner</code> and the value of <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
    /// <p>A <code>tag-key</code> is the key of a tag assigned to your Lambda function recommendations. Use this filter to find all of your Lambda function recommendations that have a tag with a specific key. This doesn’t consider the tag value. For example, you can find your Lambda function recommendations with a tag key value of <code>Owner</code> or without any tag keys assigned.</p>
    pub fn get_name(&self) -> &::std::option::Option<crate::types::LambdaFunctionRecommendationFilterName> {
        &self.name
    }
    /// Appends an item to `values`.
    ///
    /// To override the contents of this collection use [`set_values`](Self::set_values).
    ///
    /// <p>The value of the filter.</p>
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p>
    /// <ul>
    /// <li>
    /// <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code> if you specify the <code>name</code> parameter as <code>Finding</code>.</p></li>
    /// <li>
    /// <p>Specify <code>MemoryOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or <code>Inconclusive</code> if you specify the <code>name</code> parameter as <code>FindingReasonCode</code>.</p></li>
    /// </ul>
    pub fn values(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.values.unwrap_or_default();
        v.push(input.into());
        self.values = ::std::option::Option::Some(v);
        self
    }
    /// <p>The value of the filter.</p>
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p>
    /// <ul>
    /// <li>
    /// <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code> if you specify the <code>name</code> parameter as <code>Finding</code>.</p></li>
    /// <li>
    /// <p>Specify <code>MemoryOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or <code>Inconclusive</code> if you specify the <code>name</code> parameter as <code>FindingReasonCode</code>.</p></li>
    /// </ul>
    pub fn set_values(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.values = input;
        self
    }
    /// <p>The value of the filter.</p>
    /// <p>The valid values for this parameter are as follows, depending on what you specify for the <code>name</code> parameter:</p>
    /// <ul>
    /// <li>
    /// <p>Specify <code>Optimized</code>, <code>NotOptimized</code>, or <code>Unavailable</code> if you specify the <code>name</code> parameter as <code>Finding</code>.</p></li>
    /// <li>
    /// <p>Specify <code>MemoryOverprovisioned</code>, <code>MemoryUnderprovisioned</code>, <code>InsufficientData</code>, or <code>Inconclusive</code> if you specify the <code>name</code> parameter as <code>FindingReasonCode</code>.</p></li>
    /// </ul>
    pub fn get_values(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.values
    }
    /// Consumes the builder and constructs a [`LambdaFunctionRecommendationFilter`](crate::types::LambdaFunctionRecommendationFilter).
    pub fn build(self) -> crate::types::LambdaFunctionRecommendationFilter {
        crate::types::LambdaFunctionRecommendationFilter {
            name: self.name,
            values: self.values,
        }
    }
}
