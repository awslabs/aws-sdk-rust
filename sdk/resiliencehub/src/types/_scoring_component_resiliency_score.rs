// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Resiliency score of each scoring component. For more information about scoring component, see <a href="https://docs.aws.amazon.com/resilience-hub/latest/userguide/calculate-score.html">Calculating resiliency score</a>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ScoringComponentResiliencyScore {
    /// <p>Resiliency score of your application.</p>
    pub score: f64,
    /// <p>Maximum possible score that can be obtained for the scoring component. If the <code>Possible score</code> is 20 points, it indicates the maximum possible score you can achieve for your application when you run a new assessment after implementing all the Resilience Hub recommendations.</p>
    pub possible_score: f64,
    /// <p>Number of issues that must be resolved to obtain the maximum possible score for the scoring component. For SOPs, alarms, and FIS experiments, these are the number of recommendations that must be implemented. For compliance, it is the number of Application Components that has breached the resiliency policy.</p>
    /// <p>For example, if the <code>Outstanding count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 5, it indicates that 5 Amazon CloudWatch alarms must be fixed to achieve the maximum possible score.</p>
    pub outstanding_count: i64,
    /// <p>Number of recommendations that were excluded from the assessment.</p>
    /// <p>For example, if the <code>Excluded count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 7, it indicates that 7 Amazon CloudWatch alarms are excluded from the assessment.</p>
    pub excluded_count: i64,
}
impl ScoringComponentResiliencyScore {
    /// <p>Resiliency score of your application.</p>
    pub fn score(&self) -> f64 {
        self.score
    }
    /// <p>Maximum possible score that can be obtained for the scoring component. If the <code>Possible score</code> is 20 points, it indicates the maximum possible score you can achieve for your application when you run a new assessment after implementing all the Resilience Hub recommendations.</p>
    pub fn possible_score(&self) -> f64 {
        self.possible_score
    }
    /// <p>Number of issues that must be resolved to obtain the maximum possible score for the scoring component. For SOPs, alarms, and FIS experiments, these are the number of recommendations that must be implemented. For compliance, it is the number of Application Components that has breached the resiliency policy.</p>
    /// <p>For example, if the <code>Outstanding count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 5, it indicates that 5 Amazon CloudWatch alarms must be fixed to achieve the maximum possible score.</p>
    pub fn outstanding_count(&self) -> i64 {
        self.outstanding_count
    }
    /// <p>Number of recommendations that were excluded from the assessment.</p>
    /// <p>For example, if the <code>Excluded count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 7, it indicates that 7 Amazon CloudWatch alarms are excluded from the assessment.</p>
    pub fn excluded_count(&self) -> i64 {
        self.excluded_count
    }
}
impl ScoringComponentResiliencyScore {
    /// Creates a new builder-style object to manufacture [`ScoringComponentResiliencyScore`](crate::types::ScoringComponentResiliencyScore).
    pub fn builder() -> crate::types::builders::ScoringComponentResiliencyScoreBuilder {
        crate::types::builders::ScoringComponentResiliencyScoreBuilder::default()
    }
}

/// A builder for [`ScoringComponentResiliencyScore`](crate::types::ScoringComponentResiliencyScore).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ScoringComponentResiliencyScoreBuilder {
    pub(crate) score: ::std::option::Option<f64>,
    pub(crate) possible_score: ::std::option::Option<f64>,
    pub(crate) outstanding_count: ::std::option::Option<i64>,
    pub(crate) excluded_count: ::std::option::Option<i64>,
}
impl ScoringComponentResiliencyScoreBuilder {
    /// <p>Resiliency score of your application.</p>
    pub fn score(mut self, input: f64) -> Self {
        self.score = ::std::option::Option::Some(input);
        self
    }
    /// <p>Resiliency score of your application.</p>
    pub fn set_score(mut self, input: ::std::option::Option<f64>) -> Self {
        self.score = input;
        self
    }
    /// <p>Resiliency score of your application.</p>
    pub fn get_score(&self) -> &::std::option::Option<f64> {
        &self.score
    }
    /// <p>Maximum possible score that can be obtained for the scoring component. If the <code>Possible score</code> is 20 points, it indicates the maximum possible score you can achieve for your application when you run a new assessment after implementing all the Resilience Hub recommendations.</p>
    pub fn possible_score(mut self, input: f64) -> Self {
        self.possible_score = ::std::option::Option::Some(input);
        self
    }
    /// <p>Maximum possible score that can be obtained for the scoring component. If the <code>Possible score</code> is 20 points, it indicates the maximum possible score you can achieve for your application when you run a new assessment after implementing all the Resilience Hub recommendations.</p>
    pub fn set_possible_score(mut self, input: ::std::option::Option<f64>) -> Self {
        self.possible_score = input;
        self
    }
    /// <p>Maximum possible score that can be obtained for the scoring component. If the <code>Possible score</code> is 20 points, it indicates the maximum possible score you can achieve for your application when you run a new assessment after implementing all the Resilience Hub recommendations.</p>
    pub fn get_possible_score(&self) -> &::std::option::Option<f64> {
        &self.possible_score
    }
    /// <p>Number of issues that must be resolved to obtain the maximum possible score for the scoring component. For SOPs, alarms, and FIS experiments, these are the number of recommendations that must be implemented. For compliance, it is the number of Application Components that has breached the resiliency policy.</p>
    /// <p>For example, if the <code>Outstanding count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 5, it indicates that 5 Amazon CloudWatch alarms must be fixed to achieve the maximum possible score.</p>
    pub fn outstanding_count(mut self, input: i64) -> Self {
        self.outstanding_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>Number of issues that must be resolved to obtain the maximum possible score for the scoring component. For SOPs, alarms, and FIS experiments, these are the number of recommendations that must be implemented. For compliance, it is the number of Application Components that has breached the resiliency policy.</p>
    /// <p>For example, if the <code>Outstanding count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 5, it indicates that 5 Amazon CloudWatch alarms must be fixed to achieve the maximum possible score.</p>
    pub fn set_outstanding_count(mut self, input: ::std::option::Option<i64>) -> Self {
        self.outstanding_count = input;
        self
    }
    /// <p>Number of issues that must be resolved to obtain the maximum possible score for the scoring component. For SOPs, alarms, and FIS experiments, these are the number of recommendations that must be implemented. For compliance, it is the number of Application Components that has breached the resiliency policy.</p>
    /// <p>For example, if the <code>Outstanding count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 5, it indicates that 5 Amazon CloudWatch alarms must be fixed to achieve the maximum possible score.</p>
    pub fn get_outstanding_count(&self) -> &::std::option::Option<i64> {
        &self.outstanding_count
    }
    /// <p>Number of recommendations that were excluded from the assessment.</p>
    /// <p>For example, if the <code>Excluded count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 7, it indicates that 7 Amazon CloudWatch alarms are excluded from the assessment.</p>
    pub fn excluded_count(mut self, input: i64) -> Self {
        self.excluded_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>Number of recommendations that were excluded from the assessment.</p>
    /// <p>For example, if the <code>Excluded count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 7, it indicates that 7 Amazon CloudWatch alarms are excluded from the assessment.</p>
    pub fn set_excluded_count(mut self, input: ::std::option::Option<i64>) -> Self {
        self.excluded_count = input;
        self
    }
    /// <p>Number of recommendations that were excluded from the assessment.</p>
    /// <p>For example, if the <code>Excluded count</code> for Resilience Hub recommended Amazon CloudWatch alarms is 7, it indicates that 7 Amazon CloudWatch alarms are excluded from the assessment.</p>
    pub fn get_excluded_count(&self) -> &::std::option::Option<i64> {
        &self.excluded_count
    }
    /// Consumes the builder and constructs a [`ScoringComponentResiliencyScore`](crate::types::ScoringComponentResiliencyScore).
    pub fn build(self) -> crate::types::ScoringComponentResiliencyScore {
        crate::types::ScoringComponentResiliencyScore {
            score: self.score.unwrap_or_default(),
            possible_score: self.possible_score.unwrap_or_default(),
            outstanding_count: self.outstanding_count.unwrap_or_default(),
            excluded_count: self.excluded_count.unwrap_or_default(),
        }
    }
}
