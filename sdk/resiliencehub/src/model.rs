// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Defines a resiliency policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResiliencyPolicy {
    /// <p>The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:resiliency-policy/<code>policy-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>The name of the policy</p>
    #[doc(hidden)]
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The description for the policy.</p>
    #[doc(hidden)]
    pub policy_description: std::option::Option<std::string::String>,
    /// <p>Specifies a high-level geographical location constraint for where your resilience policy data can be stored.</p>
    #[doc(hidden)]
    pub data_location_constraint: std::option::Option<crate::model::DataLocationConstraint>,
    /// <p>The tier for this resiliency policy, ranging from the highest severity (<code>MissionCritical</code>) to lowest (<code>NonCritical</code>).</p>
    #[doc(hidden)]
    pub tier: std::option::Option<crate::model::ResiliencyPolicyTier>,
    /// <p>Specifies the estimated cost tier of the resiliency policy.</p>
    #[doc(hidden)]
    pub estimated_cost_tier: std::option::Option<crate::model::EstimatedCostTier>,
    /// <p>The resiliency policy.</p>
    #[doc(hidden)]
    pub policy: std::option::Option<
        std::collections::HashMap<crate::model::DisruptionType, crate::model::FailurePolicy>,
    >,
    /// <p>The timestamp for when the resiliency policy was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ResiliencyPolicy {
    /// <p>The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:resiliency-policy/<code>policy-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn policy_arn(&self) -> std::option::Option<&str> {
        self.policy_arn.as_deref()
    }
    /// <p>The name of the policy</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The description for the policy.</p>
    pub fn policy_description(&self) -> std::option::Option<&str> {
        self.policy_description.as_deref()
    }
    /// <p>Specifies a high-level geographical location constraint for where your resilience policy data can be stored.</p>
    pub fn data_location_constraint(
        &self,
    ) -> std::option::Option<&crate::model::DataLocationConstraint> {
        self.data_location_constraint.as_ref()
    }
    /// <p>The tier for this resiliency policy, ranging from the highest severity (<code>MissionCritical</code>) to lowest (<code>NonCritical</code>).</p>
    pub fn tier(&self) -> std::option::Option<&crate::model::ResiliencyPolicyTier> {
        self.tier.as_ref()
    }
    /// <p>Specifies the estimated cost tier of the resiliency policy.</p>
    pub fn estimated_cost_tier(&self) -> std::option::Option<&crate::model::EstimatedCostTier> {
        self.estimated_cost_tier.as_ref()
    }
    /// <p>The resiliency policy.</p>
    pub fn policy(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::DisruptionType, crate::model::FailurePolicy>,
    > {
        self.policy.as_ref()
    }
    /// <p>The timestamp for when the resiliency policy was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for ResiliencyPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResiliencyPolicy");
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_description", &self.policy_description);
        formatter.field("data_location_constraint", &self.data_location_constraint);
        formatter.field("tier", &self.tier);
        formatter.field("estimated_cost_tier", &self.estimated_cost_tier);
        formatter.field("policy", &self.policy);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl ResiliencyPolicy {
    /// Creates a new builder-style object to manufacture [`ResiliencyPolicy`](crate::model::ResiliencyPolicy).
    pub fn builder() -> crate::model::resiliency_policy::Builder {
        crate::model::resiliency_policy::Builder::default()
    }
}

/// See [`ResiliencyPolicy`](crate::model::ResiliencyPolicy).
pub mod resiliency_policy {

    /// A builder for [`ResiliencyPolicy`](crate::model::ResiliencyPolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_description: std::option::Option<std::string::String>,
        pub(crate) data_location_constraint:
            std::option::Option<crate::model::DataLocationConstraint>,
        pub(crate) tier: std::option::Option<crate::model::ResiliencyPolicyTier>,
        pub(crate) estimated_cost_tier: std::option::Option<crate::model::EstimatedCostTier>,
        pub(crate) policy: std::option::Option<
            std::collections::HashMap<crate::model::DisruptionType, crate::model::FailurePolicy>,
        >,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:resiliency-policy/<code>policy-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:resiliency-policy/<code>policy-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_policy_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = input;
            self
        }
        /// <p>The name of the policy</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the policy</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The description for the policy.</p>
        pub fn policy_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_description = Some(input.into());
            self
        }
        /// <p>The description for the policy.</p>
        pub fn set_policy_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_description = input;
            self
        }
        /// <p>Specifies a high-level geographical location constraint for where your resilience policy data can be stored.</p>
        pub fn data_location_constraint(
            mut self,
            input: crate::model::DataLocationConstraint,
        ) -> Self {
            self.data_location_constraint = Some(input);
            self
        }
        /// <p>Specifies a high-level geographical location constraint for where your resilience policy data can be stored.</p>
        pub fn set_data_location_constraint(
            mut self,
            input: std::option::Option<crate::model::DataLocationConstraint>,
        ) -> Self {
            self.data_location_constraint = input;
            self
        }
        /// <p>The tier for this resiliency policy, ranging from the highest severity (<code>MissionCritical</code>) to lowest (<code>NonCritical</code>).</p>
        pub fn tier(mut self, input: crate::model::ResiliencyPolicyTier) -> Self {
            self.tier = Some(input);
            self
        }
        /// <p>The tier for this resiliency policy, ranging from the highest severity (<code>MissionCritical</code>) to lowest (<code>NonCritical</code>).</p>
        pub fn set_tier(
            mut self,
            input: std::option::Option<crate::model::ResiliencyPolicyTier>,
        ) -> Self {
            self.tier = input;
            self
        }
        /// <p>Specifies the estimated cost tier of the resiliency policy.</p>
        pub fn estimated_cost_tier(mut self, input: crate::model::EstimatedCostTier) -> Self {
            self.estimated_cost_tier = Some(input);
            self
        }
        /// <p>Specifies the estimated cost tier of the resiliency policy.</p>
        pub fn set_estimated_cost_tier(
            mut self,
            input: std::option::Option<crate::model::EstimatedCostTier>,
        ) -> Self {
            self.estimated_cost_tier = input;
            self
        }
        /// Adds a key-value pair to `policy`.
        ///
        /// To override the contents of this collection use [`set_policy`](Self::set_policy).
        ///
        /// <p>The resiliency policy.</p>
        pub fn policy(
            mut self,
            k: crate::model::DisruptionType,
            v: crate::model::FailurePolicy,
        ) -> Self {
            let mut hash_map = self.policy.unwrap_or_default();
            hash_map.insert(k, v);
            self.policy = Some(hash_map);
            self
        }
        /// <p>The resiliency policy.</p>
        pub fn set_policy(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::DisruptionType,
                    crate::model::FailurePolicy,
                >,
            >,
        ) -> Self {
            self.policy = input;
            self
        }
        /// <p>The timestamp for when the resiliency policy was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp for when the resiliency policy was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ResiliencyPolicy`](crate::model::ResiliencyPolicy).
        pub fn build(self) -> crate::model::ResiliencyPolicy {
            crate::model::ResiliencyPolicy {
                policy_arn: self.policy_arn,
                policy_name: self.policy_name,
                policy_description: self.policy_description,
                data_location_constraint: self.data_location_constraint,
                tier: self.tier,
                estimated_cost_tier: self.estimated_cost_tier,
                policy: self.policy,
                creation_time: self.creation_time,
                tags: self.tags,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("policy_arn", &self.policy_arn);
            formatter.field("policy_name", &self.policy_name);
            formatter.field("policy_description", &self.policy_description);
            formatter.field("data_location_constraint", &self.data_location_constraint);
            formatter.field("tier", &self.tier);
            formatter.field("estimated_cost_tier", &self.estimated_cost_tier);
            formatter.field("policy", &self.policy);
            formatter.field("creation_time", &self.creation_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// <p>Defines a failure policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailurePolicy {
    /// <p>The Recovery Time Objective (RTO), in seconds.</p>
    #[doc(hidden)]
    pub rto_in_secs: i32,
    /// <p>The Recovery Point Objective (RPO), in seconds.</p>
    #[doc(hidden)]
    pub rpo_in_secs: i32,
}
impl FailurePolicy {
    /// <p>The Recovery Time Objective (RTO), in seconds.</p>
    pub fn rto_in_secs(&self) -> i32 {
        self.rto_in_secs
    }
    /// <p>The Recovery Point Objective (RPO), in seconds.</p>
    pub fn rpo_in_secs(&self) -> i32 {
        self.rpo_in_secs
    }
}
impl FailurePolicy {
    /// Creates a new builder-style object to manufacture [`FailurePolicy`](crate::model::FailurePolicy).
    pub fn builder() -> crate::model::failure_policy::Builder {
        crate::model::failure_policy::Builder::default()
    }
}

/// See [`FailurePolicy`](crate::model::FailurePolicy).
pub mod failure_policy {

    /// A builder for [`FailurePolicy`](crate::model::FailurePolicy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rto_in_secs: std::option::Option<i32>,
        pub(crate) rpo_in_secs: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Recovery Time Objective (RTO), in seconds.</p>
        pub fn rto_in_secs(mut self, input: i32) -> Self {
            self.rto_in_secs = Some(input);
            self
        }
        /// <p>The Recovery Time Objective (RTO), in seconds.</p>
        pub fn set_rto_in_secs(mut self, input: std::option::Option<i32>) -> Self {
            self.rto_in_secs = input;
            self
        }
        /// <p>The Recovery Point Objective (RPO), in seconds.</p>
        pub fn rpo_in_secs(mut self, input: i32) -> Self {
            self.rpo_in_secs = Some(input);
            self
        }
        /// <p>The Recovery Point Objective (RPO), in seconds.</p>
        pub fn set_rpo_in_secs(mut self, input: std::option::Option<i32>) -> Self {
            self.rpo_in_secs = input;
            self
        }
        /// Consumes the builder and constructs a [`FailurePolicy`](crate::model::FailurePolicy).
        pub fn build(self) -> crate::model::FailurePolicy {
            crate::model::FailurePolicy {
                rto_in_secs: self.rto_in_secs.unwrap_or_default(),
                rpo_in_secs: self.rpo_in_secs.unwrap_or_default(),
            }
        }
    }
}

/// When writing a match expression against `DisruptionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let disruptiontype = unimplemented!();
/// match disruptiontype {
///     DisruptionType::Az => { /* ... */ },
///     DisruptionType::Hardware => { /* ... */ },
///     DisruptionType::Region => { /* ... */ },
///     DisruptionType::Software => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `disruptiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DisruptionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DisruptionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DisruptionType::NewFeature` is defined.
/// Specifically, when `disruptiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DisruptionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DisruptionType {
    #[allow(missing_docs)] // documentation missing in model
    Az,
    #[allow(missing_docs)] // documentation missing in model
    Hardware,
    #[allow(missing_docs)] // documentation missing in model
    Region,
    #[allow(missing_docs)] // documentation missing in model
    Software,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DisruptionType {
    fn from(s: &str) -> Self {
        match s {
            "AZ" => DisruptionType::Az,
            "Hardware" => DisruptionType::Hardware,
            "Region" => DisruptionType::Region,
            "Software" => DisruptionType::Software,
            other => DisruptionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DisruptionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DisruptionType::from(s))
    }
}
impl DisruptionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DisruptionType::Az => "AZ",
            DisruptionType::Hardware => "Hardware",
            DisruptionType::Region => "Region",
            DisruptionType::Software => "Software",
            DisruptionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AZ", "Hardware", "Region", "Software"]
    }
}
impl AsRef<str> for DisruptionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EstimatedCostTier`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let estimatedcosttier = unimplemented!();
/// match estimatedcosttier {
///     EstimatedCostTier::L1 => { /* ... */ },
///     EstimatedCostTier::L2 => { /* ... */ },
///     EstimatedCostTier::L3 => { /* ... */ },
///     EstimatedCostTier::L4 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `estimatedcosttier` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EstimatedCostTier::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EstimatedCostTier::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EstimatedCostTier::NewFeature` is defined.
/// Specifically, when `estimatedcosttier` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EstimatedCostTier::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EstimatedCostTier {
    #[allow(missing_docs)] // documentation missing in model
    L1,
    #[allow(missing_docs)] // documentation missing in model
    L2,
    #[allow(missing_docs)] // documentation missing in model
    L3,
    #[allow(missing_docs)] // documentation missing in model
    L4,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EstimatedCostTier {
    fn from(s: &str) -> Self {
        match s {
            "L1" => EstimatedCostTier::L1,
            "L2" => EstimatedCostTier::L2,
            "L3" => EstimatedCostTier::L3,
            "L4" => EstimatedCostTier::L4,
            other => {
                EstimatedCostTier::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for EstimatedCostTier {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EstimatedCostTier::from(s))
    }
}
impl EstimatedCostTier {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EstimatedCostTier::L1 => "L1",
            EstimatedCostTier::L2 => "L2",
            EstimatedCostTier::L3 => "L3",
            EstimatedCostTier::L4 => "L4",
            EstimatedCostTier::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["L1", "L2", "L3", "L4"]
    }
}
impl AsRef<str> for EstimatedCostTier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResiliencyPolicyTier`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resiliencypolicytier = unimplemented!();
/// match resiliencypolicytier {
///     ResiliencyPolicyTier::CoreServices => { /* ... */ },
///     ResiliencyPolicyTier::Critical => { /* ... */ },
///     ResiliencyPolicyTier::Important => { /* ... */ },
///     ResiliencyPolicyTier::MissionCritical => { /* ... */ },
///     ResiliencyPolicyTier::NonCritical => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resiliencypolicytier` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResiliencyPolicyTier::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResiliencyPolicyTier::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResiliencyPolicyTier::NewFeature` is defined.
/// Specifically, when `resiliencypolicytier` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResiliencyPolicyTier::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResiliencyPolicyTier {
    #[allow(missing_docs)] // documentation missing in model
    CoreServices,
    #[allow(missing_docs)] // documentation missing in model
    Critical,
    #[allow(missing_docs)] // documentation missing in model
    Important,
    #[allow(missing_docs)] // documentation missing in model
    MissionCritical,
    #[allow(missing_docs)] // documentation missing in model
    NonCritical,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResiliencyPolicyTier {
    fn from(s: &str) -> Self {
        match s {
            "CoreServices" => ResiliencyPolicyTier::CoreServices,
            "Critical" => ResiliencyPolicyTier::Critical,
            "Important" => ResiliencyPolicyTier::Important,
            "MissionCritical" => ResiliencyPolicyTier::MissionCritical,
            "NonCritical" => ResiliencyPolicyTier::NonCritical,
            other => {
                ResiliencyPolicyTier::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ResiliencyPolicyTier {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResiliencyPolicyTier::from(s))
    }
}
impl ResiliencyPolicyTier {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResiliencyPolicyTier::CoreServices => "CoreServices",
            ResiliencyPolicyTier::Critical => "Critical",
            ResiliencyPolicyTier::Important => "Important",
            ResiliencyPolicyTier::MissionCritical => "MissionCritical",
            ResiliencyPolicyTier::NonCritical => "NonCritical",
            ResiliencyPolicyTier::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CoreServices",
            "Critical",
            "Important",
            "MissionCritical",
            "NonCritical",
        ]
    }
}
impl AsRef<str> for ResiliencyPolicyTier {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataLocationConstraint`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datalocationconstraint = unimplemented!();
/// match datalocationconstraint {
///     DataLocationConstraint::AnyLocation => { /* ... */ },
///     DataLocationConstraint::SameContinent => { /* ... */ },
///     DataLocationConstraint::SameCountry => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datalocationconstraint` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataLocationConstraint::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataLocationConstraint::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataLocationConstraint::NewFeature` is defined.
/// Specifically, when `datalocationconstraint` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataLocationConstraint::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataLocationConstraint {
    #[allow(missing_docs)] // documentation missing in model
    AnyLocation,
    #[allow(missing_docs)] // documentation missing in model
    SameContinent,
    #[allow(missing_docs)] // documentation missing in model
    SameCountry,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataLocationConstraint {
    fn from(s: &str) -> Self {
        match s {
            "AnyLocation" => DataLocationConstraint::AnyLocation,
            "SameContinent" => DataLocationConstraint::SameContinent,
            "SameCountry" => DataLocationConstraint::SameCountry,
            other => {
                DataLocationConstraint::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DataLocationConstraint {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataLocationConstraint::from(s))
    }
}
impl DataLocationConstraint {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataLocationConstraint::AnyLocation => "AnyLocation",
            DataLocationConstraint::SameContinent => "SameContinent",
            DataLocationConstraint::SameCountry => "SameCountry",
            DataLocationConstraint::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AnyLocation", "SameContinent", "SameCountry"]
    }
}
impl AsRef<str> for DataLocationConstraint {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines a Resilience Hub application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct App {
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub app_arn: std::option::Option<std::string::String>,
    /// <p>The name for the application.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The optional description for an app.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:resiliency-policy/<code>policy-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>The timestamp for when the app was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the application.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AppStatusType>,
    /// <p>The current status of compliance for the resiliency policy.</p>
    #[doc(hidden)]
    pub compliance_status: std::option::Option<crate::model::AppComplianceStatusType>,
    /// <p>The timestamp for the most recent compliance evaluation.</p>
    #[doc(hidden)]
    pub last_app_compliance_evaluation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current resiliency score for the application.</p>
    #[doc(hidden)]
    pub resiliency_score: f64,
    /// <p>The timestamp for the most recent resiliency score evaluation.</p>
    #[doc(hidden)]
    pub last_resiliency_score_evaluation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p> Assessment execution schedule with 'Daily' or 'Disabled' values. </p>
    #[doc(hidden)]
    pub assessment_schedule: std::option::Option<crate::model::AppAssessmentScheduleType>,
}
impl App {
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn app_arn(&self) -> std::option::Option<&str> {
        self.app_arn.as_deref()
    }
    /// <p>The name for the application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The optional description for an app.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:resiliency-policy/<code>policy-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn policy_arn(&self) -> std::option::Option<&str> {
        self.policy_arn.as_deref()
    }
    /// <p>The timestamp for when the app was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The status of the application.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AppStatusType> {
        self.status.as_ref()
    }
    /// <p>The current status of compliance for the resiliency policy.</p>
    pub fn compliance_status(&self) -> std::option::Option<&crate::model::AppComplianceStatusType> {
        self.compliance_status.as_ref()
    }
    /// <p>The timestamp for the most recent compliance evaluation.</p>
    pub fn last_app_compliance_evaluation_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_app_compliance_evaluation_time.as_ref()
    }
    /// <p>The current resiliency score for the application.</p>
    pub fn resiliency_score(&self) -> f64 {
        self.resiliency_score
    }
    /// <p>The timestamp for the most recent resiliency score evaluation.</p>
    pub fn last_resiliency_score_evaluation_time(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_resiliency_score_evaluation_time.as_ref()
    }
    /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p> Assessment execution schedule with 'Daily' or 'Disabled' values. </p>
    pub fn assessment_schedule(
        &self,
    ) -> std::option::Option<&crate::model::AppAssessmentScheduleType> {
        self.assessment_schedule.as_ref()
    }
}
impl std::fmt::Debug for App {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("App");
        formatter.field("app_arn", &self.app_arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("status", &self.status);
        formatter.field("compliance_status", &self.compliance_status);
        formatter.field(
            "last_app_compliance_evaluation_time",
            &self.last_app_compliance_evaluation_time,
        );
        formatter.field("resiliency_score", &self.resiliency_score);
        formatter.field(
            "last_resiliency_score_evaluation_time",
            &self.last_resiliency_score_evaluation_time,
        );
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("assessment_schedule", &self.assessment_schedule);
        formatter.finish()
    }
}
impl App {
    /// Creates a new builder-style object to manufacture [`App`](crate::model::App).
    pub fn builder() -> crate::model::app::Builder {
        crate::model::app::Builder::default()
    }
}

/// See [`App`](crate::model::App).
pub mod app {

    /// A builder for [`App`](crate::model::App).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) app_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::AppStatusType>,
        pub(crate) compliance_status: std::option::Option<crate::model::AppComplianceStatusType>,
        pub(crate) last_app_compliance_evaluation_time:
            std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) resiliency_score: std::option::Option<f64>,
        pub(crate) last_resiliency_score_evaluation_time:
            std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) assessment_schedule:
            std::option::Option<crate::model::AppAssessmentScheduleType>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn app_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_app_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_arn = input;
            self
        }
        /// <p>The name for the application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The optional description for an app.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The optional description for an app.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:resiliency-policy/<code>policy-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:resiliency-policy/<code>policy-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_policy_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = input;
            self
        }
        /// <p>The timestamp for when the app was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp for when the app was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The status of the application.</p>
        pub fn status(mut self, input: crate::model::AppStatusType) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the application.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AppStatusType>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The current status of compliance for the resiliency policy.</p>
        pub fn compliance_status(mut self, input: crate::model::AppComplianceStatusType) -> Self {
            self.compliance_status = Some(input);
            self
        }
        /// <p>The current status of compliance for the resiliency policy.</p>
        pub fn set_compliance_status(
            mut self,
            input: std::option::Option<crate::model::AppComplianceStatusType>,
        ) -> Self {
            self.compliance_status = input;
            self
        }
        /// <p>The timestamp for the most recent compliance evaluation.</p>
        pub fn last_app_compliance_evaluation_time(
            mut self,
            input: aws_smithy_types::DateTime,
        ) -> Self {
            self.last_app_compliance_evaluation_time = Some(input);
            self
        }
        /// <p>The timestamp for the most recent compliance evaluation.</p>
        pub fn set_last_app_compliance_evaluation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_app_compliance_evaluation_time = input;
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn resiliency_score(mut self, input: f64) -> Self {
            self.resiliency_score = Some(input);
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn set_resiliency_score(mut self, input: std::option::Option<f64>) -> Self {
            self.resiliency_score = input;
            self
        }
        /// <p>The timestamp for the most recent resiliency score evaluation.</p>
        pub fn last_resiliency_score_evaluation_time(
            mut self,
            input: aws_smithy_types::DateTime,
        ) -> Self {
            self.last_resiliency_score_evaluation_time = Some(input);
            self
        }
        /// <p>The timestamp for the most recent resiliency score evaluation.</p>
        pub fn set_last_resiliency_score_evaluation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_resiliency_score_evaluation_time = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p> Assessment execution schedule with 'Daily' or 'Disabled' values. </p>
        pub fn assessment_schedule(
            mut self,
            input: crate::model::AppAssessmentScheduleType,
        ) -> Self {
            self.assessment_schedule = Some(input);
            self
        }
        /// <p> Assessment execution schedule with 'Daily' or 'Disabled' values. </p>
        pub fn set_assessment_schedule(
            mut self,
            input: std::option::Option<crate::model::AppAssessmentScheduleType>,
        ) -> Self {
            self.assessment_schedule = input;
            self
        }
        /// Consumes the builder and constructs a [`App`](crate::model::App).
        pub fn build(self) -> crate::model::App {
            crate::model::App {
                app_arn: self.app_arn,
                name: self.name,
                description: self.description,
                policy_arn: self.policy_arn,
                creation_time: self.creation_time,
                status: self.status,
                compliance_status: self.compliance_status,
                last_app_compliance_evaluation_time: self.last_app_compliance_evaluation_time,
                resiliency_score: self.resiliency_score.unwrap_or_default(),
                last_resiliency_score_evaluation_time: self.last_resiliency_score_evaluation_time,
                tags: self.tags,
                assessment_schedule: self.assessment_schedule,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("app_arn", &self.app_arn);
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("policy_arn", &self.policy_arn);
            formatter.field("creation_time", &self.creation_time);
            formatter.field("status", &self.status);
            formatter.field("compliance_status", &self.compliance_status);
            formatter.field(
                "last_app_compliance_evaluation_time",
                &self.last_app_compliance_evaluation_time,
            );
            formatter.field("resiliency_score", &self.resiliency_score);
            formatter.field(
                "last_resiliency_score_evaluation_time",
                &self.last_resiliency_score_evaluation_time,
            );
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("assessment_schedule", &self.assessment_schedule);
            formatter.finish()
        }
    }
}

/// When writing a match expression against `AppAssessmentScheduleType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let appassessmentscheduletype = unimplemented!();
/// match appassessmentscheduletype {
///     AppAssessmentScheduleType::Daily => { /* ... */ },
///     AppAssessmentScheduleType::Disabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `appassessmentscheduletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AppAssessmentScheduleType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AppAssessmentScheduleType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AppAssessmentScheduleType::NewFeature` is defined.
/// Specifically, when `appassessmentscheduletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AppAssessmentScheduleType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppAssessmentScheduleType {
    #[allow(missing_docs)] // documentation missing in model
    Daily,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AppAssessmentScheduleType {
    fn from(s: &str) -> Self {
        match s {
            "Daily" => AppAssessmentScheduleType::Daily,
            "Disabled" => AppAssessmentScheduleType::Disabled,
            other => AppAssessmentScheduleType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AppAssessmentScheduleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppAssessmentScheduleType::from(s))
    }
}
impl AppAssessmentScheduleType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppAssessmentScheduleType::Daily => "Daily",
            AppAssessmentScheduleType::Disabled => "Disabled",
            AppAssessmentScheduleType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Daily", "Disabled"]
    }
}
impl AsRef<str> for AppAssessmentScheduleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AppComplianceStatusType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let appcompliancestatustype = unimplemented!();
/// match appcompliancestatustype {
///     AppComplianceStatusType::ChangesDetected => { /* ... */ },
///     AppComplianceStatusType::NotAssessed => { /* ... */ },
///     AppComplianceStatusType::PolicyBreached => { /* ... */ },
///     AppComplianceStatusType::PolicyMet => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `appcompliancestatustype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AppComplianceStatusType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AppComplianceStatusType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AppComplianceStatusType::NewFeature` is defined.
/// Specifically, when `appcompliancestatustype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AppComplianceStatusType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppComplianceStatusType {
    #[allow(missing_docs)] // documentation missing in model
    ChangesDetected,
    #[allow(missing_docs)] // documentation missing in model
    NotAssessed,
    #[allow(missing_docs)] // documentation missing in model
    PolicyBreached,
    #[allow(missing_docs)] // documentation missing in model
    PolicyMet,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AppComplianceStatusType {
    fn from(s: &str) -> Self {
        match s {
            "ChangesDetected" => AppComplianceStatusType::ChangesDetected,
            "NotAssessed" => AppComplianceStatusType::NotAssessed,
            "PolicyBreached" => AppComplianceStatusType::PolicyBreached,
            "PolicyMet" => AppComplianceStatusType::PolicyMet,
            other => AppComplianceStatusType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AppComplianceStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppComplianceStatusType::from(s))
    }
}
impl AppComplianceStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppComplianceStatusType::ChangesDetected => "ChangesDetected",
            AppComplianceStatusType::NotAssessed => "NotAssessed",
            AppComplianceStatusType::PolicyBreached => "PolicyBreached",
            AppComplianceStatusType::PolicyMet => "PolicyMet",
            AppComplianceStatusType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ChangesDetected",
            "NotAssessed",
            "PolicyBreached",
            "PolicyMet",
        ]
    }
}
impl AsRef<str> for AppComplianceStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AppStatusType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let appstatustype = unimplemented!();
/// match appstatustype {
///     AppStatusType::Active => { /* ... */ },
///     AppStatusType::Deleting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `appstatustype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AppStatusType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AppStatusType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AppStatusType::NewFeature` is defined.
/// Specifically, when `appstatustype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AppStatusType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AppStatusType {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AppStatusType {
    fn from(s: &str) -> Self {
        match s {
            "Active" => AppStatusType::Active,
            "Deleting" => AppStatusType::Deleting,
            other => AppStatusType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AppStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AppStatusType::from(s))
    }
}
impl AppStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AppStatusType::Active => "Active",
            AppStatusType::Deleting => "Deleting",
            AppStatusType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Active", "Deleting"]
    }
}
impl AsRef<str> for AppStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines an application assessment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AppAssessment {
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub app_arn: std::option::Option<std::string::String>,
    /// <p>The version of the application.</p>
    #[doc(hidden)]
    pub app_version: std::option::Option<std::string::String>,
    /// <p>The entity that invoked the assessment.</p>
    #[doc(hidden)]
    pub invoker: std::option::Option<crate::model::AssessmentInvoker>,
    /// <p>The cost for the application.</p>
    #[doc(hidden)]
    pub cost: std::option::Option<crate::model::Cost>,
    /// <p>The current resiliency score for the application.</p>
    #[doc(hidden)]
    pub resiliency_score: std::option::Option<crate::model::ResiliencyScore>,
    /// <p>The application compliance against the resiliency policy.</p>
    #[doc(hidden)]
    pub compliance: std::option::Option<
        std::collections::HashMap<crate::model::DisruptionType, crate::model::DisruptionCompliance>,
    >,
    /// <p>The current status of the compliance for the resiliency policy.</p>
    #[doc(hidden)]
    pub compliance_status: std::option::Option<crate::model::ComplianceStatus>,
    /// <p>The current status of the assessment for the resiliency policy.</p>
    #[doc(hidden)]
    pub assessment_status: std::option::Option<crate::model::AssessmentStatus>,
    /// <p>The starting time for the action.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end time for the action.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Error or warning message from the assessment execution</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The name of the assessment.</p>
    #[doc(hidden)]
    pub assessment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub assessment_arn: std::option::Option<std::string::String>,
    /// <p>The resiliency policy.</p>
    #[doc(hidden)]
    pub policy: std::option::Option<crate::model::ResiliencyPolicy>,
    /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p> A resource error object containing a list of errors retrieving an application's resources. </p>
    #[doc(hidden)]
    pub resource_errors_details: std::option::Option<crate::model::ResourceErrorsDetails>,
}
impl AppAssessment {
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn app_arn(&self) -> std::option::Option<&str> {
        self.app_arn.as_deref()
    }
    /// <p>The version of the application.</p>
    pub fn app_version(&self) -> std::option::Option<&str> {
        self.app_version.as_deref()
    }
    /// <p>The entity that invoked the assessment.</p>
    pub fn invoker(&self) -> std::option::Option<&crate::model::AssessmentInvoker> {
        self.invoker.as_ref()
    }
    /// <p>The cost for the application.</p>
    pub fn cost(&self) -> std::option::Option<&crate::model::Cost> {
        self.cost.as_ref()
    }
    /// <p>The current resiliency score for the application.</p>
    pub fn resiliency_score(&self) -> std::option::Option<&crate::model::ResiliencyScore> {
        self.resiliency_score.as_ref()
    }
    /// <p>The application compliance against the resiliency policy.</p>
    pub fn compliance(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            crate::model::DisruptionType,
            crate::model::DisruptionCompliance,
        >,
    > {
        self.compliance.as_ref()
    }
    /// <p>The current status of the compliance for the resiliency policy.</p>
    pub fn compliance_status(&self) -> std::option::Option<&crate::model::ComplianceStatus> {
        self.compliance_status.as_ref()
    }
    /// <p>The current status of the assessment for the resiliency policy.</p>
    pub fn assessment_status(&self) -> std::option::Option<&crate::model::AssessmentStatus> {
        self.assessment_status.as_ref()
    }
    /// <p>The starting time for the action.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The end time for the action.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>Error or warning message from the assessment execution</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The name of the assessment.</p>
    pub fn assessment_name(&self) -> std::option::Option<&str> {
        self.assessment_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn assessment_arn(&self) -> std::option::Option<&str> {
        self.assessment_arn.as_deref()
    }
    /// <p>The resiliency policy.</p>
    pub fn policy(&self) -> std::option::Option<&crate::model::ResiliencyPolicy> {
        self.policy.as_ref()
    }
    /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p> A resource error object containing a list of errors retrieving an application's resources. </p>
    pub fn resource_errors_details(
        &self,
    ) -> std::option::Option<&crate::model::ResourceErrorsDetails> {
        self.resource_errors_details.as_ref()
    }
}
impl std::fmt::Debug for AppAssessment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AppAssessment");
        formatter.field("app_arn", &self.app_arn);
        formatter.field("app_version", &self.app_version);
        formatter.field("invoker", &self.invoker);
        formatter.field("cost", &self.cost);
        formatter.field("resiliency_score", &self.resiliency_score);
        formatter.field("compliance", &self.compliance);
        formatter.field("compliance_status", &self.compliance_status);
        formatter.field("assessment_status", &self.assessment_status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("message", &self.message);
        formatter.field("assessment_name", &self.assessment_name);
        formatter.field("assessment_arn", &self.assessment_arn);
        formatter.field("policy", &self.policy);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("resource_errors_details", &self.resource_errors_details);
        formatter.finish()
    }
}
impl AppAssessment {
    /// Creates a new builder-style object to manufacture [`AppAssessment`](crate::model::AppAssessment).
    pub fn builder() -> crate::model::app_assessment::Builder {
        crate::model::app_assessment::Builder::default()
    }
}

/// See [`AppAssessment`](crate::model::AppAssessment).
pub mod app_assessment {

    /// A builder for [`AppAssessment`](crate::model::AppAssessment).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) app_arn: std::option::Option<std::string::String>,
        pub(crate) app_version: std::option::Option<std::string::String>,
        pub(crate) invoker: std::option::Option<crate::model::AssessmentInvoker>,
        pub(crate) cost: std::option::Option<crate::model::Cost>,
        pub(crate) resiliency_score: std::option::Option<crate::model::ResiliencyScore>,
        pub(crate) compliance: std::option::Option<
            std::collections::HashMap<
                crate::model::DisruptionType,
                crate::model::DisruptionCompliance,
            >,
        >,
        pub(crate) compliance_status: std::option::Option<crate::model::ComplianceStatus>,
        pub(crate) assessment_status: std::option::Option<crate::model::AssessmentStatus>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) assessment_name: std::option::Option<std::string::String>,
        pub(crate) assessment_arn: std::option::Option<std::string::String>,
        pub(crate) policy: std::option::Option<crate::model::ResiliencyPolicy>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) resource_errors_details:
            std::option::Option<crate::model::ResourceErrorsDetails>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn app_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_app_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_arn = input;
            self
        }
        /// <p>The version of the application.</p>
        pub fn app_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_version = Some(input.into());
            self
        }
        /// <p>The version of the application.</p>
        pub fn set_app_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_version = input;
            self
        }
        /// <p>The entity that invoked the assessment.</p>
        pub fn invoker(mut self, input: crate::model::AssessmentInvoker) -> Self {
            self.invoker = Some(input);
            self
        }
        /// <p>The entity that invoked the assessment.</p>
        pub fn set_invoker(
            mut self,
            input: std::option::Option<crate::model::AssessmentInvoker>,
        ) -> Self {
            self.invoker = input;
            self
        }
        /// <p>The cost for the application.</p>
        pub fn cost(mut self, input: crate::model::Cost) -> Self {
            self.cost = Some(input);
            self
        }
        /// <p>The cost for the application.</p>
        pub fn set_cost(mut self, input: std::option::Option<crate::model::Cost>) -> Self {
            self.cost = input;
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn resiliency_score(mut self, input: crate::model::ResiliencyScore) -> Self {
            self.resiliency_score = Some(input);
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn set_resiliency_score(
            mut self,
            input: std::option::Option<crate::model::ResiliencyScore>,
        ) -> Self {
            self.resiliency_score = input;
            self
        }
        /// Adds a key-value pair to `compliance`.
        ///
        /// To override the contents of this collection use [`set_compliance`](Self::set_compliance).
        ///
        /// <p>The application compliance against the resiliency policy.</p>
        pub fn compliance(
            mut self,
            k: crate::model::DisruptionType,
            v: crate::model::DisruptionCompliance,
        ) -> Self {
            let mut hash_map = self.compliance.unwrap_or_default();
            hash_map.insert(k, v);
            self.compliance = Some(hash_map);
            self
        }
        /// <p>The application compliance against the resiliency policy.</p>
        pub fn set_compliance(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::DisruptionType,
                    crate::model::DisruptionCompliance,
                >,
            >,
        ) -> Self {
            self.compliance = input;
            self
        }
        /// <p>The current status of the compliance for the resiliency policy.</p>
        pub fn compliance_status(mut self, input: crate::model::ComplianceStatus) -> Self {
            self.compliance_status = Some(input);
            self
        }
        /// <p>The current status of the compliance for the resiliency policy.</p>
        pub fn set_compliance_status(
            mut self,
            input: std::option::Option<crate::model::ComplianceStatus>,
        ) -> Self {
            self.compliance_status = input;
            self
        }
        /// <p>The current status of the assessment for the resiliency policy.</p>
        pub fn assessment_status(mut self, input: crate::model::AssessmentStatus) -> Self {
            self.assessment_status = Some(input);
            self
        }
        /// <p>The current status of the assessment for the resiliency policy.</p>
        pub fn set_assessment_status(
            mut self,
            input: std::option::Option<crate::model::AssessmentStatus>,
        ) -> Self {
            self.assessment_status = input;
            self
        }
        /// <p>The starting time for the action.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The starting time for the action.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time for the action.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time for the action.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Error or warning message from the assessment execution</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Error or warning message from the assessment execution</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The name of the assessment.</p>
        pub fn assessment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_name = Some(input.into());
            self
        }
        /// <p>The name of the assessment.</p>
        pub fn set_assessment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn assessment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_assessment_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_arn = input;
            self
        }
        /// <p>The resiliency policy.</p>
        pub fn policy(mut self, input: crate::model::ResiliencyPolicy) -> Self {
            self.policy = Some(input);
            self
        }
        /// <p>The resiliency policy.</p>
        pub fn set_policy(
            mut self,
            input: std::option::Option<crate::model::ResiliencyPolicy>,
        ) -> Self {
            self.policy = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p> A resource error object containing a list of errors retrieving an application's resources. </p>
        pub fn resource_errors_details(
            mut self,
            input: crate::model::ResourceErrorsDetails,
        ) -> Self {
            self.resource_errors_details = Some(input);
            self
        }
        /// <p> A resource error object containing a list of errors retrieving an application's resources. </p>
        pub fn set_resource_errors_details(
            mut self,
            input: std::option::Option<crate::model::ResourceErrorsDetails>,
        ) -> Self {
            self.resource_errors_details = input;
            self
        }
        /// Consumes the builder and constructs a [`AppAssessment`](crate::model::AppAssessment).
        pub fn build(self) -> crate::model::AppAssessment {
            crate::model::AppAssessment {
                app_arn: self.app_arn,
                app_version: self.app_version,
                invoker: self.invoker,
                cost: self.cost,
                resiliency_score: self.resiliency_score,
                compliance: self.compliance,
                compliance_status: self.compliance_status,
                assessment_status: self.assessment_status,
                start_time: self.start_time,
                end_time: self.end_time,
                message: self.message,
                assessment_name: self.assessment_name,
                assessment_arn: self.assessment_arn,
                policy: self.policy,
                tags: self.tags,
                resource_errors_details: self.resource_errors_details,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("app_arn", &self.app_arn);
            formatter.field("app_version", &self.app_version);
            formatter.field("invoker", &self.invoker);
            formatter.field("cost", &self.cost);
            formatter.field("resiliency_score", &self.resiliency_score);
            formatter.field("compliance", &self.compliance);
            formatter.field("compliance_status", &self.compliance_status);
            formatter.field("assessment_status", &self.assessment_status);
            formatter.field("start_time", &self.start_time);
            formatter.field("end_time", &self.end_time);
            formatter.field("message", &self.message);
            formatter.field("assessment_name", &self.assessment_name);
            formatter.field("assessment_arn", &self.assessment_arn);
            formatter.field("policy", &self.policy);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("resource_errors_details", &self.resource_errors_details);
            formatter.finish()
        }
    }
}

/// <p> A list of errors retrieving an application's resources. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceErrorsDetails {
    /// <p> A list of errors retrieving an application's resources. </p>
    #[doc(hidden)]
    pub resource_errors: std::option::Option<std::vec::Vec<crate::model::ResourceError>>,
    /// <p> This indicates if there are more errors not listed in the resourceErrors list. </p>
    #[doc(hidden)]
    pub has_more_errors: std::option::Option<bool>,
}
impl ResourceErrorsDetails {
    /// <p> A list of errors retrieving an application's resources. </p>
    pub fn resource_errors(&self) -> std::option::Option<&[crate::model::ResourceError]> {
        self.resource_errors.as_deref()
    }
    /// <p> This indicates if there are more errors not listed in the resourceErrors list. </p>
    pub fn has_more_errors(&self) -> std::option::Option<bool> {
        self.has_more_errors
    }
}
impl ResourceErrorsDetails {
    /// Creates a new builder-style object to manufacture [`ResourceErrorsDetails`](crate::model::ResourceErrorsDetails).
    pub fn builder() -> crate::model::resource_errors_details::Builder {
        crate::model::resource_errors_details::Builder::default()
    }
}

/// See [`ResourceErrorsDetails`](crate::model::ResourceErrorsDetails).
pub mod resource_errors_details {

    /// A builder for [`ResourceErrorsDetails`](crate::model::ResourceErrorsDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_errors: std::option::Option<std::vec::Vec<crate::model::ResourceError>>,
        pub(crate) has_more_errors: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `resource_errors`.
        ///
        /// To override the contents of this collection use [`set_resource_errors`](Self::set_resource_errors).
        ///
        /// <p> A list of errors retrieving an application's resources. </p>
        pub fn resource_errors(mut self, input: crate::model::ResourceError) -> Self {
            let mut v = self.resource_errors.unwrap_or_default();
            v.push(input);
            self.resource_errors = Some(v);
            self
        }
        /// <p> A list of errors retrieving an application's resources. </p>
        pub fn set_resource_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceError>>,
        ) -> Self {
            self.resource_errors = input;
            self
        }
        /// <p> This indicates if there are more errors not listed in the resourceErrors list. </p>
        pub fn has_more_errors(mut self, input: bool) -> Self {
            self.has_more_errors = Some(input);
            self
        }
        /// <p> This indicates if there are more errors not listed in the resourceErrors list. </p>
        pub fn set_has_more_errors(mut self, input: std::option::Option<bool>) -> Self {
            self.has_more_errors = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceErrorsDetails`](crate::model::ResourceErrorsDetails).
        pub fn build(self) -> crate::model::ResourceErrorsDetails {
            crate::model::ResourceErrorsDetails {
                resource_errors: self.resource_errors,
                has_more_errors: self.has_more_errors,
            }
        }
    }
}

/// <p> Defines application resource errors. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceError {
    /// <p> This is the identifier of the resource. </p>
    #[doc(hidden)]
    pub logical_resource_id: std::option::Option<std::string::String>,
    /// <p> This is the identifier of the physical resource. </p>
    #[doc(hidden)]
    pub physical_resource_id: std::option::Option<std::string::String>,
    /// <p> This is the error message. </p>
    #[doc(hidden)]
    pub reason: std::option::Option<std::string::String>,
}
impl ResourceError {
    /// <p> This is the identifier of the resource. </p>
    pub fn logical_resource_id(&self) -> std::option::Option<&str> {
        self.logical_resource_id.as_deref()
    }
    /// <p> This is the identifier of the physical resource. </p>
    pub fn physical_resource_id(&self) -> std::option::Option<&str> {
        self.physical_resource_id.as_deref()
    }
    /// <p> This is the error message. </p>
    pub fn reason(&self) -> std::option::Option<&str> {
        self.reason.as_deref()
    }
}
impl ResourceError {
    /// Creates a new builder-style object to manufacture [`ResourceError`](crate::model::ResourceError).
    pub fn builder() -> crate::model::resource_error::Builder {
        crate::model::resource_error::Builder::default()
    }
}

/// See [`ResourceError`](crate::model::ResourceError).
pub mod resource_error {

    /// A builder for [`ResourceError`](crate::model::ResourceError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logical_resource_id: std::option::Option<std::string::String>,
        pub(crate) physical_resource_id: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> This is the identifier of the resource. </p>
        pub fn logical_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.logical_resource_id = Some(input.into());
            self
        }
        /// <p> This is the identifier of the resource. </p>
        pub fn set_logical_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_resource_id = input;
            self
        }
        /// <p> This is the identifier of the physical resource. </p>
        pub fn physical_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.physical_resource_id = Some(input.into());
            self
        }
        /// <p> This is the identifier of the physical resource. </p>
        pub fn set_physical_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.physical_resource_id = input;
            self
        }
        /// <p> This is the error message. </p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason = Some(input.into());
            self
        }
        /// <p> This is the error message. </p>
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceError`](crate::model::ResourceError).
        pub fn build(self) -> crate::model::ResourceError {
            crate::model::ResourceError {
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                reason: self.reason,
            }
        }
    }
}

/// When writing a match expression against `AssessmentStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assessmentstatus = unimplemented!();
/// match assessmentstatus {
///     AssessmentStatus::Failed => { /* ... */ },
///     AssessmentStatus::Inprogress => { /* ... */ },
///     AssessmentStatus::Pending => { /* ... */ },
///     AssessmentStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assessmentstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssessmentStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssessmentStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssessmentStatus::NewFeature` is defined.
/// Specifically, when `assessmentstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssessmentStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssessmentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Inprogress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssessmentStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => AssessmentStatus::Failed,
            "InProgress" => AssessmentStatus::Inprogress,
            "Pending" => AssessmentStatus::Pending,
            "Success" => AssessmentStatus::Success,
            other => AssessmentStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssessmentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssessmentStatus::from(s))
    }
}
impl AssessmentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssessmentStatus::Failed => "Failed",
            AssessmentStatus::Inprogress => "InProgress",
            AssessmentStatus::Pending => "Pending",
            AssessmentStatus::Success => "Success",
            AssessmentStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Failed", "InProgress", "Pending", "Success"]
    }
}
impl AsRef<str> for AssessmentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ComplianceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let compliancestatus = unimplemented!();
/// match compliancestatus {
///     ComplianceStatus::PolicyBreached => { /* ... */ },
///     ComplianceStatus::PolicyMet => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `compliancestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ComplianceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ComplianceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ComplianceStatus::NewFeature` is defined.
/// Specifically, when `compliancestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ComplianceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComplianceStatus {
    #[allow(missing_docs)] // documentation missing in model
    PolicyBreached,
    #[allow(missing_docs)] // documentation missing in model
    PolicyMet,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ComplianceStatus {
    fn from(s: &str) -> Self {
        match s {
            "PolicyBreached" => ComplianceStatus::PolicyBreached,
            "PolicyMet" => ComplianceStatus::PolicyMet,
            other => ComplianceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ComplianceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ComplianceStatus::from(s))
    }
}
impl ComplianceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ComplianceStatus::PolicyBreached => "PolicyBreached",
            ComplianceStatus::PolicyMet => "PolicyMet",
            ComplianceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PolicyBreached", "PolicyMet"]
    }
}
impl AsRef<str> for ComplianceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines the compliance against the resiliency policy for a disruption.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisruptionCompliance {
    /// <p>The Recovery Time Objective (RTO) that is achievable, in seconds</p>
    #[doc(hidden)]
    pub achievable_rto_in_secs: i32,
    /// <p>The current RTO, in seconds.</p>
    #[doc(hidden)]
    pub current_rto_in_secs: i32,
    /// <p>The RTO reference identifier.</p>
    #[doc(hidden)]
    pub rto_reference_id: std::option::Option<std::string::String>,
    /// <p>The RTO description.</p>
    #[doc(hidden)]
    pub rto_description: std::option::Option<std::string::String>,
    /// <p>The current RPO, in seconds.</p>
    #[doc(hidden)]
    pub current_rpo_in_secs: i32,
    /// <p>The RPO reference identifier.</p>
    #[doc(hidden)]
    pub rpo_reference_id: std::option::Option<std::string::String>,
    /// <p>The RPO description.</p>
    #[doc(hidden)]
    pub rpo_description: std::option::Option<std::string::String>,
    /// <p>The current status of compliance for the resiliency policy.</p>
    #[doc(hidden)]
    pub compliance_status: std::option::Option<crate::model::ComplianceStatus>,
    /// <p>The Recovery Point Objective (RPO) that is achievable, in seconds.</p>
    #[doc(hidden)]
    pub achievable_rpo_in_secs: i32,
    /// <p>The disruption compliance message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl DisruptionCompliance {
    /// <p>The Recovery Time Objective (RTO) that is achievable, in seconds</p>
    pub fn achievable_rto_in_secs(&self) -> i32 {
        self.achievable_rto_in_secs
    }
    /// <p>The current RTO, in seconds.</p>
    pub fn current_rto_in_secs(&self) -> i32 {
        self.current_rto_in_secs
    }
    /// <p>The RTO reference identifier.</p>
    pub fn rto_reference_id(&self) -> std::option::Option<&str> {
        self.rto_reference_id.as_deref()
    }
    /// <p>The RTO description.</p>
    pub fn rto_description(&self) -> std::option::Option<&str> {
        self.rto_description.as_deref()
    }
    /// <p>The current RPO, in seconds.</p>
    pub fn current_rpo_in_secs(&self) -> i32 {
        self.current_rpo_in_secs
    }
    /// <p>The RPO reference identifier.</p>
    pub fn rpo_reference_id(&self) -> std::option::Option<&str> {
        self.rpo_reference_id.as_deref()
    }
    /// <p>The RPO description.</p>
    pub fn rpo_description(&self) -> std::option::Option<&str> {
        self.rpo_description.as_deref()
    }
    /// <p>The current status of compliance for the resiliency policy.</p>
    pub fn compliance_status(&self) -> std::option::Option<&crate::model::ComplianceStatus> {
        self.compliance_status.as_ref()
    }
    /// <p>The Recovery Point Objective (RPO) that is achievable, in seconds.</p>
    pub fn achievable_rpo_in_secs(&self) -> i32 {
        self.achievable_rpo_in_secs
    }
    /// <p>The disruption compliance message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl DisruptionCompliance {
    /// Creates a new builder-style object to manufacture [`DisruptionCompliance`](crate::model::DisruptionCompliance).
    pub fn builder() -> crate::model::disruption_compliance::Builder {
        crate::model::disruption_compliance::Builder::default()
    }
}

/// See [`DisruptionCompliance`](crate::model::DisruptionCompliance).
pub mod disruption_compliance {

    /// A builder for [`DisruptionCompliance`](crate::model::DisruptionCompliance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) achievable_rto_in_secs: std::option::Option<i32>,
        pub(crate) current_rto_in_secs: std::option::Option<i32>,
        pub(crate) rto_reference_id: std::option::Option<std::string::String>,
        pub(crate) rto_description: std::option::Option<std::string::String>,
        pub(crate) current_rpo_in_secs: std::option::Option<i32>,
        pub(crate) rpo_reference_id: std::option::Option<std::string::String>,
        pub(crate) rpo_description: std::option::Option<std::string::String>,
        pub(crate) compliance_status: std::option::Option<crate::model::ComplianceStatus>,
        pub(crate) achievable_rpo_in_secs: std::option::Option<i32>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Recovery Time Objective (RTO) that is achievable, in seconds</p>
        pub fn achievable_rto_in_secs(mut self, input: i32) -> Self {
            self.achievable_rto_in_secs = Some(input);
            self
        }
        /// <p>The Recovery Time Objective (RTO) that is achievable, in seconds</p>
        pub fn set_achievable_rto_in_secs(mut self, input: std::option::Option<i32>) -> Self {
            self.achievable_rto_in_secs = input;
            self
        }
        /// <p>The current RTO, in seconds.</p>
        pub fn current_rto_in_secs(mut self, input: i32) -> Self {
            self.current_rto_in_secs = Some(input);
            self
        }
        /// <p>The current RTO, in seconds.</p>
        pub fn set_current_rto_in_secs(mut self, input: std::option::Option<i32>) -> Self {
            self.current_rto_in_secs = input;
            self
        }
        /// <p>The RTO reference identifier.</p>
        pub fn rto_reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rto_reference_id = Some(input.into());
            self
        }
        /// <p>The RTO reference identifier.</p>
        pub fn set_rto_reference_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rto_reference_id = input;
            self
        }
        /// <p>The RTO description.</p>
        pub fn rto_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.rto_description = Some(input.into());
            self
        }
        /// <p>The RTO description.</p>
        pub fn set_rto_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rto_description = input;
            self
        }
        /// <p>The current RPO, in seconds.</p>
        pub fn current_rpo_in_secs(mut self, input: i32) -> Self {
            self.current_rpo_in_secs = Some(input);
            self
        }
        /// <p>The current RPO, in seconds.</p>
        pub fn set_current_rpo_in_secs(mut self, input: std::option::Option<i32>) -> Self {
            self.current_rpo_in_secs = input;
            self
        }
        /// <p>The RPO reference identifier.</p>
        pub fn rpo_reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rpo_reference_id = Some(input.into());
            self
        }
        /// <p>The RPO reference identifier.</p>
        pub fn set_rpo_reference_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rpo_reference_id = input;
            self
        }
        /// <p>The RPO description.</p>
        pub fn rpo_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.rpo_description = Some(input.into());
            self
        }
        /// <p>The RPO description.</p>
        pub fn set_rpo_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rpo_description = input;
            self
        }
        /// <p>The current status of compliance for the resiliency policy.</p>
        pub fn compliance_status(mut self, input: crate::model::ComplianceStatus) -> Self {
            self.compliance_status = Some(input);
            self
        }
        /// <p>The current status of compliance for the resiliency policy.</p>
        pub fn set_compliance_status(
            mut self,
            input: std::option::Option<crate::model::ComplianceStatus>,
        ) -> Self {
            self.compliance_status = input;
            self
        }
        /// <p>The Recovery Point Objective (RPO) that is achievable, in seconds.</p>
        pub fn achievable_rpo_in_secs(mut self, input: i32) -> Self {
            self.achievable_rpo_in_secs = Some(input);
            self
        }
        /// <p>The Recovery Point Objective (RPO) that is achievable, in seconds.</p>
        pub fn set_achievable_rpo_in_secs(mut self, input: std::option::Option<i32>) -> Self {
            self.achievable_rpo_in_secs = input;
            self
        }
        /// <p>The disruption compliance message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The disruption compliance message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DisruptionCompliance`](crate::model::DisruptionCompliance).
        pub fn build(self) -> crate::model::DisruptionCompliance {
            crate::model::DisruptionCompliance {
                achievable_rto_in_secs: self.achievable_rto_in_secs.unwrap_or_default(),
                current_rto_in_secs: self.current_rto_in_secs.unwrap_or_default(),
                rto_reference_id: self.rto_reference_id,
                rto_description: self.rto_description,
                current_rpo_in_secs: self.current_rpo_in_secs.unwrap_or_default(),
                rpo_reference_id: self.rpo_reference_id,
                rpo_description: self.rpo_description,
                compliance_status: self.compliance_status,
                achievable_rpo_in_secs: self.achievable_rpo_in_secs.unwrap_or_default(),
                message: self.message,
            }
        }
    }
}

/// <p>The overall resiliency score, returned as an object that includes the disruption score and outage score.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResiliencyScore {
    /// <p>The outage score for a valid key.</p>
    #[doc(hidden)]
    pub score: f64,
    /// <p>The disruption score for a valid key.</p>
    #[doc(hidden)]
    pub disruption_score:
        std::option::Option<std::collections::HashMap<crate::model::DisruptionType, f64>>,
}
impl ResiliencyScore {
    /// <p>The outage score for a valid key.</p>
    pub fn score(&self) -> f64 {
        self.score
    }
    /// <p>The disruption score for a valid key.</p>
    pub fn disruption_score(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<crate::model::DisruptionType, f64>> {
        self.disruption_score.as_ref()
    }
}
impl ResiliencyScore {
    /// Creates a new builder-style object to manufacture [`ResiliencyScore`](crate::model::ResiliencyScore).
    pub fn builder() -> crate::model::resiliency_score::Builder {
        crate::model::resiliency_score::Builder::default()
    }
}

/// See [`ResiliencyScore`](crate::model::ResiliencyScore).
pub mod resiliency_score {

    /// A builder for [`ResiliencyScore`](crate::model::ResiliencyScore).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) score: std::option::Option<f64>,
        pub(crate) disruption_score:
            std::option::Option<std::collections::HashMap<crate::model::DisruptionType, f64>>,
    }
    impl Builder {
        /// <p>The outage score for a valid key.</p>
        pub fn score(mut self, input: f64) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The outage score for a valid key.</p>
        pub fn set_score(mut self, input: std::option::Option<f64>) -> Self {
            self.score = input;
            self
        }
        /// Adds a key-value pair to `disruption_score`.
        ///
        /// To override the contents of this collection use [`set_disruption_score`](Self::set_disruption_score).
        ///
        /// <p>The disruption score for a valid key.</p>
        pub fn disruption_score(mut self, k: crate::model::DisruptionType, v: f64) -> Self {
            let mut hash_map = self.disruption_score.unwrap_or_default();
            hash_map.insert(k, v);
            self.disruption_score = Some(hash_map);
            self
        }
        /// <p>The disruption score for a valid key.</p>
        pub fn set_disruption_score(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::DisruptionType, f64>,
            >,
        ) -> Self {
            self.disruption_score = input;
            self
        }
        /// Consumes the builder and constructs a [`ResiliencyScore`](crate::model::ResiliencyScore).
        pub fn build(self) -> crate::model::ResiliencyScore {
            crate::model::ResiliencyScore {
                score: self.score.unwrap_or_default(),
                disruption_score: self.disruption_score,
            }
        }
    }
}

/// <p>Defines a cost object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Cost {
    /// <p>The cost amount.</p>
    #[doc(hidden)]
    pub amount: f64,
    /// <p>The cost currency, for example <code>USD</code>.</p>
    #[doc(hidden)]
    pub currency: std::option::Option<std::string::String>,
    /// <p>The cost frequency.</p>
    #[doc(hidden)]
    pub frequency: std::option::Option<crate::model::CostFrequency>,
}
impl Cost {
    /// <p>The cost amount.</p>
    pub fn amount(&self) -> f64 {
        self.amount
    }
    /// <p>The cost currency, for example <code>USD</code>.</p>
    pub fn currency(&self) -> std::option::Option<&str> {
        self.currency.as_deref()
    }
    /// <p>The cost frequency.</p>
    pub fn frequency(&self) -> std::option::Option<&crate::model::CostFrequency> {
        self.frequency.as_ref()
    }
}
impl Cost {
    /// Creates a new builder-style object to manufacture [`Cost`](crate::model::Cost).
    pub fn builder() -> crate::model::cost::Builder {
        crate::model::cost::Builder::default()
    }
}

/// See [`Cost`](crate::model::Cost).
pub mod cost {

    /// A builder for [`Cost`](crate::model::Cost).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amount: std::option::Option<f64>,
        pub(crate) currency: std::option::Option<std::string::String>,
        pub(crate) frequency: std::option::Option<crate::model::CostFrequency>,
    }
    impl Builder {
        /// <p>The cost amount.</p>
        pub fn amount(mut self, input: f64) -> Self {
            self.amount = Some(input);
            self
        }
        /// <p>The cost amount.</p>
        pub fn set_amount(mut self, input: std::option::Option<f64>) -> Self {
            self.amount = input;
            self
        }
        /// <p>The cost currency, for example <code>USD</code>.</p>
        pub fn currency(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency = Some(input.into());
            self
        }
        /// <p>The cost currency, for example <code>USD</code>.</p>
        pub fn set_currency(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.currency = input;
            self
        }
        /// <p>The cost frequency.</p>
        pub fn frequency(mut self, input: crate::model::CostFrequency) -> Self {
            self.frequency = Some(input);
            self
        }
        /// <p>The cost frequency.</p>
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::CostFrequency>,
        ) -> Self {
            self.frequency = input;
            self
        }
        /// Consumes the builder and constructs a [`Cost`](crate::model::Cost).
        pub fn build(self) -> crate::model::Cost {
            crate::model::Cost {
                amount: self.amount.unwrap_or_default(),
                currency: self.currency,
                frequency: self.frequency,
            }
        }
    }
}

/// When writing a match expression against `CostFrequency`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let costfrequency = unimplemented!();
/// match costfrequency {
///     CostFrequency::Daily => { /* ... */ },
///     CostFrequency::Hourly => { /* ... */ },
///     CostFrequency::Monthly => { /* ... */ },
///     CostFrequency::Yearly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `costfrequency` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CostFrequency::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CostFrequency::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CostFrequency::NewFeature` is defined.
/// Specifically, when `costfrequency` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CostFrequency::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CostFrequency {
    #[allow(missing_docs)] // documentation missing in model
    Daily,
    #[allow(missing_docs)] // documentation missing in model
    Hourly,
    #[allow(missing_docs)] // documentation missing in model
    Monthly,
    #[allow(missing_docs)] // documentation missing in model
    Yearly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CostFrequency {
    fn from(s: &str) -> Self {
        match s {
            "Daily" => CostFrequency::Daily,
            "Hourly" => CostFrequency::Hourly,
            "Monthly" => CostFrequency::Monthly,
            "Yearly" => CostFrequency::Yearly,
            other => CostFrequency::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CostFrequency {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CostFrequency::from(s))
    }
}
impl CostFrequency {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CostFrequency::Daily => "Daily",
            CostFrequency::Hourly => "Hourly",
            CostFrequency::Monthly => "Monthly",
            CostFrequency::Yearly => "Yearly",
            CostFrequency::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Daily", "Hourly", "Monthly", "Yearly"]
    }
}
impl AsRef<str> for CostFrequency {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AssessmentInvoker`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assessmentinvoker = unimplemented!();
/// match assessmentinvoker {
///     AssessmentInvoker::System => { /* ... */ },
///     AssessmentInvoker::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assessmentinvoker` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssessmentInvoker::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssessmentInvoker::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssessmentInvoker::NewFeature` is defined.
/// Specifically, when `assessmentinvoker` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssessmentInvoker::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssessmentInvoker {
    #[allow(missing_docs)] // documentation missing in model
    System,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssessmentInvoker {
    fn from(s: &str) -> Self {
        match s {
            "System" => AssessmentInvoker::System,
            "User" => AssessmentInvoker::User,
            other => {
                AssessmentInvoker::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AssessmentInvoker {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssessmentInvoker::from(s))
    }
}
impl AssessmentInvoker {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssessmentInvoker::System => "System",
            AssessmentInvoker::User => "User",
            AssessmentInvoker::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["System", "User"]
    }
}
impl AsRef<str> for AssessmentInvoker {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResourceResolutionStatusType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourceresolutionstatustype = unimplemented!();
/// match resourceresolutionstatustype {
///     ResourceResolutionStatusType::Failed => { /* ... */ },
///     ResourceResolutionStatusType::InProgress => { /* ... */ },
///     ResourceResolutionStatusType::Pending => { /* ... */ },
///     ResourceResolutionStatusType::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourceresolutionstatustype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceResolutionStatusType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceResolutionStatusType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceResolutionStatusType::NewFeature` is defined.
/// Specifically, when `resourceresolutionstatustype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceResolutionStatusType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceResolutionStatusType {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceResolutionStatusType {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => ResourceResolutionStatusType::Failed,
            "InProgress" => ResourceResolutionStatusType::InProgress,
            "Pending" => ResourceResolutionStatusType::Pending,
            "Success" => ResourceResolutionStatusType::Success,
            other => ResourceResolutionStatusType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ResourceResolutionStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceResolutionStatusType::from(s))
    }
}
impl ResourceResolutionStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceResolutionStatusType::Failed => "Failed",
            ResourceResolutionStatusType::InProgress => "InProgress",
            ResourceResolutionStatusType::Pending => "Pending",
            ResourceResolutionStatusType::Success => "Success",
            ResourceResolutionStatusType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Failed", "InProgress", "Pending", "Success"]
    }
}
impl AsRef<str> for ResourceResolutionStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines a resource that is not supported by Resilience Hub.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnsupportedResource {
    /// <p>The logical resource identifier for the unsupported resource.</p>
    #[doc(hidden)]
    pub logical_resource_id: std::option::Option<crate::model::LogicalResourceId>,
    /// <p>The physical resource identifier for the unsupported resource.</p>
    #[doc(hidden)]
    pub physical_resource_id: std::option::Option<crate::model::PhysicalResourceId>,
    /// <p>The type of resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
}
impl UnsupportedResource {
    /// <p>The logical resource identifier for the unsupported resource.</p>
    pub fn logical_resource_id(&self) -> std::option::Option<&crate::model::LogicalResourceId> {
        self.logical_resource_id.as_ref()
    }
    /// <p>The physical resource identifier for the unsupported resource.</p>
    pub fn physical_resource_id(&self) -> std::option::Option<&crate::model::PhysicalResourceId> {
        self.physical_resource_id.as_ref()
    }
    /// <p>The type of resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
}
impl UnsupportedResource {
    /// Creates a new builder-style object to manufacture [`UnsupportedResource`](crate::model::UnsupportedResource).
    pub fn builder() -> crate::model::unsupported_resource::Builder {
        crate::model::unsupported_resource::Builder::default()
    }
}

/// See [`UnsupportedResource`](crate::model::UnsupportedResource).
pub mod unsupported_resource {

    /// A builder for [`UnsupportedResource`](crate::model::UnsupportedResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logical_resource_id: std::option::Option<crate::model::LogicalResourceId>,
        pub(crate) physical_resource_id: std::option::Option<crate::model::PhysicalResourceId>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The logical resource identifier for the unsupported resource.</p>
        pub fn logical_resource_id(mut self, input: crate::model::LogicalResourceId) -> Self {
            self.logical_resource_id = Some(input);
            self
        }
        /// <p>The logical resource identifier for the unsupported resource.</p>
        pub fn set_logical_resource_id(
            mut self,
            input: std::option::Option<crate::model::LogicalResourceId>,
        ) -> Self {
            self.logical_resource_id = input;
            self
        }
        /// <p>The physical resource identifier for the unsupported resource.</p>
        pub fn physical_resource_id(mut self, input: crate::model::PhysicalResourceId) -> Self {
            self.physical_resource_id = Some(input);
            self
        }
        /// <p>The physical resource identifier for the unsupported resource.</p>
        pub fn set_physical_resource_id(
            mut self,
            input: std::option::Option<crate::model::PhysicalResourceId>,
        ) -> Self {
            self.physical_resource_id = input;
            self
        }
        /// <p>The type of resource.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedResource`](crate::model::UnsupportedResource).
        pub fn build(self) -> crate::model::UnsupportedResource {
            crate::model::UnsupportedResource {
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                resource_type: self.resource_type,
            }
        }
    }
}

/// <p>Defines a physical resource identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhysicalResourceId {
    /// <p>The identifier of the physical resource.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>Specifies the type of physical resource identifier.</p>
    /// <dl>
    /// <dt>
    /// Arn
    /// </dt>
    /// <dd>
    /// <p>The resource identifier is an Amazon Resource Name (ARN) .</p>
    /// </dd>
    /// <dt>
    /// Native
    /// </dt>
    /// <dd>
    /// <p>The resource identifier is a Resilience Hub-native identifier.</p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PhysicalIdentifierType>,
    /// <p>The Amazon Web Services Region that the physical resource is located in.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account that owns the physical resource.</p>
    #[doc(hidden)]
    pub aws_account_id: std::option::Option<std::string::String>,
}
impl PhysicalResourceId {
    /// <p>The identifier of the physical resource.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>Specifies the type of physical resource identifier.</p>
    /// <dl>
    /// <dt>
    /// Arn
    /// </dt>
    /// <dd>
    /// <p>The resource identifier is an Amazon Resource Name (ARN) .</p>
    /// </dd>
    /// <dt>
    /// Native
    /// </dt>
    /// <dd>
    /// <p>The resource identifier is a Resilience Hub-native identifier.</p>
    /// </dd>
    /// </dl>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PhysicalIdentifierType> {
        self.r#type.as_ref()
    }
    /// <p>The Amazon Web Services Region that the physical resource is located in.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The Amazon Web Services account that owns the physical resource.</p>
    pub fn aws_account_id(&self) -> std::option::Option<&str> {
        self.aws_account_id.as_deref()
    }
}
impl PhysicalResourceId {
    /// Creates a new builder-style object to manufacture [`PhysicalResourceId`](crate::model::PhysicalResourceId).
    pub fn builder() -> crate::model::physical_resource_id::Builder {
        crate::model::physical_resource_id::Builder::default()
    }
}

/// See [`PhysicalResourceId`](crate::model::PhysicalResourceId).
pub mod physical_resource_id {

    /// A builder for [`PhysicalResourceId`](crate::model::PhysicalResourceId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::PhysicalIdentifierType>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) aws_account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the physical resource.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the physical resource.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>Specifies the type of physical resource identifier.</p>
        /// <dl>
        /// <dt>
        /// Arn
        /// </dt>
        /// <dd>
        /// <p>The resource identifier is an Amazon Resource Name (ARN) .</p>
        /// </dd>
        /// <dt>
        /// Native
        /// </dt>
        /// <dd>
        /// <p>The resource identifier is a Resilience Hub-native identifier.</p>
        /// </dd>
        /// </dl>
        pub fn r#type(mut self, input: crate::model::PhysicalIdentifierType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Specifies the type of physical resource identifier.</p>
        /// <dl>
        /// <dt>
        /// Arn
        /// </dt>
        /// <dd>
        /// <p>The resource identifier is an Amazon Resource Name (ARN) .</p>
        /// </dd>
        /// <dt>
        /// Native
        /// </dt>
        /// <dd>
        /// <p>The resource identifier is a Resilience Hub-native identifier.</p>
        /// </dd>
        /// </dl>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::PhysicalIdentifierType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Amazon Web Services Region that the physical resource is located in.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region that the physical resource is located in.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The Amazon Web Services account that owns the physical resource.</p>
        pub fn aws_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account that owns the physical resource.</p>
        pub fn set_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PhysicalResourceId`](crate::model::PhysicalResourceId).
        pub fn build(self) -> crate::model::PhysicalResourceId {
            crate::model::PhysicalResourceId {
                identifier: self.identifier,
                r#type: self.r#type,
                aws_region: self.aws_region,
                aws_account_id: self.aws_account_id,
            }
        }
    }
}

/// When writing a match expression against `PhysicalIdentifierType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let physicalidentifiertype = unimplemented!();
/// match physicalidentifiertype {
///     PhysicalIdentifierType::Arn => { /* ... */ },
///     PhysicalIdentifierType::Native => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `physicalidentifiertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PhysicalIdentifierType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PhysicalIdentifierType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PhysicalIdentifierType::NewFeature` is defined.
/// Specifically, when `physicalidentifiertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PhysicalIdentifierType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PhysicalIdentifierType {
    #[allow(missing_docs)] // documentation missing in model
    Arn,
    #[allow(missing_docs)] // documentation missing in model
    Native,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PhysicalIdentifierType {
    fn from(s: &str) -> Self {
        match s {
            "Arn" => PhysicalIdentifierType::Arn,
            "Native" => PhysicalIdentifierType::Native,
            other => {
                PhysicalIdentifierType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PhysicalIdentifierType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PhysicalIdentifierType::from(s))
    }
}
impl PhysicalIdentifierType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PhysicalIdentifierType::Arn => "Arn",
            PhysicalIdentifierType::Native => "Native",
            PhysicalIdentifierType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Arn", "Native"]
    }
}
impl AsRef<str> for PhysicalIdentifierType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines a logical resource identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogicalResourceId {
    /// <p>The identifier of the resource.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>The name of the CloudFormation stack this resource belongs to.</p>
    #[doc(hidden)]
    pub logical_stack_name: std::option::Option<std::string::String>,
    /// <p>The name of the resource group that this resource belongs to.</p>
    #[doc(hidden)]
    pub resource_group_name: std::option::Option<std::string::String>,
    /// <p> The name of the Terraform S3 state file this resource belongs to. </p>
    #[doc(hidden)]
    pub terraform_source_name: std::option::Option<std::string::String>,
}
impl LogicalResourceId {
    /// <p>The identifier of the resource.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>The name of the CloudFormation stack this resource belongs to.</p>
    pub fn logical_stack_name(&self) -> std::option::Option<&str> {
        self.logical_stack_name.as_deref()
    }
    /// <p>The name of the resource group that this resource belongs to.</p>
    pub fn resource_group_name(&self) -> std::option::Option<&str> {
        self.resource_group_name.as_deref()
    }
    /// <p> The name of the Terraform S3 state file this resource belongs to. </p>
    pub fn terraform_source_name(&self) -> std::option::Option<&str> {
        self.terraform_source_name.as_deref()
    }
}
impl LogicalResourceId {
    /// Creates a new builder-style object to manufacture [`LogicalResourceId`](crate::model::LogicalResourceId).
    pub fn builder() -> crate::model::logical_resource_id::Builder {
        crate::model::logical_resource_id::Builder::default()
    }
}

/// See [`LogicalResourceId`](crate::model::LogicalResourceId).
pub mod logical_resource_id {

    /// A builder for [`LogicalResourceId`](crate::model::LogicalResourceId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) logical_stack_name: std::option::Option<std::string::String>,
        pub(crate) resource_group_name: std::option::Option<std::string::String>,
        pub(crate) terraform_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the resource.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the resource.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>The name of the CloudFormation stack this resource belongs to.</p>
        pub fn logical_stack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.logical_stack_name = Some(input.into());
            self
        }
        /// <p>The name of the CloudFormation stack this resource belongs to.</p>
        pub fn set_logical_stack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_stack_name = input;
            self
        }
        /// <p>The name of the resource group that this resource belongs to.</p>
        pub fn resource_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_group_name = Some(input.into());
            self
        }
        /// <p>The name of the resource group that this resource belongs to.</p>
        pub fn set_resource_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_group_name = input;
            self
        }
        /// <p> The name of the Terraform S3 state file this resource belongs to. </p>
        pub fn terraform_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.terraform_source_name = Some(input.into());
            self
        }
        /// <p> The name of the Terraform S3 state file this resource belongs to. </p>
        pub fn set_terraform_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.terraform_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`LogicalResourceId`](crate::model::LogicalResourceId).
        pub fn build(self) -> crate::model::LogicalResourceId {
            crate::model::LogicalResourceId {
                identifier: self.identifier,
                logical_stack_name: self.logical_stack_name,
                resource_group_name: self.resource_group_name,
                terraform_source_name: self.terraform_source_name,
            }
        }
    }
}

/// <p>Defines a test recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TestRecommendation {
    /// <p>Identifier for the test recommendation.</p>
    #[doc(hidden)]
    pub recommendation_id: std::option::Option<std::string::String>,
    /// <p>The reference identifier for the test recommendation.</p>
    #[doc(hidden)]
    pub reference_id: std::option::Option<std::string::String>,
    /// <p>The name of the application component.</p>
    #[doc(hidden)]
    pub app_component_name: std::option::Option<std::string::String>,
    /// <p>The name of the test recommendation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The intent of the test recommendation.</p>
    #[doc(hidden)]
    pub intent: std::option::Option<std::string::String>,
    /// <p>The level of risk for this test recommendation.</p>
    #[doc(hidden)]
    pub risk: std::option::Option<crate::model::TestRisk>,
    /// <p>The type of test recommendation.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::TestType>,
    /// <p>The description for the test recommendation.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The test recommendation items.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::RecommendationItem>>,
    /// <p>The prerequisite of the test recommendation.</p>
    #[doc(hidden)]
    pub prerequisite: std::option::Option<std::string::String>,
    /// <p> A list of recommended alarms that are used in the test and must be exported before or with the test. </p>
    #[doc(hidden)]
    pub depends_on_alarms: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TestRecommendation {
    /// <p>Identifier for the test recommendation.</p>
    pub fn recommendation_id(&self) -> std::option::Option<&str> {
        self.recommendation_id.as_deref()
    }
    /// <p>The reference identifier for the test recommendation.</p>
    pub fn reference_id(&self) -> std::option::Option<&str> {
        self.reference_id.as_deref()
    }
    /// <p>The name of the application component.</p>
    pub fn app_component_name(&self) -> std::option::Option<&str> {
        self.app_component_name.as_deref()
    }
    /// <p>The name of the test recommendation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The intent of the test recommendation.</p>
    pub fn intent(&self) -> std::option::Option<&str> {
        self.intent.as_deref()
    }
    /// <p>The level of risk for this test recommendation.</p>
    pub fn risk(&self) -> std::option::Option<&crate::model::TestRisk> {
        self.risk.as_ref()
    }
    /// <p>The type of test recommendation.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::TestType> {
        self.r#type.as_ref()
    }
    /// <p>The description for the test recommendation.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The test recommendation items.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::RecommendationItem]> {
        self.items.as_deref()
    }
    /// <p>The prerequisite of the test recommendation.</p>
    pub fn prerequisite(&self) -> std::option::Option<&str> {
        self.prerequisite.as_deref()
    }
    /// <p> A list of recommended alarms that are used in the test and must be exported before or with the test. </p>
    pub fn depends_on_alarms(&self) -> std::option::Option<&[std::string::String]> {
        self.depends_on_alarms.as_deref()
    }
}
impl TestRecommendation {
    /// Creates a new builder-style object to manufacture [`TestRecommendation`](crate::model::TestRecommendation).
    pub fn builder() -> crate::model::test_recommendation::Builder {
        crate::model::test_recommendation::Builder::default()
    }
}

/// See [`TestRecommendation`](crate::model::TestRecommendation).
pub mod test_recommendation {

    /// A builder for [`TestRecommendation`](crate::model::TestRecommendation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation_id: std::option::Option<std::string::String>,
        pub(crate) reference_id: std::option::Option<std::string::String>,
        pub(crate) app_component_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) intent: std::option::Option<std::string::String>,
        pub(crate) risk: std::option::Option<crate::model::TestRisk>,
        pub(crate) r#type: std::option::Option<crate::model::TestType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::RecommendationItem>>,
        pub(crate) prerequisite: std::option::Option<std::string::String>,
        pub(crate) depends_on_alarms: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Identifier for the test recommendation.</p>
        pub fn recommendation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation_id = Some(input.into());
            self
        }
        /// <p>Identifier for the test recommendation.</p>
        pub fn set_recommendation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_id = input;
            self
        }
        /// <p>The reference identifier for the test recommendation.</p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_id = Some(input.into());
            self
        }
        /// <p>The reference identifier for the test recommendation.</p>
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_id = input;
            self
        }
        /// <p>The name of the application component.</p>
        pub fn app_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_component_name = Some(input.into());
            self
        }
        /// <p>The name of the application component.</p>
        pub fn set_app_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_component_name = input;
            self
        }
        /// <p>The name of the test recommendation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the test recommendation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The intent of the test recommendation.</p>
        pub fn intent(mut self, input: impl Into<std::string::String>) -> Self {
            self.intent = Some(input.into());
            self
        }
        /// <p>The intent of the test recommendation.</p>
        pub fn set_intent(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.intent = input;
            self
        }
        /// <p>The level of risk for this test recommendation.</p>
        pub fn risk(mut self, input: crate::model::TestRisk) -> Self {
            self.risk = Some(input);
            self
        }
        /// <p>The level of risk for this test recommendation.</p>
        pub fn set_risk(mut self, input: std::option::Option<crate::model::TestRisk>) -> Self {
            self.risk = input;
            self
        }
        /// <p>The type of test recommendation.</p>
        pub fn r#type(mut self, input: crate::model::TestType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of test recommendation.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::TestType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The description for the test recommendation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description for the test recommendation.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>The test recommendation items.</p>
        pub fn items(mut self, input: crate::model::RecommendationItem) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>The test recommendation items.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecommendationItem>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>The prerequisite of the test recommendation.</p>
        pub fn prerequisite(mut self, input: impl Into<std::string::String>) -> Self {
            self.prerequisite = Some(input.into());
            self
        }
        /// <p>The prerequisite of the test recommendation.</p>
        pub fn set_prerequisite(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prerequisite = input;
            self
        }
        /// Appends an item to `depends_on_alarms`.
        ///
        /// To override the contents of this collection use [`set_depends_on_alarms`](Self::set_depends_on_alarms).
        ///
        /// <p> A list of recommended alarms that are used in the test and must be exported before or with the test. </p>
        pub fn depends_on_alarms(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.depends_on_alarms.unwrap_or_default();
            v.push(input.into());
            self.depends_on_alarms = Some(v);
            self
        }
        /// <p> A list of recommended alarms that are used in the test and must be exported before or with the test. </p>
        pub fn set_depends_on_alarms(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.depends_on_alarms = input;
            self
        }
        /// Consumes the builder and constructs a [`TestRecommendation`](crate::model::TestRecommendation).
        pub fn build(self) -> crate::model::TestRecommendation {
            crate::model::TestRecommendation {
                recommendation_id: self.recommendation_id,
                reference_id: self.reference_id,
                app_component_name: self.app_component_name,
                name: self.name,
                intent: self.intent,
                risk: self.risk,
                r#type: self.r#type,
                description: self.description,
                items: self.items,
                prerequisite: self.prerequisite,
                depends_on_alarms: self.depends_on_alarms,
            }
        }
    }
}

/// <p>Defines a recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendationItem {
    /// <p>The resource identifier.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The target account identifier.</p>
    #[doc(hidden)]
    pub target_account_id: std::option::Option<std::string::String>,
    /// <p>The target region.</p>
    #[doc(hidden)]
    pub target_region: std::option::Option<std::string::String>,
    /// <p>Specifies if the recommendation has already been implemented.</p>
    #[doc(hidden)]
    pub already_implemented: std::option::Option<bool>,
}
impl RecommendationItem {
    /// <p>The resource identifier.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The target account identifier.</p>
    pub fn target_account_id(&self) -> std::option::Option<&str> {
        self.target_account_id.as_deref()
    }
    /// <p>The target region.</p>
    pub fn target_region(&self) -> std::option::Option<&str> {
        self.target_region.as_deref()
    }
    /// <p>Specifies if the recommendation has already been implemented.</p>
    pub fn already_implemented(&self) -> std::option::Option<bool> {
        self.already_implemented
    }
}
impl RecommendationItem {
    /// Creates a new builder-style object to manufacture [`RecommendationItem`](crate::model::RecommendationItem).
    pub fn builder() -> crate::model::recommendation_item::Builder {
        crate::model::recommendation_item::Builder::default()
    }
}

/// See [`RecommendationItem`](crate::model::RecommendationItem).
pub mod recommendation_item {

    /// A builder for [`RecommendationItem`](crate::model::RecommendationItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) target_account_id: std::option::Option<std::string::String>,
        pub(crate) target_region: std::option::Option<std::string::String>,
        pub(crate) already_implemented: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The resource identifier.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The resource identifier.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The target account identifier.</p>
        pub fn target_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_account_id = Some(input.into());
            self
        }
        /// <p>The target account identifier.</p>
        pub fn set_target_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_account_id = input;
            self
        }
        /// <p>The target region.</p>
        pub fn target_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_region = Some(input.into());
            self
        }
        /// <p>The target region.</p>
        pub fn set_target_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_region = input;
            self
        }
        /// <p>Specifies if the recommendation has already been implemented.</p>
        pub fn already_implemented(mut self, input: bool) -> Self {
            self.already_implemented = Some(input);
            self
        }
        /// <p>Specifies if the recommendation has already been implemented.</p>
        pub fn set_already_implemented(mut self, input: std::option::Option<bool>) -> Self {
            self.already_implemented = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationItem`](crate::model::RecommendationItem).
        pub fn build(self) -> crate::model::RecommendationItem {
            crate::model::RecommendationItem {
                resource_id: self.resource_id,
                target_account_id: self.target_account_id,
                target_region: self.target_region,
                already_implemented: self.already_implemented,
            }
        }
    }
}

/// When writing a match expression against `TestType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let testtype = unimplemented!();
/// match testtype {
///     TestType::Az => { /* ... */ },
///     TestType::Hardware => { /* ... */ },
///     TestType::Region => { /* ... */ },
///     TestType::Software => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `testtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TestType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TestType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TestType::NewFeature` is defined.
/// Specifically, when `testtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TestType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TestType {
    #[allow(missing_docs)] // documentation missing in model
    Az,
    #[allow(missing_docs)] // documentation missing in model
    Hardware,
    #[allow(missing_docs)] // documentation missing in model
    Region,
    #[allow(missing_docs)] // documentation missing in model
    Software,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TestType {
    fn from(s: &str) -> Self {
        match s {
            "AZ" => TestType::Az,
            "Hardware" => TestType::Hardware,
            "Region" => TestType::Region,
            "Software" => TestType::Software,
            other => TestType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TestType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TestType::from(s))
    }
}
impl TestType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TestType::Az => "AZ",
            TestType::Hardware => "Hardware",
            TestType::Region => "Region",
            TestType::Software => "Software",
            TestType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AZ", "Hardware", "Region", "Software"]
    }
}
impl AsRef<str> for TestType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TestRisk`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let testrisk = unimplemented!();
/// match testrisk {
///     TestRisk::High => { /* ... */ },
///     TestRisk::Medium => { /* ... */ },
///     TestRisk::Small => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `testrisk` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TestRisk::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TestRisk::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TestRisk::NewFeature` is defined.
/// Specifically, when `testrisk` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TestRisk::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TestRisk {
    #[allow(missing_docs)] // documentation missing in model
    High,
    #[allow(missing_docs)] // documentation missing in model
    Medium,
    #[allow(missing_docs)] // documentation missing in model
    Small,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TestRisk {
    fn from(s: &str) -> Self {
        match s {
            "High" => TestRisk::High,
            "Medium" => TestRisk::Medium,
            "Small" => TestRisk::Small,
            other => TestRisk::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TestRisk {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TestRisk::from(s))
    }
}
impl TestRisk {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TestRisk::High => "High",
            TestRisk::Medium => "Medium",
            TestRisk::Small => "Small",
            TestRisk::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["High", "Medium", "Small"]
    }
}
impl AsRef<str> for TestRisk {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines a standard operating procedure (SOP) recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SopRecommendation {
    /// <p>The service type.</p>
    #[doc(hidden)]
    pub service_type: std::option::Option<crate::model::SopServiceType>,
    /// <p>The application component name.</p>
    #[doc(hidden)]
    pub app_component_name: std::option::Option<std::string::String>,
    /// <p>The description of the SOP recommendation.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Identifier for the SOP recommendation.</p>
    #[doc(hidden)]
    pub recommendation_id: std::option::Option<std::string::String>,
    /// <p>The name of the SOP recommendation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The recommendation items.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::RecommendationItem>>,
    /// <p>The reference identifier for the SOP recommendation.</p>
    #[doc(hidden)]
    pub reference_id: std::option::Option<std::string::String>,
    /// <p>The prerequisite for the SOP recommendation.</p>
    #[doc(hidden)]
    pub prerequisite: std::option::Option<std::string::String>,
}
impl SopRecommendation {
    /// <p>The service type.</p>
    pub fn service_type(&self) -> std::option::Option<&crate::model::SopServiceType> {
        self.service_type.as_ref()
    }
    /// <p>The application component name.</p>
    pub fn app_component_name(&self) -> std::option::Option<&str> {
        self.app_component_name.as_deref()
    }
    /// <p>The description of the SOP recommendation.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Identifier for the SOP recommendation.</p>
    pub fn recommendation_id(&self) -> std::option::Option<&str> {
        self.recommendation_id.as_deref()
    }
    /// <p>The name of the SOP recommendation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The recommendation items.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::RecommendationItem]> {
        self.items.as_deref()
    }
    /// <p>The reference identifier for the SOP recommendation.</p>
    pub fn reference_id(&self) -> std::option::Option<&str> {
        self.reference_id.as_deref()
    }
    /// <p>The prerequisite for the SOP recommendation.</p>
    pub fn prerequisite(&self) -> std::option::Option<&str> {
        self.prerequisite.as_deref()
    }
}
impl SopRecommendation {
    /// Creates a new builder-style object to manufacture [`SopRecommendation`](crate::model::SopRecommendation).
    pub fn builder() -> crate::model::sop_recommendation::Builder {
        crate::model::sop_recommendation::Builder::default()
    }
}

/// See [`SopRecommendation`](crate::model::SopRecommendation).
pub mod sop_recommendation {

    /// A builder for [`SopRecommendation`](crate::model::SopRecommendation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_type: std::option::Option<crate::model::SopServiceType>,
        pub(crate) app_component_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) recommendation_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::RecommendationItem>>,
        pub(crate) reference_id: std::option::Option<std::string::String>,
        pub(crate) prerequisite: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The service type.</p>
        pub fn service_type(mut self, input: crate::model::SopServiceType) -> Self {
            self.service_type = Some(input);
            self
        }
        /// <p>The service type.</p>
        pub fn set_service_type(
            mut self,
            input: std::option::Option<crate::model::SopServiceType>,
        ) -> Self {
            self.service_type = input;
            self
        }
        /// <p>The application component name.</p>
        pub fn app_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_component_name = Some(input.into());
            self
        }
        /// <p>The application component name.</p>
        pub fn set_app_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_component_name = input;
            self
        }
        /// <p>The description of the SOP recommendation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the SOP recommendation.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Identifier for the SOP recommendation.</p>
        pub fn recommendation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation_id = Some(input.into());
            self
        }
        /// <p>Identifier for the SOP recommendation.</p>
        pub fn set_recommendation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_id = input;
            self
        }
        /// <p>The name of the SOP recommendation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the SOP recommendation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>The recommendation items.</p>
        pub fn items(mut self, input: crate::model::RecommendationItem) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>The recommendation items.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecommendationItem>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>The reference identifier for the SOP recommendation.</p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_id = Some(input.into());
            self
        }
        /// <p>The reference identifier for the SOP recommendation.</p>
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_id = input;
            self
        }
        /// <p>The prerequisite for the SOP recommendation.</p>
        pub fn prerequisite(mut self, input: impl Into<std::string::String>) -> Self {
            self.prerequisite = Some(input.into());
            self
        }
        /// <p>The prerequisite for the SOP recommendation.</p>
        pub fn set_prerequisite(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prerequisite = input;
            self
        }
        /// Consumes the builder and constructs a [`SopRecommendation`](crate::model::SopRecommendation).
        pub fn build(self) -> crate::model::SopRecommendation {
            crate::model::SopRecommendation {
                service_type: self.service_type,
                app_component_name: self.app_component_name,
                description: self.description,
                recommendation_id: self.recommendation_id,
                name: self.name,
                items: self.items,
                reference_id: self.reference_id,
                prerequisite: self.prerequisite,
            }
        }
    }
}

/// When writing a match expression against `SopServiceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sopservicetype = unimplemented!();
/// match sopservicetype {
///     SopServiceType::Ssm => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sopservicetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SopServiceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SopServiceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SopServiceType::NewFeature` is defined.
/// Specifically, when `sopservicetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SopServiceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SopServiceType {
    #[allow(missing_docs)] // documentation missing in model
    Ssm,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SopServiceType {
    fn from(s: &str) -> Self {
        match s {
            "SSM" => SopServiceType::Ssm,
            other => SopServiceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SopServiceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SopServiceType::from(s))
    }
}
impl SopServiceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SopServiceType::Ssm => "SSM",
            SopServiceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SSM"]
    }
}
impl AsRef<str> for SopServiceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines a recommendation template created with the <code>CreateRecommendationTemplate</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecommendationTemplate {
    /// <p>The file location of the template.</p>
    #[doc(hidden)]
    pub templates_location: std::option::Option<crate::model::S3Location>,
    /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub assessment_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub app_arn: std::option::Option<std::string::String>,
    /// <p>Identifiers for the recommendations used in the recommendation template.</p>
    #[doc(hidden)]
    pub recommendation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of strings that specify the recommendation template type or types.</p>
    /// <dl>
    /// <dt>
    /// Alarm
    /// </dt>
    /// <dd>
    /// <p>The template is an <code>AlarmRecommendation</code> template.</p>
    /// </dd>
    /// <dt>
    /// Sop
    /// </dt>
    /// <dd>
    /// <p>The template is a <code>SopRecommendation</code> template.</p>
    /// </dd>
    /// <dt>
    /// Test
    /// </dt>
    /// <dd>
    /// <p>The template is a <code>TestRecommendation</code> template.</p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub recommendation_types:
        std::option::Option<std::vec::Vec<crate::model::RenderRecommendationType>>,
    /// <p>The format of the recommendation template.</p>
    /// <dl>
    /// <dt>
    /// CfnJson
    /// </dt>
    /// <dd>
    /// <p>The template is CloudFormation JSON.</p>
    /// </dd>
    /// <dt>
    /// CfnYaml
    /// </dt>
    /// <dd>
    /// <p>The template is CloudFormation YAML.</p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::TemplateFormat>,
    /// <p>The Amazon Resource Name (ARN) for the recommendation template.</p>
    #[doc(hidden)]
    pub recommendation_template_arn: std::option::Option<std::string::String>,
    /// <p>The message for the recommendation template.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The status of the action.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RecommendationTemplateStatus>,
    /// <p>The name for the recommendation template.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The start time for the action.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end time for the action.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Indicates if replacements are needed.</p>
    #[doc(hidden)]
    pub needs_replacements: std::option::Option<bool>,
}
impl RecommendationTemplate {
    /// <p>The file location of the template.</p>
    pub fn templates_location(&self) -> std::option::Option<&crate::model::S3Location> {
        self.templates_location.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn assessment_arn(&self) -> std::option::Option<&str> {
        self.assessment_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn app_arn(&self) -> std::option::Option<&str> {
        self.app_arn.as_deref()
    }
    /// <p>Identifiers for the recommendations used in the recommendation template.</p>
    pub fn recommendation_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.recommendation_ids.as_deref()
    }
    /// <p>An array of strings that specify the recommendation template type or types.</p>
    /// <dl>
    /// <dt>
    /// Alarm
    /// </dt>
    /// <dd>
    /// <p>The template is an <code>AlarmRecommendation</code> template.</p>
    /// </dd>
    /// <dt>
    /// Sop
    /// </dt>
    /// <dd>
    /// <p>The template is a <code>SopRecommendation</code> template.</p>
    /// </dd>
    /// <dt>
    /// Test
    /// </dt>
    /// <dd>
    /// <p>The template is a <code>TestRecommendation</code> template.</p>
    /// </dd>
    /// </dl>
    pub fn recommendation_types(
        &self,
    ) -> std::option::Option<&[crate::model::RenderRecommendationType]> {
        self.recommendation_types.as_deref()
    }
    /// <p>The format of the recommendation template.</p>
    /// <dl>
    /// <dt>
    /// CfnJson
    /// </dt>
    /// <dd>
    /// <p>The template is CloudFormation JSON.</p>
    /// </dd>
    /// <dt>
    /// CfnYaml
    /// </dt>
    /// <dd>
    /// <p>The template is CloudFormation YAML.</p>
    /// </dd>
    /// </dl>
    pub fn format(&self) -> std::option::Option<&crate::model::TemplateFormat> {
        self.format.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) for the recommendation template.</p>
    pub fn recommendation_template_arn(&self) -> std::option::Option<&str> {
        self.recommendation_template_arn.as_deref()
    }
    /// <p>The message for the recommendation template.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The status of the action.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::RecommendationTemplateStatus> {
        self.status.as_ref()
    }
    /// <p>The name for the recommendation template.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The start time for the action.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The end time for the action.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>Indicates if replacements are needed.</p>
    pub fn needs_replacements(&self) -> std::option::Option<bool> {
        self.needs_replacements
    }
}
impl std::fmt::Debug for RecommendationTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecommendationTemplate");
        formatter.field("templates_location", &self.templates_location);
        formatter.field("assessment_arn", &self.assessment_arn);
        formatter.field("app_arn", &self.app_arn);
        formatter.field("recommendation_ids", &self.recommendation_ids);
        formatter.field("recommendation_types", &self.recommendation_types);
        formatter.field("format", &self.format);
        formatter.field(
            "recommendation_template_arn",
            &self.recommendation_template_arn,
        );
        formatter.field("message", &self.message);
        formatter.field("status", &self.status);
        formatter.field("name", &self.name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("needs_replacements", &self.needs_replacements);
        formatter.finish()
    }
}
impl RecommendationTemplate {
    /// Creates a new builder-style object to manufacture [`RecommendationTemplate`](crate::model::RecommendationTemplate).
    pub fn builder() -> crate::model::recommendation_template::Builder {
        crate::model::recommendation_template::Builder::default()
    }
}

/// See [`RecommendationTemplate`](crate::model::RecommendationTemplate).
pub mod recommendation_template {

    /// A builder for [`RecommendationTemplate`](crate::model::RecommendationTemplate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) templates_location: std::option::Option<crate::model::S3Location>,
        pub(crate) assessment_arn: std::option::Option<std::string::String>,
        pub(crate) app_arn: std::option::Option<std::string::String>,
        pub(crate) recommendation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) recommendation_types:
            std::option::Option<std::vec::Vec<crate::model::RenderRecommendationType>>,
        pub(crate) format: std::option::Option<crate::model::TemplateFormat>,
        pub(crate) recommendation_template_arn: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::RecommendationTemplateStatus>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) needs_replacements: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The file location of the template.</p>
        pub fn templates_location(mut self, input: crate::model::S3Location) -> Self {
            self.templates_location = Some(input);
            self
        }
        /// <p>The file location of the template.</p>
        pub fn set_templates_location(
            mut self,
            input: std::option::Option<crate::model::S3Location>,
        ) -> Self {
            self.templates_location = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn assessment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_assessment_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn app_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_app_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_arn = input;
            self
        }
        /// Appends an item to `recommendation_ids`.
        ///
        /// To override the contents of this collection use [`set_recommendation_ids`](Self::set_recommendation_ids).
        ///
        /// <p>Identifiers for the recommendations used in the recommendation template.</p>
        pub fn recommendation_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.recommendation_ids.unwrap_or_default();
            v.push(input.into());
            self.recommendation_ids = Some(v);
            self
        }
        /// <p>Identifiers for the recommendations used in the recommendation template.</p>
        pub fn set_recommendation_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.recommendation_ids = input;
            self
        }
        /// Appends an item to `recommendation_types`.
        ///
        /// To override the contents of this collection use [`set_recommendation_types`](Self::set_recommendation_types).
        ///
        /// <p>An array of strings that specify the recommendation template type or types.</p>
        /// <dl>
        /// <dt>
        /// Alarm
        /// </dt>
        /// <dd>
        /// <p>The template is an <code>AlarmRecommendation</code> template.</p>
        /// </dd>
        /// <dt>
        /// Sop
        /// </dt>
        /// <dd>
        /// <p>The template is a <code>SopRecommendation</code> template.</p>
        /// </dd>
        /// <dt>
        /// Test
        /// </dt>
        /// <dd>
        /// <p>The template is a <code>TestRecommendation</code> template.</p>
        /// </dd>
        /// </dl>
        pub fn recommendation_types(
            mut self,
            input: crate::model::RenderRecommendationType,
        ) -> Self {
            let mut v = self.recommendation_types.unwrap_or_default();
            v.push(input);
            self.recommendation_types = Some(v);
            self
        }
        /// <p>An array of strings that specify the recommendation template type or types.</p>
        /// <dl>
        /// <dt>
        /// Alarm
        /// </dt>
        /// <dd>
        /// <p>The template is an <code>AlarmRecommendation</code> template.</p>
        /// </dd>
        /// <dt>
        /// Sop
        /// </dt>
        /// <dd>
        /// <p>The template is a <code>SopRecommendation</code> template.</p>
        /// </dd>
        /// <dt>
        /// Test
        /// </dt>
        /// <dd>
        /// <p>The template is a <code>TestRecommendation</code> template.</p>
        /// </dd>
        /// </dl>
        pub fn set_recommendation_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RenderRecommendationType>>,
        ) -> Self {
            self.recommendation_types = input;
            self
        }
        /// <p>The format of the recommendation template.</p>
        /// <dl>
        /// <dt>
        /// CfnJson
        /// </dt>
        /// <dd>
        /// <p>The template is CloudFormation JSON.</p>
        /// </dd>
        /// <dt>
        /// CfnYaml
        /// </dt>
        /// <dd>
        /// <p>The template is CloudFormation YAML.</p>
        /// </dd>
        /// </dl>
        pub fn format(mut self, input: crate::model::TemplateFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>The format of the recommendation template.</p>
        /// <dl>
        /// <dt>
        /// CfnJson
        /// </dt>
        /// <dd>
        /// <p>The template is CloudFormation JSON.</p>
        /// </dd>
        /// <dt>
        /// CfnYaml
        /// </dt>
        /// <dd>
        /// <p>The template is CloudFormation YAML.</p>
        /// </dd>
        /// </dl>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::TemplateFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the recommendation template.</p>
        pub fn recommendation_template_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_template_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the recommendation template.</p>
        pub fn set_recommendation_template_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_template_arn = input;
            self
        }
        /// <p>The message for the recommendation template.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the recommendation template.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The status of the action.</p>
        pub fn status(mut self, input: crate::model::RecommendationTemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the action.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::RecommendationTemplateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The name for the recommendation template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the recommendation template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The start time for the action.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time for the action.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time for the action.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time for the action.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Indicates if replacements are needed.</p>
        pub fn needs_replacements(mut self, input: bool) -> Self {
            self.needs_replacements = Some(input);
            self
        }
        /// <p>Indicates if replacements are needed.</p>
        pub fn set_needs_replacements(mut self, input: std::option::Option<bool>) -> Self {
            self.needs_replacements = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationTemplate`](crate::model::RecommendationTemplate).
        pub fn build(self) -> crate::model::RecommendationTemplate {
            crate::model::RecommendationTemplate {
                templates_location: self.templates_location,
                assessment_arn: self.assessment_arn,
                app_arn: self.app_arn,
                recommendation_ids: self.recommendation_ids,
                recommendation_types: self.recommendation_types,
                format: self.format,
                recommendation_template_arn: self.recommendation_template_arn,
                message: self.message,
                status: self.status,
                name: self.name,
                start_time: self.start_time,
                end_time: self.end_time,
                tags: self.tags,
                needs_replacements: self.needs_replacements,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("templates_location", &self.templates_location);
            formatter.field("assessment_arn", &self.assessment_arn);
            formatter.field("app_arn", &self.app_arn);
            formatter.field("recommendation_ids", &self.recommendation_ids);
            formatter.field("recommendation_types", &self.recommendation_types);
            formatter.field("format", &self.format);
            formatter.field(
                "recommendation_template_arn",
                &self.recommendation_template_arn,
            );
            formatter.field("message", &self.message);
            formatter.field("status", &self.status);
            formatter.field("name", &self.name);
            formatter.field("start_time", &self.start_time);
            formatter.field("end_time", &self.end_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("needs_replacements", &self.needs_replacements);
            formatter.finish()
        }
    }
}

/// When writing a match expression against `RecommendationTemplateStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recommendationtemplatestatus = unimplemented!();
/// match recommendationtemplatestatus {
///     RecommendationTemplateStatus::Failed => { /* ... */ },
///     RecommendationTemplateStatus::InProgress => { /* ... */ },
///     RecommendationTemplateStatus::Pending => { /* ... */ },
///     RecommendationTemplateStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recommendationtemplatestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecommendationTemplateStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecommendationTemplateStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecommendationTemplateStatus::NewFeature` is defined.
/// Specifically, when `recommendationtemplatestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecommendationTemplateStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecommendationTemplateStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecommendationTemplateStatus {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => RecommendationTemplateStatus::Failed,
            "InProgress" => RecommendationTemplateStatus::InProgress,
            "Pending" => RecommendationTemplateStatus::Pending,
            "Success" => RecommendationTemplateStatus::Success,
            other => RecommendationTemplateStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for RecommendationTemplateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecommendationTemplateStatus::from(s))
    }
}
impl RecommendationTemplateStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecommendationTemplateStatus::Failed => "Failed",
            RecommendationTemplateStatus::InProgress => "InProgress",
            RecommendationTemplateStatus::Pending => "Pending",
            RecommendationTemplateStatus::Success => "Success",
            RecommendationTemplateStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Failed", "InProgress", "Pending", "Success"]
    }
}
impl AsRef<str> for RecommendationTemplateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TemplateFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let templateformat = unimplemented!();
/// match templateformat {
///     TemplateFormat::CfnJson => { /* ... */ },
///     TemplateFormat::CfnYaml => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `templateformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TemplateFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TemplateFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TemplateFormat::NewFeature` is defined.
/// Specifically, when `templateformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TemplateFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TemplateFormat {
    #[allow(missing_docs)] // documentation missing in model
    CfnJson,
    #[allow(missing_docs)] // documentation missing in model
    CfnYaml,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TemplateFormat {
    fn from(s: &str) -> Self {
        match s {
            "CfnJson" => TemplateFormat::CfnJson,
            "CfnYaml" => TemplateFormat::CfnYaml,
            other => TemplateFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TemplateFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TemplateFormat::from(s))
    }
}
impl TemplateFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TemplateFormat::CfnJson => "CfnJson",
            TemplateFormat::CfnYaml => "CfnYaml",
            TemplateFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CfnJson", "CfnYaml"]
    }
}
impl AsRef<str> for TemplateFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RenderRecommendationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let renderrecommendationtype = unimplemented!();
/// match renderrecommendationtype {
///     RenderRecommendationType::Alarm => { /* ... */ },
///     RenderRecommendationType::Sop => { /* ... */ },
///     RenderRecommendationType::Test => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `renderrecommendationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RenderRecommendationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RenderRecommendationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RenderRecommendationType::NewFeature` is defined.
/// Specifically, when `renderrecommendationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RenderRecommendationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RenderRecommendationType {
    #[allow(missing_docs)] // documentation missing in model
    Alarm,
    #[allow(missing_docs)] // documentation missing in model
    Sop,
    #[allow(missing_docs)] // documentation missing in model
    Test,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RenderRecommendationType {
    fn from(s: &str) -> Self {
        match s {
            "Alarm" => RenderRecommendationType::Alarm,
            "Sop" => RenderRecommendationType::Sop,
            "Test" => RenderRecommendationType::Test,
            other => RenderRecommendationType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for RenderRecommendationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RenderRecommendationType::from(s))
    }
}
impl RenderRecommendationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RenderRecommendationType::Alarm => "Alarm",
            RenderRecommendationType::Sop => "Sop",
            RenderRecommendationType::Test => "Test",
            RenderRecommendationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Alarm", "Sop", "Test"]
    }
}
impl AsRef<str> for RenderRecommendationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The location of the Amazon S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Location {
    /// <p>The name of the Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p>The prefix for the Amazon S3 bucket.</p>
    #[doc(hidden)]
    pub prefix: std::option::Option<std::string::String>,
}
impl S3Location {
    /// <p>The name of the Amazon S3 bucket.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p>The prefix for the Amazon S3 bucket.</p>
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
}
impl S3Location {
    /// Creates a new builder-style object to manufacture [`S3Location`](crate::model::S3Location).
    pub fn builder() -> crate::model::s3_location::Builder {
        crate::model::s3_location::Builder::default()
    }
}

/// See [`S3Location`](crate::model::S3Location).
pub mod s3_location {

    /// A builder for [`S3Location`](crate::model::S3Location).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Amazon S3 bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p>The name of the Amazon S3 bucket.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p>The prefix for the Amazon S3 bucket.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        /// <p>The prefix for the Amazon S3 bucket.</p>
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Location`](crate::model::S3Location).
        pub fn build(self) -> crate::model::S3Location {
            crate::model::S3Location {
                bucket: self.bucket,
                prefix: self.prefix,
            }
        }
    }
}

/// <p>The version of the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppVersionSummary {
    /// <p>The version of the application.</p>
    #[doc(hidden)]
    pub app_version: std::option::Option<std::string::String>,
}
impl AppVersionSummary {
    /// <p>The version of the application.</p>
    pub fn app_version(&self) -> std::option::Option<&str> {
        self.app_version.as_deref()
    }
}
impl AppVersionSummary {
    /// Creates a new builder-style object to manufacture [`AppVersionSummary`](crate::model::AppVersionSummary).
    pub fn builder() -> crate::model::app_version_summary::Builder {
        crate::model::app_version_summary::Builder::default()
    }
}

/// See [`AppVersionSummary`](crate::model::AppVersionSummary).
pub mod app_version_summary {

    /// A builder for [`AppVersionSummary`](crate::model::AppVersionSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version of the application.</p>
        pub fn app_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_version = Some(input.into());
            self
        }
        /// <p>The version of the application.</p>
        pub fn set_app_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_version = input;
            self
        }
        /// Consumes the builder and constructs a [`AppVersionSummary`](crate::model::AppVersionSummary).
        pub fn build(self) -> crate::model::AppVersionSummary {
            crate::model::AppVersionSummary {
                app_version: self.app_version,
            }
        }
    }
}

/// <p>Defines a physical resource. A physical resource is a resource that exists in your account. It can be identified using an Amazon Resource Name (ARN) or a Resilience Hub-native identifier. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PhysicalResource {
    /// <p>The name of the resource.</p>
    #[doc(hidden)]
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The logical identifier of the resource.</p>
    #[doc(hidden)]
    pub logical_resource_id: std::option::Option<crate::model::LogicalResourceId>,
    /// <p>The physical identifier of the resource.</p>
    #[doc(hidden)]
    pub physical_resource_id: std::option::Option<crate::model::PhysicalResourceId>,
    /// <p>The type of resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The application components that belong to this resource.</p>
    #[doc(hidden)]
    pub app_components: std::option::Option<std::vec::Vec<crate::model::AppComponent>>,
}
impl PhysicalResource {
    /// <p>The name of the resource.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The logical identifier of the resource.</p>
    pub fn logical_resource_id(&self) -> std::option::Option<&crate::model::LogicalResourceId> {
        self.logical_resource_id.as_ref()
    }
    /// <p>The physical identifier of the resource.</p>
    pub fn physical_resource_id(&self) -> std::option::Option<&crate::model::PhysicalResourceId> {
        self.physical_resource_id.as_ref()
    }
    /// <p>The type of resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The application components that belong to this resource.</p>
    pub fn app_components(&self) -> std::option::Option<&[crate::model::AppComponent]> {
        self.app_components.as_deref()
    }
}
impl PhysicalResource {
    /// Creates a new builder-style object to manufacture [`PhysicalResource`](crate::model::PhysicalResource).
    pub fn builder() -> crate::model::physical_resource::Builder {
        crate::model::physical_resource::Builder::default()
    }
}

/// See [`PhysicalResource`](crate::model::PhysicalResource).
pub mod physical_resource {

    /// A builder for [`PhysicalResource`](crate::model::PhysicalResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) logical_resource_id: std::option::Option<crate::model::LogicalResourceId>,
        pub(crate) physical_resource_id: std::option::Option<crate::model::PhysicalResourceId>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) app_components: std::option::Option<std::vec::Vec<crate::model::AppComponent>>,
    }
    impl Builder {
        /// <p>The name of the resource.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The logical identifier of the resource.</p>
        pub fn logical_resource_id(mut self, input: crate::model::LogicalResourceId) -> Self {
            self.logical_resource_id = Some(input);
            self
        }
        /// <p>The logical identifier of the resource.</p>
        pub fn set_logical_resource_id(
            mut self,
            input: std::option::Option<crate::model::LogicalResourceId>,
        ) -> Self {
            self.logical_resource_id = input;
            self
        }
        /// <p>The physical identifier of the resource.</p>
        pub fn physical_resource_id(mut self, input: crate::model::PhysicalResourceId) -> Self {
            self.physical_resource_id = Some(input);
            self
        }
        /// <p>The physical identifier of the resource.</p>
        pub fn set_physical_resource_id(
            mut self,
            input: std::option::Option<crate::model::PhysicalResourceId>,
        ) -> Self {
            self.physical_resource_id = input;
            self
        }
        /// <p>The type of resource.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Appends an item to `app_components`.
        ///
        /// To override the contents of this collection use [`set_app_components`](Self::set_app_components).
        ///
        /// <p>The application components that belong to this resource.</p>
        pub fn app_components(mut self, input: crate::model::AppComponent) -> Self {
            let mut v = self.app_components.unwrap_or_default();
            v.push(input);
            self.app_components = Some(v);
            self
        }
        /// <p>The application components that belong to this resource.</p>
        pub fn set_app_components(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AppComponent>>,
        ) -> Self {
            self.app_components = input;
            self
        }
        /// Consumes the builder and constructs a [`PhysicalResource`](crate::model::PhysicalResource).
        pub fn build(self) -> crate::model::PhysicalResource {
            crate::model::PhysicalResource {
                resource_name: self.resource_name,
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                resource_type: self.resource_type,
                app_components: self.app_components,
            }
        }
    }
}

/// <p>Defines an application component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppComponent {
    /// <p>The name of the application component.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of application component.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl AppComponent {
    /// <p>The name of the application component.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of application component.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl AppComponent {
    /// Creates a new builder-style object to manufacture [`AppComponent`](crate::model::AppComponent).
    pub fn builder() -> crate::model::app_component::Builder {
        crate::model::app_component::Builder::default()
    }
}

/// See [`AppComponent`](crate::model::AppComponent).
pub mod app_component {

    /// A builder for [`AppComponent`](crate::model::AppComponent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the application component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the application component.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of application component.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of application component.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`AppComponent`](crate::model::AppComponent).
        pub fn build(self) -> crate::model::AppComponent {
            crate::model::AppComponent {
                name: self.name,
                r#type: self.r#type,
            }
        }
    }
}

/// <p>Defines a resource mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceMapping {
    /// <p>The name of the resource this resource is mapped to.</p>
    #[doc(hidden)]
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The name of the CloudFormation stack this resource is mapped to.</p>
    #[doc(hidden)]
    pub logical_stack_name: std::option::Option<std::string::String>,
    /// <p>The name of the application this resource is mapped to.</p>
    #[doc(hidden)]
    pub app_registry_app_name: std::option::Option<std::string::String>,
    /// <p>The name of the resource group this resource is mapped to.</p>
    #[doc(hidden)]
    pub resource_group_name: std::option::Option<std::string::String>,
    /// <p>Specifies the type of resource mapping.</p>
    /// <dl>
    /// <dt>
    /// AppRegistryApp
    /// </dt>
    /// <dd>
    /// <p>The resource is mapped to another application. The name of the application is contained in the <code>appRegistryAppName</code> property.</p>
    /// </dd>
    /// <dt>
    /// CfnStack
    /// </dt>
    /// <dd>
    /// <p>The resource is mapped to a CloudFormation stack. The name of the CloudFormation stack is contained in the <code>logicalStackName</code> property.</p>
    /// </dd>
    /// <dt>
    /// Resource
    /// </dt>
    /// <dd>
    /// <p>The resource is mapped to another resource. The name of the resource is contained in the <code>resourceName</code> property.</p>
    /// </dd>
    /// <dt>
    /// ResourceGroup
    /// </dt>
    /// <dd>
    /// <p>The resource is mapped to a resource group. The name of the resource group is contained in the <code>resourceGroupName</code> property.</p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub mapping_type: std::option::Option<crate::model::ResourceMappingType>,
    /// <p>The identifier of this resource.</p>
    #[doc(hidden)]
    pub physical_resource_id: std::option::Option<crate::model::PhysicalResourceId>,
    /// <p> The short name of the Terraform source. </p>
    #[doc(hidden)]
    pub terraform_source_name: std::option::Option<std::string::String>,
}
impl ResourceMapping {
    /// <p>The name of the resource this resource is mapped to.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The name of the CloudFormation stack this resource is mapped to.</p>
    pub fn logical_stack_name(&self) -> std::option::Option<&str> {
        self.logical_stack_name.as_deref()
    }
    /// <p>The name of the application this resource is mapped to.</p>
    pub fn app_registry_app_name(&self) -> std::option::Option<&str> {
        self.app_registry_app_name.as_deref()
    }
    /// <p>The name of the resource group this resource is mapped to.</p>
    pub fn resource_group_name(&self) -> std::option::Option<&str> {
        self.resource_group_name.as_deref()
    }
    /// <p>Specifies the type of resource mapping.</p>
    /// <dl>
    /// <dt>
    /// AppRegistryApp
    /// </dt>
    /// <dd>
    /// <p>The resource is mapped to another application. The name of the application is contained in the <code>appRegistryAppName</code> property.</p>
    /// </dd>
    /// <dt>
    /// CfnStack
    /// </dt>
    /// <dd>
    /// <p>The resource is mapped to a CloudFormation stack. The name of the CloudFormation stack is contained in the <code>logicalStackName</code> property.</p>
    /// </dd>
    /// <dt>
    /// Resource
    /// </dt>
    /// <dd>
    /// <p>The resource is mapped to another resource. The name of the resource is contained in the <code>resourceName</code> property.</p>
    /// </dd>
    /// <dt>
    /// ResourceGroup
    /// </dt>
    /// <dd>
    /// <p>The resource is mapped to a resource group. The name of the resource group is contained in the <code>resourceGroupName</code> property.</p>
    /// </dd>
    /// </dl>
    pub fn mapping_type(&self) -> std::option::Option<&crate::model::ResourceMappingType> {
        self.mapping_type.as_ref()
    }
    /// <p>The identifier of this resource.</p>
    pub fn physical_resource_id(&self) -> std::option::Option<&crate::model::PhysicalResourceId> {
        self.physical_resource_id.as_ref()
    }
    /// <p> The short name of the Terraform source. </p>
    pub fn terraform_source_name(&self) -> std::option::Option<&str> {
        self.terraform_source_name.as_deref()
    }
}
impl ResourceMapping {
    /// Creates a new builder-style object to manufacture [`ResourceMapping`](crate::model::ResourceMapping).
    pub fn builder() -> crate::model::resource_mapping::Builder {
        crate::model::resource_mapping::Builder::default()
    }
}

/// See [`ResourceMapping`](crate::model::ResourceMapping).
pub mod resource_mapping {

    /// A builder for [`ResourceMapping`](crate::model::ResourceMapping).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) logical_stack_name: std::option::Option<std::string::String>,
        pub(crate) app_registry_app_name: std::option::Option<std::string::String>,
        pub(crate) resource_group_name: std::option::Option<std::string::String>,
        pub(crate) mapping_type: std::option::Option<crate::model::ResourceMappingType>,
        pub(crate) physical_resource_id: std::option::Option<crate::model::PhysicalResourceId>,
        pub(crate) terraform_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the resource this resource is mapped to.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the resource this resource is mapped to.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The name of the CloudFormation stack this resource is mapped to.</p>
        pub fn logical_stack_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.logical_stack_name = Some(input.into());
            self
        }
        /// <p>The name of the CloudFormation stack this resource is mapped to.</p>
        pub fn set_logical_stack_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_stack_name = input;
            self
        }
        /// <p>The name of the application this resource is mapped to.</p>
        pub fn app_registry_app_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_registry_app_name = Some(input.into());
            self
        }
        /// <p>The name of the application this resource is mapped to.</p>
        pub fn set_app_registry_app_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_registry_app_name = input;
            self
        }
        /// <p>The name of the resource group this resource is mapped to.</p>
        pub fn resource_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_group_name = Some(input.into());
            self
        }
        /// <p>The name of the resource group this resource is mapped to.</p>
        pub fn set_resource_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_group_name = input;
            self
        }
        /// <p>Specifies the type of resource mapping.</p>
        /// <dl>
        /// <dt>
        /// AppRegistryApp
        /// </dt>
        /// <dd>
        /// <p>The resource is mapped to another application. The name of the application is contained in the <code>appRegistryAppName</code> property.</p>
        /// </dd>
        /// <dt>
        /// CfnStack
        /// </dt>
        /// <dd>
        /// <p>The resource is mapped to a CloudFormation stack. The name of the CloudFormation stack is contained in the <code>logicalStackName</code> property.</p>
        /// </dd>
        /// <dt>
        /// Resource
        /// </dt>
        /// <dd>
        /// <p>The resource is mapped to another resource. The name of the resource is contained in the <code>resourceName</code> property.</p>
        /// </dd>
        /// <dt>
        /// ResourceGroup
        /// </dt>
        /// <dd>
        /// <p>The resource is mapped to a resource group. The name of the resource group is contained in the <code>resourceGroupName</code> property.</p>
        /// </dd>
        /// </dl>
        pub fn mapping_type(mut self, input: crate::model::ResourceMappingType) -> Self {
            self.mapping_type = Some(input);
            self
        }
        /// <p>Specifies the type of resource mapping.</p>
        /// <dl>
        /// <dt>
        /// AppRegistryApp
        /// </dt>
        /// <dd>
        /// <p>The resource is mapped to another application. The name of the application is contained in the <code>appRegistryAppName</code> property.</p>
        /// </dd>
        /// <dt>
        /// CfnStack
        /// </dt>
        /// <dd>
        /// <p>The resource is mapped to a CloudFormation stack. The name of the CloudFormation stack is contained in the <code>logicalStackName</code> property.</p>
        /// </dd>
        /// <dt>
        /// Resource
        /// </dt>
        /// <dd>
        /// <p>The resource is mapped to another resource. The name of the resource is contained in the <code>resourceName</code> property.</p>
        /// </dd>
        /// <dt>
        /// ResourceGroup
        /// </dt>
        /// <dd>
        /// <p>The resource is mapped to a resource group. The name of the resource group is contained in the <code>resourceGroupName</code> property.</p>
        /// </dd>
        /// </dl>
        pub fn set_mapping_type(
            mut self,
            input: std::option::Option<crate::model::ResourceMappingType>,
        ) -> Self {
            self.mapping_type = input;
            self
        }
        /// <p>The identifier of this resource.</p>
        pub fn physical_resource_id(mut self, input: crate::model::PhysicalResourceId) -> Self {
            self.physical_resource_id = Some(input);
            self
        }
        /// <p>The identifier of this resource.</p>
        pub fn set_physical_resource_id(
            mut self,
            input: std::option::Option<crate::model::PhysicalResourceId>,
        ) -> Self {
            self.physical_resource_id = input;
            self
        }
        /// <p> The short name of the Terraform source. </p>
        pub fn terraform_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.terraform_source_name = Some(input.into());
            self
        }
        /// <p> The short name of the Terraform source. </p>
        pub fn set_terraform_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.terraform_source_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceMapping`](crate::model::ResourceMapping).
        pub fn build(self) -> crate::model::ResourceMapping {
            crate::model::ResourceMapping {
                resource_name: self.resource_name,
                logical_stack_name: self.logical_stack_name,
                app_registry_app_name: self.app_registry_app_name,
                resource_group_name: self.resource_group_name,
                mapping_type: self.mapping_type,
                physical_resource_id: self.physical_resource_id,
                terraform_source_name: self.terraform_source_name,
            }
        }
    }
}

/// When writing a match expression against `ResourceMappingType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcemappingtype = unimplemented!();
/// match resourcemappingtype {
///     ResourceMappingType::AppRegistryApp => { /* ... */ },
///     ResourceMappingType::CfnStack => { /* ... */ },
///     ResourceMappingType::Resource => { /* ... */ },
///     ResourceMappingType::ResourceGroup => { /* ... */ },
///     ResourceMappingType::Terraform => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcemappingtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceMappingType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceMappingType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceMappingType::NewFeature` is defined.
/// Specifically, when `resourcemappingtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceMappingType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceMappingType {
    #[allow(missing_docs)] // documentation missing in model
    AppRegistryApp,
    #[allow(missing_docs)] // documentation missing in model
    CfnStack,
    #[allow(missing_docs)] // documentation missing in model
    Resource,
    #[allow(missing_docs)] // documentation missing in model
    ResourceGroup,
    #[allow(missing_docs)] // documentation missing in model
    Terraform,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceMappingType {
    fn from(s: &str) -> Self {
        match s {
            "AppRegistryApp" => ResourceMappingType::AppRegistryApp,
            "CfnStack" => ResourceMappingType::CfnStack,
            "Resource" => ResourceMappingType::Resource,
            "ResourceGroup" => ResourceMappingType::ResourceGroup,
            "Terraform" => ResourceMappingType::Terraform,
            other => {
                ResourceMappingType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ResourceMappingType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceMappingType::from(s))
    }
}
impl ResourceMappingType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceMappingType::AppRegistryApp => "AppRegistryApp",
            ResourceMappingType::CfnStack => "CfnStack",
            ResourceMappingType::Resource => "Resource",
            ResourceMappingType::ResourceGroup => "ResourceGroup",
            ResourceMappingType::Terraform => "Terraform",
            ResourceMappingType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AppRegistryApp",
            "CfnStack",
            "Resource",
            "ResourceGroup",
            "Terraform",
        ]
    }
}
impl AsRef<str> for ResourceMappingType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines an application summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppSummary {
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub app_arn: std::option::Option<std::string::String>,
    /// <p>The name of the application.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The optional description for an app.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The timestamp for when the app was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current status of compliance for the resiliency policy.</p>
    #[doc(hidden)]
    pub compliance_status: std::option::Option<crate::model::AppComplianceStatusType>,
    /// <p>The current resiliency score for the application.</p>
    #[doc(hidden)]
    pub resiliency_score: f64,
    /// <p> Assessment execution schedule with 'Daily' or 'Disabled' values. </p>
    #[doc(hidden)]
    pub assessment_schedule: std::option::Option<crate::model::AppAssessmentScheduleType>,
    /// <p>The status of the application.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AppStatusType>,
}
impl AppSummary {
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn app_arn(&self) -> std::option::Option<&str> {
        self.app_arn.as_deref()
    }
    /// <p>The name of the application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The optional description for an app.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The timestamp for when the app was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The current status of compliance for the resiliency policy.</p>
    pub fn compliance_status(&self) -> std::option::Option<&crate::model::AppComplianceStatusType> {
        self.compliance_status.as_ref()
    }
    /// <p>The current resiliency score for the application.</p>
    pub fn resiliency_score(&self) -> f64 {
        self.resiliency_score
    }
    /// <p> Assessment execution schedule with 'Daily' or 'Disabled' values. </p>
    pub fn assessment_schedule(
        &self,
    ) -> std::option::Option<&crate::model::AppAssessmentScheduleType> {
        self.assessment_schedule.as_ref()
    }
    /// <p>The status of the application.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AppStatusType> {
        self.status.as_ref()
    }
}
impl AppSummary {
    /// Creates a new builder-style object to manufacture [`AppSummary`](crate::model::AppSummary).
    pub fn builder() -> crate::model::app_summary::Builder {
        crate::model::app_summary::Builder::default()
    }
}

/// See [`AppSummary`](crate::model::AppSummary).
pub mod app_summary {

    /// A builder for [`AppSummary`](crate::model::AppSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) compliance_status: std::option::Option<crate::model::AppComplianceStatusType>,
        pub(crate) resiliency_score: std::option::Option<f64>,
        pub(crate) assessment_schedule:
            std::option::Option<crate::model::AppAssessmentScheduleType>,
        pub(crate) status: std::option::Option<crate::model::AppStatusType>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn app_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_app_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_arn = input;
            self
        }
        /// <p>The name of the application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The optional description for an app.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The optional description for an app.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The timestamp for when the app was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The timestamp for when the app was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The current status of compliance for the resiliency policy.</p>
        pub fn compliance_status(mut self, input: crate::model::AppComplianceStatusType) -> Self {
            self.compliance_status = Some(input);
            self
        }
        /// <p>The current status of compliance for the resiliency policy.</p>
        pub fn set_compliance_status(
            mut self,
            input: std::option::Option<crate::model::AppComplianceStatusType>,
        ) -> Self {
            self.compliance_status = input;
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn resiliency_score(mut self, input: f64) -> Self {
            self.resiliency_score = Some(input);
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn set_resiliency_score(mut self, input: std::option::Option<f64>) -> Self {
            self.resiliency_score = input;
            self
        }
        /// <p> Assessment execution schedule with 'Daily' or 'Disabled' values. </p>
        pub fn assessment_schedule(
            mut self,
            input: crate::model::AppAssessmentScheduleType,
        ) -> Self {
            self.assessment_schedule = Some(input);
            self
        }
        /// <p> Assessment execution schedule with 'Daily' or 'Disabled' values. </p>
        pub fn set_assessment_schedule(
            mut self,
            input: std::option::Option<crate::model::AppAssessmentScheduleType>,
        ) -> Self {
            self.assessment_schedule = input;
            self
        }
        /// <p>The status of the application.</p>
        pub fn status(mut self, input: crate::model::AppStatusType) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the application.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AppStatusType>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AppSummary`](crate::model::AppSummary).
        pub fn build(self) -> crate::model::AppSummary {
            crate::model::AppSummary {
                app_arn: self.app_arn,
                name: self.name,
                description: self.description,
                creation_time: self.creation_time,
                compliance_status: self.compliance_status,
                resiliency_score: self.resiliency_score.unwrap_or_default(),
                assessment_schedule: self.assessment_schedule,
                status: self.status,
            }
        }
    }
}

/// <p>Defines recommendations for a Resilience Hub application component, returned as an object. This object contains component names, configuration recommendations, and recommendation statuses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComponentRecommendation {
    /// <p>The name of the application component.</p>
    #[doc(hidden)]
    pub app_component_name: std::option::Option<std::string::String>,
    /// <p>The recommendation status.</p>
    #[doc(hidden)]
    pub recommendation_status: std::option::Option<crate::model::RecommendationComplianceStatus>,
    /// <p>The list of recommendations.</p>
    #[doc(hidden)]
    pub config_recommendations:
        std::option::Option<std::vec::Vec<crate::model::ConfigRecommendation>>,
}
impl ComponentRecommendation {
    /// <p>The name of the application component.</p>
    pub fn app_component_name(&self) -> std::option::Option<&str> {
        self.app_component_name.as_deref()
    }
    /// <p>The recommendation status.</p>
    pub fn recommendation_status(
        &self,
    ) -> std::option::Option<&crate::model::RecommendationComplianceStatus> {
        self.recommendation_status.as_ref()
    }
    /// <p>The list of recommendations.</p>
    pub fn config_recommendations(
        &self,
    ) -> std::option::Option<&[crate::model::ConfigRecommendation]> {
        self.config_recommendations.as_deref()
    }
}
impl ComponentRecommendation {
    /// Creates a new builder-style object to manufacture [`ComponentRecommendation`](crate::model::ComponentRecommendation).
    pub fn builder() -> crate::model::component_recommendation::Builder {
        crate::model::component_recommendation::Builder::default()
    }
}

/// See [`ComponentRecommendation`](crate::model::ComponentRecommendation).
pub mod component_recommendation {

    /// A builder for [`ComponentRecommendation`](crate::model::ComponentRecommendation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_component_name: std::option::Option<std::string::String>,
        pub(crate) recommendation_status:
            std::option::Option<crate::model::RecommendationComplianceStatus>,
        pub(crate) config_recommendations:
            std::option::Option<std::vec::Vec<crate::model::ConfigRecommendation>>,
    }
    impl Builder {
        /// <p>The name of the application component.</p>
        pub fn app_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_component_name = Some(input.into());
            self
        }
        /// <p>The name of the application component.</p>
        pub fn set_app_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_component_name = input;
            self
        }
        /// <p>The recommendation status.</p>
        pub fn recommendation_status(
            mut self,
            input: crate::model::RecommendationComplianceStatus,
        ) -> Self {
            self.recommendation_status = Some(input);
            self
        }
        /// <p>The recommendation status.</p>
        pub fn set_recommendation_status(
            mut self,
            input: std::option::Option<crate::model::RecommendationComplianceStatus>,
        ) -> Self {
            self.recommendation_status = input;
            self
        }
        /// Appends an item to `config_recommendations`.
        ///
        /// To override the contents of this collection use [`set_config_recommendations`](Self::set_config_recommendations).
        ///
        /// <p>The list of recommendations.</p>
        pub fn config_recommendations(mut self, input: crate::model::ConfigRecommendation) -> Self {
            let mut v = self.config_recommendations.unwrap_or_default();
            v.push(input);
            self.config_recommendations = Some(v);
            self
        }
        /// <p>The list of recommendations.</p>
        pub fn set_config_recommendations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ConfigRecommendation>>,
        ) -> Self {
            self.config_recommendations = input;
            self
        }
        /// Consumes the builder and constructs a [`ComponentRecommendation`](crate::model::ComponentRecommendation).
        pub fn build(self) -> crate::model::ComponentRecommendation {
            crate::model::ComponentRecommendation {
                app_component_name: self.app_component_name,
                recommendation_status: self.recommendation_status,
                config_recommendations: self.config_recommendations,
            }
        }
    }
}

/// <p>Defines a configuration recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigRecommendation {
    /// <p>The cost for the application.</p>
    #[doc(hidden)]
    pub cost: std::option::Option<crate::model::Cost>,
    /// <p>The application component name.</p>
    #[doc(hidden)]
    pub app_component_name: std::option::Option<std::string::String>,
    /// <p>The current compliance against the resiliency policy before applying the configuration change.</p>
    #[doc(hidden)]
    pub compliance: std::option::Option<
        std::collections::HashMap<crate::model::DisruptionType, crate::model::DisruptionCompliance>,
    >,
    /// <p>The expected compliance against the resiliency policy after applying the configuration change.</p>
    #[doc(hidden)]
    pub recommendation_compliance: std::option::Option<
        std::collections::HashMap<
            crate::model::DisruptionType,
            crate::model::RecommendationDisruptionCompliance,
        >,
    >,
    /// <p>The type of optimization.</p>
    #[doc(hidden)]
    pub optimization_type: std::option::Option<crate::model::ConfigRecommendationOptimizationType>,
    /// <p>The name of the recommendation configuration.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The optional description for an app.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>List of the suggested configuration changes.</p>
    #[doc(hidden)]
    pub suggested_changes: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The architecture type.</p>
    #[doc(hidden)]
    pub ha_architecture: std::option::Option<crate::model::HaArchitecture>,
    /// <p>The reference identifier for the recommendation configuration.</p>
    #[doc(hidden)]
    pub reference_id: std::option::Option<std::string::String>,
}
impl ConfigRecommendation {
    /// <p>The cost for the application.</p>
    pub fn cost(&self) -> std::option::Option<&crate::model::Cost> {
        self.cost.as_ref()
    }
    /// <p>The application component name.</p>
    pub fn app_component_name(&self) -> std::option::Option<&str> {
        self.app_component_name.as_deref()
    }
    /// <p>The current compliance against the resiliency policy before applying the configuration change.</p>
    pub fn compliance(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            crate::model::DisruptionType,
            crate::model::DisruptionCompliance,
        >,
    > {
        self.compliance.as_ref()
    }
    /// <p>The expected compliance against the resiliency policy after applying the configuration change.</p>
    pub fn recommendation_compliance(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            crate::model::DisruptionType,
            crate::model::RecommendationDisruptionCompliance,
        >,
    > {
        self.recommendation_compliance.as_ref()
    }
    /// <p>The type of optimization.</p>
    pub fn optimization_type(
        &self,
    ) -> std::option::Option<&crate::model::ConfigRecommendationOptimizationType> {
        self.optimization_type.as_ref()
    }
    /// <p>The name of the recommendation configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The optional description for an app.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>List of the suggested configuration changes.</p>
    pub fn suggested_changes(&self) -> std::option::Option<&[std::string::String]> {
        self.suggested_changes.as_deref()
    }
    /// <p>The architecture type.</p>
    pub fn ha_architecture(&self) -> std::option::Option<&crate::model::HaArchitecture> {
        self.ha_architecture.as_ref()
    }
    /// <p>The reference identifier for the recommendation configuration.</p>
    pub fn reference_id(&self) -> std::option::Option<&str> {
        self.reference_id.as_deref()
    }
}
impl ConfigRecommendation {
    /// Creates a new builder-style object to manufacture [`ConfigRecommendation`](crate::model::ConfigRecommendation).
    pub fn builder() -> crate::model::config_recommendation::Builder {
        crate::model::config_recommendation::Builder::default()
    }
}

/// See [`ConfigRecommendation`](crate::model::ConfigRecommendation).
pub mod config_recommendation {

    /// A builder for [`ConfigRecommendation`](crate::model::ConfigRecommendation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cost: std::option::Option<crate::model::Cost>,
        pub(crate) app_component_name: std::option::Option<std::string::String>,
        pub(crate) compliance: std::option::Option<
            std::collections::HashMap<
                crate::model::DisruptionType,
                crate::model::DisruptionCompliance,
            >,
        >,
        pub(crate) recommendation_compliance: std::option::Option<
            std::collections::HashMap<
                crate::model::DisruptionType,
                crate::model::RecommendationDisruptionCompliance,
            >,
        >,
        pub(crate) optimization_type:
            std::option::Option<crate::model::ConfigRecommendationOptimizationType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) suggested_changes: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) ha_architecture: std::option::Option<crate::model::HaArchitecture>,
        pub(crate) reference_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The cost for the application.</p>
        pub fn cost(mut self, input: crate::model::Cost) -> Self {
            self.cost = Some(input);
            self
        }
        /// <p>The cost for the application.</p>
        pub fn set_cost(mut self, input: std::option::Option<crate::model::Cost>) -> Self {
            self.cost = input;
            self
        }
        /// <p>The application component name.</p>
        pub fn app_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_component_name = Some(input.into());
            self
        }
        /// <p>The application component name.</p>
        pub fn set_app_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_component_name = input;
            self
        }
        /// Adds a key-value pair to `compliance`.
        ///
        /// To override the contents of this collection use [`set_compliance`](Self::set_compliance).
        ///
        /// <p>The current compliance against the resiliency policy before applying the configuration change.</p>
        pub fn compliance(
            mut self,
            k: crate::model::DisruptionType,
            v: crate::model::DisruptionCompliance,
        ) -> Self {
            let mut hash_map = self.compliance.unwrap_or_default();
            hash_map.insert(k, v);
            self.compliance = Some(hash_map);
            self
        }
        /// <p>The current compliance against the resiliency policy before applying the configuration change.</p>
        pub fn set_compliance(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::DisruptionType,
                    crate::model::DisruptionCompliance,
                >,
            >,
        ) -> Self {
            self.compliance = input;
            self
        }
        /// Adds a key-value pair to `recommendation_compliance`.
        ///
        /// To override the contents of this collection use [`set_recommendation_compliance`](Self::set_recommendation_compliance).
        ///
        /// <p>The expected compliance against the resiliency policy after applying the configuration change.</p>
        pub fn recommendation_compliance(
            mut self,
            k: crate::model::DisruptionType,
            v: crate::model::RecommendationDisruptionCompliance,
        ) -> Self {
            let mut hash_map = self.recommendation_compliance.unwrap_or_default();
            hash_map.insert(k, v);
            self.recommendation_compliance = Some(hash_map);
            self
        }
        /// <p>The expected compliance against the resiliency policy after applying the configuration change.</p>
        pub fn set_recommendation_compliance(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::DisruptionType,
                    crate::model::RecommendationDisruptionCompliance,
                >,
            >,
        ) -> Self {
            self.recommendation_compliance = input;
            self
        }
        /// <p>The type of optimization.</p>
        pub fn optimization_type(
            mut self,
            input: crate::model::ConfigRecommendationOptimizationType,
        ) -> Self {
            self.optimization_type = Some(input);
            self
        }
        /// <p>The type of optimization.</p>
        pub fn set_optimization_type(
            mut self,
            input: std::option::Option<crate::model::ConfigRecommendationOptimizationType>,
        ) -> Self {
            self.optimization_type = input;
            self
        }
        /// <p>The name of the recommendation configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the recommendation configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The optional description for an app.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The optional description for an app.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `suggested_changes`.
        ///
        /// To override the contents of this collection use [`set_suggested_changes`](Self::set_suggested_changes).
        ///
        /// <p>List of the suggested configuration changes.</p>
        pub fn suggested_changes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.suggested_changes.unwrap_or_default();
            v.push(input.into());
            self.suggested_changes = Some(v);
            self
        }
        /// <p>List of the suggested configuration changes.</p>
        pub fn set_suggested_changes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.suggested_changes = input;
            self
        }
        /// <p>The architecture type.</p>
        pub fn ha_architecture(mut self, input: crate::model::HaArchitecture) -> Self {
            self.ha_architecture = Some(input);
            self
        }
        /// <p>The architecture type.</p>
        pub fn set_ha_architecture(
            mut self,
            input: std::option::Option<crate::model::HaArchitecture>,
        ) -> Self {
            self.ha_architecture = input;
            self
        }
        /// <p>The reference identifier for the recommendation configuration.</p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_id = Some(input.into());
            self
        }
        /// <p>The reference identifier for the recommendation configuration.</p>
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigRecommendation`](crate::model::ConfigRecommendation).
        pub fn build(self) -> crate::model::ConfigRecommendation {
            crate::model::ConfigRecommendation {
                cost: self.cost,
                app_component_name: self.app_component_name,
                compliance: self.compliance,
                recommendation_compliance: self.recommendation_compliance,
                optimization_type: self.optimization_type,
                name: self.name,
                description: self.description,
                suggested_changes: self.suggested_changes,
                ha_architecture: self.ha_architecture,
                reference_id: self.reference_id,
            }
        }
    }
}

/// When writing a match expression against `HaArchitecture`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let haarchitecture = unimplemented!();
/// match haarchitecture {
///     HaArchitecture::BackupAndRestore => { /* ... */ },
///     HaArchitecture::MultiSite => { /* ... */ },
///     HaArchitecture::NoRecoveryPlan => { /* ... */ },
///     HaArchitecture::PilotLight => { /* ... */ },
///     HaArchitecture::WarmStandby => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `haarchitecture` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HaArchitecture::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HaArchitecture::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HaArchitecture::NewFeature` is defined.
/// Specifically, when `haarchitecture` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HaArchitecture::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HaArchitecture {
    #[allow(missing_docs)] // documentation missing in model
    BackupAndRestore,
    #[allow(missing_docs)] // documentation missing in model
    MultiSite,
    #[allow(missing_docs)] // documentation missing in model
    NoRecoveryPlan,
    #[allow(missing_docs)] // documentation missing in model
    PilotLight,
    #[allow(missing_docs)] // documentation missing in model
    WarmStandby,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HaArchitecture {
    fn from(s: &str) -> Self {
        match s {
            "BackupAndRestore" => HaArchitecture::BackupAndRestore,
            "MultiSite" => HaArchitecture::MultiSite,
            "NoRecoveryPlan" => HaArchitecture::NoRecoveryPlan,
            "PilotLight" => HaArchitecture::PilotLight,
            "WarmStandby" => HaArchitecture::WarmStandby,
            other => HaArchitecture::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for HaArchitecture {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HaArchitecture::from(s))
    }
}
impl HaArchitecture {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HaArchitecture::BackupAndRestore => "BackupAndRestore",
            HaArchitecture::MultiSite => "MultiSite",
            HaArchitecture::NoRecoveryPlan => "NoRecoveryPlan",
            HaArchitecture::PilotLight => "PilotLight",
            HaArchitecture::WarmStandby => "WarmStandby",
            HaArchitecture::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BackupAndRestore",
            "MultiSite",
            "NoRecoveryPlan",
            "PilotLight",
            "WarmStandby",
        ]
    }
}
impl AsRef<str> for HaArchitecture {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConfigRecommendationOptimizationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let configrecommendationoptimizationtype = unimplemented!();
/// match configrecommendationoptimizationtype {
///     ConfigRecommendationOptimizationType::BestAzRecovery => { /* ... */ },
///     ConfigRecommendationOptimizationType::BestAttainable => { /* ... */ },
///     ConfigRecommendationOptimizationType::BestRegionRecovery => { /* ... */ },
///     ConfigRecommendationOptimizationType::LeastChange => { /* ... */ },
///     ConfigRecommendationOptimizationType::LeastCost => { /* ... */ },
///     ConfigRecommendationOptimizationType::LeastErrors => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `configrecommendationoptimizationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfigRecommendationOptimizationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfigRecommendationOptimizationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfigRecommendationOptimizationType::NewFeature` is defined.
/// Specifically, when `configrecommendationoptimizationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfigRecommendationOptimizationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigRecommendationOptimizationType {
    #[allow(missing_docs)] // documentation missing in model
    BestAzRecovery,
    #[allow(missing_docs)] // documentation missing in model
    BestAttainable,
    #[allow(missing_docs)] // documentation missing in model
    BestRegionRecovery,
    #[allow(missing_docs)] // documentation missing in model
    LeastChange,
    #[allow(missing_docs)] // documentation missing in model
    LeastCost,
    #[allow(missing_docs)] // documentation missing in model
    LeastErrors,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfigRecommendationOptimizationType {
    fn from(s: &str) -> Self {
        match s {
            "BestAZRecovery" => ConfigRecommendationOptimizationType::BestAzRecovery,
            "BestAttainable" => ConfigRecommendationOptimizationType::BestAttainable,
            "BestRegionRecovery" => ConfigRecommendationOptimizationType::BestRegionRecovery,
            "LeastChange" => ConfigRecommendationOptimizationType::LeastChange,
            "LeastCost" => ConfigRecommendationOptimizationType::LeastCost,
            "LeastErrors" => ConfigRecommendationOptimizationType::LeastErrors,
            other => ConfigRecommendationOptimizationType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ConfigRecommendationOptimizationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigRecommendationOptimizationType::from(s))
    }
}
impl ConfigRecommendationOptimizationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigRecommendationOptimizationType::BestAzRecovery => "BestAZRecovery",
            ConfigRecommendationOptimizationType::BestAttainable => "BestAttainable",
            ConfigRecommendationOptimizationType::BestRegionRecovery => "BestRegionRecovery",
            ConfigRecommendationOptimizationType::LeastChange => "LeastChange",
            ConfigRecommendationOptimizationType::LeastCost => "LeastCost",
            ConfigRecommendationOptimizationType::LeastErrors => "LeastErrors",
            ConfigRecommendationOptimizationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BestAZRecovery",
            "BestAttainable",
            "BestRegionRecovery",
            "LeastChange",
            "LeastCost",
            "LeastErrors",
        ]
    }
}
impl AsRef<str> for ConfigRecommendationOptimizationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines a disruption compliance recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecommendationDisruptionCompliance {
    /// <p>The expected compliance status after applying the recommended configuration change.</p>
    #[doc(hidden)]
    pub expected_compliance_status: std::option::Option<crate::model::ComplianceStatus>,
    /// <p>The expected RTO after applying the recommended configuration change.</p>
    #[doc(hidden)]
    pub expected_rto_in_secs: i32,
    /// <p>The expected Recovery Time Objective (RTO) description after applying the recommended configuration change.</p>
    #[doc(hidden)]
    pub expected_rto_description: std::option::Option<std::string::String>,
    /// <p>The expected RPO after applying the recommended configuration change.</p>
    #[doc(hidden)]
    pub expected_rpo_in_secs: i32,
    /// <p>The expected Recovery Point Objective (RPO) description after applying the recommended configuration change.</p>
    #[doc(hidden)]
    pub expected_rpo_description: std::option::Option<std::string::String>,
}
impl RecommendationDisruptionCompliance {
    /// <p>The expected compliance status after applying the recommended configuration change.</p>
    pub fn expected_compliance_status(
        &self,
    ) -> std::option::Option<&crate::model::ComplianceStatus> {
        self.expected_compliance_status.as_ref()
    }
    /// <p>The expected RTO after applying the recommended configuration change.</p>
    pub fn expected_rto_in_secs(&self) -> i32 {
        self.expected_rto_in_secs
    }
    /// <p>The expected Recovery Time Objective (RTO) description after applying the recommended configuration change.</p>
    pub fn expected_rto_description(&self) -> std::option::Option<&str> {
        self.expected_rto_description.as_deref()
    }
    /// <p>The expected RPO after applying the recommended configuration change.</p>
    pub fn expected_rpo_in_secs(&self) -> i32 {
        self.expected_rpo_in_secs
    }
    /// <p>The expected Recovery Point Objective (RPO) description after applying the recommended configuration change.</p>
    pub fn expected_rpo_description(&self) -> std::option::Option<&str> {
        self.expected_rpo_description.as_deref()
    }
}
impl RecommendationDisruptionCompliance {
    /// Creates a new builder-style object to manufacture [`RecommendationDisruptionCompliance`](crate::model::RecommendationDisruptionCompliance).
    pub fn builder() -> crate::model::recommendation_disruption_compliance::Builder {
        crate::model::recommendation_disruption_compliance::Builder::default()
    }
}

/// See [`RecommendationDisruptionCompliance`](crate::model::RecommendationDisruptionCompliance).
pub mod recommendation_disruption_compliance {

    /// A builder for [`RecommendationDisruptionCompliance`](crate::model::RecommendationDisruptionCompliance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expected_compliance_status: std::option::Option<crate::model::ComplianceStatus>,
        pub(crate) expected_rto_in_secs: std::option::Option<i32>,
        pub(crate) expected_rto_description: std::option::Option<std::string::String>,
        pub(crate) expected_rpo_in_secs: std::option::Option<i32>,
        pub(crate) expected_rpo_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The expected compliance status after applying the recommended configuration change.</p>
        pub fn expected_compliance_status(mut self, input: crate::model::ComplianceStatus) -> Self {
            self.expected_compliance_status = Some(input);
            self
        }
        /// <p>The expected compliance status after applying the recommended configuration change.</p>
        pub fn set_expected_compliance_status(
            mut self,
            input: std::option::Option<crate::model::ComplianceStatus>,
        ) -> Self {
            self.expected_compliance_status = input;
            self
        }
        /// <p>The expected RTO after applying the recommended configuration change.</p>
        pub fn expected_rto_in_secs(mut self, input: i32) -> Self {
            self.expected_rto_in_secs = Some(input);
            self
        }
        /// <p>The expected RTO after applying the recommended configuration change.</p>
        pub fn set_expected_rto_in_secs(mut self, input: std::option::Option<i32>) -> Self {
            self.expected_rto_in_secs = input;
            self
        }
        /// <p>The expected Recovery Time Objective (RTO) description after applying the recommended configuration change.</p>
        pub fn expected_rto_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_rto_description = Some(input.into());
            self
        }
        /// <p>The expected Recovery Time Objective (RTO) description after applying the recommended configuration change.</p>
        pub fn set_expected_rto_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_rto_description = input;
            self
        }
        /// <p>The expected RPO after applying the recommended configuration change.</p>
        pub fn expected_rpo_in_secs(mut self, input: i32) -> Self {
            self.expected_rpo_in_secs = Some(input);
            self
        }
        /// <p>The expected RPO after applying the recommended configuration change.</p>
        pub fn set_expected_rpo_in_secs(mut self, input: std::option::Option<i32>) -> Self {
            self.expected_rpo_in_secs = input;
            self
        }
        /// <p>The expected Recovery Point Objective (RPO) description after applying the recommended configuration change.</p>
        pub fn expected_rpo_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_rpo_description = Some(input.into());
            self
        }
        /// <p>The expected Recovery Point Objective (RPO) description after applying the recommended configuration change.</p>
        pub fn set_expected_rpo_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_rpo_description = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommendationDisruptionCompliance`](crate::model::RecommendationDisruptionCompliance).
        pub fn build(self) -> crate::model::RecommendationDisruptionCompliance {
            crate::model::RecommendationDisruptionCompliance {
                expected_compliance_status: self.expected_compliance_status,
                expected_rto_in_secs: self.expected_rto_in_secs.unwrap_or_default(),
                expected_rto_description: self.expected_rto_description,
                expected_rpo_in_secs: self.expected_rpo_in_secs.unwrap_or_default(),
                expected_rpo_description: self.expected_rpo_description,
            }
        }
    }
}

/// When writing a match expression against `RecommendationComplianceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recommendationcompliancestatus = unimplemented!();
/// match recommendationcompliancestatus {
///     RecommendationComplianceStatus::BreachedCanMeet => { /* ... */ },
///     RecommendationComplianceStatus::BreachedUnattainable => { /* ... */ },
///     RecommendationComplianceStatus::MetCanImprove => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recommendationcompliancestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecommendationComplianceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecommendationComplianceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecommendationComplianceStatus::NewFeature` is defined.
/// Specifically, when `recommendationcompliancestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecommendationComplianceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecommendationComplianceStatus {
    #[allow(missing_docs)] // documentation missing in model
    BreachedCanMeet,
    #[allow(missing_docs)] // documentation missing in model
    BreachedUnattainable,
    #[allow(missing_docs)] // documentation missing in model
    MetCanImprove,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecommendationComplianceStatus {
    fn from(s: &str) -> Self {
        match s {
            "BreachedCanMeet" => RecommendationComplianceStatus::BreachedCanMeet,
            "BreachedUnattainable" => RecommendationComplianceStatus::BreachedUnattainable,
            "MetCanImprove" => RecommendationComplianceStatus::MetCanImprove,
            other => RecommendationComplianceStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for RecommendationComplianceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecommendationComplianceStatus::from(s))
    }
}
impl RecommendationComplianceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecommendationComplianceStatus::BreachedCanMeet => "BreachedCanMeet",
            RecommendationComplianceStatus::BreachedUnattainable => "BreachedUnattainable",
            RecommendationComplianceStatus::MetCanImprove => "MetCanImprove",
            RecommendationComplianceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BreachedCanMeet", "BreachedUnattainable", "MetCanImprove"]
    }
}
impl AsRef<str> for RecommendationComplianceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Defines the compliance of an application component against the resiliency policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppComponentCompliance {
    /// <p>The cost for the application.</p>
    #[doc(hidden)]
    pub cost: std::option::Option<crate::model::Cost>,
    /// <p>The name of the application component.</p>
    #[doc(hidden)]
    pub app_component_name: std::option::Option<std::string::String>,
    /// <p>The compliance of the application component against the resiliency policy.</p>
    #[doc(hidden)]
    pub compliance: std::option::Option<
        std::collections::HashMap<crate::model::DisruptionType, crate::model::DisruptionCompliance>,
    >,
    /// <p>The compliance message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The status of the action.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ComplianceStatus>,
    /// <p>The current resiliency score for the application.</p>
    #[doc(hidden)]
    pub resiliency_score: std::option::Option<crate::model::ResiliencyScore>,
}
impl AppComponentCompliance {
    /// <p>The cost for the application.</p>
    pub fn cost(&self) -> std::option::Option<&crate::model::Cost> {
        self.cost.as_ref()
    }
    /// <p>The name of the application component.</p>
    pub fn app_component_name(&self) -> std::option::Option<&str> {
        self.app_component_name.as_deref()
    }
    /// <p>The compliance of the application component against the resiliency policy.</p>
    pub fn compliance(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            crate::model::DisruptionType,
            crate::model::DisruptionCompliance,
        >,
    > {
        self.compliance.as_ref()
    }
    /// <p>The compliance message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The status of the action.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ComplianceStatus> {
        self.status.as_ref()
    }
    /// <p>The current resiliency score for the application.</p>
    pub fn resiliency_score(&self) -> std::option::Option<&crate::model::ResiliencyScore> {
        self.resiliency_score.as_ref()
    }
}
impl AppComponentCompliance {
    /// Creates a new builder-style object to manufacture [`AppComponentCompliance`](crate::model::AppComponentCompliance).
    pub fn builder() -> crate::model::app_component_compliance::Builder {
        crate::model::app_component_compliance::Builder::default()
    }
}

/// See [`AppComponentCompliance`](crate::model::AppComponentCompliance).
pub mod app_component_compliance {

    /// A builder for [`AppComponentCompliance`](crate::model::AppComponentCompliance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cost: std::option::Option<crate::model::Cost>,
        pub(crate) app_component_name: std::option::Option<std::string::String>,
        pub(crate) compliance: std::option::Option<
            std::collections::HashMap<
                crate::model::DisruptionType,
                crate::model::DisruptionCompliance,
            >,
        >,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ComplianceStatus>,
        pub(crate) resiliency_score: std::option::Option<crate::model::ResiliencyScore>,
    }
    impl Builder {
        /// <p>The cost for the application.</p>
        pub fn cost(mut self, input: crate::model::Cost) -> Self {
            self.cost = Some(input);
            self
        }
        /// <p>The cost for the application.</p>
        pub fn set_cost(mut self, input: std::option::Option<crate::model::Cost>) -> Self {
            self.cost = input;
            self
        }
        /// <p>The name of the application component.</p>
        pub fn app_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_component_name = Some(input.into());
            self
        }
        /// <p>The name of the application component.</p>
        pub fn set_app_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_component_name = input;
            self
        }
        /// Adds a key-value pair to `compliance`.
        ///
        /// To override the contents of this collection use [`set_compliance`](Self::set_compliance).
        ///
        /// <p>The compliance of the application component against the resiliency policy.</p>
        pub fn compliance(
            mut self,
            k: crate::model::DisruptionType,
            v: crate::model::DisruptionCompliance,
        ) -> Self {
            let mut hash_map = self.compliance.unwrap_or_default();
            hash_map.insert(k, v);
            self.compliance = Some(hash_map);
            self
        }
        /// <p>The compliance of the application component against the resiliency policy.</p>
        pub fn set_compliance(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::DisruptionType,
                    crate::model::DisruptionCompliance,
                >,
            >,
        ) -> Self {
            self.compliance = input;
            self
        }
        /// <p>The compliance message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The compliance message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The status of the action.</p>
        pub fn status(mut self, input: crate::model::ComplianceStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the action.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ComplianceStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn resiliency_score(mut self, input: crate::model::ResiliencyScore) -> Self {
            self.resiliency_score = Some(input);
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn set_resiliency_score(
            mut self,
            input: std::option::Option<crate::model::ResiliencyScore>,
        ) -> Self {
            self.resiliency_score = input;
            self
        }
        /// Consumes the builder and constructs a [`AppComponentCompliance`](crate::model::AppComponentCompliance).
        pub fn build(self) -> crate::model::AppComponentCompliance {
            crate::model::AppComponentCompliance {
                cost: self.cost,
                app_component_name: self.app_component_name,
                compliance: self.compliance,
                message: self.message,
                status: self.status,
                resiliency_score: self.resiliency_score,
            }
        }
    }
}

/// <p>Defines an application assessment summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppAssessmentSummary {
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub app_arn: std::option::Option<std::string::String>,
    /// <p>The version of the application.</p>
    #[doc(hidden)]
    pub app_version: std::option::Option<std::string::String>,
    /// <p>The current status of the assessment for the resiliency policy.</p>
    #[doc(hidden)]
    pub assessment_status: std::option::Option<crate::model::AssessmentStatus>,
    /// <p>The entity that invoked the assessment.</p>
    #[doc(hidden)]
    pub invoker: std::option::Option<crate::model::AssessmentInvoker>,
    /// <p>The starting time for the action.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end time for the action.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The message from the assessment run.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The name of the assessment.</p>
    #[doc(hidden)]
    pub assessment_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    #[doc(hidden)]
    pub assessment_arn: std::option::Option<std::string::String>,
    /// <p>The current status of compliance for the resiliency policy.</p>
    #[doc(hidden)]
    pub compliance_status: std::option::Option<crate::model::ComplianceStatus>,
    /// <p>The cost for the application.</p>
    #[doc(hidden)]
    pub cost: std::option::Option<crate::model::Cost>,
    /// <p>The current resiliency score for the application.</p>
    #[doc(hidden)]
    pub resiliency_score: f64,
}
impl AppAssessmentSummary {
    /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn app_arn(&self) -> std::option::Option<&str> {
        self.app_arn.as_deref()
    }
    /// <p>The version of the application.</p>
    pub fn app_version(&self) -> std::option::Option<&str> {
        self.app_version.as_deref()
    }
    /// <p>The current status of the assessment for the resiliency policy.</p>
    pub fn assessment_status(&self) -> std::option::Option<&crate::model::AssessmentStatus> {
        self.assessment_status.as_ref()
    }
    /// <p>The entity that invoked the assessment.</p>
    pub fn invoker(&self) -> std::option::Option<&crate::model::AssessmentInvoker> {
        self.invoker.as_ref()
    }
    /// <p>The starting time for the action.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The end time for the action.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The message from the assessment run.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The name of the assessment.</p>
    pub fn assessment_name(&self) -> std::option::Option<&str> {
        self.assessment_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
    pub fn assessment_arn(&self) -> std::option::Option<&str> {
        self.assessment_arn.as_deref()
    }
    /// <p>The current status of compliance for the resiliency policy.</p>
    pub fn compliance_status(&self) -> std::option::Option<&crate::model::ComplianceStatus> {
        self.compliance_status.as_ref()
    }
    /// <p>The cost for the application.</p>
    pub fn cost(&self) -> std::option::Option<&crate::model::Cost> {
        self.cost.as_ref()
    }
    /// <p>The current resiliency score for the application.</p>
    pub fn resiliency_score(&self) -> f64 {
        self.resiliency_score
    }
}
impl AppAssessmentSummary {
    /// Creates a new builder-style object to manufacture [`AppAssessmentSummary`](crate::model::AppAssessmentSummary).
    pub fn builder() -> crate::model::app_assessment_summary::Builder {
        crate::model::app_assessment_summary::Builder::default()
    }
}

/// See [`AppAssessmentSummary`](crate::model::AppAssessmentSummary).
pub mod app_assessment_summary {

    /// A builder for [`AppAssessmentSummary`](crate::model::AppAssessmentSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_arn: std::option::Option<std::string::String>,
        pub(crate) app_version: std::option::Option<std::string::String>,
        pub(crate) assessment_status: std::option::Option<crate::model::AssessmentStatus>,
        pub(crate) invoker: std::option::Option<crate::model::AssessmentInvoker>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) assessment_name: std::option::Option<std::string::String>,
        pub(crate) assessment_arn: std::option::Option<std::string::String>,
        pub(crate) compliance_status: std::option::Option<crate::model::ComplianceStatus>,
        pub(crate) cost: std::option::Option<crate::model::Cost>,
        pub(crate) resiliency_score: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn app_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the application. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_app_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_arn = input;
            self
        }
        /// <p>The version of the application.</p>
        pub fn app_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_version = Some(input.into());
            self
        }
        /// <p>The version of the application.</p>
        pub fn set_app_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_version = input;
            self
        }
        /// <p>The current status of the assessment for the resiliency policy.</p>
        pub fn assessment_status(mut self, input: crate::model::AssessmentStatus) -> Self {
            self.assessment_status = Some(input);
            self
        }
        /// <p>The current status of the assessment for the resiliency policy.</p>
        pub fn set_assessment_status(
            mut self,
            input: std::option::Option<crate::model::AssessmentStatus>,
        ) -> Self {
            self.assessment_status = input;
            self
        }
        /// <p>The entity that invoked the assessment.</p>
        pub fn invoker(mut self, input: crate::model::AssessmentInvoker) -> Self {
            self.invoker = Some(input);
            self
        }
        /// <p>The entity that invoked the assessment.</p>
        pub fn set_invoker(
            mut self,
            input: std::option::Option<crate::model::AssessmentInvoker>,
        ) -> Self {
            self.invoker = input;
            self
        }
        /// <p>The starting time for the action.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The starting time for the action.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time for the action.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time for the action.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The message from the assessment run.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message from the assessment run.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The name of the assessment.</p>
        pub fn assessment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_name = Some(input.into());
            self
        }
        /// <p>The name of the assessment.</p>
        pub fn set_assessment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn assessment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.assessment_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:<code>partition</code>:resiliencehub:<code>region</code>:<code>account</code>:app-assessment/<code>app-id</code>. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html"> Amazon Resource Names (ARNs)</a> in the <i>AWS General Reference</i>.</p>
        pub fn set_assessment_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assessment_arn = input;
            self
        }
        /// <p>The current status of compliance for the resiliency policy.</p>
        pub fn compliance_status(mut self, input: crate::model::ComplianceStatus) -> Self {
            self.compliance_status = Some(input);
            self
        }
        /// <p>The current status of compliance for the resiliency policy.</p>
        pub fn set_compliance_status(
            mut self,
            input: std::option::Option<crate::model::ComplianceStatus>,
        ) -> Self {
            self.compliance_status = input;
            self
        }
        /// <p>The cost for the application.</p>
        pub fn cost(mut self, input: crate::model::Cost) -> Self {
            self.cost = Some(input);
            self
        }
        /// <p>The cost for the application.</p>
        pub fn set_cost(mut self, input: std::option::Option<crate::model::Cost>) -> Self {
            self.cost = input;
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn resiliency_score(mut self, input: f64) -> Self {
            self.resiliency_score = Some(input);
            self
        }
        /// <p>The current resiliency score for the application.</p>
        pub fn set_resiliency_score(mut self, input: std::option::Option<f64>) -> Self {
            self.resiliency_score = input;
            self
        }
        /// Consumes the builder and constructs a [`AppAssessmentSummary`](crate::model::AppAssessmentSummary).
        pub fn build(self) -> crate::model::AppAssessmentSummary {
            crate::model::AppAssessmentSummary {
                app_arn: self.app_arn,
                app_version: self.app_version,
                assessment_status: self.assessment_status,
                invoker: self.invoker,
                start_time: self.start_time,
                end_time: self.end_time,
                message: self.message,
                assessment_name: self.assessment_name,
                assessment_arn: self.assessment_arn,
                compliance_status: self.compliance_status,
                cost: self.cost,
                resiliency_score: self.resiliency_score.unwrap_or_default(),
            }
        }
    }
}

/// <p>Defines a recommendation for a CloudWatch alarm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AlarmRecommendation {
    /// <p>The identifier of the alarm recommendation.</p>
    #[doc(hidden)]
    pub recommendation_id: std::option::Option<std::string::String>,
    /// <p>The reference identifier of the alarm recommendation.</p>
    #[doc(hidden)]
    pub reference_id: std::option::Option<std::string::String>,
    /// <p>The name of the alarm recommendation.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the recommendation.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of alarm recommendation.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::AlarmType>,
    /// <p>The application component for the CloudWatch alarm recommendation.</p>
    #[doc(hidden)]
    pub app_component_name: std::option::Option<std::string::String>,
    /// <p>The list of CloudWatch alarm recommendations.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::RecommendationItem>>,
    /// <p>The prerequisite for the alarm recommendation.</p>
    #[doc(hidden)]
    pub prerequisite: std::option::Option<std::string::String>,
}
impl AlarmRecommendation {
    /// <p>The identifier of the alarm recommendation.</p>
    pub fn recommendation_id(&self) -> std::option::Option<&str> {
        self.recommendation_id.as_deref()
    }
    /// <p>The reference identifier of the alarm recommendation.</p>
    pub fn reference_id(&self) -> std::option::Option<&str> {
        self.reference_id.as_deref()
    }
    /// <p>The name of the alarm recommendation.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the recommendation.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of alarm recommendation.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::AlarmType> {
        self.r#type.as_ref()
    }
    /// <p>The application component for the CloudWatch alarm recommendation.</p>
    pub fn app_component_name(&self) -> std::option::Option<&str> {
        self.app_component_name.as_deref()
    }
    /// <p>The list of CloudWatch alarm recommendations.</p>
    pub fn items(&self) -> std::option::Option<&[crate::model::RecommendationItem]> {
        self.items.as_deref()
    }
    /// <p>The prerequisite for the alarm recommendation.</p>
    pub fn prerequisite(&self) -> std::option::Option<&str> {
        self.prerequisite.as_deref()
    }
}
impl AlarmRecommendation {
    /// Creates a new builder-style object to manufacture [`AlarmRecommendation`](crate::model::AlarmRecommendation).
    pub fn builder() -> crate::model::alarm_recommendation::Builder {
        crate::model::alarm_recommendation::Builder::default()
    }
}

/// See [`AlarmRecommendation`](crate::model::AlarmRecommendation).
pub mod alarm_recommendation {

    /// A builder for [`AlarmRecommendation`](crate::model::AlarmRecommendation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation_id: std::option::Option<std::string::String>,
        pub(crate) reference_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::AlarmType>,
        pub(crate) app_component_name: std::option::Option<std::string::String>,
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::RecommendationItem>>,
        pub(crate) prerequisite: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the alarm recommendation.</p>
        pub fn recommendation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation_id = Some(input.into());
            self
        }
        /// <p>The identifier of the alarm recommendation.</p>
        pub fn set_recommendation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_id = input;
            self
        }
        /// <p>The reference identifier of the alarm recommendation.</p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_id = Some(input.into());
            self
        }
        /// <p>The reference identifier of the alarm recommendation.</p>
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_id = input;
            self
        }
        /// <p>The name of the alarm recommendation.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the alarm recommendation.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the recommendation.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the recommendation.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of alarm recommendation.</p>
        pub fn r#type(mut self, input: crate::model::AlarmType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of alarm recommendation.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::AlarmType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The application component for the CloudWatch alarm recommendation.</p>
        pub fn app_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_component_name = Some(input.into());
            self
        }
        /// <p>The application component for the CloudWatch alarm recommendation.</p>
        pub fn set_app_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_component_name = input;
            self
        }
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>The list of CloudWatch alarm recommendations.</p>
        pub fn items(mut self, input: crate::model::RecommendationItem) -> Self {
            let mut v = self.items.unwrap_or_default();
            v.push(input);
            self.items = Some(v);
            self
        }
        /// <p>The list of CloudWatch alarm recommendations.</p>
        pub fn set_items(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecommendationItem>>,
        ) -> Self {
            self.items = input;
            self
        }
        /// <p>The prerequisite for the alarm recommendation.</p>
        pub fn prerequisite(mut self, input: impl Into<std::string::String>) -> Self {
            self.prerequisite = Some(input.into());
            self
        }
        /// <p>The prerequisite for the alarm recommendation.</p>
        pub fn set_prerequisite(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prerequisite = input;
            self
        }
        /// Consumes the builder and constructs a [`AlarmRecommendation`](crate::model::AlarmRecommendation).
        pub fn build(self) -> crate::model::AlarmRecommendation {
            crate::model::AlarmRecommendation {
                recommendation_id: self.recommendation_id,
                reference_id: self.reference_id,
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                app_component_name: self.app_component_name,
                items: self.items,
                prerequisite: self.prerequisite,
            }
        }
    }
}

/// When writing a match expression against `AlarmType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let alarmtype = unimplemented!();
/// match alarmtype {
///     AlarmType::Canary => { /* ... */ },
///     AlarmType::Composite => { /* ... */ },
///     AlarmType::Event => { /* ... */ },
///     AlarmType::Logs => { /* ... */ },
///     AlarmType::Metric => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `alarmtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AlarmType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AlarmType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AlarmType::NewFeature` is defined.
/// Specifically, when `alarmtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AlarmType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AlarmType {
    #[allow(missing_docs)] // documentation missing in model
    Canary,
    #[allow(missing_docs)] // documentation missing in model
    Composite,
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    Logs,
    #[allow(missing_docs)] // documentation missing in model
    Metric,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AlarmType {
    fn from(s: &str) -> Self {
        match s {
            "Canary" => AlarmType::Canary,
            "Composite" => AlarmType::Composite,
            "Event" => AlarmType::Event,
            "Logs" => AlarmType::Logs,
            "Metric" => AlarmType::Metric,
            other => AlarmType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AlarmType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AlarmType::from(s))
    }
}
impl AlarmType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AlarmType::Canary => "Canary",
            AlarmType::Composite => "Composite",
            AlarmType::Event => "Event",
            AlarmType::Logs => "Logs",
            AlarmType::Metric => "Metric",
            AlarmType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Canary", "Composite", "Event", "Logs", "Metric"]
    }
}
impl AsRef<str> for AlarmType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The Terraform s3 state file you need to import. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TerraformSource {
    /// <p> The Terraform s3 state file you need to import. </p>
    #[doc(hidden)]
    pub s3_state_file_url: std::option::Option<std::string::String>,
}
impl TerraformSource {
    /// <p> The Terraform s3 state file you need to import. </p>
    pub fn s3_state_file_url(&self) -> std::option::Option<&str> {
        self.s3_state_file_url.as_deref()
    }
}
impl TerraformSource {
    /// Creates a new builder-style object to manufacture [`TerraformSource`](crate::model::TerraformSource).
    pub fn builder() -> crate::model::terraform_source::Builder {
        crate::model::terraform_source::Builder::default()
    }
}

/// See [`TerraformSource`](crate::model::TerraformSource).
pub mod terraform_source {

    /// A builder for [`TerraformSource`](crate::model::TerraformSource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_state_file_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The Terraform s3 state file you need to import. </p>
        pub fn s3_state_file_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_state_file_url = Some(input.into());
            self
        }
        /// <p> The Terraform s3 state file you need to import. </p>
        pub fn set_s3_state_file_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_state_file_url = input;
            self
        }
        /// Consumes the builder and constructs a [`TerraformSource`](crate::model::TerraformSource).
        pub fn build(self) -> crate::model::TerraformSource {
            crate::model::TerraformSource {
                s3_state_file_url: self.s3_state_file_url,
            }
        }
    }
}

/// When writing a match expression against `ResourceImportStatusType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourceimportstatustype = unimplemented!();
/// match resourceimportstatustype {
///     ResourceImportStatusType::Failed => { /* ... */ },
///     ResourceImportStatusType::InProgress => { /* ... */ },
///     ResourceImportStatusType::Pending => { /* ... */ },
///     ResourceImportStatusType::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourceimportstatustype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceImportStatusType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceImportStatusType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceImportStatusType::NewFeature` is defined.
/// Specifically, when `resourceimportstatustype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceImportStatusType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceImportStatusType {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceImportStatusType {
    fn from(s: &str) -> Self {
        match s {
            "Failed" => ResourceImportStatusType::Failed,
            "InProgress" => ResourceImportStatusType::InProgress,
            "Pending" => ResourceImportStatusType::Pending,
            "Success" => ResourceImportStatusType::Success,
            other => ResourceImportStatusType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ResourceImportStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceImportStatusType::from(s))
    }
}
impl ResourceImportStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceImportStatusType::Failed => "Failed",
            ResourceImportStatusType::InProgress => "InProgress",
            ResourceImportStatusType::Pending => "Pending",
            ResourceImportStatusType::Success => "Success",
            ResourceImportStatusType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Failed", "InProgress", "Pending", "Success"]
    }
}
impl AsRef<str> for ResourceImportStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
