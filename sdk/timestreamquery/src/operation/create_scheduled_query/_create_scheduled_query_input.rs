// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CreateScheduledQueryInput {
    /// <p>Name of the scheduled query.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The query string to run. Parameter names can be specified in the query string <code>@</code> character followed by an identifier. The named Parameter <code>@scheduled_runtime</code> is reserved and can be used in the query to get the time at which the query is scheduled to run.</p>
    /// <p>The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of <code>@scheduled_runtime</code> paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the <code>@scheduled_runtime</code> parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.</p>
    pub query_string: ::std::option::Option<::std::string::String>,
    /// <p>The schedule configuration for the query.</p>
    pub schedule_configuration: ::std::option::Option<crate::types::ScheduleConfiguration>,
    /// <p>Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it. </p>
    pub notification_configuration: ::std::option::Option<crate::types::NotificationConfiguration>,
    /// <p>Configuration used for writing the result of a query.</p>
    pub target_configuration: ::std::option::Option<crate::types::TargetConfiguration>,
    /// <p>Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request. </p>
    /// <ul>
    /// <li> <p> If CreateScheduledQuery is called without a <code>ClientToken</code>, the Query SDK generates a <code>ClientToken</code> on your behalf.</p> </li>
    /// <li> <p> After 8 hours, any request with the same <code>ClientToken</code> is treated as a new request. </p> </li>
    /// </ul>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>The ARN for the IAM role that Timestream will assume when running the scheduled query. </p>
    pub scheduled_query_execution_role_arn: ::std::option::Option<::std::string::String>,
    /// <p>A list of key-value pairs to label the scheduled query.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with <i>alias/</i> </p>
    /// <p>If ErrorReportConfiguration uses <code>SSE_KMS</code> as encryption type, the same KmsKeyId is used to encrypt the error report at rest.</p>
    pub kms_key_id: ::std::option::Option<::std::string::String>,
    /// <p>Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results. </p>
    pub error_report_configuration: ::std::option::Option<crate::types::ErrorReportConfiguration>,
}
impl CreateScheduledQueryInput {
    /// <p>Name of the scheduled query.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The query string to run. Parameter names can be specified in the query string <code>@</code> character followed by an identifier. The named Parameter <code>@scheduled_runtime</code> is reserved and can be used in the query to get the time at which the query is scheduled to run.</p>
    /// <p>The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of <code>@scheduled_runtime</code> paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the <code>@scheduled_runtime</code> parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.</p>
    pub fn query_string(&self) -> ::std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The schedule configuration for the query.</p>
    pub fn schedule_configuration(&self) -> ::std::option::Option<&crate::types::ScheduleConfiguration> {
        self.schedule_configuration.as_ref()
    }
    /// <p>Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it. </p>
    pub fn notification_configuration(&self) -> ::std::option::Option<&crate::types::NotificationConfiguration> {
        self.notification_configuration.as_ref()
    }
    /// <p>Configuration used for writing the result of a query.</p>
    pub fn target_configuration(&self) -> ::std::option::Option<&crate::types::TargetConfiguration> {
        self.target_configuration.as_ref()
    }
    /// <p>Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request. </p>
    /// <ul>
    /// <li> <p> If CreateScheduledQuery is called without a <code>ClientToken</code>, the Query SDK generates a <code>ClientToken</code> on your behalf.</p> </li>
    /// <li> <p> After 8 hours, any request with the same <code>ClientToken</code> is treated as a new request. </p> </li>
    /// </ul>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The ARN for the IAM role that Timestream will assume when running the scheduled query. </p>
    pub fn scheduled_query_execution_role_arn(&self) -> ::std::option::Option<&str> {
        self.scheduled_query_execution_role_arn.as_deref()
    }
    /// <p>A list of key-value pairs to label the scheduled query.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with <i>alias/</i> </p>
    /// <p>If ErrorReportConfiguration uses <code>SSE_KMS</code> as encryption type, the same KmsKeyId is used to encrypt the error report at rest.</p>
    pub fn kms_key_id(&self) -> ::std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results. </p>
    pub fn error_report_configuration(&self) -> ::std::option::Option<&crate::types::ErrorReportConfiguration> {
        self.error_report_configuration.as_ref()
    }
}
impl ::std::fmt::Debug for CreateScheduledQueryInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CreateScheduledQueryInput");
        formatter.field("name", &self.name);
        formatter.field("query_string", &"*** Sensitive Data Redacted ***");
        formatter.field("schedule_configuration", &self.schedule_configuration);
        formatter.field("notification_configuration", &self.notification_configuration);
        formatter.field("target_configuration", &self.target_configuration);
        formatter.field("client_token", &"*** Sensitive Data Redacted ***");
        formatter.field("scheduled_query_execution_role_arn", &self.scheduled_query_execution_role_arn);
        formatter.field("tags", &self.tags);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("error_report_configuration", &self.error_report_configuration);
        formatter.finish()
    }
}
impl CreateScheduledQueryInput {
    /// Creates a new builder-style object to manufacture [`CreateScheduledQueryInput`](crate::operation::create_scheduled_query::CreateScheduledQueryInput).
    pub fn builder() -> crate::operation::create_scheduled_query::builders::CreateScheduledQueryInputBuilder {
        crate::operation::create_scheduled_query::builders::CreateScheduledQueryInputBuilder::default()
    }
}

/// A builder for [`CreateScheduledQueryInput`](crate::operation::create_scheduled_query::CreateScheduledQueryInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct CreateScheduledQueryInputBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) query_string: ::std::option::Option<::std::string::String>,
    pub(crate) schedule_configuration: ::std::option::Option<crate::types::ScheduleConfiguration>,
    pub(crate) notification_configuration: ::std::option::Option<crate::types::NotificationConfiguration>,
    pub(crate) target_configuration: ::std::option::Option<crate::types::TargetConfiguration>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) scheduled_query_execution_role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) kms_key_id: ::std::option::Option<::std::string::String>,
    pub(crate) error_report_configuration: ::std::option::Option<crate::types::ErrorReportConfiguration>,
}
impl CreateScheduledQueryInputBuilder {
    /// <p>Name of the scheduled query.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Name of the scheduled query.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>Name of the scheduled query.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The query string to run. Parameter names can be specified in the query string <code>@</code> character followed by an identifier. The named Parameter <code>@scheduled_runtime</code> is reserved and can be used in the query to get the time at which the query is scheduled to run.</p>
    /// <p>The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of <code>@scheduled_runtime</code> paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the <code>@scheduled_runtime</code> parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.</p>
    /// This field is required.
    pub fn query_string(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.query_string = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The query string to run. Parameter names can be specified in the query string <code>@</code> character followed by an identifier. The named Parameter <code>@scheduled_runtime</code> is reserved and can be used in the query to get the time at which the query is scheduled to run.</p>
    /// <p>The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of <code>@scheduled_runtime</code> paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the <code>@scheduled_runtime</code> parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.</p>
    pub fn set_query_string(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.query_string = input;
        self
    }
    /// <p>The query string to run. Parameter names can be specified in the query string <code>@</code> character followed by an identifier. The named Parameter <code>@scheduled_runtime</code> is reserved and can be used in the query to get the time at which the query is scheduled to run.</p>
    /// <p>The timestamp calculated according to the ScheduleConfiguration parameter, will be the value of <code>@scheduled_runtime</code> paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the <code>@scheduled_runtime</code> parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.</p>
    pub fn get_query_string(&self) -> &::std::option::Option<::std::string::String> {
        &self.query_string
    }
    /// <p>The schedule configuration for the query.</p>
    /// This field is required.
    pub fn schedule_configuration(mut self, input: crate::types::ScheduleConfiguration) -> Self {
        self.schedule_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The schedule configuration for the query.</p>
    pub fn set_schedule_configuration(mut self, input: ::std::option::Option<crate::types::ScheduleConfiguration>) -> Self {
        self.schedule_configuration = input;
        self
    }
    /// <p>The schedule configuration for the query.</p>
    pub fn get_schedule_configuration(&self) -> &::std::option::Option<crate::types::ScheduleConfiguration> {
        &self.schedule_configuration
    }
    /// <p>Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it. </p>
    /// This field is required.
    pub fn notification_configuration(mut self, input: crate::types::NotificationConfiguration) -> Self {
        self.notification_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it. </p>
    pub fn set_notification_configuration(mut self, input: ::std::option::Option<crate::types::NotificationConfiguration>) -> Self {
        self.notification_configuration = input;
        self
    }
    /// <p>Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it. </p>
    pub fn get_notification_configuration(&self) -> &::std::option::Option<crate::types::NotificationConfiguration> {
        &self.notification_configuration
    }
    /// <p>Configuration used for writing the result of a query.</p>
    pub fn target_configuration(mut self, input: crate::types::TargetConfiguration) -> Self {
        self.target_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configuration used for writing the result of a query.</p>
    pub fn set_target_configuration(mut self, input: ::std::option::Option<crate::types::TargetConfiguration>) -> Self {
        self.target_configuration = input;
        self
    }
    /// <p>Configuration used for writing the result of a query.</p>
    pub fn get_target_configuration(&self) -> &::std::option::Option<crate::types::TargetConfiguration> {
        &self.target_configuration
    }
    /// <p>Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request. </p>
    /// <ul>
    /// <li> <p> If CreateScheduledQuery is called without a <code>ClientToken</code>, the Query SDK generates a <code>ClientToken</code> on your behalf.</p> </li>
    /// <li> <p> After 8 hours, any request with the same <code>ClientToken</code> is treated as a new request. </p> </li>
    /// </ul>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request. </p>
    /// <ul>
    /// <li> <p> If CreateScheduledQuery is called without a <code>ClientToken</code>, the Query SDK generates a <code>ClientToken</code> on your behalf.</p> </li>
    /// <li> <p> After 8 hours, any request with the same <code>ClientToken</code> is treated as a new request. </p> </li>
    /// </ul>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>Using a ClientToken makes the call to CreateScheduledQuery idempotent, in other words, making the same request repeatedly will produce the same result. Making multiple identical CreateScheduledQuery requests has the same effect as making a single request. </p>
    /// <ul>
    /// <li> <p> If CreateScheduledQuery is called without a <code>ClientToken</code>, the Query SDK generates a <code>ClientToken</code> on your behalf.</p> </li>
    /// <li> <p> After 8 hours, any request with the same <code>ClientToken</code> is treated as a new request. </p> </li>
    /// </ul>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// <p>The ARN for the IAM role that Timestream will assume when running the scheduled query. </p>
    /// This field is required.
    pub fn scheduled_query_execution_role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.scheduled_query_execution_role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN for the IAM role that Timestream will assume when running the scheduled query. </p>
    pub fn set_scheduled_query_execution_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.scheduled_query_execution_role_arn = input;
        self
    }
    /// <p>The ARN for the IAM role that Timestream will assume when running the scheduled query. </p>
    pub fn get_scheduled_query_execution_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.scheduled_query_execution_role_arn
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of key-value pairs to label the scheduled query.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of key-value pairs to label the scheduled query.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>A list of key-value pairs to label the scheduled query.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with <i>alias/</i> </p>
    /// <p>If ErrorReportConfiguration uses <code>SSE_KMS</code> as encryption type, the same KmsKeyId is used to encrypt the error report at rest.</p>
    pub fn kms_key_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.kms_key_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with <i>alias/</i> </p>
    /// <p>If ErrorReportConfiguration uses <code>SSE_KMS</code> as encryption type, the same KmsKeyId is used to encrypt the error report at rest.</p>
    pub fn set_kms_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.kms_key_id = input;
        self
    }
    /// <p>The Amazon KMS key used to encrypt the scheduled query resource, at-rest. If the Amazon KMS key is not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with <i>alias/</i> </p>
    /// <p>If ErrorReportConfiguration uses <code>SSE_KMS</code> as encryption type, the same KmsKeyId is used to encrypt the error report at rest.</p>
    pub fn get_kms_key_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.kms_key_id
    }
    /// <p>Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results. </p>
    /// This field is required.
    pub fn error_report_configuration(mut self, input: crate::types::ErrorReportConfiguration) -> Self {
        self.error_report_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results. </p>
    pub fn set_error_report_configuration(mut self, input: ::std::option::Option<crate::types::ErrorReportConfiguration>) -> Self {
        self.error_report_configuration = input;
        self
    }
    /// <p>Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results. </p>
    pub fn get_error_report_configuration(&self) -> &::std::option::Option<crate::types::ErrorReportConfiguration> {
        &self.error_report_configuration
    }
    /// Consumes the builder and constructs a [`CreateScheduledQueryInput`](crate::operation::create_scheduled_query::CreateScheduledQueryInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_scheduled_query::CreateScheduledQueryInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::create_scheduled_query::CreateScheduledQueryInput {
            name: self.name,
            query_string: self.query_string,
            schedule_configuration: self.schedule_configuration,
            notification_configuration: self.notification_configuration,
            target_configuration: self.target_configuration,
            client_token: self.client_token,
            scheduled_query_execution_role_arn: self.scheduled_query_execution_role_arn,
            tags: self.tags,
            kms_key_id: self.kms_key_id,
            error_report_configuration: self.error_report_configuration,
        })
    }
}
impl ::std::fmt::Debug for CreateScheduledQueryInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CreateScheduledQueryInputBuilder");
        formatter.field("name", &self.name);
        formatter.field("query_string", &"*** Sensitive Data Redacted ***");
        formatter.field("schedule_configuration", &self.schedule_configuration);
        formatter.field("notification_configuration", &self.notification_configuration);
        formatter.field("target_configuration", &self.target_configuration);
        formatter.field("client_token", &"*** Sensitive Data Redacted ***");
        formatter.field("scheduled_query_execution_role_arn", &self.scheduled_query_execution_role_arn);
        formatter.field("tags", &self.tags);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("error_report_configuration", &self.error_report_configuration);
        formatter.finish()
    }
}
