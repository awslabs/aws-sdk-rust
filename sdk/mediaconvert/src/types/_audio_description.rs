// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Settings related to one audio tab on the MediaConvert console. In your job JSON, an instance of AudioDescription is equivalent to one audio tab in the console. Usually, one audio tab corresponds to one output audio track. Depending on how you set up your input audio selectors and whether you use audio selector groups, one audio tab can correspond to a group of output audio tracks.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AudioDescription {
    /// Specify the QuickTime audio channel layout tags for the audio channels in this audio track. When you don't specify a value, MediaConvert labels your track as Center (C) by default. To use Audio layout tagging, your output must be in a QuickTime (MOV) container and your audio codec must be AAC, WAV, or AIFF.
    pub audio_channel_tagging_settings: ::std::option::Option<crate::types::AudioChannelTaggingSettings>,
    /// Advanced audio normalization settings. Ignore these settings unless you need to comply with a loudness standard.
    pub audio_normalization_settings: ::std::option::Option<crate::types::AudioNormalizationSettings>,
    /// Settings for audio pitch correction during framerate conversion.
    pub audio_pitch_correction_settings: ::std::option::Option<crate::types::AudioPitchCorrectionSettings>,
    /// Specifies which audio data to use from each input. In the simplest case, specify an "Audio Selector":#inputs-audio_selector by name based on its order within each input. For example if you specify "Audio Selector 3", then the third audio selector will be used from each input. If an input does not have an "Audio Selector 3", then the audio selector marked as "default" in that input will be used. If there is no audio selector marked as "default", silence will be inserted for the duration of that input. Alternatively, an "Audio Selector Group":#inputs-audio_selector_group name may be specified, with similar default/silence behavior. If no audio_source_name is specified, then "Audio Selector 1" will be chosen automatically.
    pub audio_source_name: ::std::option::Option<::std::string::String>,
    /// Applies only if Follow Input Audio Type is unchecked (false). A number between 0 and 255. The following are defined in ISO-IEC 13818-1: 0 = Undefined, 1 = Clean Effects, 2 = Hearing Impaired, 3 = Visually Impaired Commentary, 4-255 = Reserved.
    pub audio_type: ::std::option::Option<i32>,
    /// When set to FOLLOW_INPUT, if the input contains an ISO 639 audio_type, then that value is passed through to the output. If the input contains no ISO 639 audio_type, the value in Audio Type is included in the output. Otherwise the value in Audio Type is included in the output. Note that this field and audioType are both ignored if audioDescriptionBroadcasterMix is set to BROADCASTER_MIXED_AD.
    pub audio_type_control: ::std::option::Option<crate::types::AudioTypeControl>,
    /// Settings related to audio encoding. The settings in this group vary depending on the value that you choose for your audio codec.
    pub codec_settings: ::std::option::Option<crate::types::AudioCodecSettings>,
    /// Specify the language for this audio output track. The service puts this language code into your output audio track when you set Language code control to Use configured. The service also uses your specified custom language code when you set Language code control to Follow input, but your input file doesn't specify a language code. For all outputs, you can use an ISO 639-2 or ISO 639-3 code. For streaming outputs, you can also use any other code in the full RFC-5646 specification. Streaming outputs are those that are in one of the following output groups: CMAF, DASH ISO, Apple HLS, or Microsoft Smooth Streaming.
    pub custom_language_code: ::std::option::Option<::std::string::String>,
    /// Specify the language for your output audio track. To follow the input language: Leave blank. When you do, also set Language code control to Follow input. If no input language is detected MediaConvert will not write an output language code. To follow the input langauge, but fall back to a specified language code if there is no input language to follow: Enter an ISO 639-2 three-letter language code in all capital letters. When you do, also set Language code control to Follow input. To specify the language code: Enter an ISO 639 three-letter language code in all capital letters. When you do, also set Language code control to Use configured.
    pub language_code: ::std::option::Option<crate::types::LanguageCode>,
    /// Specify which source for language code takes precedence for this audio track. When you choose Follow input, the service uses the language code from the input track if it's present. If there's no languge code on the input track, the service uses the code that you specify in the setting Language code. When you choose Use configured, the service uses the language code that you specify.
    pub language_code_control: ::std::option::Option<crate::types::AudioLanguageCodeControl>,
    /// Advanced audio remixing settings.
    pub remix_settings: ::std::option::Option<crate::types::RemixSettings>,
    /// Specify a label for this output audio stream. For example, "English", "Director commentary", or "track_2". For streaming outputs, MediaConvert passes this information into destination manifests for display on the end-viewer's player device. For outputs in other output groups, the service ignores this setting.
    pub stream_name: ::std::option::Option<::std::string::String>,
}
impl AudioDescription {
    /// Specify the QuickTime audio channel layout tags for the audio channels in this audio track. When you don't specify a value, MediaConvert labels your track as Center (C) by default. To use Audio layout tagging, your output must be in a QuickTime (MOV) container and your audio codec must be AAC, WAV, or AIFF.
    pub fn audio_channel_tagging_settings(&self) -> ::std::option::Option<&crate::types::AudioChannelTaggingSettings> {
        self.audio_channel_tagging_settings.as_ref()
    }
    /// Advanced audio normalization settings. Ignore these settings unless you need to comply with a loudness standard.
    pub fn audio_normalization_settings(&self) -> ::std::option::Option<&crate::types::AudioNormalizationSettings> {
        self.audio_normalization_settings.as_ref()
    }
    /// Settings for audio pitch correction during framerate conversion.
    pub fn audio_pitch_correction_settings(&self) -> ::std::option::Option<&crate::types::AudioPitchCorrectionSettings> {
        self.audio_pitch_correction_settings.as_ref()
    }
    /// Specifies which audio data to use from each input. In the simplest case, specify an "Audio Selector":#inputs-audio_selector by name based on its order within each input. For example if you specify "Audio Selector 3", then the third audio selector will be used from each input. If an input does not have an "Audio Selector 3", then the audio selector marked as "default" in that input will be used. If there is no audio selector marked as "default", silence will be inserted for the duration of that input. Alternatively, an "Audio Selector Group":#inputs-audio_selector_group name may be specified, with similar default/silence behavior. If no audio_source_name is specified, then "Audio Selector 1" will be chosen automatically.
    pub fn audio_source_name(&self) -> ::std::option::Option<&str> {
        self.audio_source_name.as_deref()
    }
    /// Applies only if Follow Input Audio Type is unchecked (false). A number between 0 and 255. The following are defined in ISO-IEC 13818-1: 0 = Undefined, 1 = Clean Effects, 2 = Hearing Impaired, 3 = Visually Impaired Commentary, 4-255 = Reserved.
    pub fn audio_type(&self) -> ::std::option::Option<i32> {
        self.audio_type
    }
    /// When set to FOLLOW_INPUT, if the input contains an ISO 639 audio_type, then that value is passed through to the output. If the input contains no ISO 639 audio_type, the value in Audio Type is included in the output. Otherwise the value in Audio Type is included in the output. Note that this field and audioType are both ignored if audioDescriptionBroadcasterMix is set to BROADCASTER_MIXED_AD.
    pub fn audio_type_control(&self) -> ::std::option::Option<&crate::types::AudioTypeControl> {
        self.audio_type_control.as_ref()
    }
    /// Settings related to audio encoding. The settings in this group vary depending on the value that you choose for your audio codec.
    pub fn codec_settings(&self) -> ::std::option::Option<&crate::types::AudioCodecSettings> {
        self.codec_settings.as_ref()
    }
    /// Specify the language for this audio output track. The service puts this language code into your output audio track when you set Language code control to Use configured. The service also uses your specified custom language code when you set Language code control to Follow input, but your input file doesn't specify a language code. For all outputs, you can use an ISO 639-2 or ISO 639-3 code. For streaming outputs, you can also use any other code in the full RFC-5646 specification. Streaming outputs are those that are in one of the following output groups: CMAF, DASH ISO, Apple HLS, or Microsoft Smooth Streaming.
    pub fn custom_language_code(&self) -> ::std::option::Option<&str> {
        self.custom_language_code.as_deref()
    }
    /// Specify the language for your output audio track. To follow the input language: Leave blank. When you do, also set Language code control to Follow input. If no input language is detected MediaConvert will not write an output language code. To follow the input langauge, but fall back to a specified language code if there is no input language to follow: Enter an ISO 639-2 three-letter language code in all capital letters. When you do, also set Language code control to Follow input. To specify the language code: Enter an ISO 639 three-letter language code in all capital letters. When you do, also set Language code control to Use configured.
    pub fn language_code(&self) -> ::std::option::Option<&crate::types::LanguageCode> {
        self.language_code.as_ref()
    }
    /// Specify which source for language code takes precedence for this audio track. When you choose Follow input, the service uses the language code from the input track if it's present. If there's no languge code on the input track, the service uses the code that you specify in the setting Language code. When you choose Use configured, the service uses the language code that you specify.
    pub fn language_code_control(&self) -> ::std::option::Option<&crate::types::AudioLanguageCodeControl> {
        self.language_code_control.as_ref()
    }
    /// Advanced audio remixing settings.
    pub fn remix_settings(&self) -> ::std::option::Option<&crate::types::RemixSettings> {
        self.remix_settings.as_ref()
    }
    /// Specify a label for this output audio stream. For example, "English", "Director commentary", or "track_2". For streaming outputs, MediaConvert passes this information into destination manifests for display on the end-viewer's player device. For outputs in other output groups, the service ignores this setting.
    pub fn stream_name(&self) -> ::std::option::Option<&str> {
        self.stream_name.as_deref()
    }
}
impl AudioDescription {
    /// Creates a new builder-style object to manufacture [`AudioDescription`](crate::types::AudioDescription).
    pub fn builder() -> crate::types::builders::AudioDescriptionBuilder {
        crate::types::builders::AudioDescriptionBuilder::default()
    }
}

/// A builder for [`AudioDescription`](crate::types::AudioDescription).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct AudioDescriptionBuilder {
    pub(crate) audio_channel_tagging_settings: ::std::option::Option<crate::types::AudioChannelTaggingSettings>,
    pub(crate) audio_normalization_settings: ::std::option::Option<crate::types::AudioNormalizationSettings>,
    pub(crate) audio_pitch_correction_settings: ::std::option::Option<crate::types::AudioPitchCorrectionSettings>,
    pub(crate) audio_source_name: ::std::option::Option<::std::string::String>,
    pub(crate) audio_type: ::std::option::Option<i32>,
    pub(crate) audio_type_control: ::std::option::Option<crate::types::AudioTypeControl>,
    pub(crate) codec_settings: ::std::option::Option<crate::types::AudioCodecSettings>,
    pub(crate) custom_language_code: ::std::option::Option<::std::string::String>,
    pub(crate) language_code: ::std::option::Option<crate::types::LanguageCode>,
    pub(crate) language_code_control: ::std::option::Option<crate::types::AudioLanguageCodeControl>,
    pub(crate) remix_settings: ::std::option::Option<crate::types::RemixSettings>,
    pub(crate) stream_name: ::std::option::Option<::std::string::String>,
}
impl AudioDescriptionBuilder {
    /// Specify the QuickTime audio channel layout tags for the audio channels in this audio track. When you don't specify a value, MediaConvert labels your track as Center (C) by default. To use Audio layout tagging, your output must be in a QuickTime (MOV) container and your audio codec must be AAC, WAV, or AIFF.
    pub fn audio_channel_tagging_settings(mut self, input: crate::types::AudioChannelTaggingSettings) -> Self {
        self.audio_channel_tagging_settings = ::std::option::Option::Some(input);
        self
    }
    /// Specify the QuickTime audio channel layout tags for the audio channels in this audio track. When you don't specify a value, MediaConvert labels your track as Center (C) by default. To use Audio layout tagging, your output must be in a QuickTime (MOV) container and your audio codec must be AAC, WAV, or AIFF.
    pub fn set_audio_channel_tagging_settings(mut self, input: ::std::option::Option<crate::types::AudioChannelTaggingSettings>) -> Self {
        self.audio_channel_tagging_settings = input;
        self
    }
    /// Specify the QuickTime audio channel layout tags for the audio channels in this audio track. When you don't specify a value, MediaConvert labels your track as Center (C) by default. To use Audio layout tagging, your output must be in a QuickTime (MOV) container and your audio codec must be AAC, WAV, or AIFF.
    pub fn get_audio_channel_tagging_settings(&self) -> &::std::option::Option<crate::types::AudioChannelTaggingSettings> {
        &self.audio_channel_tagging_settings
    }
    /// Advanced audio normalization settings. Ignore these settings unless you need to comply with a loudness standard.
    pub fn audio_normalization_settings(mut self, input: crate::types::AudioNormalizationSettings) -> Self {
        self.audio_normalization_settings = ::std::option::Option::Some(input);
        self
    }
    /// Advanced audio normalization settings. Ignore these settings unless you need to comply with a loudness standard.
    pub fn set_audio_normalization_settings(mut self, input: ::std::option::Option<crate::types::AudioNormalizationSettings>) -> Self {
        self.audio_normalization_settings = input;
        self
    }
    /// Advanced audio normalization settings. Ignore these settings unless you need to comply with a loudness standard.
    pub fn get_audio_normalization_settings(&self) -> &::std::option::Option<crate::types::AudioNormalizationSettings> {
        &self.audio_normalization_settings
    }
    /// Settings for audio pitch correction during framerate conversion.
    pub fn audio_pitch_correction_settings(mut self, input: crate::types::AudioPitchCorrectionSettings) -> Self {
        self.audio_pitch_correction_settings = ::std::option::Option::Some(input);
        self
    }
    /// Settings for audio pitch correction during framerate conversion.
    pub fn set_audio_pitch_correction_settings(mut self, input: ::std::option::Option<crate::types::AudioPitchCorrectionSettings>) -> Self {
        self.audio_pitch_correction_settings = input;
        self
    }
    /// Settings for audio pitch correction during framerate conversion.
    pub fn get_audio_pitch_correction_settings(&self) -> &::std::option::Option<crate::types::AudioPitchCorrectionSettings> {
        &self.audio_pitch_correction_settings
    }
    /// Specifies which audio data to use from each input. In the simplest case, specify an "Audio Selector":#inputs-audio_selector by name based on its order within each input. For example if you specify "Audio Selector 3", then the third audio selector will be used from each input. If an input does not have an "Audio Selector 3", then the audio selector marked as "default" in that input will be used. If there is no audio selector marked as "default", silence will be inserted for the duration of that input. Alternatively, an "Audio Selector Group":#inputs-audio_selector_group name may be specified, with similar default/silence behavior. If no audio_source_name is specified, then "Audio Selector 1" will be chosen automatically.
    pub fn audio_source_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.audio_source_name = ::std::option::Option::Some(input.into());
        self
    }
    /// Specifies which audio data to use from each input. In the simplest case, specify an "Audio Selector":#inputs-audio_selector by name based on its order within each input. For example if you specify "Audio Selector 3", then the third audio selector will be used from each input. If an input does not have an "Audio Selector 3", then the audio selector marked as "default" in that input will be used. If there is no audio selector marked as "default", silence will be inserted for the duration of that input. Alternatively, an "Audio Selector Group":#inputs-audio_selector_group name may be specified, with similar default/silence behavior. If no audio_source_name is specified, then "Audio Selector 1" will be chosen automatically.
    pub fn set_audio_source_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.audio_source_name = input;
        self
    }
    /// Specifies which audio data to use from each input. In the simplest case, specify an "Audio Selector":#inputs-audio_selector by name based on its order within each input. For example if you specify "Audio Selector 3", then the third audio selector will be used from each input. If an input does not have an "Audio Selector 3", then the audio selector marked as "default" in that input will be used. If there is no audio selector marked as "default", silence will be inserted for the duration of that input. Alternatively, an "Audio Selector Group":#inputs-audio_selector_group name may be specified, with similar default/silence behavior. If no audio_source_name is specified, then "Audio Selector 1" will be chosen automatically.
    pub fn get_audio_source_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.audio_source_name
    }
    /// Applies only if Follow Input Audio Type is unchecked (false). A number between 0 and 255. The following are defined in ISO-IEC 13818-1: 0 = Undefined, 1 = Clean Effects, 2 = Hearing Impaired, 3 = Visually Impaired Commentary, 4-255 = Reserved.
    pub fn audio_type(mut self, input: i32) -> Self {
        self.audio_type = ::std::option::Option::Some(input);
        self
    }
    /// Applies only if Follow Input Audio Type is unchecked (false). A number between 0 and 255. The following are defined in ISO-IEC 13818-1: 0 = Undefined, 1 = Clean Effects, 2 = Hearing Impaired, 3 = Visually Impaired Commentary, 4-255 = Reserved.
    pub fn set_audio_type(mut self, input: ::std::option::Option<i32>) -> Self {
        self.audio_type = input;
        self
    }
    /// Applies only if Follow Input Audio Type is unchecked (false). A number between 0 and 255. The following are defined in ISO-IEC 13818-1: 0 = Undefined, 1 = Clean Effects, 2 = Hearing Impaired, 3 = Visually Impaired Commentary, 4-255 = Reserved.
    pub fn get_audio_type(&self) -> &::std::option::Option<i32> {
        &self.audio_type
    }
    /// When set to FOLLOW_INPUT, if the input contains an ISO 639 audio_type, then that value is passed through to the output. If the input contains no ISO 639 audio_type, the value in Audio Type is included in the output. Otherwise the value in Audio Type is included in the output. Note that this field and audioType are both ignored if audioDescriptionBroadcasterMix is set to BROADCASTER_MIXED_AD.
    pub fn audio_type_control(mut self, input: crate::types::AudioTypeControl) -> Self {
        self.audio_type_control = ::std::option::Option::Some(input);
        self
    }
    /// When set to FOLLOW_INPUT, if the input contains an ISO 639 audio_type, then that value is passed through to the output. If the input contains no ISO 639 audio_type, the value in Audio Type is included in the output. Otherwise the value in Audio Type is included in the output. Note that this field and audioType are both ignored if audioDescriptionBroadcasterMix is set to BROADCASTER_MIXED_AD.
    pub fn set_audio_type_control(mut self, input: ::std::option::Option<crate::types::AudioTypeControl>) -> Self {
        self.audio_type_control = input;
        self
    }
    /// When set to FOLLOW_INPUT, if the input contains an ISO 639 audio_type, then that value is passed through to the output. If the input contains no ISO 639 audio_type, the value in Audio Type is included in the output. Otherwise the value in Audio Type is included in the output. Note that this field and audioType are both ignored if audioDescriptionBroadcasterMix is set to BROADCASTER_MIXED_AD.
    pub fn get_audio_type_control(&self) -> &::std::option::Option<crate::types::AudioTypeControl> {
        &self.audio_type_control
    }
    /// Settings related to audio encoding. The settings in this group vary depending on the value that you choose for your audio codec.
    pub fn codec_settings(mut self, input: crate::types::AudioCodecSettings) -> Self {
        self.codec_settings = ::std::option::Option::Some(input);
        self
    }
    /// Settings related to audio encoding. The settings in this group vary depending on the value that you choose for your audio codec.
    pub fn set_codec_settings(mut self, input: ::std::option::Option<crate::types::AudioCodecSettings>) -> Self {
        self.codec_settings = input;
        self
    }
    /// Settings related to audio encoding. The settings in this group vary depending on the value that you choose for your audio codec.
    pub fn get_codec_settings(&self) -> &::std::option::Option<crate::types::AudioCodecSettings> {
        &self.codec_settings
    }
    /// Specify the language for this audio output track. The service puts this language code into your output audio track when you set Language code control to Use configured. The service also uses your specified custom language code when you set Language code control to Follow input, but your input file doesn't specify a language code. For all outputs, you can use an ISO 639-2 or ISO 639-3 code. For streaming outputs, you can also use any other code in the full RFC-5646 specification. Streaming outputs are those that are in one of the following output groups: CMAF, DASH ISO, Apple HLS, or Microsoft Smooth Streaming.
    pub fn custom_language_code(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.custom_language_code = ::std::option::Option::Some(input.into());
        self
    }
    /// Specify the language for this audio output track. The service puts this language code into your output audio track when you set Language code control to Use configured. The service also uses your specified custom language code when you set Language code control to Follow input, but your input file doesn't specify a language code. For all outputs, you can use an ISO 639-2 or ISO 639-3 code. For streaming outputs, you can also use any other code in the full RFC-5646 specification. Streaming outputs are those that are in one of the following output groups: CMAF, DASH ISO, Apple HLS, or Microsoft Smooth Streaming.
    pub fn set_custom_language_code(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.custom_language_code = input;
        self
    }
    /// Specify the language for this audio output track. The service puts this language code into your output audio track when you set Language code control to Use configured. The service also uses your specified custom language code when you set Language code control to Follow input, but your input file doesn't specify a language code. For all outputs, you can use an ISO 639-2 or ISO 639-3 code. For streaming outputs, you can also use any other code in the full RFC-5646 specification. Streaming outputs are those that are in one of the following output groups: CMAF, DASH ISO, Apple HLS, or Microsoft Smooth Streaming.
    pub fn get_custom_language_code(&self) -> &::std::option::Option<::std::string::String> {
        &self.custom_language_code
    }
    /// Specify the language for your output audio track. To follow the input language: Leave blank. When you do, also set Language code control to Follow input. If no input language is detected MediaConvert will not write an output language code. To follow the input langauge, but fall back to a specified language code if there is no input language to follow: Enter an ISO 639-2 three-letter language code in all capital letters. When you do, also set Language code control to Follow input. To specify the language code: Enter an ISO 639 three-letter language code in all capital letters. When you do, also set Language code control to Use configured.
    pub fn language_code(mut self, input: crate::types::LanguageCode) -> Self {
        self.language_code = ::std::option::Option::Some(input);
        self
    }
    /// Specify the language for your output audio track. To follow the input language: Leave blank. When you do, also set Language code control to Follow input. If no input language is detected MediaConvert will not write an output language code. To follow the input langauge, but fall back to a specified language code if there is no input language to follow: Enter an ISO 639-2 three-letter language code in all capital letters. When you do, also set Language code control to Follow input. To specify the language code: Enter an ISO 639 three-letter language code in all capital letters. When you do, also set Language code control to Use configured.
    pub fn set_language_code(mut self, input: ::std::option::Option<crate::types::LanguageCode>) -> Self {
        self.language_code = input;
        self
    }
    /// Specify the language for your output audio track. To follow the input language: Leave blank. When you do, also set Language code control to Follow input. If no input language is detected MediaConvert will not write an output language code. To follow the input langauge, but fall back to a specified language code if there is no input language to follow: Enter an ISO 639-2 three-letter language code in all capital letters. When you do, also set Language code control to Follow input. To specify the language code: Enter an ISO 639 three-letter language code in all capital letters. When you do, also set Language code control to Use configured.
    pub fn get_language_code(&self) -> &::std::option::Option<crate::types::LanguageCode> {
        &self.language_code
    }
    /// Specify which source for language code takes precedence for this audio track. When you choose Follow input, the service uses the language code from the input track if it's present. If there's no languge code on the input track, the service uses the code that you specify in the setting Language code. When you choose Use configured, the service uses the language code that you specify.
    pub fn language_code_control(mut self, input: crate::types::AudioLanguageCodeControl) -> Self {
        self.language_code_control = ::std::option::Option::Some(input);
        self
    }
    /// Specify which source for language code takes precedence for this audio track. When you choose Follow input, the service uses the language code from the input track if it's present. If there's no languge code on the input track, the service uses the code that you specify in the setting Language code. When you choose Use configured, the service uses the language code that you specify.
    pub fn set_language_code_control(mut self, input: ::std::option::Option<crate::types::AudioLanguageCodeControl>) -> Self {
        self.language_code_control = input;
        self
    }
    /// Specify which source for language code takes precedence for this audio track. When you choose Follow input, the service uses the language code from the input track if it's present. If there's no languge code on the input track, the service uses the code that you specify in the setting Language code. When you choose Use configured, the service uses the language code that you specify.
    pub fn get_language_code_control(&self) -> &::std::option::Option<crate::types::AudioLanguageCodeControl> {
        &self.language_code_control
    }
    /// Advanced audio remixing settings.
    pub fn remix_settings(mut self, input: crate::types::RemixSettings) -> Self {
        self.remix_settings = ::std::option::Option::Some(input);
        self
    }
    /// Advanced audio remixing settings.
    pub fn set_remix_settings(mut self, input: ::std::option::Option<crate::types::RemixSettings>) -> Self {
        self.remix_settings = input;
        self
    }
    /// Advanced audio remixing settings.
    pub fn get_remix_settings(&self) -> &::std::option::Option<crate::types::RemixSettings> {
        &self.remix_settings
    }
    /// Specify a label for this output audio stream. For example, "English", "Director commentary", or "track_2". For streaming outputs, MediaConvert passes this information into destination manifests for display on the end-viewer's player device. For outputs in other output groups, the service ignores this setting.
    pub fn stream_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.stream_name = ::std::option::Option::Some(input.into());
        self
    }
    /// Specify a label for this output audio stream. For example, "English", "Director commentary", or "track_2". For streaming outputs, MediaConvert passes this information into destination manifests for display on the end-viewer's player device. For outputs in other output groups, the service ignores this setting.
    pub fn set_stream_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.stream_name = input;
        self
    }
    /// Specify a label for this output audio stream. For example, "English", "Director commentary", or "track_2". For streaming outputs, MediaConvert passes this information into destination manifests for display on the end-viewer's player device. For outputs in other output groups, the service ignores this setting.
    pub fn get_stream_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.stream_name
    }
    /// Consumes the builder and constructs a [`AudioDescription`](crate::types::AudioDescription).
    pub fn build(self) -> crate::types::AudioDescription {
        crate::types::AudioDescription {
            audio_channel_tagging_settings: self.audio_channel_tagging_settings,
            audio_normalization_settings: self.audio_normalization_settings,
            audio_pitch_correction_settings: self.audio_pitch_correction_settings,
            audio_source_name: self.audio_source_name,
            audio_type: self.audio_type,
            audio_type_control: self.audio_type_control,
            codec_settings: self.codec_settings,
            custom_language_code: self.custom_language_code,
            language_code: self.language_code,
            language_code_control: self.language_code_control,
            remix_settings: self.remix_settings,
            stream_name: self.stream_name,
        }
    }
}
