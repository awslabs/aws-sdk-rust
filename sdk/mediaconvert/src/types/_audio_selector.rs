// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Use Audio selectors to specify a track or set of tracks from the input that you will use in your outputs. You can use multiple Audio selectors per input.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AudioSelector {
    /// Apply audio timing corrections to help synchronize audio and video in your output. To apply timing corrections, your input must meet the following requirements: * Container: MP4, or MOV, with an accurate time-to-sample (STTS) table. * Audio track: AAC. Choose from the following audio timing correction settings: * Disabled (Default): Apply no correction. * Auto: Recommended for most inputs. MediaConvert analyzes the audio timing in your input and determines which correction setting to use, if needed. * Track: Adjust the duration of each audio frame by a constant amount to align the audio track length with STTS duration. Track-level correction does not affect pitch, and is recommended for tonal audio content such as music. * Frame: Adjust the duration of each audio frame by a variable amount to align audio frames with STTS timestamps. No corrections are made to already-aligned frames. Frame-level correction may affect the pitch of corrected frames, and is recommended for atonal audio content such as speech or percussion. * Force: Apply audio duration correction, either Track or Frame depending on your input, regardless of the accuracy of your input's STTS table. Your output audio and video may not be aligned or it may contain audio artifacts.
    pub audio_duration_correction: ::std::option::Option<crate::types::AudioDurationCorrection>,
    /// Selects a specific language code from within an audio source, using the ISO 639-2 or ISO 639-3 three-letter language code
    pub custom_language_code: ::std::option::Option<::std::string::String>,
    /// Enable this setting on one audio selector to set it as the default for the job. The service uses this default for outputs where it can't find the specified input audio. If you don't set a default, those outputs have no audio.
    pub default_selection: ::std::option::Option<crate::types::AudioDefaultSelection>,
    /// Specify the S3, HTTP, or HTTPS URL for your external audio file input.
    pub external_audio_file_input: ::std::option::Option<::std::string::String>,
    /// Settings specific to audio sources in an HLS alternate rendition group. Specify the properties (renditionGroupId, renditionName or renditionLanguageCode) to identify the unique audio track among the alternative rendition groups present in the HLS manifest. If no unique track is found, or multiple tracks match the properties provided, the job fails. If no properties in hlsRenditionGroupSettings are specified, the default audio track within the video segment is chosen. If there is no audio within video segment, the alternative audio with DEFAULT=YES is chosen instead.
    pub hls_rendition_group_settings: ::std::option::Option<crate::types::HlsRenditionGroupSettings>,
    /// Specify the language, using an ISO 639-2 three-letter code in all capital letters. You can find a list of codes at: https://www.loc.gov/standards/iso639-2/php/code_list.php
    pub language_code: ::std::option::Option<crate::types::LanguageCode>,
    /// Specify a time delta, in milliseconds, to offset the audio from the input video. To specify no offset: Keep the default value, 0. To specify an offset: Enter an integer from -2147483648 to 2147483647
    pub offset: ::std::option::Option<i32>,
    /// Selects a specific PID from within an audio source (e.g. 257 selects PID 0x101).
    pub pids: ::std::option::Option<::std::vec::Vec<i32>>,
    /// Use this setting for input streams that contain Dolby E, to have the service extract specific program data from the track. To select multiple programs, create multiple selectors with the same Track and different Program numbers. In the console, this setting is visible when you set Selector type to Track. Choose the program number from the dropdown list. If your input file has incorrect metadata, you can choose All channels instead of a program number to have the service ignore the program IDs and include all the programs in the track.
    pub program_selection: ::std::option::Option<i32>,
    /// Use these settings to reorder the audio channels of one input to match those of another input. This allows you to combine the two files into a single output, one after the other.
    pub remix_settings: ::std::option::Option<crate::types::RemixSettings>,
    /// Specify how MediaConvert selects audio content within your input. The default is Track. PID: Select audio by specifying the Packet Identifier (PID) values for MPEG Transport Stream inputs. Use this when you know the exact PID values of your audio streams. Track: Default. Select audio by track number. This is the most common option and works with most input container formats. If more types of audio data get recognized in the future, these numberings may shift, but the numberings used for Stream mode will not. Language code: Select audio by language using an ISO 639-2 or ISO 639-3 three-letter code in all capital letters. Use this when your source has embedded language metadata and you want to select tracks based on their language. HLS rendition group: Select audio from an HLS rendition group. Use this when your input is an HLS package with multiple audio renditions and you want to select specific rendition groups. All PCM: Select all uncompressed PCM audio tracks from your input automatically. This is useful when you want to include all PCM audio tracks without specifying individual track numbers. Stream: Select audio by stream number. Stream numbers include all tracks in the source file, regardless of type, and correspond to either the order of tracks in the file, or if applicable, the stream number metadata of the track. Although all tracks count toward these stream numbers, in this audio selector context, only the stream number of a track containing audio data may be used. If your source file contains a track which is not recognized by the service, then the corresponding stream number will still be reserved for future use. If more types of audio data get recognized in the future, these numberings will not shift.
    pub selector_type: ::std::option::Option<crate::types::AudioSelectorType>,
    /// Identify a track from the input audio to include in this selector by entering the stream index number. These numberings count all tracks in the input file, but only a track containing audio data may be used here. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    pub streams: ::std::option::Option<::std::vec::Vec<i32>>,
    /// Identify a track from the input audio to include in this selector by entering the track index number. These numberings include only tracks recognized as audio. If the service recognizes more types of audio tracks in the future, these numberings may shift. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    pub tracks: ::std::option::Option<::std::vec::Vec<i32>>,
}
impl AudioSelector {
    /// Apply audio timing corrections to help synchronize audio and video in your output. To apply timing corrections, your input must meet the following requirements: * Container: MP4, or MOV, with an accurate time-to-sample (STTS) table. * Audio track: AAC. Choose from the following audio timing correction settings: * Disabled (Default): Apply no correction. * Auto: Recommended for most inputs. MediaConvert analyzes the audio timing in your input and determines which correction setting to use, if needed. * Track: Adjust the duration of each audio frame by a constant amount to align the audio track length with STTS duration. Track-level correction does not affect pitch, and is recommended for tonal audio content such as music. * Frame: Adjust the duration of each audio frame by a variable amount to align audio frames with STTS timestamps. No corrections are made to already-aligned frames. Frame-level correction may affect the pitch of corrected frames, and is recommended for atonal audio content such as speech or percussion. * Force: Apply audio duration correction, either Track or Frame depending on your input, regardless of the accuracy of your input's STTS table. Your output audio and video may not be aligned or it may contain audio artifacts.
    pub fn audio_duration_correction(&self) -> ::std::option::Option<&crate::types::AudioDurationCorrection> {
        self.audio_duration_correction.as_ref()
    }
    /// Selects a specific language code from within an audio source, using the ISO 639-2 or ISO 639-3 three-letter language code
    pub fn custom_language_code(&self) -> ::std::option::Option<&str> {
        self.custom_language_code.as_deref()
    }
    /// Enable this setting on one audio selector to set it as the default for the job. The service uses this default for outputs where it can't find the specified input audio. If you don't set a default, those outputs have no audio.
    pub fn default_selection(&self) -> ::std::option::Option<&crate::types::AudioDefaultSelection> {
        self.default_selection.as_ref()
    }
    /// Specify the S3, HTTP, or HTTPS URL for your external audio file input.
    pub fn external_audio_file_input(&self) -> ::std::option::Option<&str> {
        self.external_audio_file_input.as_deref()
    }
    /// Settings specific to audio sources in an HLS alternate rendition group. Specify the properties (renditionGroupId, renditionName or renditionLanguageCode) to identify the unique audio track among the alternative rendition groups present in the HLS manifest. If no unique track is found, or multiple tracks match the properties provided, the job fails. If no properties in hlsRenditionGroupSettings are specified, the default audio track within the video segment is chosen. If there is no audio within video segment, the alternative audio with DEFAULT=YES is chosen instead.
    pub fn hls_rendition_group_settings(&self) -> ::std::option::Option<&crate::types::HlsRenditionGroupSettings> {
        self.hls_rendition_group_settings.as_ref()
    }
    /// Specify the language, using an ISO 639-2 three-letter code in all capital letters. You can find a list of codes at: https://www.loc.gov/standards/iso639-2/php/code_list.php
    pub fn language_code(&self) -> ::std::option::Option<&crate::types::LanguageCode> {
        self.language_code.as_ref()
    }
    /// Specify a time delta, in milliseconds, to offset the audio from the input video. To specify no offset: Keep the default value, 0. To specify an offset: Enter an integer from -2147483648 to 2147483647
    pub fn offset(&self) -> ::std::option::Option<i32> {
        self.offset
    }
    /// Selects a specific PID from within an audio source (e.g. 257 selects PID 0x101).
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.pids.is_none()`.
    pub fn pids(&self) -> &[i32] {
        self.pids.as_deref().unwrap_or_default()
    }
    /// Use this setting for input streams that contain Dolby E, to have the service extract specific program data from the track. To select multiple programs, create multiple selectors with the same Track and different Program numbers. In the console, this setting is visible when you set Selector type to Track. Choose the program number from the dropdown list. If your input file has incorrect metadata, you can choose All channels instead of a program number to have the service ignore the program IDs and include all the programs in the track.
    pub fn program_selection(&self) -> ::std::option::Option<i32> {
        self.program_selection
    }
    /// Use these settings to reorder the audio channels of one input to match those of another input. This allows you to combine the two files into a single output, one after the other.
    pub fn remix_settings(&self) -> ::std::option::Option<&crate::types::RemixSettings> {
        self.remix_settings.as_ref()
    }
    /// Specify how MediaConvert selects audio content within your input. The default is Track. PID: Select audio by specifying the Packet Identifier (PID) values for MPEG Transport Stream inputs. Use this when you know the exact PID values of your audio streams. Track: Default. Select audio by track number. This is the most common option and works with most input container formats. If more types of audio data get recognized in the future, these numberings may shift, but the numberings used for Stream mode will not. Language code: Select audio by language using an ISO 639-2 or ISO 639-3 three-letter code in all capital letters. Use this when your source has embedded language metadata and you want to select tracks based on their language. HLS rendition group: Select audio from an HLS rendition group. Use this when your input is an HLS package with multiple audio renditions and you want to select specific rendition groups. All PCM: Select all uncompressed PCM audio tracks from your input automatically. This is useful when you want to include all PCM audio tracks without specifying individual track numbers. Stream: Select audio by stream number. Stream numbers include all tracks in the source file, regardless of type, and correspond to either the order of tracks in the file, or if applicable, the stream number metadata of the track. Although all tracks count toward these stream numbers, in this audio selector context, only the stream number of a track containing audio data may be used. If your source file contains a track which is not recognized by the service, then the corresponding stream number will still be reserved for future use. If more types of audio data get recognized in the future, these numberings will not shift.
    pub fn selector_type(&self) -> ::std::option::Option<&crate::types::AudioSelectorType> {
        self.selector_type.as_ref()
    }
    /// Identify a track from the input audio to include in this selector by entering the stream index number. These numberings count all tracks in the input file, but only a track containing audio data may be used here. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.streams.is_none()`.
    pub fn streams(&self) -> &[i32] {
        self.streams.as_deref().unwrap_or_default()
    }
    /// Identify a track from the input audio to include in this selector by entering the track index number. These numberings include only tracks recognized as audio. If the service recognizes more types of audio tracks in the future, these numberings may shift. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tracks.is_none()`.
    pub fn tracks(&self) -> &[i32] {
        self.tracks.as_deref().unwrap_or_default()
    }
}
impl AudioSelector {
    /// Creates a new builder-style object to manufacture [`AudioSelector`](crate::types::AudioSelector).
    pub fn builder() -> crate::types::builders::AudioSelectorBuilder {
        crate::types::builders::AudioSelectorBuilder::default()
    }
}

/// A builder for [`AudioSelector`](crate::types::AudioSelector).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct AudioSelectorBuilder {
    pub(crate) audio_duration_correction: ::std::option::Option<crate::types::AudioDurationCorrection>,
    pub(crate) custom_language_code: ::std::option::Option<::std::string::String>,
    pub(crate) default_selection: ::std::option::Option<crate::types::AudioDefaultSelection>,
    pub(crate) external_audio_file_input: ::std::option::Option<::std::string::String>,
    pub(crate) hls_rendition_group_settings: ::std::option::Option<crate::types::HlsRenditionGroupSettings>,
    pub(crate) language_code: ::std::option::Option<crate::types::LanguageCode>,
    pub(crate) offset: ::std::option::Option<i32>,
    pub(crate) pids: ::std::option::Option<::std::vec::Vec<i32>>,
    pub(crate) program_selection: ::std::option::Option<i32>,
    pub(crate) remix_settings: ::std::option::Option<crate::types::RemixSettings>,
    pub(crate) selector_type: ::std::option::Option<crate::types::AudioSelectorType>,
    pub(crate) streams: ::std::option::Option<::std::vec::Vec<i32>>,
    pub(crate) tracks: ::std::option::Option<::std::vec::Vec<i32>>,
}
impl AudioSelectorBuilder {
    /// Apply audio timing corrections to help synchronize audio and video in your output. To apply timing corrections, your input must meet the following requirements: * Container: MP4, or MOV, with an accurate time-to-sample (STTS) table. * Audio track: AAC. Choose from the following audio timing correction settings: * Disabled (Default): Apply no correction. * Auto: Recommended for most inputs. MediaConvert analyzes the audio timing in your input and determines which correction setting to use, if needed. * Track: Adjust the duration of each audio frame by a constant amount to align the audio track length with STTS duration. Track-level correction does not affect pitch, and is recommended for tonal audio content such as music. * Frame: Adjust the duration of each audio frame by a variable amount to align audio frames with STTS timestamps. No corrections are made to already-aligned frames. Frame-level correction may affect the pitch of corrected frames, and is recommended for atonal audio content such as speech or percussion. * Force: Apply audio duration correction, either Track or Frame depending on your input, regardless of the accuracy of your input's STTS table. Your output audio and video may not be aligned or it may contain audio artifacts.
    pub fn audio_duration_correction(mut self, input: crate::types::AudioDurationCorrection) -> Self {
        self.audio_duration_correction = ::std::option::Option::Some(input);
        self
    }
    /// Apply audio timing corrections to help synchronize audio and video in your output. To apply timing corrections, your input must meet the following requirements: * Container: MP4, or MOV, with an accurate time-to-sample (STTS) table. * Audio track: AAC. Choose from the following audio timing correction settings: * Disabled (Default): Apply no correction. * Auto: Recommended for most inputs. MediaConvert analyzes the audio timing in your input and determines which correction setting to use, if needed. * Track: Adjust the duration of each audio frame by a constant amount to align the audio track length with STTS duration. Track-level correction does not affect pitch, and is recommended for tonal audio content such as music. * Frame: Adjust the duration of each audio frame by a variable amount to align audio frames with STTS timestamps. No corrections are made to already-aligned frames. Frame-level correction may affect the pitch of corrected frames, and is recommended for atonal audio content such as speech or percussion. * Force: Apply audio duration correction, either Track or Frame depending on your input, regardless of the accuracy of your input's STTS table. Your output audio and video may not be aligned or it may contain audio artifacts.
    pub fn set_audio_duration_correction(mut self, input: ::std::option::Option<crate::types::AudioDurationCorrection>) -> Self {
        self.audio_duration_correction = input;
        self
    }
    /// Apply audio timing corrections to help synchronize audio and video in your output. To apply timing corrections, your input must meet the following requirements: * Container: MP4, or MOV, with an accurate time-to-sample (STTS) table. * Audio track: AAC. Choose from the following audio timing correction settings: * Disabled (Default): Apply no correction. * Auto: Recommended for most inputs. MediaConvert analyzes the audio timing in your input and determines which correction setting to use, if needed. * Track: Adjust the duration of each audio frame by a constant amount to align the audio track length with STTS duration. Track-level correction does not affect pitch, and is recommended for tonal audio content such as music. * Frame: Adjust the duration of each audio frame by a variable amount to align audio frames with STTS timestamps. No corrections are made to already-aligned frames. Frame-level correction may affect the pitch of corrected frames, and is recommended for atonal audio content such as speech or percussion. * Force: Apply audio duration correction, either Track or Frame depending on your input, regardless of the accuracy of your input's STTS table. Your output audio and video may not be aligned or it may contain audio artifacts.
    pub fn get_audio_duration_correction(&self) -> &::std::option::Option<crate::types::AudioDurationCorrection> {
        &self.audio_duration_correction
    }
    /// Selects a specific language code from within an audio source, using the ISO 639-2 or ISO 639-3 three-letter language code
    pub fn custom_language_code(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.custom_language_code = ::std::option::Option::Some(input.into());
        self
    }
    /// Selects a specific language code from within an audio source, using the ISO 639-2 or ISO 639-3 three-letter language code
    pub fn set_custom_language_code(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.custom_language_code = input;
        self
    }
    /// Selects a specific language code from within an audio source, using the ISO 639-2 or ISO 639-3 three-letter language code
    pub fn get_custom_language_code(&self) -> &::std::option::Option<::std::string::String> {
        &self.custom_language_code
    }
    /// Enable this setting on one audio selector to set it as the default for the job. The service uses this default for outputs where it can't find the specified input audio. If you don't set a default, those outputs have no audio.
    pub fn default_selection(mut self, input: crate::types::AudioDefaultSelection) -> Self {
        self.default_selection = ::std::option::Option::Some(input);
        self
    }
    /// Enable this setting on one audio selector to set it as the default for the job. The service uses this default for outputs where it can't find the specified input audio. If you don't set a default, those outputs have no audio.
    pub fn set_default_selection(mut self, input: ::std::option::Option<crate::types::AudioDefaultSelection>) -> Self {
        self.default_selection = input;
        self
    }
    /// Enable this setting on one audio selector to set it as the default for the job. The service uses this default for outputs where it can't find the specified input audio. If you don't set a default, those outputs have no audio.
    pub fn get_default_selection(&self) -> &::std::option::Option<crate::types::AudioDefaultSelection> {
        &self.default_selection
    }
    /// Specify the S3, HTTP, or HTTPS URL for your external audio file input.
    pub fn external_audio_file_input(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.external_audio_file_input = ::std::option::Option::Some(input.into());
        self
    }
    /// Specify the S3, HTTP, or HTTPS URL for your external audio file input.
    pub fn set_external_audio_file_input(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.external_audio_file_input = input;
        self
    }
    /// Specify the S3, HTTP, or HTTPS URL for your external audio file input.
    pub fn get_external_audio_file_input(&self) -> &::std::option::Option<::std::string::String> {
        &self.external_audio_file_input
    }
    /// Settings specific to audio sources in an HLS alternate rendition group. Specify the properties (renditionGroupId, renditionName or renditionLanguageCode) to identify the unique audio track among the alternative rendition groups present in the HLS manifest. If no unique track is found, or multiple tracks match the properties provided, the job fails. If no properties in hlsRenditionGroupSettings are specified, the default audio track within the video segment is chosen. If there is no audio within video segment, the alternative audio with DEFAULT=YES is chosen instead.
    pub fn hls_rendition_group_settings(mut self, input: crate::types::HlsRenditionGroupSettings) -> Self {
        self.hls_rendition_group_settings = ::std::option::Option::Some(input);
        self
    }
    /// Settings specific to audio sources in an HLS alternate rendition group. Specify the properties (renditionGroupId, renditionName or renditionLanguageCode) to identify the unique audio track among the alternative rendition groups present in the HLS manifest. If no unique track is found, or multiple tracks match the properties provided, the job fails. If no properties in hlsRenditionGroupSettings are specified, the default audio track within the video segment is chosen. If there is no audio within video segment, the alternative audio with DEFAULT=YES is chosen instead.
    pub fn set_hls_rendition_group_settings(mut self, input: ::std::option::Option<crate::types::HlsRenditionGroupSettings>) -> Self {
        self.hls_rendition_group_settings = input;
        self
    }
    /// Settings specific to audio sources in an HLS alternate rendition group. Specify the properties (renditionGroupId, renditionName or renditionLanguageCode) to identify the unique audio track among the alternative rendition groups present in the HLS manifest. If no unique track is found, or multiple tracks match the properties provided, the job fails. If no properties in hlsRenditionGroupSettings are specified, the default audio track within the video segment is chosen. If there is no audio within video segment, the alternative audio with DEFAULT=YES is chosen instead.
    pub fn get_hls_rendition_group_settings(&self) -> &::std::option::Option<crate::types::HlsRenditionGroupSettings> {
        &self.hls_rendition_group_settings
    }
    /// Specify the language, using an ISO 639-2 three-letter code in all capital letters. You can find a list of codes at: https://www.loc.gov/standards/iso639-2/php/code_list.php
    pub fn language_code(mut self, input: crate::types::LanguageCode) -> Self {
        self.language_code = ::std::option::Option::Some(input);
        self
    }
    /// Specify the language, using an ISO 639-2 three-letter code in all capital letters. You can find a list of codes at: https://www.loc.gov/standards/iso639-2/php/code_list.php
    pub fn set_language_code(mut self, input: ::std::option::Option<crate::types::LanguageCode>) -> Self {
        self.language_code = input;
        self
    }
    /// Specify the language, using an ISO 639-2 three-letter code in all capital letters. You can find a list of codes at: https://www.loc.gov/standards/iso639-2/php/code_list.php
    pub fn get_language_code(&self) -> &::std::option::Option<crate::types::LanguageCode> {
        &self.language_code
    }
    /// Specify a time delta, in milliseconds, to offset the audio from the input video. To specify no offset: Keep the default value, 0. To specify an offset: Enter an integer from -2147483648 to 2147483647
    pub fn offset(mut self, input: i32) -> Self {
        self.offset = ::std::option::Option::Some(input);
        self
    }
    /// Specify a time delta, in milliseconds, to offset the audio from the input video. To specify no offset: Keep the default value, 0. To specify an offset: Enter an integer from -2147483648 to 2147483647
    pub fn set_offset(mut self, input: ::std::option::Option<i32>) -> Self {
        self.offset = input;
        self
    }
    /// Specify a time delta, in milliseconds, to offset the audio from the input video. To specify no offset: Keep the default value, 0. To specify an offset: Enter an integer from -2147483648 to 2147483647
    pub fn get_offset(&self) -> &::std::option::Option<i32> {
        &self.offset
    }
    /// Appends an item to `pids`.
    ///
    /// To override the contents of this collection use [`set_pids`](Self::set_pids).
    ///
    /// Selects a specific PID from within an audio source (e.g. 257 selects PID 0x101).
    pub fn pids(mut self, input: i32) -> Self {
        let mut v = self.pids.unwrap_or_default();
        v.push(input);
        self.pids = ::std::option::Option::Some(v);
        self
    }
    /// Selects a specific PID from within an audio source (e.g. 257 selects PID 0x101).
    pub fn set_pids(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.pids = input;
        self
    }
    /// Selects a specific PID from within an audio source (e.g. 257 selects PID 0x101).
    pub fn get_pids(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.pids
    }
    /// Use this setting for input streams that contain Dolby E, to have the service extract specific program data from the track. To select multiple programs, create multiple selectors with the same Track and different Program numbers. In the console, this setting is visible when you set Selector type to Track. Choose the program number from the dropdown list. If your input file has incorrect metadata, you can choose All channels instead of a program number to have the service ignore the program IDs and include all the programs in the track.
    pub fn program_selection(mut self, input: i32) -> Self {
        self.program_selection = ::std::option::Option::Some(input);
        self
    }
    /// Use this setting for input streams that contain Dolby E, to have the service extract specific program data from the track. To select multiple programs, create multiple selectors with the same Track and different Program numbers. In the console, this setting is visible when you set Selector type to Track. Choose the program number from the dropdown list. If your input file has incorrect metadata, you can choose All channels instead of a program number to have the service ignore the program IDs and include all the programs in the track.
    pub fn set_program_selection(mut self, input: ::std::option::Option<i32>) -> Self {
        self.program_selection = input;
        self
    }
    /// Use this setting for input streams that contain Dolby E, to have the service extract specific program data from the track. To select multiple programs, create multiple selectors with the same Track and different Program numbers. In the console, this setting is visible when you set Selector type to Track. Choose the program number from the dropdown list. If your input file has incorrect metadata, you can choose All channels instead of a program number to have the service ignore the program IDs and include all the programs in the track.
    pub fn get_program_selection(&self) -> &::std::option::Option<i32> {
        &self.program_selection
    }
    /// Use these settings to reorder the audio channels of one input to match those of another input. This allows you to combine the two files into a single output, one after the other.
    pub fn remix_settings(mut self, input: crate::types::RemixSettings) -> Self {
        self.remix_settings = ::std::option::Option::Some(input);
        self
    }
    /// Use these settings to reorder the audio channels of one input to match those of another input. This allows you to combine the two files into a single output, one after the other.
    pub fn set_remix_settings(mut self, input: ::std::option::Option<crate::types::RemixSettings>) -> Self {
        self.remix_settings = input;
        self
    }
    /// Use these settings to reorder the audio channels of one input to match those of another input. This allows you to combine the two files into a single output, one after the other.
    pub fn get_remix_settings(&self) -> &::std::option::Option<crate::types::RemixSettings> {
        &self.remix_settings
    }
    /// Specify how MediaConvert selects audio content within your input. The default is Track. PID: Select audio by specifying the Packet Identifier (PID) values for MPEG Transport Stream inputs. Use this when you know the exact PID values of your audio streams. Track: Default. Select audio by track number. This is the most common option and works with most input container formats. If more types of audio data get recognized in the future, these numberings may shift, but the numberings used for Stream mode will not. Language code: Select audio by language using an ISO 639-2 or ISO 639-3 three-letter code in all capital letters. Use this when your source has embedded language metadata and you want to select tracks based on their language. HLS rendition group: Select audio from an HLS rendition group. Use this when your input is an HLS package with multiple audio renditions and you want to select specific rendition groups. All PCM: Select all uncompressed PCM audio tracks from your input automatically. This is useful when you want to include all PCM audio tracks without specifying individual track numbers. Stream: Select audio by stream number. Stream numbers include all tracks in the source file, regardless of type, and correspond to either the order of tracks in the file, or if applicable, the stream number metadata of the track. Although all tracks count toward these stream numbers, in this audio selector context, only the stream number of a track containing audio data may be used. If your source file contains a track which is not recognized by the service, then the corresponding stream number will still be reserved for future use. If more types of audio data get recognized in the future, these numberings will not shift.
    pub fn selector_type(mut self, input: crate::types::AudioSelectorType) -> Self {
        self.selector_type = ::std::option::Option::Some(input);
        self
    }
    /// Specify how MediaConvert selects audio content within your input. The default is Track. PID: Select audio by specifying the Packet Identifier (PID) values for MPEG Transport Stream inputs. Use this when you know the exact PID values of your audio streams. Track: Default. Select audio by track number. This is the most common option and works with most input container formats. If more types of audio data get recognized in the future, these numberings may shift, but the numberings used for Stream mode will not. Language code: Select audio by language using an ISO 639-2 or ISO 639-3 three-letter code in all capital letters. Use this when your source has embedded language metadata and you want to select tracks based on their language. HLS rendition group: Select audio from an HLS rendition group. Use this when your input is an HLS package with multiple audio renditions and you want to select specific rendition groups. All PCM: Select all uncompressed PCM audio tracks from your input automatically. This is useful when you want to include all PCM audio tracks without specifying individual track numbers. Stream: Select audio by stream number. Stream numbers include all tracks in the source file, regardless of type, and correspond to either the order of tracks in the file, or if applicable, the stream number metadata of the track. Although all tracks count toward these stream numbers, in this audio selector context, only the stream number of a track containing audio data may be used. If your source file contains a track which is not recognized by the service, then the corresponding stream number will still be reserved for future use. If more types of audio data get recognized in the future, these numberings will not shift.
    pub fn set_selector_type(mut self, input: ::std::option::Option<crate::types::AudioSelectorType>) -> Self {
        self.selector_type = input;
        self
    }
    /// Specify how MediaConvert selects audio content within your input. The default is Track. PID: Select audio by specifying the Packet Identifier (PID) values for MPEG Transport Stream inputs. Use this when you know the exact PID values of your audio streams. Track: Default. Select audio by track number. This is the most common option and works with most input container formats. If more types of audio data get recognized in the future, these numberings may shift, but the numberings used for Stream mode will not. Language code: Select audio by language using an ISO 639-2 or ISO 639-3 three-letter code in all capital letters. Use this when your source has embedded language metadata and you want to select tracks based on their language. HLS rendition group: Select audio from an HLS rendition group. Use this when your input is an HLS package with multiple audio renditions and you want to select specific rendition groups. All PCM: Select all uncompressed PCM audio tracks from your input automatically. This is useful when you want to include all PCM audio tracks without specifying individual track numbers. Stream: Select audio by stream number. Stream numbers include all tracks in the source file, regardless of type, and correspond to either the order of tracks in the file, or if applicable, the stream number metadata of the track. Although all tracks count toward these stream numbers, in this audio selector context, only the stream number of a track containing audio data may be used. If your source file contains a track which is not recognized by the service, then the corresponding stream number will still be reserved for future use. If more types of audio data get recognized in the future, these numberings will not shift.
    pub fn get_selector_type(&self) -> &::std::option::Option<crate::types::AudioSelectorType> {
        &self.selector_type
    }
    /// Appends an item to `streams`.
    ///
    /// To override the contents of this collection use [`set_streams`](Self::set_streams).
    ///
    /// Identify a track from the input audio to include in this selector by entering the stream index number. These numberings count all tracks in the input file, but only a track containing audio data may be used here. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    pub fn streams(mut self, input: i32) -> Self {
        let mut v = self.streams.unwrap_or_default();
        v.push(input);
        self.streams = ::std::option::Option::Some(v);
        self
    }
    /// Identify a track from the input audio to include in this selector by entering the stream index number. These numberings count all tracks in the input file, but only a track containing audio data may be used here. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    pub fn set_streams(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.streams = input;
        self
    }
    /// Identify a track from the input audio to include in this selector by entering the stream index number. These numberings count all tracks in the input file, but only a track containing audio data may be used here. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    pub fn get_streams(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.streams
    }
    /// Appends an item to `tracks`.
    ///
    /// To override the contents of this collection use [`set_tracks`](Self::set_tracks).
    ///
    /// Identify a track from the input audio to include in this selector by entering the track index number. These numberings include only tracks recognized as audio. If the service recognizes more types of audio tracks in the future, these numberings may shift. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    pub fn tracks(mut self, input: i32) -> Self {
        let mut v = self.tracks.unwrap_or_default();
        v.push(input);
        self.tracks = ::std::option::Option::Some(v);
        self
    }
    /// Identify a track from the input audio to include in this selector by entering the track index number. These numberings include only tracks recognized as audio. If the service recognizes more types of audio tracks in the future, these numberings may shift. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    pub fn set_tracks(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.tracks = input;
        self
    }
    /// Identify a track from the input audio to include in this selector by entering the track index number. These numberings include only tracks recognized as audio. If the service recognizes more types of audio tracks in the future, these numberings may shift. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For example, type "1,2,3" to include tracks 1 through 3.
    pub fn get_tracks(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.tracks
    }
    /// Consumes the builder and constructs a [`AudioSelector`](crate::types::AudioSelector).
    pub fn build(self) -> crate::types::AudioSelector {
        crate::types::AudioSelector {
            audio_duration_correction: self.audio_duration_correction,
            custom_language_code: self.custom_language_code,
            default_selection: self.default_selection,
            external_audio_file_input: self.external_audio_file_input,
            hls_rendition_group_settings: self.hls_rendition_group_settings,
            language_code: self.language_code,
            offset: self.offset,
            pids: self.pids,
            program_selection: self.program_selection,
            remix_settings: self.remix_settings,
            selector_type: self.selector_type,
            streams: self.streams,
            tracks: self.tracks,
        }
    }
}
