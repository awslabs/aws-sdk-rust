// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Settings for deinterlacer
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Deinterlacer {
    /// Only applies when you set Deinterlacer (DeinterlaceMode) to Deinterlace (DEINTERLACE) or Adaptive (ADAPTIVE). Motion adaptive interpolate (INTERPOLATE) produces sharper pictures, while blend (BLEND) produces smoother motion. Use (INTERPOLATE_TICKER) OR (BLEND_TICKER) if your source file includes a ticker, such as a scrolling headline at the bottom of the frame.
    #[doc(hidden)]
    pub algorithm: std::option::Option<crate::types::DeinterlaceAlgorithm>,
    /// - When set to NORMAL (default), the deinterlacer does not convert frames that are tagged in metadata as progressive. It will only convert those that are tagged as some other type. - When set to FORCE_ALL_FRAMES, the deinterlacer converts every frame to progressive - even those that are already tagged as progressive. Turn Force mode on only if there is a good chance that the metadata has tagged frames as progressive when they are not progressive. Do not turn on otherwise; processing frames that are already progressive into progressive will probably result in lower quality video.
    #[doc(hidden)]
    pub control: std::option::Option<crate::types::DeinterlacerControl>,
    /// Use Deinterlacer (DeinterlaceMode) to choose how the service will do deinterlacing. Default is Deinterlace. - Deinterlace converts interlaced to progressive. - Inverse telecine converts Hard Telecine 29.97i to progressive 23.976p. - Adaptive auto-detects and converts to progressive.
    #[doc(hidden)]
    pub mode: std::option::Option<crate::types::DeinterlacerMode>,
}
impl Deinterlacer {
    /// Only applies when you set Deinterlacer (DeinterlaceMode) to Deinterlace (DEINTERLACE) or Adaptive (ADAPTIVE). Motion adaptive interpolate (INTERPOLATE) produces sharper pictures, while blend (BLEND) produces smoother motion. Use (INTERPOLATE_TICKER) OR (BLEND_TICKER) if your source file includes a ticker, such as a scrolling headline at the bottom of the frame.
    pub fn algorithm(&self) -> std::option::Option<&crate::types::DeinterlaceAlgorithm> {
        self.algorithm.as_ref()
    }
    /// - When set to NORMAL (default), the deinterlacer does not convert frames that are tagged in metadata as progressive. It will only convert those that are tagged as some other type. - When set to FORCE_ALL_FRAMES, the deinterlacer converts every frame to progressive - even those that are already tagged as progressive. Turn Force mode on only if there is a good chance that the metadata has tagged frames as progressive when they are not progressive. Do not turn on otherwise; processing frames that are already progressive into progressive will probably result in lower quality video.
    pub fn control(&self) -> std::option::Option<&crate::types::DeinterlacerControl> {
        self.control.as_ref()
    }
    /// Use Deinterlacer (DeinterlaceMode) to choose how the service will do deinterlacing. Default is Deinterlace. - Deinterlace converts interlaced to progressive. - Inverse telecine converts Hard Telecine 29.97i to progressive 23.976p. - Adaptive auto-detects and converts to progressive.
    pub fn mode(&self) -> std::option::Option<&crate::types::DeinterlacerMode> {
        self.mode.as_ref()
    }
}
impl Deinterlacer {
    /// Creates a new builder-style object to manufacture [`Deinterlacer`](crate::types::Deinterlacer).
    pub fn builder() -> crate::types::builders::DeinterlacerBuilder {
        crate::types::builders::DeinterlacerBuilder::default()
    }
}

/// A builder for [`Deinterlacer`](crate::types::Deinterlacer).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct DeinterlacerBuilder {
    pub(crate) algorithm: std::option::Option<crate::types::DeinterlaceAlgorithm>,
    pub(crate) control: std::option::Option<crate::types::DeinterlacerControl>,
    pub(crate) mode: std::option::Option<crate::types::DeinterlacerMode>,
}
impl DeinterlacerBuilder {
    /// Only applies when you set Deinterlacer (DeinterlaceMode) to Deinterlace (DEINTERLACE) or Adaptive (ADAPTIVE). Motion adaptive interpolate (INTERPOLATE) produces sharper pictures, while blend (BLEND) produces smoother motion. Use (INTERPOLATE_TICKER) OR (BLEND_TICKER) if your source file includes a ticker, such as a scrolling headline at the bottom of the frame.
    pub fn algorithm(mut self, input: crate::types::DeinterlaceAlgorithm) -> Self {
        self.algorithm = Some(input);
        self
    }
    /// Only applies when you set Deinterlacer (DeinterlaceMode) to Deinterlace (DEINTERLACE) or Adaptive (ADAPTIVE). Motion adaptive interpolate (INTERPOLATE) produces sharper pictures, while blend (BLEND) produces smoother motion. Use (INTERPOLATE_TICKER) OR (BLEND_TICKER) if your source file includes a ticker, such as a scrolling headline at the bottom of the frame.
    pub fn set_algorithm(
        mut self,
        input: std::option::Option<crate::types::DeinterlaceAlgorithm>,
    ) -> Self {
        self.algorithm = input;
        self
    }
    /// - When set to NORMAL (default), the deinterlacer does not convert frames that are tagged in metadata as progressive. It will only convert those that are tagged as some other type. - When set to FORCE_ALL_FRAMES, the deinterlacer converts every frame to progressive - even those that are already tagged as progressive. Turn Force mode on only if there is a good chance that the metadata has tagged frames as progressive when they are not progressive. Do not turn on otherwise; processing frames that are already progressive into progressive will probably result in lower quality video.
    pub fn control(mut self, input: crate::types::DeinterlacerControl) -> Self {
        self.control = Some(input);
        self
    }
    /// - When set to NORMAL (default), the deinterlacer does not convert frames that are tagged in metadata as progressive. It will only convert those that are tagged as some other type. - When set to FORCE_ALL_FRAMES, the deinterlacer converts every frame to progressive - even those that are already tagged as progressive. Turn Force mode on only if there is a good chance that the metadata has tagged frames as progressive when they are not progressive. Do not turn on otherwise; processing frames that are already progressive into progressive will probably result in lower quality video.
    pub fn set_control(
        mut self,
        input: std::option::Option<crate::types::DeinterlacerControl>,
    ) -> Self {
        self.control = input;
        self
    }
    /// Use Deinterlacer (DeinterlaceMode) to choose how the service will do deinterlacing. Default is Deinterlace. - Deinterlace converts interlaced to progressive. - Inverse telecine converts Hard Telecine 29.97i to progressive 23.976p. - Adaptive auto-detects and converts to progressive.
    pub fn mode(mut self, input: crate::types::DeinterlacerMode) -> Self {
        self.mode = Some(input);
        self
    }
    /// Use Deinterlacer (DeinterlaceMode) to choose how the service will do deinterlacing. Default is Deinterlace. - Deinterlace converts interlaced to progressive. - Inverse telecine converts Hard Telecine 29.97i to progressive 23.976p. - Adaptive auto-detects and converts to progressive.
    pub fn set_mode(mut self, input: std::option::Option<crate::types::DeinterlacerMode>) -> Self {
        self.mode = input;
        self
    }
    /// Consumes the builder and constructs a [`Deinterlacer`](crate::types::Deinterlacer).
    pub fn build(self) -> crate::types::Deinterlacer {
        crate::types::Deinterlacer {
            algorithm: self.algorithm,
            control: self.control,
            mode: self.mode,
        }
    }
}
