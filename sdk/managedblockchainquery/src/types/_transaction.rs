// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>There are two possible types of transactions used for this data type:</p>
/// <ul>
/// <li> <p>A Bitcoin transaction is a movement of BTC from one address to another.</p> </li>
/// <li> <p>An Ethereum transaction refers to an action initiated by an externally owned account, which is an account managed by a human, not a contract. For example, if Bob sends Alice 1 ETH, Bob's account must be debited and Alice's must be credited. This state-changing action occurs within a transaction.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Transaction {
    /// <p>The blockchain network where the transaction occurred.</p>
    pub network: crate::types::QueryNetwork,
    /// <p>The block hash is a unique identifier for a block. It is a fixed-size string that is calculated by using the information in the block. The block hash is used to verify the integrity of the data in the block.</p>
    pub block_hash: ::std::option::Option<::std::string::String>,
    /// <p>The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub transaction_hash: ::std::string::String,
    /// <p>The block number in which the transaction is recorded.</p>
    pub block_number: ::std::option::Option<::std::string::String>,
    /// <p>The <code>Timestamp</code> of the transaction. </p>
    pub transaction_timestamp: ::aws_smithy_types::DateTime,
    /// <p>The index of the transaction within a blockchain.</p>
    pub transaction_index: i64,
    /// <p>The number of transactions in the block.</p>
    pub number_of_transactions: i64,
    /// <p>The status of the transaction.</p>
    pub status: crate::types::QueryTransactionStatus,
    /// <p>The identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub to: ::std::string::String,
    /// <p>The initiator of the transaction. It is either in the form a public key or a contract address.</p>
    pub from: ::std::option::Option<::std::string::String>,
    /// <p>The blockchain address for the contract.</p>
    pub contract_address: ::std::option::Option<::std::string::String>,
    /// <p>The amount of gas used for the transaction.</p>
    pub gas_used: ::std::option::Option<::std::string::String>,
    /// <p>The amount of gas used up to the specified point in the block.</p>
    pub cumulative_gas_used: ::std::option::Option<::std::string::String>,
    /// <p>The effective gas price.</p>
    pub effective_gas_price: ::std::option::Option<::std::string::String>,
    /// <p>The signature of the transaction. The Z coordinate of a point V.</p>
    pub signature_v: ::std::option::Option<i32>,
    /// <p>The signature of the transaction. The X coordinate of a point R.</p>
    pub signature_r: ::std::option::Option<::std::string::String>,
    /// <p>The signature of the transaction. The Y coordinate of a point S.</p>
    pub signature_s: ::std::option::Option<::std::string::String>,
    /// <p>The transaction fee.</p>
    pub transaction_fee: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub transaction_id: ::std::option::Option<::std::string::String>,
}
impl Transaction {
    /// <p>The blockchain network where the transaction occurred.</p>
    pub fn network(&self) -> &crate::types::QueryNetwork {
        &self.network
    }
    /// <p>The block hash is a unique identifier for a block. It is a fixed-size string that is calculated by using the information in the block. The block hash is used to verify the integrity of the data in the block.</p>
    pub fn block_hash(&self) -> ::std::option::Option<&str> {
        self.block_hash.as_deref()
    }
    /// <p>The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn transaction_hash(&self) -> &str {
        use std::ops::Deref;
        self.transaction_hash.deref()
    }
    /// <p>The block number in which the transaction is recorded.</p>
    pub fn block_number(&self) -> ::std::option::Option<&str> {
        self.block_number.as_deref()
    }
    /// <p>The <code>Timestamp</code> of the transaction. </p>
    pub fn transaction_timestamp(&self) -> &::aws_smithy_types::DateTime {
        &self.transaction_timestamp
    }
    /// <p>The index of the transaction within a blockchain.</p>
    pub fn transaction_index(&self) -> i64 {
        self.transaction_index
    }
    /// <p>The number of transactions in the block.</p>
    pub fn number_of_transactions(&self) -> i64 {
        self.number_of_transactions
    }
    /// <p>The status of the transaction.</p>
    pub fn status(&self) -> &crate::types::QueryTransactionStatus {
        &self.status
    }
    /// <p>The identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn to(&self) -> &str {
        use std::ops::Deref;
        self.to.deref()
    }
    /// <p>The initiator of the transaction. It is either in the form a public key or a contract address.</p>
    pub fn from(&self) -> ::std::option::Option<&str> {
        self.from.as_deref()
    }
    /// <p>The blockchain address for the contract.</p>
    pub fn contract_address(&self) -> ::std::option::Option<&str> {
        self.contract_address.as_deref()
    }
    /// <p>The amount of gas used for the transaction.</p>
    pub fn gas_used(&self) -> ::std::option::Option<&str> {
        self.gas_used.as_deref()
    }
    /// <p>The amount of gas used up to the specified point in the block.</p>
    pub fn cumulative_gas_used(&self) -> ::std::option::Option<&str> {
        self.cumulative_gas_used.as_deref()
    }
    /// <p>The effective gas price.</p>
    pub fn effective_gas_price(&self) -> ::std::option::Option<&str> {
        self.effective_gas_price.as_deref()
    }
    /// <p>The signature of the transaction. The Z coordinate of a point V.</p>
    pub fn signature_v(&self) -> ::std::option::Option<i32> {
        self.signature_v
    }
    /// <p>The signature of the transaction. The X coordinate of a point R.</p>
    pub fn signature_r(&self) -> ::std::option::Option<&str> {
        self.signature_r.as_deref()
    }
    /// <p>The signature of the transaction. The Y coordinate of a point S.</p>
    pub fn signature_s(&self) -> ::std::option::Option<&str> {
        self.signature_s.as_deref()
    }
    /// <p>The transaction fee.</p>
    pub fn transaction_fee(&self) -> ::std::option::Option<&str> {
        self.transaction_fee.as_deref()
    }
    /// <p>The unique identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn transaction_id(&self) -> ::std::option::Option<&str> {
        self.transaction_id.as_deref()
    }
}
impl Transaction {
    /// Creates a new builder-style object to manufacture [`Transaction`](crate::types::Transaction).
    pub fn builder() -> crate::types::builders::TransactionBuilder {
        crate::types::builders::TransactionBuilder::default()
    }
}

/// A builder for [`Transaction`](crate::types::Transaction).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct TransactionBuilder {
    pub(crate) network: ::std::option::Option<crate::types::QueryNetwork>,
    pub(crate) block_hash: ::std::option::Option<::std::string::String>,
    pub(crate) transaction_hash: ::std::option::Option<::std::string::String>,
    pub(crate) block_number: ::std::option::Option<::std::string::String>,
    pub(crate) transaction_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) transaction_index: ::std::option::Option<i64>,
    pub(crate) number_of_transactions: ::std::option::Option<i64>,
    pub(crate) status: ::std::option::Option<crate::types::QueryTransactionStatus>,
    pub(crate) to: ::std::option::Option<::std::string::String>,
    pub(crate) from: ::std::option::Option<::std::string::String>,
    pub(crate) contract_address: ::std::option::Option<::std::string::String>,
    pub(crate) gas_used: ::std::option::Option<::std::string::String>,
    pub(crate) cumulative_gas_used: ::std::option::Option<::std::string::String>,
    pub(crate) effective_gas_price: ::std::option::Option<::std::string::String>,
    pub(crate) signature_v: ::std::option::Option<i32>,
    pub(crate) signature_r: ::std::option::Option<::std::string::String>,
    pub(crate) signature_s: ::std::option::Option<::std::string::String>,
    pub(crate) transaction_fee: ::std::option::Option<::std::string::String>,
    pub(crate) transaction_id: ::std::option::Option<::std::string::String>,
}
impl TransactionBuilder {
    /// <p>The blockchain network where the transaction occurred.</p>
    /// This field is required.
    pub fn network(mut self, input: crate::types::QueryNetwork) -> Self {
        self.network = ::std::option::Option::Some(input);
        self
    }
    /// <p>The blockchain network where the transaction occurred.</p>
    pub fn set_network(mut self, input: ::std::option::Option<crate::types::QueryNetwork>) -> Self {
        self.network = input;
        self
    }
    /// <p>The blockchain network where the transaction occurred.</p>
    pub fn get_network(&self) -> &::std::option::Option<crate::types::QueryNetwork> {
        &self.network
    }
    /// <p>The block hash is a unique identifier for a block. It is a fixed-size string that is calculated by using the information in the block. The block hash is used to verify the integrity of the data in the block.</p>
    pub fn block_hash(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.block_hash = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The block hash is a unique identifier for a block. It is a fixed-size string that is calculated by using the information in the block. The block hash is used to verify the integrity of the data in the block.</p>
    pub fn set_block_hash(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.block_hash = input;
        self
    }
    /// <p>The block hash is a unique identifier for a block. It is a fixed-size string that is calculated by using the information in the block. The block hash is used to verify the integrity of the data in the block.</p>
    pub fn get_block_hash(&self) -> &::std::option::Option<::std::string::String> {
        &self.block_hash
    }
    /// <p>The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    /// This field is required.
    pub fn transaction_hash(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.transaction_hash = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn set_transaction_hash(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.transaction_hash = input;
        self
    }
    /// <p>The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn get_transaction_hash(&self) -> &::std::option::Option<::std::string::String> {
        &self.transaction_hash
    }
    /// <p>The block number in which the transaction is recorded.</p>
    pub fn block_number(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.block_number = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The block number in which the transaction is recorded.</p>
    pub fn set_block_number(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.block_number = input;
        self
    }
    /// <p>The block number in which the transaction is recorded.</p>
    pub fn get_block_number(&self) -> &::std::option::Option<::std::string::String> {
        &self.block_number
    }
    /// <p>The <code>Timestamp</code> of the transaction. </p>
    /// This field is required.
    pub fn transaction_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.transaction_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The <code>Timestamp</code> of the transaction. </p>
    pub fn set_transaction_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.transaction_timestamp = input;
        self
    }
    /// <p>The <code>Timestamp</code> of the transaction. </p>
    pub fn get_transaction_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.transaction_timestamp
    }
    /// <p>The index of the transaction within a blockchain.</p>
    /// This field is required.
    pub fn transaction_index(mut self, input: i64) -> Self {
        self.transaction_index = ::std::option::Option::Some(input);
        self
    }
    /// <p>The index of the transaction within a blockchain.</p>
    pub fn set_transaction_index(mut self, input: ::std::option::Option<i64>) -> Self {
        self.transaction_index = input;
        self
    }
    /// <p>The index of the transaction within a blockchain.</p>
    pub fn get_transaction_index(&self) -> &::std::option::Option<i64> {
        &self.transaction_index
    }
    /// <p>The number of transactions in the block.</p>
    /// This field is required.
    pub fn number_of_transactions(mut self, input: i64) -> Self {
        self.number_of_transactions = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of transactions in the block.</p>
    pub fn set_number_of_transactions(mut self, input: ::std::option::Option<i64>) -> Self {
        self.number_of_transactions = input;
        self
    }
    /// <p>The number of transactions in the block.</p>
    pub fn get_number_of_transactions(&self) -> &::std::option::Option<i64> {
        &self.number_of_transactions
    }
    /// <p>The status of the transaction.</p>
    /// This field is required.
    pub fn status(mut self, input: crate::types::QueryTransactionStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the transaction.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::QueryTransactionStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the transaction.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::QueryTransactionStatus> {
        &self.status
    }
    /// <p>The identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    /// This field is required.
    pub fn to(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.to = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn set_to(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.to = input;
        self
    }
    /// <p>The identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn get_to(&self) -> &::std::option::Option<::std::string::String> {
        &self.to
    }
    /// <p>The initiator of the transaction. It is either in the form a public key or a contract address.</p>
    pub fn from(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.from = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The initiator of the transaction. It is either in the form a public key or a contract address.</p>
    pub fn set_from(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.from = input;
        self
    }
    /// <p>The initiator of the transaction. It is either in the form a public key or a contract address.</p>
    pub fn get_from(&self) -> &::std::option::Option<::std::string::String> {
        &self.from
    }
    /// <p>The blockchain address for the contract.</p>
    pub fn contract_address(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.contract_address = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The blockchain address for the contract.</p>
    pub fn set_contract_address(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.contract_address = input;
        self
    }
    /// <p>The blockchain address for the contract.</p>
    pub fn get_contract_address(&self) -> &::std::option::Option<::std::string::String> {
        &self.contract_address
    }
    /// <p>The amount of gas used for the transaction.</p>
    pub fn gas_used(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.gas_used = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The amount of gas used for the transaction.</p>
    pub fn set_gas_used(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.gas_used = input;
        self
    }
    /// <p>The amount of gas used for the transaction.</p>
    pub fn get_gas_used(&self) -> &::std::option::Option<::std::string::String> {
        &self.gas_used
    }
    /// <p>The amount of gas used up to the specified point in the block.</p>
    pub fn cumulative_gas_used(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cumulative_gas_used = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The amount of gas used up to the specified point in the block.</p>
    pub fn set_cumulative_gas_used(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cumulative_gas_used = input;
        self
    }
    /// <p>The amount of gas used up to the specified point in the block.</p>
    pub fn get_cumulative_gas_used(&self) -> &::std::option::Option<::std::string::String> {
        &self.cumulative_gas_used
    }
    /// <p>The effective gas price.</p>
    pub fn effective_gas_price(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.effective_gas_price = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The effective gas price.</p>
    pub fn set_effective_gas_price(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.effective_gas_price = input;
        self
    }
    /// <p>The effective gas price.</p>
    pub fn get_effective_gas_price(&self) -> &::std::option::Option<::std::string::String> {
        &self.effective_gas_price
    }
    /// <p>The signature of the transaction. The Z coordinate of a point V.</p>
    pub fn signature_v(mut self, input: i32) -> Self {
        self.signature_v = ::std::option::Option::Some(input);
        self
    }
    /// <p>The signature of the transaction. The Z coordinate of a point V.</p>
    pub fn set_signature_v(mut self, input: ::std::option::Option<i32>) -> Self {
        self.signature_v = input;
        self
    }
    /// <p>The signature of the transaction. The Z coordinate of a point V.</p>
    pub fn get_signature_v(&self) -> &::std::option::Option<i32> {
        &self.signature_v
    }
    /// <p>The signature of the transaction. The X coordinate of a point R.</p>
    pub fn signature_r(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.signature_r = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The signature of the transaction. The X coordinate of a point R.</p>
    pub fn set_signature_r(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.signature_r = input;
        self
    }
    /// <p>The signature of the transaction. The X coordinate of a point R.</p>
    pub fn get_signature_r(&self) -> &::std::option::Option<::std::string::String> {
        &self.signature_r
    }
    /// <p>The signature of the transaction. The Y coordinate of a point S.</p>
    pub fn signature_s(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.signature_s = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The signature of the transaction. The Y coordinate of a point S.</p>
    pub fn set_signature_s(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.signature_s = input;
        self
    }
    /// <p>The signature of the transaction. The Y coordinate of a point S.</p>
    pub fn get_signature_s(&self) -> &::std::option::Option<::std::string::String> {
        &self.signature_s
    }
    /// <p>The transaction fee.</p>
    pub fn transaction_fee(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.transaction_fee = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The transaction fee.</p>
    pub fn set_transaction_fee(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.transaction_fee = input;
        self
    }
    /// <p>The transaction fee.</p>
    pub fn get_transaction_fee(&self) -> &::std::option::Option<::std::string::String> {
        &self.transaction_fee
    }
    /// <p>The unique identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn transaction_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.transaction_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn set_transaction_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.transaction_id = input;
        self
    }
    /// <p>The unique identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.</p>
    pub fn get_transaction_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.transaction_id
    }
    /// Consumes the builder and constructs a [`Transaction`](crate::types::Transaction).
    /// This method will fail if any of the following fields are not set:
    /// - [`network`](crate::types::builders::TransactionBuilder::network)
    /// - [`transaction_hash`](crate::types::builders::TransactionBuilder::transaction_hash)
    /// - [`transaction_timestamp`](crate::types::builders::TransactionBuilder::transaction_timestamp)
    /// - [`transaction_index`](crate::types::builders::TransactionBuilder::transaction_index)
    /// - [`number_of_transactions`](crate::types::builders::TransactionBuilder::number_of_transactions)
    /// - [`status`](crate::types::builders::TransactionBuilder::status)
    /// - [`to`](crate::types::builders::TransactionBuilder::to)
    pub fn build(self) -> ::std::result::Result<crate::types::Transaction, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::Transaction {
            network: self.network.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "network",
                    "network was not specified but it is required when building Transaction",
                )
            })?,
            block_hash: self.block_hash,
            transaction_hash: self.transaction_hash.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "transaction_hash",
                    "transaction_hash was not specified but it is required when building Transaction",
                )
            })?,
            block_number: self.block_number,
            transaction_timestamp: self.transaction_timestamp.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "transaction_timestamp",
                    "transaction_timestamp was not specified but it is required when building Transaction",
                )
            })?,
            transaction_index: self.transaction_index.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "transaction_index",
                    "transaction_index was not specified but it is required when building Transaction",
                )
            })?,
            number_of_transactions: self.number_of_transactions.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "number_of_transactions",
                    "number_of_transactions was not specified but it is required when building Transaction",
                )
            })?,
            status: self.status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "status",
                    "status was not specified but it is required when building Transaction",
                )
            })?,
            to: self.to.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "to",
                    "to was not specified but it is required when building Transaction",
                )
            })?,
            from: self.from,
            contract_address: self.contract_address,
            gas_used: self.gas_used,
            cumulative_gas_used: self.cumulative_gas_used,
            effective_gas_price: self.effective_gas_price,
            signature_v: self.signature_v,
            signature_r: self.signature_r,
            signature_s: self.signature_s,
            transaction_fee: self.transaction_fee,
            transaction_id: self.transaction_id,
        })
    }
}
