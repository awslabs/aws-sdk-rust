// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>You do not have sufficient access to perform this action. Access denied errors appear when Amazon Security Lake explicitly or implicitly denies an authorization request. An explicit denial occurs when a policy contains a Deny statement for the specific Amazon Web Services action. An implicit denial occurs when there is no applicable Deny statement and also no applicable Allow statement.</p>
    AccessDeniedException(crate::types::error::AccessDeniedException),
    /// <p>Amazon Security Lake cannot find an Amazon Web Services account with the accountID that you specified, or the account whose credentials you used to make this request isn't a member of an organization.</p>
    AccountNotFoundException(crate::types::error::AccountNotFoundException),
    /// <p>Amazon Security Lake generally returns 404 errors if the requested object is missing from the bucket.</p>
    BucketNotFoundException(crate::types::error::BucketNotFoundException),
    /// <p>More than one process tried to modify a resource at the same time. </p>
    ConcurrentModificationException(crate::types::error::ConcurrentModificationException),
    /// <p>Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.</p>
    ConflictException(crate::types::error::ConflictException),
    /// <p>There was a conflict when you attempted to modify a Security Lake source name. </p>
    ConflictSourceNamesException(crate::types::error::ConflictSourceNamesException),
    /// <p>A conflicting subscription exception operation is in progress. </p>
    ConflictSubscriptionException(crate::types::error::ConflictSubscriptionException),
    /// <p>Represents an error interacting with the Amazon EventBridge service.</p>
    EventBridgeException(crate::types::error::EventBridgeException),
    /// <p>Internal service exceptions are sometimes caused by transient issues. Before you start troubleshooting, perform the operation again. </p>
    InternalServerException(crate::types::error::InternalServerException),
    /// <p>The request was rejected because a value that's not valid or is out of range was supplied for an input parameter. </p>
    InvalidInputException(crate::types::error::InvalidInputException),
    /// <p>The resource could not be found.</p>
    ResourceNotFoundException(crate::types::error::ResourceNotFoundException),
    /// <p>Provides an extension of the AmazonServiceException for errors reported by Amazon S3 while processing a request. In particular, this class provides access to the Amazon S3 extended request ID. If Amazon S3 is incorrectly handling a request and you need to contact Amazon, this extended request ID may provide useful debugging information. </p>
    S3Exception(crate::types::error::S3Exception),
    /// <p>You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase. </p>
    ServiceQuotaExceededException(crate::types::error::ServiceQuotaExceededException),
    /// <p>The limit on the number of requests per second was exceeded. </p>
    ThrottlingException(crate::types::error::ThrottlingException),
    /// <p>Your signing certificate could not be validated. </p>
    ValidationException(crate::types::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessDeniedException(inner) => inner.fmt(f),
            Error::AccountNotFoundException(inner) => inner.fmt(f),
            Error::BucketNotFoundException(inner) => inner.fmt(f),
            Error::ConcurrentModificationException(inner) => inner.fmt(f),
            Error::ConflictException(inner) => inner.fmt(f),
            Error::ConflictSourceNamesException(inner) => inner.fmt(f),
            Error::ConflictSubscriptionException(inner) => inner.fmt(f),
            Error::EventBridgeException(inner) => inner.fmt(f),
            Error::InternalServerException(inner) => inner.fmt(f),
            Error::InvalidInputException(inner) => inner.fmt(f),
            Error::ResourceNotFoundException(inner) => inner.fmt(f),
            Error::S3Exception(inner) => inner.fmt(f),
            Error::ServiceQuotaExceededException(inner) => inner.fmt(f),
            Error::ThrottlingException(inner) => inner.fmt(f),
            Error::ValidationException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_aws_log_source::CreateAwsLogSourceError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_aws_log_source::CreateAwsLogSourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_aws_log_source::CreateAwsLogSourceError> for Error {
    fn from(err: crate::operation::create_aws_log_source::CreateAwsLogSourceError) -> Self {
        match err {
            crate::operation::create_aws_log_source::CreateAwsLogSourceError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::create_aws_log_source::CreateAwsLogSourceError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::create_aws_log_source::CreateAwsLogSourceError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::create_aws_log_source::CreateAwsLogSourceError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::create_aws_log_source::CreateAwsLogSourceError::S3Exception(inner) => Error::S3Exception(inner),
            crate::operation::create_aws_log_source::CreateAwsLogSourceError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::create_aws_log_source::CreateAwsLogSourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_custom_log_source::CreateCustomLogSourceError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_custom_log_source::CreateCustomLogSourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_custom_log_source::CreateCustomLogSourceError> for Error {
    fn from(err: crate::operation::create_custom_log_source::CreateCustomLogSourceError) -> Self {
        match err {
            crate::operation::create_custom_log_source::CreateCustomLogSourceError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::create_custom_log_source::CreateCustomLogSourceError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::create_custom_log_source::CreateCustomLogSourceError::BucketNotFoundException(inner) => Error::BucketNotFoundException(inner),
            crate::operation::create_custom_log_source::CreateCustomLogSourceError::ConflictSourceNamesException(inner) => Error::ConflictSourceNamesException(inner),
            crate::operation::create_custom_log_source::CreateCustomLogSourceError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::create_custom_log_source::CreateCustomLogSourceError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::create_custom_log_source::CreateCustomLogSourceError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::create_custom_log_source::CreateCustomLogSourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_datalake::CreateDatalakeError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_datalake::CreateDatalakeError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_datalake::CreateDatalakeError> for Error {
    fn from(err: crate::operation::create_datalake::CreateDatalakeError) -> Self {
        match err {
            crate::operation::create_datalake::CreateDatalakeError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::create_datalake::CreateDatalakeError::ConflictException(inner) => Error::ConflictException(inner),
            crate::operation::create_datalake::CreateDatalakeError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::create_datalake::CreateDatalakeError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::create_datalake::CreateDatalakeError::ServiceQuotaExceededException(inner) => Error::ServiceQuotaExceededException(inner),
            crate::operation::create_datalake::CreateDatalakeError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::operation::create_datalake::CreateDatalakeError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::create_datalake::CreateDatalakeError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_datalake_auto_enable::CreateDatalakeAutoEnableError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_datalake_auto_enable::CreateDatalakeAutoEnableError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_datalake_auto_enable::CreateDatalakeAutoEnableError> for Error {
    fn from(
        err: crate::operation::create_datalake_auto_enable::CreateDatalakeAutoEnableError,
    ) -> Self {
        match err {
            crate::operation::create_datalake_auto_enable::CreateDatalakeAutoEnableError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::create_datalake_auto_enable::CreateDatalakeAutoEnableError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::create_datalake_auto_enable::CreateDatalakeAutoEnableError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::create_datalake_auto_enable::CreateDatalakeAutoEnableError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::create_datalake_auto_enable::CreateDatalakeAutoEnableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_datalake_delegated_admin::CreateDatalakeDelegatedAdminError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_datalake_delegated_admin::CreateDatalakeDelegatedAdminError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_datalake_delegated_admin::CreateDatalakeDelegatedAdminError>
    for Error
{
    fn from(
        err: crate::operation::create_datalake_delegated_admin::CreateDatalakeDelegatedAdminError,
    ) -> Self {
        match err {
            crate::operation::create_datalake_delegated_admin::CreateDatalakeDelegatedAdminError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::create_datalake_delegated_admin::CreateDatalakeDelegatedAdminError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::create_datalake_delegated_admin::CreateDatalakeDelegatedAdminError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::operation::create_datalake_delegated_admin::CreateDatalakeDelegatedAdminError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::create_datalake_delegated_admin::CreateDatalakeDelegatedAdminError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_datalake_exceptions_subscription::CreateDatalakeExceptionsSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_datalake_exceptions_subscription::CreateDatalakeExceptionsSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_datalake_exceptions_subscription::CreateDatalakeExceptionsSubscriptionError> for Error {
    fn from(err: crate::operation::create_datalake_exceptions_subscription::CreateDatalakeExceptionsSubscriptionError) -> Self {
        match err {
            crate::operation::create_datalake_exceptions_subscription::CreateDatalakeExceptionsSubscriptionError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::create_datalake_exceptions_subscription::CreateDatalakeExceptionsSubscriptionError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::create_datalake_exceptions_subscription::CreateDatalakeExceptionsSubscriptionError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::create_datalake_exceptions_subscription::CreateDatalakeExceptionsSubscriptionError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::create_datalake_exceptions_subscription::CreateDatalakeExceptionsSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_subscriber::CreateSubscriberError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_subscriber::CreateSubscriberError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_subscriber::CreateSubscriberError> for Error {
    fn from(err: crate::operation::create_subscriber::CreateSubscriberError) -> Self {
        match err {
            crate::operation::create_subscriber::CreateSubscriberError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::create_subscriber::CreateSubscriberError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::create_subscriber::CreateSubscriberError::BucketNotFoundException(inner) => Error::BucketNotFoundException(inner),
            crate::operation::create_subscriber::CreateSubscriberError::ConflictSubscriptionException(inner) => Error::ConflictSubscriptionException(inner),
            crate::operation::create_subscriber::CreateSubscriberError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::create_subscriber::CreateSubscriberError::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::operation::create_subscriber::CreateSubscriberError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::create_subscriber::CreateSubscriberError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::create_subscriber::CreateSubscriberError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError> for Error {
    fn from(err: crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError) -> Self {
        match err {
            crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::create_subscription_notification_configuration::CreateSubscriptionNotificationConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_aws_log_source::DeleteAwsLogSourceError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_aws_log_source::DeleteAwsLogSourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_aws_log_source::DeleteAwsLogSourceError> for Error {
    fn from(err: crate::operation::delete_aws_log_source::DeleteAwsLogSourceError) -> Self {
        match err {
            crate::operation::delete_aws_log_source::DeleteAwsLogSourceError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::delete_aws_log_source::DeleteAwsLogSourceError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::delete_aws_log_source::DeleteAwsLogSourceError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::delete_aws_log_source::DeleteAwsLogSourceError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::delete_aws_log_source::DeleteAwsLogSourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_custom_log_source::DeleteCustomLogSourceError> for Error {
    fn from(err: crate::operation::delete_custom_log_source::DeleteCustomLogSourceError) -> Self {
        match err {
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError::BucketNotFoundException(inner) => Error::BucketNotFoundException(inner),
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError::ConflictSourceNamesException(inner) => Error::ConflictSourceNamesException(inner),
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::delete_custom_log_source::DeleteCustomLogSourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_datalake::DeleteDatalakeError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_datalake::DeleteDatalakeError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_datalake::DeleteDatalakeError> for Error {
    fn from(err: crate::operation::delete_datalake::DeleteDatalakeError) -> Self {
        match err {
            crate::operation::delete_datalake::DeleteDatalakeError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::delete_datalake::DeleteDatalakeError::ConflictException(inner) => Error::ConflictException(inner),
            crate::operation::delete_datalake::DeleteDatalakeError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::delete_datalake::DeleteDatalakeError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::delete_datalake::DeleteDatalakeError::ServiceQuotaExceededException(inner) => Error::ServiceQuotaExceededException(inner),
            crate::operation::delete_datalake::DeleteDatalakeError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::operation::delete_datalake::DeleteDatalakeError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::delete_datalake::DeleteDatalakeError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_datalake_auto_enable::DeleteDatalakeAutoEnableError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_datalake_auto_enable::DeleteDatalakeAutoEnableError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_datalake_auto_enable::DeleteDatalakeAutoEnableError> for Error {
    fn from(
        err: crate::operation::delete_datalake_auto_enable::DeleteDatalakeAutoEnableError,
    ) -> Self {
        match err {
            crate::operation::delete_datalake_auto_enable::DeleteDatalakeAutoEnableError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::delete_datalake_auto_enable::DeleteDatalakeAutoEnableError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::delete_datalake_auto_enable::DeleteDatalakeAutoEnableError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::delete_datalake_auto_enable::DeleteDatalakeAutoEnableError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::delete_datalake_auto_enable::DeleteDatalakeAutoEnableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_datalake_delegated_admin::DeleteDatalakeDelegatedAdminError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_datalake_delegated_admin::DeleteDatalakeDelegatedAdminError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_datalake_delegated_admin::DeleteDatalakeDelegatedAdminError>
    for Error
{
    fn from(
        err: crate::operation::delete_datalake_delegated_admin::DeleteDatalakeDelegatedAdminError,
    ) -> Self {
        match err {
            crate::operation::delete_datalake_delegated_admin::DeleteDatalakeDelegatedAdminError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::delete_datalake_delegated_admin::DeleteDatalakeDelegatedAdminError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::delete_datalake_delegated_admin::DeleteDatalakeDelegatedAdminError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::operation::delete_datalake_delegated_admin::DeleteDatalakeDelegatedAdminError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::delete_datalake_delegated_admin::DeleteDatalakeDelegatedAdminError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_datalake_exceptions_subscription::DeleteDatalakeExceptionsSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_datalake_exceptions_subscription::DeleteDatalakeExceptionsSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_datalake_exceptions_subscription::DeleteDatalakeExceptionsSubscriptionError> for Error {
    fn from(err: crate::operation::delete_datalake_exceptions_subscription::DeleteDatalakeExceptionsSubscriptionError) -> Self {
        match err {
            crate::operation::delete_datalake_exceptions_subscription::DeleteDatalakeExceptionsSubscriptionError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::delete_datalake_exceptions_subscription::DeleteDatalakeExceptionsSubscriptionError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::delete_datalake_exceptions_subscription::DeleteDatalakeExceptionsSubscriptionError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::delete_datalake_exceptions_subscription::DeleteDatalakeExceptionsSubscriptionError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::delete_datalake_exceptions_subscription::DeleteDatalakeExceptionsSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_subscriber::DeleteSubscriberError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_subscriber::DeleteSubscriberError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_subscriber::DeleteSubscriberError> for Error {
    fn from(err: crate::operation::delete_subscriber::DeleteSubscriberError) -> Self {
        match err {
            crate::operation::delete_subscriber::DeleteSubscriberError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::delete_subscriber::DeleteSubscriberError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::delete_subscriber::DeleteSubscriberError::BucketNotFoundException(inner) => Error::BucketNotFoundException(inner),
            crate::operation::delete_subscriber::DeleteSubscriberError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::delete_subscriber::DeleteSubscriberError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::delete_subscriber::DeleteSubscriberError::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::operation::delete_subscriber::DeleteSubscriberError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::delete_subscriber::DeleteSubscriberError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::delete_subscriber::DeleteSubscriberError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError> for Error {
    fn from(err: crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError) -> Self {
        match err {
            crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::delete_subscription_notification_configuration::DeleteSubscriptionNotificationConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_datalake::GetDatalakeError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::get_datalake::GetDatalakeError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_datalake::GetDatalakeError> for Error {
    fn from(err: crate::operation::get_datalake::GetDatalakeError) -> Self {
        match err {
            crate::operation::get_datalake::GetDatalakeError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::operation::get_datalake::GetDatalakeError::AccountNotFoundException(inner) => {
                Error::AccountNotFoundException(inner)
            }
            crate::operation::get_datalake::GetDatalakeError::InternalServerException(inner) => {
                Error::InternalServerException(inner)
            }
            crate::operation::get_datalake::GetDatalakeError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::operation::get_datalake::GetDatalakeError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::get_datalake::GetDatalakeError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_datalake_auto_enable::GetDatalakeAutoEnableError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_datalake_auto_enable::GetDatalakeAutoEnableError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_datalake_auto_enable::GetDatalakeAutoEnableError> for Error {
    fn from(err: crate::operation::get_datalake_auto_enable::GetDatalakeAutoEnableError) -> Self {
        match err {
            crate::operation::get_datalake_auto_enable::GetDatalakeAutoEnableError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::get_datalake_auto_enable::GetDatalakeAutoEnableError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::get_datalake_auto_enable::GetDatalakeAutoEnableError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::get_datalake_auto_enable::GetDatalakeAutoEnableError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::get_datalake_auto_enable::GetDatalakeAutoEnableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_datalake_exceptions_expiry::GetDatalakeExceptionsExpiryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_datalake_exceptions_expiry::GetDatalakeExceptionsExpiryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_datalake_exceptions_expiry::GetDatalakeExceptionsExpiryError>
    for Error
{
    fn from(
        err: crate::operation::get_datalake_exceptions_expiry::GetDatalakeExceptionsExpiryError,
    ) -> Self {
        match err {
            crate::operation::get_datalake_exceptions_expiry::GetDatalakeExceptionsExpiryError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::get_datalake_exceptions_expiry::GetDatalakeExceptionsExpiryError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::get_datalake_exceptions_expiry::GetDatalakeExceptionsExpiryError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::get_datalake_exceptions_expiry::GetDatalakeExceptionsExpiryError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::get_datalake_exceptions_expiry::GetDatalakeExceptionsExpiryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_datalake_exceptions_subscription::GetDatalakeExceptionsSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_datalake_exceptions_subscription::GetDatalakeExceptionsSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_datalake_exceptions_subscription::GetDatalakeExceptionsSubscriptionError> for Error {
    fn from(err: crate::operation::get_datalake_exceptions_subscription::GetDatalakeExceptionsSubscriptionError) -> Self {
        match err {
            crate::operation::get_datalake_exceptions_subscription::GetDatalakeExceptionsSubscriptionError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::get_datalake_exceptions_subscription::GetDatalakeExceptionsSubscriptionError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::get_datalake_exceptions_subscription::GetDatalakeExceptionsSubscriptionError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::get_datalake_exceptions_subscription::GetDatalakeExceptionsSubscriptionError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::get_datalake_exceptions_subscription::GetDatalakeExceptionsSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_datalake_status::GetDatalakeStatusError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_datalake_status::GetDatalakeStatusError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_datalake_status::GetDatalakeStatusError> for Error {
    fn from(err: crate::operation::get_datalake_status::GetDatalakeStatusError) -> Self {
        match err {
            crate::operation::get_datalake_status::GetDatalakeStatusError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::get_datalake_status::GetDatalakeStatusError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::get_datalake_status::GetDatalakeStatusError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::get_datalake_status::GetDatalakeStatusError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::get_datalake_status::GetDatalakeStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::get_subscriber::GetSubscriberError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_subscriber::GetSubscriberError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_subscriber::GetSubscriberError> for Error {
    fn from(err: crate::operation::get_subscriber::GetSubscriberError) -> Self {
        match err {
            crate::operation::get_subscriber::GetSubscriberError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::operation::get_subscriber::GetSubscriberError::AccountNotFoundException(
                inner,
            ) => Error::AccountNotFoundException(inner),
            crate::operation::get_subscriber::GetSubscriberError::InternalServerException(
                inner,
            ) => Error::InternalServerException(inner),
            crate::operation::get_subscriber::GetSubscriberError::InvalidInputException(inner) => {
                Error::InvalidInputException(inner)
            }
            crate::operation::get_subscriber::GetSubscriberError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::operation::get_subscriber::GetSubscriberError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_datalake_exceptions::ListDatalakeExceptionsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_datalake_exceptions::ListDatalakeExceptionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_datalake_exceptions::ListDatalakeExceptionsError> for Error {
    fn from(err: crate::operation::list_datalake_exceptions::ListDatalakeExceptionsError) -> Self {
        match err {
            crate::operation::list_datalake_exceptions::ListDatalakeExceptionsError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::list_datalake_exceptions::ListDatalakeExceptionsError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::list_datalake_exceptions::ListDatalakeExceptionsError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::list_datalake_exceptions::ListDatalakeExceptionsError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::list_datalake_exceptions::ListDatalakeExceptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_log_sources::ListLogSourcesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_log_sources::ListLogSourcesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_log_sources::ListLogSourcesError> for Error {
    fn from(err: crate::operation::list_log_sources::ListLogSourcesError) -> Self {
        match err {
            crate::operation::list_log_sources::ListLogSourcesError::AccessDeniedException(
                inner,
            ) => Error::AccessDeniedException(inner),
            crate::operation::list_log_sources::ListLogSourcesError::AccountNotFoundException(
                inner,
            ) => Error::AccountNotFoundException(inner),
            crate::operation::list_log_sources::ListLogSourcesError::InternalServerException(
                inner,
            ) => Error::InternalServerException(inner),
            crate::operation::list_log_sources::ListLogSourcesError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::operation::list_log_sources::ListLogSourcesError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::list_log_sources::ListLogSourcesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_subscribers::ListSubscribersError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_subscribers::ListSubscribersError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_subscribers::ListSubscribersError> for Error {
    fn from(err: crate::operation::list_subscribers::ListSubscribersError) -> Self {
        match err {
            crate::operation::list_subscribers::ListSubscribersError::AccessDeniedException(
                inner,
            ) => Error::AccessDeniedException(inner),
            crate::operation::list_subscribers::ListSubscribersError::AccountNotFoundException(
                inner,
            ) => Error::AccountNotFoundException(inner),
            crate::operation::list_subscribers::ListSubscribersError::InternalServerException(
                inner,
            ) => Error::InternalServerException(inner),
            crate::operation::list_subscribers::ListSubscribersError::InvalidInputException(
                inner,
            ) => Error::InvalidInputException(inner),
            crate::operation::list_subscribers::ListSubscribersError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::operation::list_subscribers::ListSubscribersError::ValidationException(
                inner,
            ) => Error::ValidationException(inner),
            crate::operation::list_subscribers::ListSubscribersError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_datalake::UpdateDatalakeError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_datalake::UpdateDatalakeError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_datalake::UpdateDatalakeError> for Error {
    fn from(err: crate::operation::update_datalake::UpdateDatalakeError) -> Self {
        match err {
            crate::operation::update_datalake::UpdateDatalakeError::AccessDeniedException(
                inner,
            ) => Error::AccessDeniedException(inner),
            crate::operation::update_datalake::UpdateDatalakeError::EventBridgeException(inner) => {
                Error::EventBridgeException(inner)
            }
            crate::operation::update_datalake::UpdateDatalakeError::InternalServerException(
                inner,
            ) => Error::InternalServerException(inner),
            crate::operation::update_datalake::UpdateDatalakeError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::operation::update_datalake::UpdateDatalakeError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::update_datalake::UpdateDatalakeError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_datalake_exceptions_expiry::UpdateDatalakeExceptionsExpiryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_datalake_exceptions_expiry::UpdateDatalakeExceptionsExpiryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_datalake_exceptions_expiry::UpdateDatalakeExceptionsExpiryError>
    for Error
{
    fn from(
        err: crate::operation::update_datalake_exceptions_expiry::UpdateDatalakeExceptionsExpiryError,
    ) -> Self {
        match err {
            crate::operation::update_datalake_exceptions_expiry::UpdateDatalakeExceptionsExpiryError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::update_datalake_exceptions_expiry::UpdateDatalakeExceptionsExpiryError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::update_datalake_exceptions_expiry::UpdateDatalakeExceptionsExpiryError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::update_datalake_exceptions_expiry::UpdateDatalakeExceptionsExpiryError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::update_datalake_exceptions_expiry::UpdateDatalakeExceptionsExpiryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_datalake_exceptions_subscription::UpdateDatalakeExceptionsSubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_datalake_exceptions_subscription::UpdateDatalakeExceptionsSubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_datalake_exceptions_subscription::UpdateDatalakeExceptionsSubscriptionError> for Error {
    fn from(err: crate::operation::update_datalake_exceptions_subscription::UpdateDatalakeExceptionsSubscriptionError) -> Self {
        match err {
            crate::operation::update_datalake_exceptions_subscription::UpdateDatalakeExceptionsSubscriptionError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::update_datalake_exceptions_subscription::UpdateDatalakeExceptionsSubscriptionError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::update_datalake_exceptions_subscription::UpdateDatalakeExceptionsSubscriptionError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::update_datalake_exceptions_subscription::UpdateDatalakeExceptionsSubscriptionError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::update_datalake_exceptions_subscription::UpdateDatalakeExceptionsSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_subscriber::UpdateSubscriberError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_subscriber::UpdateSubscriberError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_subscriber::UpdateSubscriberError> for Error {
    fn from(err: crate::operation::update_subscriber::UpdateSubscriberError) -> Self {
        match err {
            crate::operation::update_subscriber::UpdateSubscriberError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::update_subscriber::UpdateSubscriberError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::update_subscriber::UpdateSubscriberError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::update_subscriber::UpdateSubscriberError::ConflictSubscriptionException(inner) => Error::ConflictSubscriptionException(inner),
            crate::operation::update_subscriber::UpdateSubscriberError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::update_subscriber::UpdateSubscriberError::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::operation::update_subscriber::UpdateSubscriberError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::update_subscriber::UpdateSubscriberError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError> for Error {
    fn from(err: crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError) -> Self {
        match err {
            crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError::AccessDeniedException(inner) => Error::AccessDeniedException(inner),
            crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError::AccountNotFoundException(inner) => Error::AccountNotFoundException(inner),
            crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError::ConcurrentModificationException(inner) => Error::ConcurrentModificationException(inner),
            crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError::InternalServerException(inner) => Error::InternalServerException(inner),
            crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::update_subscription_notification_configuration::UpdateSubscriptionNotificationConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessDeniedException(e) => e.request_id(),
            Self::AccountNotFoundException(e) => e.request_id(),
            Self::BucketNotFoundException(e) => e.request_id(),
            Self::ConcurrentModificationException(e) => e.request_id(),
            Self::ConflictException(e) => e.request_id(),
            Self::ConflictSourceNamesException(e) => e.request_id(),
            Self::ConflictSubscriptionException(e) => e.request_id(),
            Self::EventBridgeException(e) => e.request_id(),
            Self::InternalServerException(e) => e.request_id(),
            Self::InvalidInputException(e) => e.request_id(),
            Self::ResourceNotFoundException(e) => e.request_id(),
            Self::S3Exception(e) => e.request_id(),
            Self::ServiceQuotaExceededException(e) => e.request_id(),
            Self::ThrottlingException(e) => e.request_id(),
            Self::ValidationException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
