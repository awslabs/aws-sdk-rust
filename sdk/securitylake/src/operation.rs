// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Operation shape for `CreateAwsLogSource`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`create_aws_log_source`](crate::client::Client::create_aws_log_source).
///
/// See [`crate::client::fluent_builders::CreateAwsLogSource`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct CreateAwsLogSource {
    _private: (),
}
impl CreateAwsLogSource {
    /// Creates a new builder-style object to manufacture [`CreateAwsLogSourceInput`](crate::input::CreateAwsLogSourceInput).
    pub fn builder() -> crate::input::create_aws_log_source_input::Builder {
        crate::input::create_aws_log_source_input::Builder::default()
    }
    /// Creates a new `CreateAwsLogSource` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateAwsLogSource {
    type Output = std::result::Result<
        crate::output::CreateAwsLogSourceOutput,
        crate::error::CreateAwsLogSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_aws_log_source_error(response)
        } else {
            crate::operation_deser::parse_create_aws_log_source_response(response)
        }
    }
}

/// Operation shape for `CreateCustomLogSource`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`create_custom_log_source`](crate::client::Client::create_custom_log_source).
///
/// See [`crate::client::fluent_builders::CreateCustomLogSource`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct CreateCustomLogSource {
    _private: (),
}
impl CreateCustomLogSource {
    /// Creates a new builder-style object to manufacture [`CreateCustomLogSourceInput`](crate::input::CreateCustomLogSourceInput).
    pub fn builder() -> crate::input::create_custom_log_source_input::Builder {
        crate::input::create_custom_log_source_input::Builder::default()
    }
    /// Creates a new `CreateCustomLogSource` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateCustomLogSource {
    type Output = std::result::Result<
        crate::output::CreateCustomLogSourceOutput,
        crate::error::CreateCustomLogSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_custom_log_source_error(response)
        } else {
            crate::operation_deser::parse_create_custom_log_source_response(response)
        }
    }
}

/// Operation shape for `CreateDatalake`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`create_datalake`](crate::client::Client::create_datalake).
///
/// See [`crate::client::fluent_builders::CreateDatalake`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct CreateDatalake {
    _private: (),
}
impl CreateDatalake {
    /// Creates a new builder-style object to manufacture [`CreateDatalakeInput`](crate::input::CreateDatalakeInput).
    pub fn builder() -> crate::input::create_datalake_input::Builder {
        crate::input::create_datalake_input::Builder::default()
    }
    /// Creates a new `CreateDatalake` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateDatalake {
    type Output =
        std::result::Result<crate::output::CreateDatalakeOutput, crate::error::CreateDatalakeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_datalake_error(response)
        } else {
            crate::operation_deser::parse_create_datalake_response(response)
        }
    }
}

/// Operation shape for `CreateDatalakeAutoEnable`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`create_datalake_auto_enable`](crate::client::Client::create_datalake_auto_enable).
///
/// See [`crate::client::fluent_builders::CreateDatalakeAutoEnable`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct CreateDatalakeAutoEnable {
    _private: (),
}
impl CreateDatalakeAutoEnable {
    /// Creates a new builder-style object to manufacture [`CreateDatalakeAutoEnableInput`](crate::input::CreateDatalakeAutoEnableInput).
    pub fn builder() -> crate::input::create_datalake_auto_enable_input::Builder {
        crate::input::create_datalake_auto_enable_input::Builder::default()
    }
    /// Creates a new `CreateDatalakeAutoEnable` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateDatalakeAutoEnable {
    type Output = std::result::Result<
        crate::output::CreateDatalakeAutoEnableOutput,
        crate::error::CreateDatalakeAutoEnableError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_datalake_auto_enable_error(response)
        } else {
            crate::operation_deser::parse_create_datalake_auto_enable_response(response)
        }
    }
}

/// Operation shape for `CreateDatalakeDelegatedAdmin`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`create_datalake_delegated_admin`](crate::client::Client::create_datalake_delegated_admin).
///
/// See [`crate::client::fluent_builders::CreateDatalakeDelegatedAdmin`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct CreateDatalakeDelegatedAdmin {
    _private: (),
}
impl CreateDatalakeDelegatedAdmin {
    /// Creates a new builder-style object to manufacture [`CreateDatalakeDelegatedAdminInput`](crate::input::CreateDatalakeDelegatedAdminInput).
    pub fn builder() -> crate::input::create_datalake_delegated_admin_input::Builder {
        crate::input::create_datalake_delegated_admin_input::Builder::default()
    }
    /// Creates a new `CreateDatalakeDelegatedAdmin` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateDatalakeDelegatedAdmin {
    type Output = std::result::Result<
        crate::output::CreateDatalakeDelegatedAdminOutput,
        crate::error::CreateDatalakeDelegatedAdminError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_datalake_delegated_admin_error(response)
        } else {
            crate::operation_deser::parse_create_datalake_delegated_admin_response(response)
        }
    }
}

/// Operation shape for `CreateDatalakeExceptionsSubscription`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`create_datalake_exceptions_subscription`](crate::client::Client::create_datalake_exceptions_subscription).
///
/// See [`crate::client::fluent_builders::CreateDatalakeExceptionsSubscription`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct CreateDatalakeExceptionsSubscription {
    _private: (),
}
impl CreateDatalakeExceptionsSubscription {
    /// Creates a new builder-style object to manufacture [`CreateDatalakeExceptionsSubscriptionInput`](crate::input::CreateDatalakeExceptionsSubscriptionInput).
    pub fn builder() -> crate::input::create_datalake_exceptions_subscription_input::Builder {
        crate::input::create_datalake_exceptions_subscription_input::Builder::default()
    }
    /// Creates a new `CreateDatalakeExceptionsSubscription` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateDatalakeExceptionsSubscription {
    type Output = std::result::Result<
        crate::output::CreateDatalakeExceptionsSubscriptionOutput,
        crate::error::CreateDatalakeExceptionsSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_datalake_exceptions_subscription_error(response)
        } else {
            crate::operation_deser::parse_create_datalake_exceptions_subscription_response(response)
        }
    }
}

/// Operation shape for `CreateSubscriber`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`create_subscriber`](crate::client::Client::create_subscriber).
///
/// See [`crate::client::fluent_builders::CreateSubscriber`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct CreateSubscriber {
    _private: (),
}
impl CreateSubscriber {
    /// Creates a new builder-style object to manufacture [`CreateSubscriberInput`](crate::input::CreateSubscriberInput).
    pub fn builder() -> crate::input::create_subscriber_input::Builder {
        crate::input::create_subscriber_input::Builder::default()
    }
    /// Creates a new `CreateSubscriber` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateSubscriber {
    type Output = std::result::Result<
        crate::output::CreateSubscriberOutput,
        crate::error::CreateSubscriberError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_subscriber_error(response)
        } else {
            crate::operation_deser::parse_create_subscriber_response(response)
        }
    }
}

/// Operation shape for `CreateSubscriptionNotificationConfiguration`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`create_subscription_notification_configuration`](crate::client::Client::create_subscription_notification_configuration).
///
/// See [`crate::client::fluent_builders::CreateSubscriptionNotificationConfiguration`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct CreateSubscriptionNotificationConfiguration {
    _private: (),
}
impl CreateSubscriptionNotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateSubscriptionNotificationConfigurationInput`](crate::input::CreateSubscriptionNotificationConfigurationInput).
    pub fn builder() -> crate::input::create_subscription_notification_configuration_input::Builder
    {
        crate::input::create_subscription_notification_configuration_input::Builder::default()
    }
    /// Creates a new `CreateSubscriptionNotificationConfiguration` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse
    for CreateSubscriptionNotificationConfiguration
{
    type Output = std::result::Result<
        crate::output::CreateSubscriptionNotificationConfigurationOutput,
        crate::error::CreateSubscriptionNotificationConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_subscription_notification_configuration_error(
                response,
            )
        } else {
            crate::operation_deser::parse_create_subscription_notification_configuration_response(
                response,
            )
        }
    }
}

/// Operation shape for `DeleteAwsLogSource`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`delete_aws_log_source`](crate::client::Client::delete_aws_log_source).
///
/// See [`crate::client::fluent_builders::DeleteAwsLogSource`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct DeleteAwsLogSource {
    _private: (),
}
impl DeleteAwsLogSource {
    /// Creates a new builder-style object to manufacture [`DeleteAwsLogSourceInput`](crate::input::DeleteAwsLogSourceInput).
    pub fn builder() -> crate::input::delete_aws_log_source_input::Builder {
        crate::input::delete_aws_log_source_input::Builder::default()
    }
    /// Creates a new `DeleteAwsLogSource` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for DeleteAwsLogSource {
    type Output = std::result::Result<
        crate::output::DeleteAwsLogSourceOutput,
        crate::error::DeleteAwsLogSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_aws_log_source_error(response)
        } else {
            crate::operation_deser::parse_delete_aws_log_source_response(response)
        }
    }
}

/// Operation shape for `DeleteCustomLogSource`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`delete_custom_log_source`](crate::client::Client::delete_custom_log_source).
///
/// See [`crate::client::fluent_builders::DeleteCustomLogSource`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct DeleteCustomLogSource {
    _private: (),
}
impl DeleteCustomLogSource {
    /// Creates a new builder-style object to manufacture [`DeleteCustomLogSourceInput`](crate::input::DeleteCustomLogSourceInput).
    pub fn builder() -> crate::input::delete_custom_log_source_input::Builder {
        crate::input::delete_custom_log_source_input::Builder::default()
    }
    /// Creates a new `DeleteCustomLogSource` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for DeleteCustomLogSource {
    type Output = std::result::Result<
        crate::output::DeleteCustomLogSourceOutput,
        crate::error::DeleteCustomLogSourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_custom_log_source_error(response)
        } else {
            crate::operation_deser::parse_delete_custom_log_source_response(response)
        }
    }
}

/// Operation shape for `DeleteDatalake`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`delete_datalake`](crate::client::Client::delete_datalake).
///
/// See [`crate::client::fluent_builders::DeleteDatalake`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct DeleteDatalake {
    _private: (),
}
impl DeleteDatalake {
    /// Creates a new builder-style object to manufacture [`DeleteDatalakeInput`](crate::input::DeleteDatalakeInput).
    pub fn builder() -> crate::input::delete_datalake_input::Builder {
        crate::input::delete_datalake_input::Builder::default()
    }
    /// Creates a new `DeleteDatalake` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for DeleteDatalake {
    type Output =
        std::result::Result<crate::output::DeleteDatalakeOutput, crate::error::DeleteDatalakeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_datalake_error(response)
        } else {
            crate::operation_deser::parse_delete_datalake_response(response)
        }
    }
}

/// Operation shape for `DeleteDatalakeAutoEnable`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`delete_datalake_auto_enable`](crate::client::Client::delete_datalake_auto_enable).
///
/// See [`crate::client::fluent_builders::DeleteDatalakeAutoEnable`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct DeleteDatalakeAutoEnable {
    _private: (),
}
impl DeleteDatalakeAutoEnable {
    /// Creates a new builder-style object to manufacture [`DeleteDatalakeAutoEnableInput`](crate::input::DeleteDatalakeAutoEnableInput).
    pub fn builder() -> crate::input::delete_datalake_auto_enable_input::Builder {
        crate::input::delete_datalake_auto_enable_input::Builder::default()
    }
    /// Creates a new `DeleteDatalakeAutoEnable` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for DeleteDatalakeAutoEnable {
    type Output = std::result::Result<
        crate::output::DeleteDatalakeAutoEnableOutput,
        crate::error::DeleteDatalakeAutoEnableError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_datalake_auto_enable_error(response)
        } else {
            crate::operation_deser::parse_delete_datalake_auto_enable_response(response)
        }
    }
}

/// Operation shape for `DeleteDatalakeDelegatedAdmin`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`delete_datalake_delegated_admin`](crate::client::Client::delete_datalake_delegated_admin).
///
/// See [`crate::client::fluent_builders::DeleteDatalakeDelegatedAdmin`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct DeleteDatalakeDelegatedAdmin {
    _private: (),
}
impl DeleteDatalakeDelegatedAdmin {
    /// Creates a new builder-style object to manufacture [`DeleteDatalakeDelegatedAdminInput`](crate::input::DeleteDatalakeDelegatedAdminInput).
    pub fn builder() -> crate::input::delete_datalake_delegated_admin_input::Builder {
        crate::input::delete_datalake_delegated_admin_input::Builder::default()
    }
    /// Creates a new `DeleteDatalakeDelegatedAdmin` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for DeleteDatalakeDelegatedAdmin {
    type Output = std::result::Result<
        crate::output::DeleteDatalakeDelegatedAdminOutput,
        crate::error::DeleteDatalakeDelegatedAdminError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_datalake_delegated_admin_error(response)
        } else {
            crate::operation_deser::parse_delete_datalake_delegated_admin_response(response)
        }
    }
}

/// Operation shape for `DeleteDatalakeExceptionsSubscription`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`delete_datalake_exceptions_subscription`](crate::client::Client::delete_datalake_exceptions_subscription).
///
/// See [`crate::client::fluent_builders::DeleteDatalakeExceptionsSubscription`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct DeleteDatalakeExceptionsSubscription {
    _private: (),
}
impl DeleteDatalakeExceptionsSubscription {
    /// Creates a new builder-style object to manufacture [`DeleteDatalakeExceptionsSubscriptionInput`](crate::input::DeleteDatalakeExceptionsSubscriptionInput).
    pub fn builder() -> crate::input::delete_datalake_exceptions_subscription_input::Builder {
        crate::input::delete_datalake_exceptions_subscription_input::Builder::default()
    }
    /// Creates a new `DeleteDatalakeExceptionsSubscription` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for DeleteDatalakeExceptionsSubscription {
    type Output = std::result::Result<
        crate::output::DeleteDatalakeExceptionsSubscriptionOutput,
        crate::error::DeleteDatalakeExceptionsSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_datalake_exceptions_subscription_error(response)
        } else {
            crate::operation_deser::parse_delete_datalake_exceptions_subscription_response(response)
        }
    }
}

/// Operation shape for `DeleteSubscriber`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`delete_subscriber`](crate::client::Client::delete_subscriber).
///
/// See [`crate::client::fluent_builders::DeleteSubscriber`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct DeleteSubscriber {
    _private: (),
}
impl DeleteSubscriber {
    /// Creates a new builder-style object to manufacture [`DeleteSubscriberInput`](crate::input::DeleteSubscriberInput).
    pub fn builder() -> crate::input::delete_subscriber_input::Builder {
        crate::input::delete_subscriber_input::Builder::default()
    }
    /// Creates a new `DeleteSubscriber` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for DeleteSubscriber {
    type Output = std::result::Result<
        crate::output::DeleteSubscriberOutput,
        crate::error::DeleteSubscriberError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_subscriber_error(response)
        } else {
            crate::operation_deser::parse_delete_subscriber_response(response)
        }
    }
}

/// Operation shape for `DeleteSubscriptionNotificationConfiguration`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`delete_subscription_notification_configuration`](crate::client::Client::delete_subscription_notification_configuration).
///
/// See [`crate::client::fluent_builders::DeleteSubscriptionNotificationConfiguration`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct DeleteSubscriptionNotificationConfiguration {
    _private: (),
}
impl DeleteSubscriptionNotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteSubscriptionNotificationConfigurationInput`](crate::input::DeleteSubscriptionNotificationConfigurationInput).
    pub fn builder() -> crate::input::delete_subscription_notification_configuration_input::Builder
    {
        crate::input::delete_subscription_notification_configuration_input::Builder::default()
    }
    /// Creates a new `DeleteSubscriptionNotificationConfiguration` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse
    for DeleteSubscriptionNotificationConfiguration
{
    type Output = std::result::Result<
        crate::output::DeleteSubscriptionNotificationConfigurationOutput,
        crate::error::DeleteSubscriptionNotificationConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_subscription_notification_configuration_error(
                response,
            )
        } else {
            crate::operation_deser::parse_delete_subscription_notification_configuration_response(
                response,
            )
        }
    }
}

/// Operation shape for `GetDatalake`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`get_datalake`](crate::client::Client::get_datalake).
///
/// See [`crate::client::fluent_builders::GetDatalake`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct GetDatalake {
    _private: (),
}
impl GetDatalake {
    /// Creates a new builder-style object to manufacture [`GetDatalakeInput`](crate::input::GetDatalakeInput).
    pub fn builder() -> crate::input::get_datalake_input::Builder {
        crate::input::get_datalake_input::Builder::default()
    }
    /// Creates a new `GetDatalake` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for GetDatalake {
    type Output =
        std::result::Result<crate::output::GetDatalakeOutput, crate::error::GetDatalakeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_datalake_error(response)
        } else {
            crate::operation_deser::parse_get_datalake_response(response)
        }
    }
}

/// Operation shape for `GetDatalakeAutoEnable`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`get_datalake_auto_enable`](crate::client::Client::get_datalake_auto_enable).
///
/// See [`crate::client::fluent_builders::GetDatalakeAutoEnable`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct GetDatalakeAutoEnable {
    _private: (),
}
impl GetDatalakeAutoEnable {
    /// Creates a new builder-style object to manufacture [`GetDatalakeAutoEnableInput`](crate::input::GetDatalakeAutoEnableInput).
    pub fn builder() -> crate::input::get_datalake_auto_enable_input::Builder {
        crate::input::get_datalake_auto_enable_input::Builder::default()
    }
    /// Creates a new `GetDatalakeAutoEnable` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for GetDatalakeAutoEnable {
    type Output = std::result::Result<
        crate::output::GetDatalakeAutoEnableOutput,
        crate::error::GetDatalakeAutoEnableError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_datalake_auto_enable_error(response)
        } else {
            crate::operation_deser::parse_get_datalake_auto_enable_response(response)
        }
    }
}

/// Operation shape for `GetDatalakeExceptionsExpiry`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`get_datalake_exceptions_expiry`](crate::client::Client::get_datalake_exceptions_expiry).
///
/// See [`crate::client::fluent_builders::GetDatalakeExceptionsExpiry`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct GetDatalakeExceptionsExpiry {
    _private: (),
}
impl GetDatalakeExceptionsExpiry {
    /// Creates a new builder-style object to manufacture [`GetDatalakeExceptionsExpiryInput`](crate::input::GetDatalakeExceptionsExpiryInput).
    pub fn builder() -> crate::input::get_datalake_exceptions_expiry_input::Builder {
        crate::input::get_datalake_exceptions_expiry_input::Builder::default()
    }
    /// Creates a new `GetDatalakeExceptionsExpiry` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for GetDatalakeExceptionsExpiry {
    type Output = std::result::Result<
        crate::output::GetDatalakeExceptionsExpiryOutput,
        crate::error::GetDatalakeExceptionsExpiryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_datalake_exceptions_expiry_error(response)
        } else {
            crate::operation_deser::parse_get_datalake_exceptions_expiry_response(response)
        }
    }
}

/// Operation shape for `GetDatalakeExceptionsSubscription`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`get_datalake_exceptions_subscription`](crate::client::Client::get_datalake_exceptions_subscription).
///
/// See [`crate::client::fluent_builders::GetDatalakeExceptionsSubscription`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct GetDatalakeExceptionsSubscription {
    _private: (),
}
impl GetDatalakeExceptionsSubscription {
    /// Creates a new builder-style object to manufacture [`GetDatalakeExceptionsSubscriptionInput`](crate::input::GetDatalakeExceptionsSubscriptionInput).
    pub fn builder() -> crate::input::get_datalake_exceptions_subscription_input::Builder {
        crate::input::get_datalake_exceptions_subscription_input::Builder::default()
    }
    /// Creates a new `GetDatalakeExceptionsSubscription` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for GetDatalakeExceptionsSubscription {
    type Output = std::result::Result<
        crate::output::GetDatalakeExceptionsSubscriptionOutput,
        crate::error::GetDatalakeExceptionsSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_datalake_exceptions_subscription_error(response)
        } else {
            crate::operation_deser::parse_get_datalake_exceptions_subscription_response(response)
        }
    }
}

/// Operation shape for `GetDatalakeStatus`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`get_datalake_status`](crate::client::Client::get_datalake_status).
///
/// See [`crate::client::fluent_builders::GetDatalakeStatus`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct GetDatalakeStatus {
    _private: (),
}
impl GetDatalakeStatus {
    /// Creates a new builder-style object to manufacture [`GetDatalakeStatusInput`](crate::input::GetDatalakeStatusInput).
    pub fn builder() -> crate::input::get_datalake_status_input::Builder {
        crate::input::get_datalake_status_input::Builder::default()
    }
    /// Creates a new `GetDatalakeStatus` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for GetDatalakeStatus {
    type Output = std::result::Result<
        crate::output::GetDatalakeStatusOutput,
        crate::error::GetDatalakeStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_datalake_status_error(response)
        } else {
            crate::operation_deser::parse_get_datalake_status_response(response)
        }
    }
}

/// Operation shape for `GetSubscriber`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`get_subscriber`](crate::client::Client::get_subscriber).
///
/// See [`crate::client::fluent_builders::GetSubscriber`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct GetSubscriber {
    _private: (),
}
impl GetSubscriber {
    /// Creates a new builder-style object to manufacture [`GetSubscriberInput`](crate::input::GetSubscriberInput).
    pub fn builder() -> crate::input::get_subscriber_input::Builder {
        crate::input::get_subscriber_input::Builder::default()
    }
    /// Creates a new `GetSubscriber` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for GetSubscriber {
    type Output =
        std::result::Result<crate::output::GetSubscriberOutput, crate::error::GetSubscriberError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_subscriber_error(response)
        } else {
            crate::operation_deser::parse_get_subscriber_response(response)
        }
    }
}

/// Operation shape for `ListDatalakeExceptions`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`list_datalake_exceptions`](crate::client::Client::list_datalake_exceptions).
///
/// See [`crate::client::fluent_builders::ListDatalakeExceptions`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct ListDatalakeExceptions {
    _private: (),
}
impl ListDatalakeExceptions {
    /// Creates a new builder-style object to manufacture [`ListDatalakeExceptionsInput`](crate::input::ListDatalakeExceptionsInput).
    pub fn builder() -> crate::input::list_datalake_exceptions_input::Builder {
        crate::input::list_datalake_exceptions_input::Builder::default()
    }
    /// Creates a new `ListDatalakeExceptions` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for ListDatalakeExceptions {
    type Output = std::result::Result<
        crate::output::ListDatalakeExceptionsOutput,
        crate::error::ListDatalakeExceptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_datalake_exceptions_error(response)
        } else {
            crate::operation_deser::parse_list_datalake_exceptions_response(response)
        }
    }
}

/// Operation shape for `ListLogSources`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`list_log_sources`](crate::client::Client::list_log_sources).
///
/// See [`crate::client::fluent_builders::ListLogSources`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct ListLogSources {
    _private: (),
}
impl ListLogSources {
    /// Creates a new builder-style object to manufacture [`ListLogSourcesInput`](crate::input::ListLogSourcesInput).
    pub fn builder() -> crate::input::list_log_sources_input::Builder {
        crate::input::list_log_sources_input::Builder::default()
    }
    /// Creates a new `ListLogSources` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for ListLogSources {
    type Output =
        std::result::Result<crate::output::ListLogSourcesOutput, crate::error::ListLogSourcesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_log_sources_error(response)
        } else {
            crate::operation_deser::parse_list_log_sources_response(response)
        }
    }
}

/// Operation shape for `ListSubscribers`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`list_subscribers`](crate::client::Client::list_subscribers).
///
/// See [`crate::client::fluent_builders::ListSubscribers`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct ListSubscribers {
    _private: (),
}
impl ListSubscribers {
    /// Creates a new builder-style object to manufacture [`ListSubscribersInput`](crate::input::ListSubscribersInput).
    pub fn builder() -> crate::input::list_subscribers_input::Builder {
        crate::input::list_subscribers_input::Builder::default()
    }
    /// Creates a new `ListSubscribers` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for ListSubscribers {
    type Output = std::result::Result<
        crate::output::ListSubscribersOutput,
        crate::error::ListSubscribersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_subscribers_error(response)
        } else {
            crate::operation_deser::parse_list_subscribers_response(response)
        }
    }
}

/// Operation shape for `UpdateDatalake`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`update_datalake`](crate::client::Client::update_datalake).
///
/// See [`crate::client::fluent_builders::UpdateDatalake`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct UpdateDatalake {
    _private: (),
}
impl UpdateDatalake {
    /// Creates a new builder-style object to manufacture [`UpdateDatalakeInput`](crate::input::UpdateDatalakeInput).
    pub fn builder() -> crate::input::update_datalake_input::Builder {
        crate::input::update_datalake_input::Builder::default()
    }
    /// Creates a new `UpdateDatalake` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for UpdateDatalake {
    type Output =
        std::result::Result<crate::output::UpdateDatalakeOutput, crate::error::UpdateDatalakeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_datalake_error(response)
        } else {
            crate::operation_deser::parse_update_datalake_response(response)
        }
    }
}

/// Operation shape for `UpdateDatalakeExceptionsExpiry`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`update_datalake_exceptions_expiry`](crate::client::Client::update_datalake_exceptions_expiry).
///
/// See [`crate::client::fluent_builders::UpdateDatalakeExceptionsExpiry`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct UpdateDatalakeExceptionsExpiry {
    _private: (),
}
impl UpdateDatalakeExceptionsExpiry {
    /// Creates a new builder-style object to manufacture [`UpdateDatalakeExceptionsExpiryInput`](crate::input::UpdateDatalakeExceptionsExpiryInput).
    pub fn builder() -> crate::input::update_datalake_exceptions_expiry_input::Builder {
        crate::input::update_datalake_exceptions_expiry_input::Builder::default()
    }
    /// Creates a new `UpdateDatalakeExceptionsExpiry` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for UpdateDatalakeExceptionsExpiry {
    type Output = std::result::Result<
        crate::output::UpdateDatalakeExceptionsExpiryOutput,
        crate::error::UpdateDatalakeExceptionsExpiryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_datalake_exceptions_expiry_error(response)
        } else {
            crate::operation_deser::parse_update_datalake_exceptions_expiry_response(response)
        }
    }
}

/// Operation shape for `UpdateDatalakeExceptionsSubscription`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`update_datalake_exceptions_subscription`](crate::client::Client::update_datalake_exceptions_subscription).
///
/// See [`crate::client::fluent_builders::UpdateDatalakeExceptionsSubscription`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct UpdateDatalakeExceptionsSubscription {
    _private: (),
}
impl UpdateDatalakeExceptionsSubscription {
    /// Creates a new builder-style object to manufacture [`UpdateDatalakeExceptionsSubscriptionInput`](crate::input::UpdateDatalakeExceptionsSubscriptionInput).
    pub fn builder() -> crate::input::update_datalake_exceptions_subscription_input::Builder {
        crate::input::update_datalake_exceptions_subscription_input::Builder::default()
    }
    /// Creates a new `UpdateDatalakeExceptionsSubscription` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for UpdateDatalakeExceptionsSubscription {
    type Output = std::result::Result<
        crate::output::UpdateDatalakeExceptionsSubscriptionOutput,
        crate::error::UpdateDatalakeExceptionsSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_datalake_exceptions_subscription_error(response)
        } else {
            crate::operation_deser::parse_update_datalake_exceptions_subscription_response(response)
        }
    }
}

/// Operation shape for `UpdateSubscriber`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`update_subscriber`](crate::client::Client::update_subscriber).
///
/// See [`crate::client::fluent_builders::UpdateSubscriber`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct UpdateSubscriber {
    _private: (),
}
impl UpdateSubscriber {
    /// Creates a new builder-style object to manufacture [`UpdateSubscriberInput`](crate::input::UpdateSubscriberInput).
    pub fn builder() -> crate::input::update_subscriber_input::Builder {
        crate::input::update_subscriber_input::Builder::default()
    }
    /// Creates a new `UpdateSubscriber` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse for UpdateSubscriber {
    type Output = std::result::Result<
        crate::output::UpdateSubscriberOutput,
        crate::error::UpdateSubscriberError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_subscriber_error(response)
        } else {
            crate::operation_deser::parse_update_subscriber_response(response)
        }
    }
}

/// Operation shape for `UpdateSubscriptionNotificationConfiguration`.
///
/// This is usually constructed for you using the the fluent builder returned by
/// [`update_subscription_notification_configuration`](crate::client::Client::update_subscription_notification_configuration).
///
/// See [`crate::client::fluent_builders::UpdateSubscriptionNotificationConfiguration`] for more details about the operation.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
pub struct UpdateSubscriptionNotificationConfiguration {
    _private: (),
}
impl UpdateSubscriptionNotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`UpdateSubscriptionNotificationConfigurationInput`](crate::input::UpdateSubscriptionNotificationConfigurationInput).
    pub fn builder() -> crate::input::update_subscription_notification_configuration_input::Builder
    {
        crate::input::update_subscription_notification_configuration_input::Builder::default()
    }
    /// Creates a new `UpdateSubscriptionNotificationConfiguration` operation.
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl aws_smithy_http::response::ParseStrictResponse
    for UpdateSubscriptionNotificationConfiguration
{
    type Output = std::result::Result<
        crate::output::UpdateSubscriptionNotificationConfigurationOutput,
        crate::error::UpdateSubscriptionNotificationConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_subscription_notification_configuration_error(
                response,
            )
        } else {
            crate::operation_deser::parse_update_subscription_notification_configuration_response(
                response,
            )
        }
    }
}

/// Operation customization and supporting types
pub mod customize;
