// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The input fails to meet the constraints specified in Amazon Security Lake. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationExceptionField {
    /// <p>Name of the validation exception.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Describes the error encountered.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationExceptionField {
    /// <p>Name of the validation exception.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Describes the error encountered.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {

    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the validation exception.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the validation exception.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Describes the error encountered.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Describes the error encountered.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name,
                message: self.message,
            }
        }
    }
}

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::CannotParse => { /* ... */ },
///     ValidationExceptionReason::FieldValidationFailed => { /* ... */ },
///     ValidationExceptionReason::Other => { /* ... */ },
///     ValidationExceptionReason::UnknownOperation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    CannotParse,
    #[allow(missing_docs)] // documentation missing in model
    FieldValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    UnknownOperation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "cannotParse" => ValidationExceptionReason::CannotParse,
            "fieldValidationFailed" => ValidationExceptionReason::FieldValidationFailed,
            "other" => ValidationExceptionReason::Other,
            "unknownOperation" => ValidationExceptionReason::UnknownOperation,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::CannotParse => "cannotParse",
            ValidationExceptionReason::FieldValidationFailed => "fieldValidationFailed",
            ValidationExceptionReason::Other => "other",
            ValidationExceptionReason::UnknownOperation => "unknownOperation",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "cannotParse",
            "fieldValidationFailed",
            "other",
            "unknownOperation",
        ]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `HttpsMethod`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let httpsmethod = unimplemented!();
/// match httpsmethod {
///     HttpsMethod::Post => { /* ... */ },
///     HttpsMethod::Put => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `httpsmethod` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HttpsMethod::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HttpsMethod::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HttpsMethod::NewFeature` is defined.
/// Specifically, when `httpsmethod` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HttpsMethod::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HttpsMethod {
    #[allow(missing_docs)] // documentation missing in model
    Post,
    #[allow(missing_docs)] // documentation missing in model
    Put,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for HttpsMethod {
    fn from(s: &str) -> Self {
        match s {
            "POST" => HttpsMethod::Post,
            "PUT" => HttpsMethod::Put,
            other => HttpsMethod::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for HttpsMethod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HttpsMethod::from(s))
    }
}
impl HttpsMethod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HttpsMethod::Post => "POST",
            HttpsMethod::Put => "PUT",
            HttpsMethod::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["POST", "PUT"]
    }
}
impl AsRef<str> for HttpsMethod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides details about the Amazon Security Lake account subscription. Subscribers are notified of new objects for a source as the data is written to your Amazon S3 bucket for Security Lake. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubscriberResource {
    /// <p>The subscription ID of the Amazon Security Lake subscriber account.</p>
    #[doc(hidden)]
    pub subscription_id: std::option::Option<std::string::String>,
    /// <p>Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. For more information, see the Amazon Security Lake User Guide.</p>
    #[doc(hidden)]
    pub source_types: std::option::Option<std::vec::Vec<crate::model::SourceType>>,
    /// <p>The Amazon Web Services account ID you are using to create your Amazon Security Lake account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of your Amazon Security Lake subscriber account.</p>
    #[doc(hidden)]
    pub subscriber_name: std::option::Option<std::string::String>,
    /// <p>The subscriber descriptions for a subscriber account. The description for a subscriber includes <code>subscriberName</code>, <code>accountID</code>, <code>externalID</code>, and <code>subscriptionId</code>.</p>
    #[doc(hidden)]
    pub subscriber_description: std::option::Option<std::string::String>,
    /// <p>The subscription status of the Amazon Security Lake subscriber account.</p>
    #[doc(hidden)]
    pub subscription_status: std::option::Option<crate::model::SubscriptionStatus>,
    /// <p>The Amazon Resource Name (ARN) specifying the role of the subscriber.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The ARN for the Amazon Simple Notification Service.</p>
    #[doc(hidden)]
    pub sns_arn: std::option::Option<std::string::String>,
    /// <p>The ARN for the Amazon S3 bucket. </p>
    #[doc(hidden)]
    pub s3_bucket_arn: std::option::Option<std::string::String>,
    /// <p>You can choose to notify subscribers of new objects with an Amazon Simple Queue Service (Amazon SQS) queue or through messaging to an HTTPS endpoint provided by the subscriber. </p>
    /// <p> Subscribers can consume data by directly querying Lake Formation tables in your Amazon S3 bucket through services like Amazon Athena. This subscription type is defined as <code>LAKEFORMATION</code>. </p>
    #[doc(hidden)]
    pub access_types: std::option::Option<std::vec::Vec<crate::model::AccessType>>,
    /// <p>The subscription endpoint to which exception messages are posted. </p>
    #[doc(hidden)]
    pub subscription_endpoint: std::option::Option<std::string::String>,
    /// <p>The subscription protocol to which exception messages are posted. </p>
    #[doc(hidden)]
    pub subscription_protocol: std::option::Option<crate::model::EndpointProtocol>,
    /// <p>The external ID of the subscriber. The external ID lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.</p>
    #[doc(hidden)]
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the subscription was created. </p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the subscription was created. </p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl SubscriberResource {
    /// <p>The subscription ID of the Amazon Security Lake subscriber account.</p>
    pub fn subscription_id(&self) -> std::option::Option<&str> {
        self.subscription_id.as_deref()
    }
    /// <p>Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. For more information, see the Amazon Security Lake User Guide.</p>
    pub fn source_types(&self) -> std::option::Option<&[crate::model::SourceType]> {
        self.source_types.as_deref()
    }
    /// <p>The Amazon Web Services account ID you are using to create your Amazon Security Lake account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The name of your Amazon Security Lake subscriber account.</p>
    pub fn subscriber_name(&self) -> std::option::Option<&str> {
        self.subscriber_name.as_deref()
    }
    /// <p>The subscriber descriptions for a subscriber account. The description for a subscriber includes <code>subscriberName</code>, <code>accountID</code>, <code>externalID</code>, and <code>subscriptionId</code>.</p>
    pub fn subscriber_description(&self) -> std::option::Option<&str> {
        self.subscriber_description.as_deref()
    }
    /// <p>The subscription status of the Amazon Security Lake subscriber account.</p>
    pub fn subscription_status(&self) -> std::option::Option<&crate::model::SubscriptionStatus> {
        self.subscription_status.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) specifying the role of the subscriber.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The ARN for the Amazon Simple Notification Service.</p>
    pub fn sns_arn(&self) -> std::option::Option<&str> {
        self.sns_arn.as_deref()
    }
    /// <p>The ARN for the Amazon S3 bucket. </p>
    pub fn s3_bucket_arn(&self) -> std::option::Option<&str> {
        self.s3_bucket_arn.as_deref()
    }
    /// <p>You can choose to notify subscribers of new objects with an Amazon Simple Queue Service (Amazon SQS) queue or through messaging to an HTTPS endpoint provided by the subscriber. </p>
    /// <p> Subscribers can consume data by directly querying Lake Formation tables in your Amazon S3 bucket through services like Amazon Athena. This subscription type is defined as <code>LAKEFORMATION</code>. </p>
    pub fn access_types(&self) -> std::option::Option<&[crate::model::AccessType]> {
        self.access_types.as_deref()
    }
    /// <p>The subscription endpoint to which exception messages are posted. </p>
    pub fn subscription_endpoint(&self) -> std::option::Option<&str> {
        self.subscription_endpoint.as_deref()
    }
    /// <p>The subscription protocol to which exception messages are posted. </p>
    pub fn subscription_protocol(&self) -> std::option::Option<&crate::model::EndpointProtocol> {
        self.subscription_protocol.as_ref()
    }
    /// <p>The external ID of the subscriber. The external ID lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.</p>
    pub fn external_id(&self) -> std::option::Option<&str> {
        self.external_id.as_deref()
    }
    /// <p>The date and time when the subscription was created. </p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time when the subscription was created. </p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
impl SubscriberResource {
    /// Creates a new builder-style object to manufacture [`SubscriberResource`](crate::model::SubscriberResource).
    pub fn builder() -> crate::model::subscriber_resource::Builder {
        crate::model::subscriber_resource::Builder::default()
    }
}

/// See [`SubscriberResource`](crate::model::SubscriberResource).
pub mod subscriber_resource {

    /// A builder for [`SubscriberResource`](crate::model::SubscriberResource).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_id: std::option::Option<std::string::String>,
        pub(crate) source_types: std::option::Option<std::vec::Vec<crate::model::SourceType>>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) subscriber_name: std::option::Option<std::string::String>,
        pub(crate) subscriber_description: std::option::Option<std::string::String>,
        pub(crate) subscription_status: std::option::Option<crate::model::SubscriptionStatus>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) sns_arn: std::option::Option<std::string::String>,
        pub(crate) s3_bucket_arn: std::option::Option<std::string::String>,
        pub(crate) access_types: std::option::Option<std::vec::Vec<crate::model::AccessType>>,
        pub(crate) subscription_endpoint: std::option::Option<std::string::String>,
        pub(crate) subscription_protocol: std::option::Option<crate::model::EndpointProtocol>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The subscription ID of the Amazon Security Lake subscriber account.</p>
        pub fn subscription_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_id = Some(input.into());
            self
        }
        /// <p>The subscription ID of the Amazon Security Lake subscriber account.</p>
        pub fn set_subscription_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscription_id = input;
            self
        }
        /// Appends an item to `source_types`.
        ///
        /// To override the contents of this collection use [`set_source_types`](Self::set_source_types).
        ///
        /// <p>Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. For more information, see the Amazon Security Lake User Guide.</p>
        pub fn source_types(mut self, input: crate::model::SourceType) -> Self {
            let mut v = self.source_types.unwrap_or_default();
            v.push(input);
            self.source_types = Some(v);
            self
        }
        /// <p>Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. For more information, see the Amazon Security Lake User Guide.</p>
        pub fn set_source_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SourceType>>,
        ) -> Self {
            self.source_types = input;
            self
        }
        /// <p>The Amazon Web Services account ID you are using to create your Amazon Security Lake account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID you are using to create your Amazon Security Lake account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The name of your Amazon Security Lake subscriber account.</p>
        pub fn subscriber_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscriber_name = Some(input.into());
            self
        }
        /// <p>The name of your Amazon Security Lake subscriber account.</p>
        pub fn set_subscriber_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscriber_name = input;
            self
        }
        /// <p>The subscriber descriptions for a subscriber account. The description for a subscriber includes <code>subscriberName</code>, <code>accountID</code>, <code>externalID</code>, and <code>subscriptionId</code>.</p>
        pub fn subscriber_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscriber_description = Some(input.into());
            self
        }
        /// <p>The subscriber descriptions for a subscriber account. The description for a subscriber includes <code>subscriberName</code>, <code>accountID</code>, <code>externalID</code>, and <code>subscriptionId</code>.</p>
        pub fn set_subscriber_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscriber_description = input;
            self
        }
        /// <p>The subscription status of the Amazon Security Lake subscriber account.</p>
        pub fn subscription_status(mut self, input: crate::model::SubscriptionStatus) -> Self {
            self.subscription_status = Some(input);
            self
        }
        /// <p>The subscription status of the Amazon Security Lake subscriber account.</p>
        pub fn set_subscription_status(
            mut self,
            input: std::option::Option<crate::model::SubscriptionStatus>,
        ) -> Self {
            self.subscription_status = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) specifying the role of the subscriber.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) specifying the role of the subscriber.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The ARN for the Amazon Simple Notification Service.</p>
        pub fn sns_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the Amazon Simple Notification Service.</p>
        pub fn set_sns_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sns_arn = input;
            self
        }
        /// <p>The ARN for the Amazon S3 bucket. </p>
        pub fn s3_bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_arn = Some(input.into());
            self
        }
        /// <p>The ARN for the Amazon S3 bucket. </p>
        pub fn set_s3_bucket_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_arn = input;
            self
        }
        /// Appends an item to `access_types`.
        ///
        /// To override the contents of this collection use [`set_access_types`](Self::set_access_types).
        ///
        /// <p>You can choose to notify subscribers of new objects with an Amazon Simple Queue Service (Amazon SQS) queue or through messaging to an HTTPS endpoint provided by the subscriber. </p>
        /// <p> Subscribers can consume data by directly querying Lake Formation tables in your Amazon S3 bucket through services like Amazon Athena. This subscription type is defined as <code>LAKEFORMATION</code>. </p>
        pub fn access_types(mut self, input: crate::model::AccessType) -> Self {
            let mut v = self.access_types.unwrap_or_default();
            v.push(input);
            self.access_types = Some(v);
            self
        }
        /// <p>You can choose to notify subscribers of new objects with an Amazon Simple Queue Service (Amazon SQS) queue or through messaging to an HTTPS endpoint provided by the subscriber. </p>
        /// <p> Subscribers can consume data by directly querying Lake Formation tables in your Amazon S3 bucket through services like Amazon Athena. This subscription type is defined as <code>LAKEFORMATION</code>. </p>
        pub fn set_access_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AccessType>>,
        ) -> Self {
            self.access_types = input;
            self
        }
        /// <p>The subscription endpoint to which exception messages are posted. </p>
        pub fn subscription_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_endpoint = Some(input.into());
            self
        }
        /// <p>The subscription endpoint to which exception messages are posted. </p>
        pub fn set_subscription_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscription_endpoint = input;
            self
        }
        /// <p>The subscription protocol to which exception messages are posted. </p>
        pub fn subscription_protocol(mut self, input: crate::model::EndpointProtocol) -> Self {
            self.subscription_protocol = Some(input);
            self
        }
        /// <p>The subscription protocol to which exception messages are posted. </p>
        pub fn set_subscription_protocol(
            mut self,
            input: std::option::Option<crate::model::EndpointProtocol>,
        ) -> Self {
            self.subscription_protocol = input;
            self
        }
        /// <p>The external ID of the subscriber. The external ID lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        /// <p>The external ID of the subscriber. The external ID lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input;
            self
        }
        /// <p>The date and time when the subscription was created. </p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the subscription was created. </p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time when the subscription was created. </p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time when the subscription was created. </p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscriberResource`](crate::model::SubscriberResource).
        pub fn build(self) -> crate::model::SubscriberResource {
            crate::model::SubscriberResource {
                subscription_id: self.subscription_id,
                source_types: self.source_types,
                account_id: self.account_id,
                subscriber_name: self.subscriber_name,
                subscriber_description: self.subscriber_description,
                subscription_status: self.subscription_status,
                role_arn: self.role_arn,
                sns_arn: self.sns_arn,
                s3_bucket_arn: self.s3_bucket_arn,
                access_types: self.access_types,
                subscription_endpoint: self.subscription_endpoint,
                subscription_protocol: self.subscription_protocol,
                external_id: self.external_id,
                created_at: self.created_at,
                updated_at: self.updated_at,
            }
        }
    }
}

/// When writing a match expression against `EndpointProtocol`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let endpointprotocol = unimplemented!();
/// match endpointprotocol {
///     EndpointProtocol::Https => { /* ... */ },
///     EndpointProtocol::Sqs => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `endpointprotocol` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EndpointProtocol::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EndpointProtocol::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EndpointProtocol::NewFeature` is defined.
/// Specifically, when `endpointprotocol` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EndpointProtocol::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointProtocol {
    #[allow(missing_docs)] // documentation missing in model
    Https,
    #[allow(missing_docs)] // documentation missing in model
    Sqs,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EndpointProtocol {
    fn from(s: &str) -> Self {
        match s {
            "HTTPS" => EndpointProtocol::Https,
            "SQS" => EndpointProtocol::Sqs,
            other => EndpointProtocol::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EndpointProtocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointProtocol::from(s))
    }
}
impl EndpointProtocol {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndpointProtocol::Https => "HTTPS",
            EndpointProtocol::Sqs => "SQS",
            EndpointProtocol::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HTTPS", "SQS"]
    }
}
impl AsRef<str> for EndpointProtocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AccessType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let accesstype = unimplemented!();
/// match accesstype {
///     AccessType::Lakeformation => { /* ... */ },
///     AccessType::S3 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `accesstype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AccessType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AccessType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AccessType::NewFeature` is defined.
/// Specifically, when `accesstype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AccessType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccessType {
    #[allow(missing_docs)] // documentation missing in model
    Lakeformation,
    #[allow(missing_docs)] // documentation missing in model
    S3,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AccessType {
    fn from(s: &str) -> Self {
        match s {
            "LAKEFORMATION" => AccessType::Lakeformation,
            "S3" => AccessType::S3,
            other => AccessType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AccessType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccessType::from(s))
    }
}
impl AccessType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AccessType::Lakeformation => "LAKEFORMATION",
            AccessType::S3 => "S3",
            AccessType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LAKEFORMATION", "S3"]
    }
}
impl AsRef<str> for AccessType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SubscriptionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let subscriptionstatus = unimplemented!();
/// match subscriptionstatus {
///     SubscriptionStatus::Active => { /* ... */ },
///     SubscriptionStatus::Deactivated => { /* ... */ },
///     SubscriptionStatus::Pending => { /* ... */ },
///     SubscriptionStatus::Ready => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `subscriptionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SubscriptionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SubscriptionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SubscriptionStatus::NewFeature` is defined.
/// Specifically, when `subscriptionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SubscriptionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SubscriptionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deactivated,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SubscriptionStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => SubscriptionStatus::Active,
            "DEACTIVATED" => SubscriptionStatus::Deactivated,
            "PENDING" => SubscriptionStatus::Pending,
            "READY" => SubscriptionStatus::Ready,
            other => {
                SubscriptionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SubscriptionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SubscriptionStatus::from(s))
    }
}
impl SubscriptionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SubscriptionStatus::Active => "ACTIVE",
            SubscriptionStatus::Deactivated => "DEACTIVATED",
            SubscriptionStatus::Pending => "PENDING",
            SubscriptionStatus::Ready => "READY",
            SubscriptionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "DEACTIVATED", "PENDING", "READY"]
    }
}
impl AsRef<str> for SubscriptionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The supported source types from which logs and events are collected in Amazon Security Lake. For the list of supported Amazon Web Services, see the <a href="https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html">Amazon Security Lake User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum SourceType {
    /// <p>Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. </p>
    AwsSourceType(crate::model::AwsLogSourceType),
    /// <p>Amazon Security Lake supports custom source types. For a detailed list, see the Amazon Security Lake User Guide.</p>
    CustomSourceType(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl SourceType {
    /// Tries to convert the enum instance into [`AwsSourceType`](crate::model::SourceType::AwsSourceType), extracting the inner [`AwsLogSourceType`](crate::model::AwsLogSourceType).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_aws_source_type(
        &self,
    ) -> std::result::Result<&crate::model::AwsLogSourceType, &Self> {
        if let SourceType::AwsSourceType(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AwsSourceType`](crate::model::SourceType::AwsSourceType).
    pub fn is_aws_source_type(&self) -> bool {
        self.as_aws_source_type().is_ok()
    }
    /// Tries to convert the enum instance into [`CustomSourceType`](crate::model::SourceType::CustomSourceType), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_custom_source_type(&self) -> std::result::Result<&std::string::String, &Self> {
        if let SourceType::CustomSourceType(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`CustomSourceType`](crate::model::SourceType::CustomSourceType).
    pub fn is_custom_source_type(&self) -> bool {
        self.as_custom_source_type().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// When writing a match expression against `AwsLogSourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let awslogsourcetype = unimplemented!();
/// match awslogsourcetype {
///     AwsLogSourceType::CloudTrail => { /* ... */ },
///     AwsLogSourceType::Route53 => { /* ... */ },
///     AwsLogSourceType::ShFindings => { /* ... */ },
///     AwsLogSourceType::VpcFlow => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `awslogsourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AwsLogSourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AwsLogSourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AwsLogSourceType::NewFeature` is defined.
/// Specifically, when `awslogsourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AwsLogSourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AwsLogSourceType {
    #[allow(missing_docs)] // documentation missing in model
    CloudTrail,
    #[allow(missing_docs)] // documentation missing in model
    Route53,
    #[allow(missing_docs)] // documentation missing in model
    ShFindings,
    #[allow(missing_docs)] // documentation missing in model
    VpcFlow,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AwsLogSourceType {
    fn from(s: &str) -> Self {
        match s {
            "CLOUD_TRAIL" => AwsLogSourceType::CloudTrail,
            "ROUTE53" => AwsLogSourceType::Route53,
            "SH_FINDINGS" => AwsLogSourceType::ShFindings,
            "VPC_FLOW" => AwsLogSourceType::VpcFlow,
            other => AwsLogSourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AwsLogSourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AwsLogSourceType::from(s))
    }
}
impl AwsLogSourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AwsLogSourceType::CloudTrail => "CLOUD_TRAIL",
            AwsLogSourceType::Route53 => "ROUTE53",
            AwsLogSourceType::ShFindings => "SH_FINDINGS",
            AwsLogSourceType::VpcFlow => "VPC_FLOW",
            AwsLogSourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLOUD_TRAIL", "ROUTE53", "SH_FINDINGS", "VPC_FLOW"]
    }
}
impl AsRef<str> for AwsLogSourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SubscriptionProtocolType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let subscriptionprotocoltype = unimplemented!();
/// match subscriptionprotocoltype {
///     SubscriptionProtocolType::App => { /* ... */ },
///     SubscriptionProtocolType::Email => { /* ... */ },
///     SubscriptionProtocolType::EmailJson => { /* ... */ },
///     SubscriptionProtocolType::Firehose => { /* ... */ },
///     SubscriptionProtocolType::Http => { /* ... */ },
///     SubscriptionProtocolType::Https => { /* ... */ },
///     SubscriptionProtocolType::Lambda => { /* ... */ },
///     SubscriptionProtocolType::Sms => { /* ... */ },
///     SubscriptionProtocolType::Sqs => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `subscriptionprotocoltype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SubscriptionProtocolType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SubscriptionProtocolType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SubscriptionProtocolType::NewFeature` is defined.
/// Specifically, when `subscriptionprotocoltype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SubscriptionProtocolType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SubscriptionProtocolType {
    #[allow(missing_docs)] // documentation missing in model
    App,
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    EmailJson,
    #[allow(missing_docs)] // documentation missing in model
    Firehose,
    #[allow(missing_docs)] // documentation missing in model
    Http,
    #[allow(missing_docs)] // documentation missing in model
    Https,
    #[allow(missing_docs)] // documentation missing in model
    Lambda,
    #[allow(missing_docs)] // documentation missing in model
    Sms,
    #[allow(missing_docs)] // documentation missing in model
    Sqs,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SubscriptionProtocolType {
    fn from(s: &str) -> Self {
        match s {
            "APP" => SubscriptionProtocolType::App,
            "EMAIL" => SubscriptionProtocolType::Email,
            "EMAIL_JSON" => SubscriptionProtocolType::EmailJson,
            "FIREHOSE" => SubscriptionProtocolType::Firehose,
            "HTTP" => SubscriptionProtocolType::Http,
            "HTTPS" => SubscriptionProtocolType::Https,
            "LAMBDA" => SubscriptionProtocolType::Lambda,
            "SMS" => SubscriptionProtocolType::Sms,
            "SQS" => SubscriptionProtocolType::Sqs,
            other => SubscriptionProtocolType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SubscriptionProtocolType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SubscriptionProtocolType::from(s))
    }
}
impl SubscriptionProtocolType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SubscriptionProtocolType::App => "APP",
            SubscriptionProtocolType::Email => "EMAIL",
            SubscriptionProtocolType::EmailJson => "EMAIL_JSON",
            SubscriptionProtocolType::Firehose => "FIREHOSE",
            SubscriptionProtocolType::Http => "HTTP",
            SubscriptionProtocolType::Https => "HTTPS",
            SubscriptionProtocolType::Lambda => "LAMBDA",
            SubscriptionProtocolType::Sms => "SMS",
            SubscriptionProtocolType::Sqs => "SQS",
            SubscriptionProtocolType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "APP",
            "EMAIL",
            "EMAIL_JSON",
            "FIREHOSE",
            "HTTP",
            "HTTPS",
            "LAMBDA",
            "SMS",
            "SQS",
        ]
    }
}
impl AsRef<str> for SubscriptionProtocolType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides details of Amazon Security Lake configuration object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LakeConfigurationRequest {
    /// <p>The type of encryption key used by Amazon Security Lake to encrypt the Security Lake configuration object.</p>
    #[doc(hidden)]
    pub encryption_key: std::option::Option<std::string::String>,
    /// <p>Retention settings for the destination Amazon S3 buckets. </p>
    #[doc(hidden)]
    pub retention_settings: std::option::Option<std::vec::Vec<crate::model::RetentionSetting>>,
    /// <p>A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.</p>
    #[doc(hidden)]
    pub tags_map:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket.</p>
    /// <p>Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region. </p>
    #[doc(hidden)]
    pub replication_destination_regions: std::option::Option<std::vec::Vec<crate::model::Region>>,
    /// <p>Replication settings for the Amazon S3 buckets. This parameter uses the Identity and Access Management (IAM) role you created that is managed by Security Lake, to ensure the replication setting is correct. </p>
    #[doc(hidden)]
    pub replication_role_arn: std::option::Option<std::string::String>,
}
impl LakeConfigurationRequest {
    /// <p>The type of encryption key used by Amazon Security Lake to encrypt the Security Lake configuration object.</p>
    pub fn encryption_key(&self) -> std::option::Option<&str> {
        self.encryption_key.as_deref()
    }
    /// <p>Retention settings for the destination Amazon S3 buckets. </p>
    pub fn retention_settings(&self) -> std::option::Option<&[crate::model::RetentionSetting]> {
        self.retention_settings.as_deref()
    }
    /// <p>A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.</p>
    pub fn tags_map(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags_map.as_ref()
    }
    /// <p>Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket.</p>
    /// <p>Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region. </p>
    pub fn replication_destination_regions(&self) -> std::option::Option<&[crate::model::Region]> {
        self.replication_destination_regions.as_deref()
    }
    /// <p>Replication settings for the Amazon S3 buckets. This parameter uses the Identity and Access Management (IAM) role you created that is managed by Security Lake, to ensure the replication setting is correct. </p>
    pub fn replication_role_arn(&self) -> std::option::Option<&str> {
        self.replication_role_arn.as_deref()
    }
}
impl LakeConfigurationRequest {
    /// Creates a new builder-style object to manufacture [`LakeConfigurationRequest`](crate::model::LakeConfigurationRequest).
    pub fn builder() -> crate::model::lake_configuration_request::Builder {
        crate::model::lake_configuration_request::Builder::default()
    }
}

/// See [`LakeConfigurationRequest`](crate::model::LakeConfigurationRequest).
pub mod lake_configuration_request {

    /// A builder for [`LakeConfigurationRequest`](crate::model::LakeConfigurationRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_key: std::option::Option<std::string::String>,
        pub(crate) retention_settings:
            std::option::Option<std::vec::Vec<crate::model::RetentionSetting>>,
        pub(crate) tags_map: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) replication_destination_regions:
            std::option::Option<std::vec::Vec<crate::model::Region>>,
        pub(crate) replication_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of encryption key used by Amazon Security Lake to encrypt the Security Lake configuration object.</p>
        pub fn encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key = Some(input.into());
            self
        }
        /// <p>The type of encryption key used by Amazon Security Lake to encrypt the Security Lake configuration object.</p>
        pub fn set_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key = input;
            self
        }
        /// Appends an item to `retention_settings`.
        ///
        /// To override the contents of this collection use [`set_retention_settings`](Self::set_retention_settings).
        ///
        /// <p>Retention settings for the destination Amazon S3 buckets. </p>
        pub fn retention_settings(mut self, input: crate::model::RetentionSetting) -> Self {
            let mut v = self.retention_settings.unwrap_or_default();
            v.push(input);
            self.retention_settings = Some(v);
            self
        }
        /// <p>Retention settings for the destination Amazon S3 buckets. </p>
        pub fn set_retention_settings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RetentionSetting>>,
        ) -> Self {
            self.retention_settings = input;
            self
        }
        /// Adds a key-value pair to `tags_map`.
        ///
        /// To override the contents of this collection use [`set_tags_map`](Self::set_tags_map).
        ///
        /// <p>A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.</p>
        pub fn tags_map(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags_map = Some(hash_map);
            self
        }
        /// <p>A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.</p>
        pub fn set_tags_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags_map = input;
            self
        }
        /// Appends an item to `replication_destination_regions`.
        ///
        /// To override the contents of this collection use [`set_replication_destination_regions`](Self::set_replication_destination_regions).
        ///
        /// <p>Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket.</p>
        /// <p>Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region. </p>
        pub fn replication_destination_regions(mut self, input: crate::model::Region) -> Self {
            let mut v = self.replication_destination_regions.unwrap_or_default();
            v.push(input);
            self.replication_destination_regions = Some(v);
            self
        }
        /// <p>Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket.</p>
        /// <p>Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region. </p>
        pub fn set_replication_destination_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Region>>,
        ) -> Self {
            self.replication_destination_regions = input;
            self
        }
        /// <p>Replication settings for the Amazon S3 buckets. This parameter uses the Identity and Access Management (IAM) role you created that is managed by Security Lake, to ensure the replication setting is correct. </p>
        pub fn replication_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.replication_role_arn = Some(input.into());
            self
        }
        /// <p>Replication settings for the Amazon S3 buckets. This parameter uses the Identity and Access Management (IAM) role you created that is managed by Security Lake, to ensure the replication setting is correct. </p>
        pub fn set_replication_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replication_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LakeConfigurationRequest`](crate::model::LakeConfigurationRequest).
        pub fn build(self) -> crate::model::LakeConfigurationRequest {
            crate::model::LakeConfigurationRequest {
                encryption_key: self.encryption_key,
                retention_settings: self.retention_settings,
                tags_map: self.tags_map,
                replication_destination_regions: self.replication_destination_regions,
                replication_role_arn: self.replication_role_arn,
            }
        }
    }
}

/// When writing a match expression against `Region`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let region = unimplemented!();
/// match region {
///     Region::ApNortheast1 => { /* ... */ },
///     Region::ApSoutheast2 => { /* ... */ },
///     Region::EuCentral1 => { /* ... */ },
///     Region::EuWest1 => { /* ... */ },
///     Region::UsEast1 => { /* ... */ },
///     Region::UsEast2 => { /* ... */ },
///     Region::UsWest2 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `region` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Region::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Region::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Region::NewFeature` is defined.
/// Specifically, when `region` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Region::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Region {
    #[allow(missing_docs)] // documentation missing in model
    ApNortheast1,
    #[allow(missing_docs)] // documentation missing in model
    ApSoutheast2,
    #[allow(missing_docs)] // documentation missing in model
    EuCentral1,
    #[allow(missing_docs)] // documentation missing in model
    EuWest1,
    #[allow(missing_docs)] // documentation missing in model
    UsEast1,
    #[allow(missing_docs)] // documentation missing in model
    UsEast2,
    #[allow(missing_docs)] // documentation missing in model
    UsWest2,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Region {
    fn from(s: &str) -> Self {
        match s {
            "ap-northeast-1" => Region::ApNortheast1,
            "ap-southeast-2" => Region::ApSoutheast2,
            "eu-central-1" => Region::EuCentral1,
            "eu-west-1" => Region::EuWest1,
            "us-east-1" => Region::UsEast1,
            "us-east-2" => Region::UsEast2,
            "us-west-2" => Region::UsWest2,
            other => Region::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Region {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Region::from(s))
    }
}
impl Region {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Region::ApNortheast1 => "ap-northeast-1",
            Region::ApSoutheast2 => "ap-southeast-2",
            Region::EuCentral1 => "eu-central-1",
            Region::EuWest1 => "eu-west-1",
            Region::UsEast1 => "us-east-1",
            Region::UsEast2 => "us-east-2",
            Region::UsWest2 => "us-west-2",
            Region::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ap-northeast-1",
            "ap-southeast-2",
            "eu-central-1",
            "eu-west-1",
            "us-east-1",
            "us-east-2",
            "us-west-2",
        ]
    }
}
impl AsRef<str> for Region {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Retention settings for the destination Amazon S3 buckets in Amazon Security Lake. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RetentionSetting {
    /// <p>The range of storage classes that you can choose from based on the data access, resiliency, and cost requirements of your workloads.</p>
    #[doc(hidden)]
    pub storage_class: std::option::Option<crate::model::StorageClass>,
    /// <p>The retention period specifies a fixed period of time during which the Security Lake object remains locked. You can specify the retention period in days for one or more sources. </p>
    #[doc(hidden)]
    pub retention_period: std::option::Option<i32>,
}
impl RetentionSetting {
    /// <p>The range of storage classes that you can choose from based on the data access, resiliency, and cost requirements of your workloads.</p>
    pub fn storage_class(&self) -> std::option::Option<&crate::model::StorageClass> {
        self.storage_class.as_ref()
    }
    /// <p>The retention period specifies a fixed period of time during which the Security Lake object remains locked. You can specify the retention period in days for one or more sources. </p>
    pub fn retention_period(&self) -> std::option::Option<i32> {
        self.retention_period
    }
}
impl RetentionSetting {
    /// Creates a new builder-style object to manufacture [`RetentionSetting`](crate::model::RetentionSetting).
    pub fn builder() -> crate::model::retention_setting::Builder {
        crate::model::retention_setting::Builder::default()
    }
}

/// See [`RetentionSetting`](crate::model::RetentionSetting).
pub mod retention_setting {

    /// A builder for [`RetentionSetting`](crate::model::RetentionSetting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_class: std::option::Option<crate::model::StorageClass>,
        pub(crate) retention_period: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The range of storage classes that you can choose from based on the data access, resiliency, and cost requirements of your workloads.</p>
        pub fn storage_class(mut self, input: crate::model::StorageClass) -> Self {
            self.storage_class = Some(input);
            self
        }
        /// <p>The range of storage classes that you can choose from based on the data access, resiliency, and cost requirements of your workloads.</p>
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::StorageClass>,
        ) -> Self {
            self.storage_class = input;
            self
        }
        /// <p>The retention period specifies a fixed period of time during which the Security Lake object remains locked. You can specify the retention period in days for one or more sources. </p>
        pub fn retention_period(mut self, input: i32) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>The retention period specifies a fixed period of time during which the Security Lake object remains locked. You can specify the retention period in days for one or more sources. </p>
        pub fn set_retention_period(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_period = input;
            self
        }
        /// Consumes the builder and constructs a [`RetentionSetting`](crate::model::RetentionSetting).
        pub fn build(self) -> crate::model::RetentionSetting {
            crate::model::RetentionSetting {
                storage_class: self.storage_class,
                retention_period: self.retention_period,
            }
        }
    }
}

/// When writing a match expression against `StorageClass`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let storageclass = unimplemented!();
/// match storageclass {
///     StorageClass::DeepArchive => { /* ... */ },
///     StorageClass::Expire => { /* ... */ },
///     StorageClass::Glacier => { /* ... */ },
///     StorageClass::GlacierIr => { /* ... */ },
///     StorageClass::IntelligentTiering => { /* ... */ },
///     StorageClass::OnezoneIa => { /* ... */ },
///     StorageClass::StandardIa => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `storageclass` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StorageClass::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StorageClass::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StorageClass::NewFeature` is defined.
/// Specifically, when `storageclass` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StorageClass::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StorageClass {
    #[allow(missing_docs)] // documentation missing in model
    DeepArchive,
    #[allow(missing_docs)] // documentation missing in model
    Expire,
    #[allow(missing_docs)] // documentation missing in model
    Glacier,
    #[allow(missing_docs)] // documentation missing in model
    GlacierIr,
    #[allow(missing_docs)] // documentation missing in model
    IntelligentTiering,
    #[allow(missing_docs)] // documentation missing in model
    OnezoneIa,
    #[allow(missing_docs)] // documentation missing in model
    StandardIa,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StorageClass {
    fn from(s: &str) -> Self {
        match s {
            "DEEP_ARCHIVE" => StorageClass::DeepArchive,
            "EXPIRE" => StorageClass::Expire,
            "GLACIER" => StorageClass::Glacier,
            "GLACIER_IR" => StorageClass::GlacierIr,
            "INTELLIGENT_TIERING" => StorageClass::IntelligentTiering,
            "ONEZONE_IA" => StorageClass::OnezoneIa,
            "STANDARD_IA" => StorageClass::StandardIa,
            other => StorageClass::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StorageClass {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StorageClass::from(s))
    }
}
impl StorageClass {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StorageClass::DeepArchive => "DEEP_ARCHIVE",
            StorageClass::Expire => "EXPIRE",
            StorageClass::Glacier => "GLACIER",
            StorageClass::GlacierIr => "GLACIER_IR",
            StorageClass::IntelligentTiering => "INTELLIGENT_TIERING",
            StorageClass::OnezoneIa => "ONEZONE_IA",
            StorageClass::StandardIa => "STANDARD_IA",
            StorageClass::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DEEP_ARCHIVE",
            "EXPIRE",
            "GLACIER",
            "GLACIER_IR",
            "INTELLIGENT_TIERING",
            "ONEZONE_IA",
            "STANDARD_IA",
        ]
    }
}
impl AsRef<str> for StorageClass {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Dimension`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dimension = unimplemented!();
/// match dimension {
///     Dimension::Member => { /* ... */ },
///     Dimension::Region => { /* ... */ },
///     Dimension::SourceType => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dimension` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Dimension::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Dimension::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Dimension::NewFeature` is defined.
/// Specifically, when `dimension` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Dimension::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Dimension {
    #[allow(missing_docs)] // documentation missing in model
    Member,
    #[allow(missing_docs)] // documentation missing in model
    Region,
    #[allow(missing_docs)] // documentation missing in model
    SourceType,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Dimension {
    fn from(s: &str) -> Self {
        match s {
            "MEMBER" => Dimension::Member,
            "REGION" => Dimension::Region,
            "SOURCE_TYPE" => Dimension::SourceType,
            other => Dimension::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Dimension {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Dimension::from(s))
    }
}
impl Dimension {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Dimension::Member => "MEMBER",
            Dimension::Region => "REGION",
            Dimension::SourceType => "SOURCE_TYPE",
            Dimension::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MEMBER", "REGION", "SOURCE_TYPE"]
    }
}
impl AsRef<str> for Dimension {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Response element for actions that make changes, namely create, update, or delete actions. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailuresResponse {
    /// <p>List of Amazon Web Services Regions where the failure occurred. </p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
    /// <p>List of all failures. </p>
    #[doc(hidden)]
    pub failures: std::option::Option<std::vec::Vec<crate::model::Failures>>,
}
impl FailuresResponse {
    /// <p>List of Amazon Web Services Regions where the failure occurred. </p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>List of all failures. </p>
    pub fn failures(&self) -> std::option::Option<&[crate::model::Failures]> {
        self.failures.as_deref()
    }
}
impl FailuresResponse {
    /// Creates a new builder-style object to manufacture [`FailuresResponse`](crate::model::FailuresResponse).
    pub fn builder() -> crate::model::failures_response::Builder {
        crate::model::failures_response::Builder::default()
    }
}

/// See [`FailuresResponse`](crate::model::FailuresResponse).
pub mod failures_response {

    /// A builder for [`FailuresResponse`](crate::model::FailuresResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) failures: std::option::Option<std::vec::Vec<crate::model::Failures>>,
    }
    impl Builder {
        /// <p>List of Amazon Web Services Regions where the failure occurred. </p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>List of Amazon Web Services Regions where the failure occurred. </p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Appends an item to `failures`.
        ///
        /// To override the contents of this collection use [`set_failures`](Self::set_failures).
        ///
        /// <p>List of all failures. </p>
        pub fn failures(mut self, input: crate::model::Failures) -> Self {
            let mut v = self.failures.unwrap_or_default();
            v.push(input);
            self.failures = Some(v);
            self
        }
        /// <p>List of all failures. </p>
        pub fn set_failures(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Failures>>,
        ) -> Self {
            self.failures = input;
            self
        }
        /// Consumes the builder and constructs a [`FailuresResponse`](crate::model::FailuresResponse).
        pub fn build(self) -> crate::model::FailuresResponse {
            crate::model::FailuresResponse {
                region: self.region,
                failures: self.failures,
            }
        }
    }
}

/// <p>List of all failures.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Failures {
    /// <p>List of all exception messages.</p>
    #[doc(hidden)]
    pub exception_message: std::option::Option<std::string::String>,
    /// <p>List of all remediation steps for failures.</p>
    #[doc(hidden)]
    pub remediation: std::option::Option<std::string::String>,
    /// <p>This error can occur if you configure the wrong timestamp format, or if the subset of entries used for validation had errors or missing values.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl Failures {
    /// <p>List of all exception messages.</p>
    pub fn exception_message(&self) -> std::option::Option<&str> {
        self.exception_message.as_deref()
    }
    /// <p>List of all remediation steps for failures.</p>
    pub fn remediation(&self) -> std::option::Option<&str> {
        self.remediation.as_deref()
    }
    /// <p>This error can occur if you configure the wrong timestamp format, or if the subset of entries used for validation had errors or missing values.</p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
}
impl Failures {
    /// Creates a new builder-style object to manufacture [`Failures`](crate::model::Failures).
    pub fn builder() -> crate::model::failures::Builder {
        crate::model::failures::Builder::default()
    }
}

/// See [`Failures`](crate::model::Failures).
pub mod failures {

    /// A builder for [`Failures`](crate::model::Failures).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) exception_message: std::option::Option<std::string::String>,
        pub(crate) remediation: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>List of all exception messages.</p>
        pub fn exception_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.exception_message = Some(input.into());
            self
        }
        /// <p>List of all exception messages.</p>
        pub fn set_exception_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.exception_message = input;
            self
        }
        /// <p>List of all remediation steps for failures.</p>
        pub fn remediation(mut self, input: impl Into<std::string::String>) -> Self {
            self.remediation = Some(input.into());
            self
        }
        /// <p>List of all remediation steps for failures.</p>
        pub fn set_remediation(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.remediation = input;
            self
        }
        /// <p>This error can occur if you configure the wrong timestamp format, or if the subset of entries used for validation had errors or missing values.</p>
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>This error can occur if you configure the wrong timestamp format, or if the subset of entries used for validation had errors or missing values.</p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`Failures`](crate::model::Failures).
        pub fn build(self) -> crate::model::Failures {
            crate::model::Failures {
                exception_message: self.exception_message,
                remediation: self.remediation,
                timestamp: self.timestamp,
            }
        }
    }
}

/// <p>Amazon Security Lake collects logs and events from supported Amazon Web Services and custom sources. For the list of supported Amazon Web Services, see the <a href="https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html">Amazon Security Lake User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountSources {
    /// <p>The ID of the Security Lake account for which logs are collected.</p>
    #[doc(hidden)]
    pub account: std::option::Option<std::string::String>,
    /// <p>The supported Amazon Web Services from which logs and events are collected. Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. </p>
    #[doc(hidden)]
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The log status for the Security Lake account.</p>
    #[doc(hidden)]
    pub logs_status: std::option::Option<std::vec::Vec<crate::model::LogsStatus>>,
    /// <p>Initializes a new instance of the Event class.</p>
    #[doc(hidden)]
    pub event_class: std::option::Option<crate::model::OcsfEventClass>,
}
impl AccountSources {
    /// <p>The ID of the Security Lake account for which logs are collected.</p>
    pub fn account(&self) -> std::option::Option<&str> {
        self.account.as_deref()
    }
    /// <p>The supported Amazon Web Services from which logs and events are collected. Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. </p>
    pub fn source_type(&self) -> std::option::Option<&str> {
        self.source_type.as_deref()
    }
    /// <p>The log status for the Security Lake account.</p>
    pub fn logs_status(&self) -> std::option::Option<&[crate::model::LogsStatus]> {
        self.logs_status.as_deref()
    }
    /// <p>Initializes a new instance of the Event class.</p>
    pub fn event_class(&self) -> std::option::Option<&crate::model::OcsfEventClass> {
        self.event_class.as_ref()
    }
}
impl AccountSources {
    /// Creates a new builder-style object to manufacture [`AccountSources`](crate::model::AccountSources).
    pub fn builder() -> crate::model::account_sources::Builder {
        crate::model::account_sources::Builder::default()
    }
}

/// See [`AccountSources`](crate::model::AccountSources).
pub mod account_sources {

    /// A builder for [`AccountSources`](crate::model::AccountSources).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) logs_status: std::option::Option<std::vec::Vec<crate::model::LogsStatus>>,
        pub(crate) event_class: std::option::Option<crate::model::OcsfEventClass>,
    }
    impl Builder {
        /// <p>The ID of the Security Lake account for which logs are collected.</p>
        pub fn account(mut self, input: impl Into<std::string::String>) -> Self {
            self.account = Some(input.into());
            self
        }
        /// <p>The ID of the Security Lake account for which logs are collected.</p>
        pub fn set_account(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account = input;
            self
        }
        /// <p>The supported Amazon Web Services from which logs and events are collected. Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. </p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The supported Amazon Web Services from which logs and events are collected. Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. </p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// Appends an item to `logs_status`.
        ///
        /// To override the contents of this collection use [`set_logs_status`](Self::set_logs_status).
        ///
        /// <p>The log status for the Security Lake account.</p>
        pub fn logs_status(mut self, input: crate::model::LogsStatus) -> Self {
            let mut v = self.logs_status.unwrap_or_default();
            v.push(input);
            self.logs_status = Some(v);
            self
        }
        /// <p>The log status for the Security Lake account.</p>
        pub fn set_logs_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LogsStatus>>,
        ) -> Self {
            self.logs_status = input;
            self
        }
        /// <p>Initializes a new instance of the Event class.</p>
        pub fn event_class(mut self, input: crate::model::OcsfEventClass) -> Self {
            self.event_class = Some(input);
            self
        }
        /// <p>Initializes a new instance of the Event class.</p>
        pub fn set_event_class(
            mut self,
            input: std::option::Option<crate::model::OcsfEventClass>,
        ) -> Self {
            self.event_class = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountSources`](crate::model::AccountSources).
        pub fn build(self) -> crate::model::AccountSources {
            crate::model::AccountSources {
                account: self.account,
                source_type: self.source_type,
                logs_status: self.logs_status,
                event_class: self.event_class,
            }
        }
    }
}

/// When writing a match expression against `OcsfEventClass`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ocsfeventclass = unimplemented!();
/// match ocsfeventclass {
///     OcsfEventClass::AccessActivity => { /* ... */ },
///     OcsfEventClass::AccountChange => { /* ... */ },
///     OcsfEventClass::Authentication => { /* ... */ },
///     OcsfEventClass::Authorization => { /* ... */ },
///     OcsfEventClass::CloudApi => { /* ... */ },
///     OcsfEventClass::CloudStorage => { /* ... */ },
///     OcsfEventClass::ConfigState => { /* ... */ },
///     OcsfEventClass::ContainerLifecycle => { /* ... */ },
///     OcsfEventClass::DatabaseLifecycle => { /* ... */ },
///     OcsfEventClass::DhcpActivity => { /* ... */ },
///     OcsfEventClass::DnsActivity => { /* ... */ },
///     OcsfEventClass::EntityManagementAudit => { /* ... */ },
///     OcsfEventClass::FileActivity => { /* ... */ },
///     OcsfEventClass::FtpActivity => { /* ... */ },
///     OcsfEventClass::HttpActivity => { /* ... */ },
///     OcsfEventClass::InventoryInfo => { /* ... */ },
///     OcsfEventClass::KernelActivity => { /* ... */ },
///     OcsfEventClass::KernelExtension => { /* ... */ },
///     OcsfEventClass::MemoryActivity => { /* ... */ },
///     OcsfEventClass::ModuleActivity => { /* ... */ },
///     OcsfEventClass::NetworkActivity => { /* ... */ },
///     OcsfEventClass::ProcessActivity => { /* ... */ },
///     OcsfEventClass::RdpActivity => { /* ... */ },
///     OcsfEventClass::RegistryKeyActivity => { /* ... */ },
///     OcsfEventClass::RegistryValueActivity => { /* ... */ },
///     OcsfEventClass::ResourceActivity => { /* ... */ },
///     OcsfEventClass::RfbActivity => { /* ... */ },
///     OcsfEventClass::ScheduledJobActivity => { /* ... */ },
///     OcsfEventClass::SecurityFinding => { /* ... */ },
///     OcsfEventClass::SmbActivity => { /* ... */ },
///     OcsfEventClass::SmtpActivity => { /* ... */ },
///     OcsfEventClass::SshActivity => { /* ... */ },
///     OcsfEventClass::VirtualMachineActivity => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ocsfeventclass` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OcsfEventClass::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OcsfEventClass::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OcsfEventClass::NewFeature` is defined.
/// Specifically, when `ocsfeventclass` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OcsfEventClass::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OcsfEventClass {
    #[allow(missing_docs)] // documentation missing in model
    AccessActivity,
    #[allow(missing_docs)] // documentation missing in model
    AccountChange,
    #[allow(missing_docs)] // documentation missing in model
    Authentication,
    #[allow(missing_docs)] // documentation missing in model
    Authorization,
    #[allow(missing_docs)] // documentation missing in model
    CloudApi,
    #[allow(missing_docs)] // documentation missing in model
    CloudStorage,
    #[allow(missing_docs)] // documentation missing in model
    ConfigState,
    #[allow(missing_docs)] // documentation missing in model
    ContainerLifecycle,
    #[allow(missing_docs)] // documentation missing in model
    DatabaseLifecycle,
    #[allow(missing_docs)] // documentation missing in model
    DhcpActivity,
    #[allow(missing_docs)] // documentation missing in model
    DnsActivity,
    #[allow(missing_docs)] // documentation missing in model
    EntityManagementAudit,
    #[allow(missing_docs)] // documentation missing in model
    FileActivity,
    #[allow(missing_docs)] // documentation missing in model
    FtpActivity,
    #[allow(missing_docs)] // documentation missing in model
    HttpActivity,
    #[allow(missing_docs)] // documentation missing in model
    InventoryInfo,
    #[allow(missing_docs)] // documentation missing in model
    KernelActivity,
    #[allow(missing_docs)] // documentation missing in model
    KernelExtension,
    #[allow(missing_docs)] // documentation missing in model
    MemoryActivity,
    #[allow(missing_docs)] // documentation missing in model
    ModuleActivity,
    #[allow(missing_docs)] // documentation missing in model
    NetworkActivity,
    #[allow(missing_docs)] // documentation missing in model
    ProcessActivity,
    #[allow(missing_docs)] // documentation missing in model
    RdpActivity,
    #[allow(missing_docs)] // documentation missing in model
    RegistryKeyActivity,
    #[allow(missing_docs)] // documentation missing in model
    RegistryValueActivity,
    #[allow(missing_docs)] // documentation missing in model
    ResourceActivity,
    #[allow(missing_docs)] // documentation missing in model
    RfbActivity,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledJobActivity,
    #[allow(missing_docs)] // documentation missing in model
    SecurityFinding,
    #[allow(missing_docs)] // documentation missing in model
    SmbActivity,
    #[allow(missing_docs)] // documentation missing in model
    SmtpActivity,
    #[allow(missing_docs)] // documentation missing in model
    SshActivity,
    #[allow(missing_docs)] // documentation missing in model
    VirtualMachineActivity,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OcsfEventClass {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_ACTIVITY" => OcsfEventClass::AccessActivity,
            "ACCOUNT_CHANGE" => OcsfEventClass::AccountChange,
            "AUTHENTICATION" => OcsfEventClass::Authentication,
            "AUTHORIZATION" => OcsfEventClass::Authorization,
            "CLOUD_API" => OcsfEventClass::CloudApi,
            "CLOUD_STORAGE" => OcsfEventClass::CloudStorage,
            "CONFIG_STATE" => OcsfEventClass::ConfigState,
            "CONTAINER_LIFECYCLE" => OcsfEventClass::ContainerLifecycle,
            "DATABASE_LIFECYCLE" => OcsfEventClass::DatabaseLifecycle,
            "DHCP_ACTIVITY" => OcsfEventClass::DhcpActivity,
            "DNS_ACTIVITY" => OcsfEventClass::DnsActivity,
            "ENTITY_MANAGEMENT_AUDIT" => OcsfEventClass::EntityManagementAudit,
            "FILE_ACTIVITY" => OcsfEventClass::FileActivity,
            "FTP_ACTIVITY" => OcsfEventClass::FtpActivity,
            "HTTP_ACTIVITY" => OcsfEventClass::HttpActivity,
            "INVENTORY_INFO" => OcsfEventClass::InventoryInfo,
            "KERNEL_ACTIVITY" => OcsfEventClass::KernelActivity,
            "KERNEL_EXTENSION" => OcsfEventClass::KernelExtension,
            "MEMORY_ACTIVITY" => OcsfEventClass::MemoryActivity,
            "MODULE_ACTIVITY" => OcsfEventClass::ModuleActivity,
            "NETWORK_ACTIVITY" => OcsfEventClass::NetworkActivity,
            "PROCESS_ACTIVITY" => OcsfEventClass::ProcessActivity,
            "RDP_ACTIVITY" => OcsfEventClass::RdpActivity,
            "REGISTRY_KEY_ACTIVITY" => OcsfEventClass::RegistryKeyActivity,
            "REGISTRY_VALUE_ACTIVITY" => OcsfEventClass::RegistryValueActivity,
            "RESOURCE_ACTIVITY" => OcsfEventClass::ResourceActivity,
            "RFB_ACTIVITY" => OcsfEventClass::RfbActivity,
            "SCHEDULED_JOB_ACTIVITY" => OcsfEventClass::ScheduledJobActivity,
            "SECURITY_FINDING" => OcsfEventClass::SecurityFinding,
            "SMB_ACTIVITY" => OcsfEventClass::SmbActivity,
            "SMTP_ACTIVITY" => OcsfEventClass::SmtpActivity,
            "SSH_ACTIVITY" => OcsfEventClass::SshActivity,
            "VIRTUAL_MACHINE_ACTIVITY" => OcsfEventClass::VirtualMachineActivity,
            other => OcsfEventClass::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for OcsfEventClass {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OcsfEventClass::from(s))
    }
}
impl OcsfEventClass {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OcsfEventClass::AccessActivity => "ACCESS_ACTIVITY",
            OcsfEventClass::AccountChange => "ACCOUNT_CHANGE",
            OcsfEventClass::Authentication => "AUTHENTICATION",
            OcsfEventClass::Authorization => "AUTHORIZATION",
            OcsfEventClass::CloudApi => "CLOUD_API",
            OcsfEventClass::CloudStorage => "CLOUD_STORAGE",
            OcsfEventClass::ConfigState => "CONFIG_STATE",
            OcsfEventClass::ContainerLifecycle => "CONTAINER_LIFECYCLE",
            OcsfEventClass::DatabaseLifecycle => "DATABASE_LIFECYCLE",
            OcsfEventClass::DhcpActivity => "DHCP_ACTIVITY",
            OcsfEventClass::DnsActivity => "DNS_ACTIVITY",
            OcsfEventClass::EntityManagementAudit => "ENTITY_MANAGEMENT_AUDIT",
            OcsfEventClass::FileActivity => "FILE_ACTIVITY",
            OcsfEventClass::FtpActivity => "FTP_ACTIVITY",
            OcsfEventClass::HttpActivity => "HTTP_ACTIVITY",
            OcsfEventClass::InventoryInfo => "INVENTORY_INFO",
            OcsfEventClass::KernelActivity => "KERNEL_ACTIVITY",
            OcsfEventClass::KernelExtension => "KERNEL_EXTENSION",
            OcsfEventClass::MemoryActivity => "MEMORY_ACTIVITY",
            OcsfEventClass::ModuleActivity => "MODULE_ACTIVITY",
            OcsfEventClass::NetworkActivity => "NETWORK_ACTIVITY",
            OcsfEventClass::ProcessActivity => "PROCESS_ACTIVITY",
            OcsfEventClass::RdpActivity => "RDP_ACTIVITY",
            OcsfEventClass::RegistryKeyActivity => "REGISTRY_KEY_ACTIVITY",
            OcsfEventClass::RegistryValueActivity => "REGISTRY_VALUE_ACTIVITY",
            OcsfEventClass::ResourceActivity => "RESOURCE_ACTIVITY",
            OcsfEventClass::RfbActivity => "RFB_ACTIVITY",
            OcsfEventClass::ScheduledJobActivity => "SCHEDULED_JOB_ACTIVITY",
            OcsfEventClass::SecurityFinding => "SECURITY_FINDING",
            OcsfEventClass::SmbActivity => "SMB_ACTIVITY",
            OcsfEventClass::SmtpActivity => "SMTP_ACTIVITY",
            OcsfEventClass::SshActivity => "SSH_ACTIVITY",
            OcsfEventClass::VirtualMachineActivity => "VIRTUAL_MACHINE_ACTIVITY",
            OcsfEventClass::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_ACTIVITY",
            "ACCOUNT_CHANGE",
            "AUTHENTICATION",
            "AUTHORIZATION",
            "CLOUD_API",
            "CLOUD_STORAGE",
            "CONFIG_STATE",
            "CONTAINER_LIFECYCLE",
            "DATABASE_LIFECYCLE",
            "DHCP_ACTIVITY",
            "DNS_ACTIVITY",
            "ENTITY_MANAGEMENT_AUDIT",
            "FILE_ACTIVITY",
            "FTP_ACTIVITY",
            "HTTP_ACTIVITY",
            "INVENTORY_INFO",
            "KERNEL_ACTIVITY",
            "KERNEL_EXTENSION",
            "MEMORY_ACTIVITY",
            "MODULE_ACTIVITY",
            "NETWORK_ACTIVITY",
            "PROCESS_ACTIVITY",
            "RDP_ACTIVITY",
            "REGISTRY_KEY_ACTIVITY",
            "REGISTRY_VALUE_ACTIVITY",
            "RESOURCE_ACTIVITY",
            "RFB_ACTIVITY",
            "SCHEDULED_JOB_ACTIVITY",
            "SECURITY_FINDING",
            "SMB_ACTIVITY",
            "SMTP_ACTIVITY",
            "SSH_ACTIVITY",
            "VIRTUAL_MACHINE_ACTIVITY",
        ]
    }
}
impl AsRef<str> for OcsfEventClass {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Retrieves the Logs status for the Amazon Security Lake account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogsStatus {
    /// <p>Defines path the stored logs are available which has information on your systems, applications, and services. </p>
    #[doc(hidden)]
    pub path_to_logs: std::option::Option<std::string::String>,
    /// <p>The health status of services, including error codes and patterns.</p>
    #[doc(hidden)]
    pub health_status: std::option::Option<crate::model::SourceStatus>,
}
impl LogsStatus {
    /// <p>Defines path the stored logs are available which has information on your systems, applications, and services. </p>
    pub fn path_to_logs(&self) -> std::option::Option<&str> {
        self.path_to_logs.as_deref()
    }
    /// <p>The health status of services, including error codes and patterns.</p>
    pub fn health_status(&self) -> std::option::Option<&crate::model::SourceStatus> {
        self.health_status.as_ref()
    }
}
impl LogsStatus {
    /// Creates a new builder-style object to manufacture [`LogsStatus`](crate::model::LogsStatus).
    pub fn builder() -> crate::model::logs_status::Builder {
        crate::model::logs_status::Builder::default()
    }
}

/// See [`LogsStatus`](crate::model::LogsStatus).
pub mod logs_status {

    /// A builder for [`LogsStatus`](crate::model::LogsStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path_to_logs: std::option::Option<std::string::String>,
        pub(crate) health_status: std::option::Option<crate::model::SourceStatus>,
    }
    impl Builder {
        /// <p>Defines path the stored logs are available which has information on your systems, applications, and services. </p>
        pub fn path_to_logs(mut self, input: impl Into<std::string::String>) -> Self {
            self.path_to_logs = Some(input.into());
            self
        }
        /// <p>Defines path the stored logs are available which has information on your systems, applications, and services. </p>
        pub fn set_path_to_logs(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path_to_logs = input;
            self
        }
        /// <p>The health status of services, including error codes and patterns.</p>
        pub fn health_status(mut self, input: crate::model::SourceStatus) -> Self {
            self.health_status = Some(input);
            self
        }
        /// <p>The health status of services, including error codes and patterns.</p>
        pub fn set_health_status(
            mut self,
            input: std::option::Option<crate::model::SourceStatus>,
        ) -> Self {
            self.health_status = input;
            self
        }
        /// Consumes the builder and constructs a [`LogsStatus`](crate::model::LogsStatus).
        pub fn build(self) -> crate::model::LogsStatus {
            crate::model::LogsStatus {
                path_to_logs: self.path_to_logs,
                health_status: self.health_status,
            }
        }
    }
}

/// When writing a match expression against `SourceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sourcestatus = unimplemented!();
/// match sourcestatus {
///     SourceStatus::Active => { /* ... */ },
///     SourceStatus::Deactivated => { /* ... */ },
///     SourceStatus::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sourcestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SourceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SourceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SourceStatus::NewFeature` is defined.
/// Specifically, when `sourcestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SourceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SourceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deactivated,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SourceStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => SourceStatus::Active,
            "DEACTIVATED" => SourceStatus::Deactivated,
            "PENDING" => SourceStatus::Pending,
            other => SourceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SourceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SourceStatus::from(s))
    }
}
impl SourceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SourceStatus::Active => "ACTIVE",
            SourceStatus::Deactivated => "DEACTIVATED",
            SourceStatus::Pending => "PENDING",
            SourceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "DEACTIVATED", "PENDING"]
    }
}
impl AsRef<str> for SourceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Protocol used in Amazon Security Lake that dictates how notifications are posted at the endpoint. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProtocolAndNotificationEndpoint {
    /// <p>The protocol to which notification messages are posted. </p>
    #[doc(hidden)]
    pub protocol: std::option::Option<std::string::String>,
    /// <p>The account that is subscribed to receive exception notifications. </p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<std::string::String>,
}
impl ProtocolAndNotificationEndpoint {
    /// <p>The protocol to which notification messages are posted. </p>
    pub fn protocol(&self) -> std::option::Option<&str> {
        self.protocol.as_deref()
    }
    /// <p>The account that is subscribed to receive exception notifications. </p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
}
impl ProtocolAndNotificationEndpoint {
    /// Creates a new builder-style object to manufacture [`ProtocolAndNotificationEndpoint`](crate::model::ProtocolAndNotificationEndpoint).
    pub fn builder() -> crate::model::protocol_and_notification_endpoint::Builder {
        crate::model::protocol_and_notification_endpoint::Builder::default()
    }
}

/// See [`ProtocolAndNotificationEndpoint`](crate::model::ProtocolAndNotificationEndpoint).
pub mod protocol_and_notification_endpoint {

    /// A builder for [`ProtocolAndNotificationEndpoint`](crate::model::ProtocolAndNotificationEndpoint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocol: std::option::Option<std::string::String>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The protocol to which notification messages are posted. </p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol = Some(input.into());
            self
        }
        /// <p>The protocol to which notification messages are posted. </p>
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The account that is subscribed to receive exception notifications. </p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The account that is subscribed to receive exception notifications. </p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtocolAndNotificationEndpoint`](crate::model::ProtocolAndNotificationEndpoint).
        pub fn build(self) -> crate::model::ProtocolAndNotificationEndpoint {
            crate::model::ProtocolAndNotificationEndpoint {
                protocol: self.protocol,
                endpoint: self.endpoint,
            }
        }
    }
}

/// <p>Automatically enable new organization accounts as member accounts from an Amazon Security Lake administrator account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoEnableNewRegionConfiguration {
    /// <p>The Amazon Web Services Regions where Security Lake is automatically enabled.</p>
    #[doc(hidden)]
    pub region: std::option::Option<crate::model::Region>,
    /// <p>The Amazon Web Services sources that are automatically enabled in Security Lake.</p>
    #[doc(hidden)]
    pub sources: std::option::Option<std::vec::Vec<crate::model::AwsLogSourceType>>,
}
impl AutoEnableNewRegionConfiguration {
    /// <p>The Amazon Web Services Regions where Security Lake is automatically enabled.</p>
    pub fn region(&self) -> std::option::Option<&crate::model::Region> {
        self.region.as_ref()
    }
    /// <p>The Amazon Web Services sources that are automatically enabled in Security Lake.</p>
    pub fn sources(&self) -> std::option::Option<&[crate::model::AwsLogSourceType]> {
        self.sources.as_deref()
    }
}
impl AutoEnableNewRegionConfiguration {
    /// Creates a new builder-style object to manufacture [`AutoEnableNewRegionConfiguration`](crate::model::AutoEnableNewRegionConfiguration).
    pub fn builder() -> crate::model::auto_enable_new_region_configuration::Builder {
        crate::model::auto_enable_new_region_configuration::Builder::default()
    }
}

/// See [`AutoEnableNewRegionConfiguration`](crate::model::AutoEnableNewRegionConfiguration).
pub mod auto_enable_new_region_configuration {

    /// A builder for [`AutoEnableNewRegionConfiguration`](crate::model::AutoEnableNewRegionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region: std::option::Option<crate::model::Region>,
        pub(crate) sources: std::option::Option<std::vec::Vec<crate::model::AwsLogSourceType>>,
    }
    impl Builder {
        /// <p>The Amazon Web Services Regions where Security Lake is automatically enabled.</p>
        pub fn region(mut self, input: crate::model::Region) -> Self {
            self.region = Some(input);
            self
        }
        /// <p>The Amazon Web Services Regions where Security Lake is automatically enabled.</p>
        pub fn set_region(mut self, input: std::option::Option<crate::model::Region>) -> Self {
            self.region = input;
            self
        }
        /// Appends an item to `sources`.
        ///
        /// To override the contents of this collection use [`set_sources`](Self::set_sources).
        ///
        /// <p>The Amazon Web Services sources that are automatically enabled in Security Lake.</p>
        pub fn sources(mut self, input: crate::model::AwsLogSourceType) -> Self {
            let mut v = self.sources.unwrap_or_default();
            v.push(input);
            self.sources = Some(v);
            self
        }
        /// <p>The Amazon Web Services sources that are automatically enabled in Security Lake.</p>
        pub fn set_sources(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AwsLogSourceType>>,
        ) -> Self {
            self.sources = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoEnableNewRegionConfiguration`](crate::model::AutoEnableNewRegionConfiguration).
        pub fn build(self) -> crate::model::AutoEnableNewRegionConfiguration {
            crate::model::AutoEnableNewRegionConfiguration {
                region: self.region,
                sources: self.sources,
            }
        }
    }
}

/// <p>Provides details of Amazon Security Lake lake configuration object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LakeConfigurationResponse {
    /// <p>The type of encryption key used by secure the Security Lake configuration object.</p>
    #[doc(hidden)]
    pub encryption_key: std::option::Option<std::string::String>,
    /// <p>Retention settings for the destination Amazon S3 buckets. </p>
    #[doc(hidden)]
    pub retention_settings: std::option::Option<std::vec::Vec<crate::model::RetentionSetting>>,
    /// <p>A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.</p>
    #[doc(hidden)]
    pub tags_map:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket.</p>
    /// <p>Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region. </p>
    #[doc(hidden)]
    pub replication_destination_regions: std::option::Option<std::vec::Vec<crate::model::Region>>,
    /// <p>Replication settings for the Amazon S3 buckets. This parameter uses the IAM role you created that is managed by Security Lake, to ensure the replication setting is correct. </p>
    #[doc(hidden)]
    pub replication_role_arn: std::option::Option<std::string::String>,
    /// <p>Amazon Resource Names (ARNs) uniquely identify Amazon Web Services resources. Security Lake requires an ARN when you need to specify a resource unambiguously across all of Amazon Web Services, such as in IAM policies, Amazon Relational Database Service (Amazon RDS) tags, and API calls. </p>
    #[doc(hidden)]
    pub s3_bucket_arn: std::option::Option<std::string::String>,
    /// <p>Retrieves the status of the configuration operation for an account in Amazon Security Lake. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SettingsStatus>,
}
impl LakeConfigurationResponse {
    /// <p>The type of encryption key used by secure the Security Lake configuration object.</p>
    pub fn encryption_key(&self) -> std::option::Option<&str> {
        self.encryption_key.as_deref()
    }
    /// <p>Retention settings for the destination Amazon S3 buckets. </p>
    pub fn retention_settings(&self) -> std::option::Option<&[crate::model::RetentionSetting]> {
        self.retention_settings.as_deref()
    }
    /// <p>A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.</p>
    pub fn tags_map(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags_map.as_ref()
    }
    /// <p>Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket.</p>
    /// <p>Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region. </p>
    pub fn replication_destination_regions(&self) -> std::option::Option<&[crate::model::Region]> {
        self.replication_destination_regions.as_deref()
    }
    /// <p>Replication settings for the Amazon S3 buckets. This parameter uses the IAM role you created that is managed by Security Lake, to ensure the replication setting is correct. </p>
    pub fn replication_role_arn(&self) -> std::option::Option<&str> {
        self.replication_role_arn.as_deref()
    }
    /// <p>Amazon Resource Names (ARNs) uniquely identify Amazon Web Services resources. Security Lake requires an ARN when you need to specify a resource unambiguously across all of Amazon Web Services, such as in IAM policies, Amazon Relational Database Service (Amazon RDS) tags, and API calls. </p>
    pub fn s3_bucket_arn(&self) -> std::option::Option<&str> {
        self.s3_bucket_arn.as_deref()
    }
    /// <p>Retrieves the status of the configuration operation for an account in Amazon Security Lake. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::SettingsStatus> {
        self.status.as_ref()
    }
}
impl LakeConfigurationResponse {
    /// Creates a new builder-style object to manufacture [`LakeConfigurationResponse`](crate::model::LakeConfigurationResponse).
    pub fn builder() -> crate::model::lake_configuration_response::Builder {
        crate::model::lake_configuration_response::Builder::default()
    }
}

/// See [`LakeConfigurationResponse`](crate::model::LakeConfigurationResponse).
pub mod lake_configuration_response {

    /// A builder for [`LakeConfigurationResponse`](crate::model::LakeConfigurationResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_key: std::option::Option<std::string::String>,
        pub(crate) retention_settings:
            std::option::Option<std::vec::Vec<crate::model::RetentionSetting>>,
        pub(crate) tags_map: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) replication_destination_regions:
            std::option::Option<std::vec::Vec<crate::model::Region>>,
        pub(crate) replication_role_arn: std::option::Option<std::string::String>,
        pub(crate) s3_bucket_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SettingsStatus>,
    }
    impl Builder {
        /// <p>The type of encryption key used by secure the Security Lake configuration object.</p>
        pub fn encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key = Some(input.into());
            self
        }
        /// <p>The type of encryption key used by secure the Security Lake configuration object.</p>
        pub fn set_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key = input;
            self
        }
        /// Appends an item to `retention_settings`.
        ///
        /// To override the contents of this collection use [`set_retention_settings`](Self::set_retention_settings).
        ///
        /// <p>Retention settings for the destination Amazon S3 buckets. </p>
        pub fn retention_settings(mut self, input: crate::model::RetentionSetting) -> Self {
            let mut v = self.retention_settings.unwrap_or_default();
            v.push(input);
            self.retention_settings = Some(v);
            self
        }
        /// <p>Retention settings for the destination Amazon S3 buckets. </p>
        pub fn set_retention_settings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RetentionSetting>>,
        ) -> Self {
            self.retention_settings = input;
            self
        }
        /// Adds a key-value pair to `tags_map`.
        ///
        /// To override the contents of this collection use [`set_tags_map`](Self::set_tags_map).
        ///
        /// <p>A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.</p>
        pub fn tags_map(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags_map = Some(hash_map);
            self
        }
        /// <p>A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.</p>
        pub fn set_tags_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags_map = input;
            self
        }
        /// Appends an item to `replication_destination_regions`.
        ///
        /// To override the contents of this collection use [`set_replication_destination_regions`](Self::set_replication_destination_regions).
        ///
        /// <p>Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket.</p>
        /// <p>Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region. </p>
        pub fn replication_destination_regions(mut self, input: crate::model::Region) -> Self {
            let mut v = self.replication_destination_regions.unwrap_or_default();
            v.push(input);
            self.replication_destination_regions = Some(v);
            self
        }
        /// <p>Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket.</p>
        /// <p>Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region. </p>
        pub fn set_replication_destination_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Region>>,
        ) -> Self {
            self.replication_destination_regions = input;
            self
        }
        /// <p>Replication settings for the Amazon S3 buckets. This parameter uses the IAM role you created that is managed by Security Lake, to ensure the replication setting is correct. </p>
        pub fn replication_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.replication_role_arn = Some(input.into());
            self
        }
        /// <p>Replication settings for the Amazon S3 buckets. This parameter uses the IAM role you created that is managed by Security Lake, to ensure the replication setting is correct. </p>
        pub fn set_replication_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replication_role_arn = input;
            self
        }
        /// <p>Amazon Resource Names (ARNs) uniquely identify Amazon Web Services resources. Security Lake requires an ARN when you need to specify a resource unambiguously across all of Amazon Web Services, such as in IAM policies, Amazon Relational Database Service (Amazon RDS) tags, and API calls. </p>
        pub fn s3_bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Names (ARNs) uniquely identify Amazon Web Services resources. Security Lake requires an ARN when you need to specify a resource unambiguously across all of Amazon Web Services, such as in IAM policies, Amazon Relational Database Service (Amazon RDS) tags, and API calls. </p>
        pub fn set_s3_bucket_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_arn = input;
            self
        }
        /// <p>Retrieves the status of the configuration operation for an account in Amazon Security Lake. </p>
        pub fn status(mut self, input: crate::model::SettingsStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Retrieves the status of the configuration operation for an account in Amazon Security Lake. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SettingsStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`LakeConfigurationResponse`](crate::model::LakeConfigurationResponse).
        pub fn build(self) -> crate::model::LakeConfigurationResponse {
            crate::model::LakeConfigurationResponse {
                encryption_key: self.encryption_key,
                retention_settings: self.retention_settings,
                tags_map: self.tags_map,
                replication_destination_regions: self.replication_destination_regions,
                replication_role_arn: self.replication_role_arn,
                s3_bucket_arn: self.s3_bucket_arn,
                status: self.status,
            }
        }
    }
}

/// When writing a match expression against `SettingsStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let settingsstatus = unimplemented!();
/// match settingsstatus {
///     SettingsStatus::Completed => { /* ... */ },
///     SettingsStatus::Failed => { /* ... */ },
///     SettingsStatus::Initialized => { /* ... */ },
///     SettingsStatus::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `settingsstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SettingsStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SettingsStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SettingsStatus::NewFeature` is defined.
/// Specifically, when `settingsstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SettingsStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SettingsStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Initialized,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SettingsStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => SettingsStatus::Completed,
            "FAILED" => SettingsStatus::Failed,
            "INITIALIZED" => SettingsStatus::Initialized,
            "PENDING" => SettingsStatus::Pending,
            other => SettingsStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SettingsStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SettingsStatus::from(s))
    }
}
impl SettingsStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SettingsStatus::Completed => "COMPLETED",
            SettingsStatus::Failed => "FAILED",
            SettingsStatus::Initialized => "INITIALIZED",
            SettingsStatus::Pending => "PENDING",
            SettingsStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "INITIALIZED", "PENDING"]
    }
}
impl AsRef<str> for SettingsStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
