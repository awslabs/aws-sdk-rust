// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`CreateAwsLogSourceInput`](crate::input::CreateAwsLogSourceInput).
pub mod create_aws_log_source_input {
    
    /// A builder for [`CreateAwsLogSourceInput`](crate::input::CreateAwsLogSourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_order: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        pub(crate) enable_all_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>>,
        pub(crate) enable_two_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>,
        pub(crate) enable_single_dimension: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `input_order`.
        ///
        /// To override the contents of this collection use [`set_input_order`](Self::set_input_order).
        ///
        /// <p>Specifies the input order to enable dimensions in Security Lake, namely Region, source type, and member account.</p>
        pub fn input_order(mut self, input: crate::model::Dimension) -> Self {
            let mut v = self.input_order.unwrap_or_default();
                            v.push(input);
                            self.input_order = Some(v);
                            self
        }
        /// <p>Specifies the input order to enable dimensions in Security Lake, namely Region, source type, and member account.</p>
        pub fn set_input_order(mut self, input: std::option::Option<std::vec::Vec<crate::model::Dimension>>) -> Self {
            self.input_order = input; self
        }
        /// Adds a key-value pair to `enable_all_dimensions`.
        ///
        /// To override the contents of this collection use [`set_enable_all_dimensions`](Self::set_enable_all_dimensions).
        ///
        /// <p>Enables data collection from specific Amazon Web Services sources in all specific accounts and specific Regions.</p>
        pub fn enable_all_dimensions(mut self, k: impl Into<std::string::String>, v: std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>) -> Self {
            let mut hash_map = self.enable_all_dimensions.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.enable_all_dimensions = Some(hash_map);
                            self
        }
        /// <p>Enables data collection from specific Amazon Web Services sources in all specific accounts and specific Regions.</p>
        pub fn set_enable_all_dimensions(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>>) -> Self {
            self.enable_all_dimensions = input; self
        }
        /// Adds a key-value pair to `enable_two_dimensions`.
        ///
        /// To override the contents of this collection use [`set_enable_two_dimensions`](Self::set_enable_two_dimensions).
        ///
        /// <p>Enables data collection from specific Amazon Web Services sources in specific accounts or Regions.</p>
        pub fn enable_two_dimensions(mut self, k: impl Into<std::string::String>, v: std::vec::Vec<std::string::String>) -> Self {
            let mut hash_map = self.enable_two_dimensions.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.enable_two_dimensions = Some(hash_map);
                            self
        }
        /// <p>Enables data collection from specific Amazon Web Services sources in specific accounts or Regions.</p>
        pub fn set_enable_two_dimensions(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>) -> Self {
            self.enable_two_dimensions = input; self
        }
        /// Appends an item to `enable_single_dimension`.
        ///
        /// To override the contents of this collection use [`set_enable_single_dimension`](Self::set_enable_single_dimension).
        ///
        /// <p>Enables data collection from all Amazon Web Services sources in specific accounts or Regions.</p>
        pub fn enable_single_dimension(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.enable_single_dimension.unwrap_or_default();
                            v.push(input.into());
                            self.enable_single_dimension = Some(v);
                            self
        }
        /// <p>Enables data collection from all Amazon Web Services sources in specific accounts or Regions.</p>
        pub fn set_enable_single_dimension(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.enable_single_dimension = input; self
        }
        /// Consumes the builder and constructs a [`CreateAwsLogSourceInput`](crate::input::CreateAwsLogSourceInput).
        pub fn build(self) -> Result<crate::input::CreateAwsLogSourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateAwsLogSourceInput {
                    input_order: self.input_order
                    ,
                    enable_all_dimensions: self.enable_all_dimensions
                    ,
                    enable_two_dimensions: self.enable_two_dimensions
                    ,
                    enable_single_dimension: self.enable_single_dimension
                    ,
                }
            )
        }
    }
    
    
}
impl CreateAwsLogSourceInput {
    /// Consumes the builder and constructs an Operation<[`CreateAwsLogSource`](crate::operation::CreateAwsLogSource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateAwsLogSource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateAwsLogSourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/logsources/aws").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateAwsLogSourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_aws_log_source(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateAwsLogSource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateAwsLogSource", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAwsLogSourceInput`](crate::input::CreateAwsLogSourceInput).
    pub fn builder() -> crate::input::create_aws_log_source_input::Builder {
        crate::input::create_aws_log_source_input::Builder::default()
    }
}

/// See [`CreateCustomLogSourceInput`](crate::input::CreateCustomLogSourceInput).
pub mod create_custom_log_source_input {
    
    /// A builder for [`CreateCustomLogSourceInput`](crate::input::CreateCustomLogSourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_source_name: std::option::Option<std::string::String>,
        pub(crate) event_class: std::option::Option<crate::model::OcsfEventClass>,
        pub(crate) glue_invocation_role_arn: std::option::Option<std::string::String>,
        pub(crate) log_provider_account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name for a third-party custom source. This must be a Regionally unique value.</p>
        pub fn custom_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_source_name = Some(input.into());
            self
        }
        /// <p>The name for a third-party custom source. This must be a Regionally unique value.</p>
        pub fn set_custom_source_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_source_name = input; self
        }
        /// <p>The Open Cybersecurity Schema Framework (OCSF) event class which describes the type of data that the custom source will send to Security Lake.</p>
        pub fn event_class(mut self, input: crate::model::OcsfEventClass) -> Self {
            self.event_class = Some(input);
            self
        }
        /// <p>The Open Cybersecurity Schema Framework (OCSF) event class which describes the type of data that the custom source will send to Security Lake.</p>
        pub fn set_event_class(mut self, input: std::option::Option<crate::model::OcsfEventClass>) -> Self {
            self.event_class = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be used by the Glue crawler. The recommended IAM policies are:</p> 
        /// <ul> 
        /// <li> <p>The managed policy <code>AWSGlueServiceRole</code> </p> </li> 
        /// <li> <p>A custom policy granting access to your Amazon S3 Data Lake</p> </li> 
        /// </ul>
        pub fn glue_invocation_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.glue_invocation_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be used by the Glue crawler. The recommended IAM policies are:</p> 
        /// <ul> 
        /// <li> <p>The managed policy <code>AWSGlueServiceRole</code> </p> </li> 
        /// <li> <p>A custom policy granting access to your Amazon S3 Data Lake</p> </li> 
        /// </ul>
        pub fn set_glue_invocation_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.glue_invocation_role_arn = input; self
        }
        /// <p>The Amazon Web Services account ID of the custom source that will write logs and events into the Amazon S3 Data Lake.</p>
        pub fn log_provider_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_provider_account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the custom source that will write logs and events into the Amazon S3 Data Lake.</p>
        pub fn set_log_provider_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_provider_account_id = input; self
        }
        /// Consumes the builder and constructs a [`CreateCustomLogSourceInput`](crate::input::CreateCustomLogSourceInput).
        pub fn build(self) -> Result<crate::input::CreateCustomLogSourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateCustomLogSourceInput {
                    custom_source_name: self.custom_source_name
                    ,
                    event_class: self.event_class
                    ,
                    glue_invocation_role_arn: self.glue_invocation_role_arn
                    ,
                    log_provider_account_id: self.log_provider_account_id
                    ,
                }
            )
        }
    }
    
    
}
impl CreateCustomLogSourceInput {
    /// Consumes the builder and constructs an Operation<[`CreateCustomLogSource`](crate::operation::CreateCustomLogSource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateCustomLogSource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateCustomLogSourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/logsources/custom").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateCustomLogSourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_custom_log_source(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateCustomLogSource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateCustomLogSource", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateCustomLogSourceInput`](crate::input::CreateCustomLogSourceInput).
    pub fn builder() -> crate::input::create_custom_log_source_input::Builder {
        crate::input::create_custom_log_source_input::Builder::default()
    }
}

/// See [`CreateDatalakeInput`](crate::input::CreateDatalakeInput).
pub mod create_datalake_input {
    
    /// A builder for [`CreateDatalakeInput`](crate::input::CreateDatalakeInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) regions: std::option::Option<std::vec::Vec<crate::model::Region>>,
        pub(crate) configurations: std::option::Option<std::collections::HashMap<crate::model::Region, crate::model::LakeConfigurationRequest>>,
        pub(crate) enable_all: std::option::Option<bool>,
        pub(crate) meta_store_manager_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `regions`.
        ///
        /// To override the contents of this collection use [`set_regions`](Self::set_regions).
        ///
        /// <p>Enable Security Lake in the specified Regions. To enable Security Lake in specific Amazon Web Services Regions, such as us-east-1 or ap-northeast-3, provide the Region codes. For a list of Region codes, see <a href="https://docs.aws.amazon.com/general/latest/gr/securitylake.html">Amazon Security Lake endpoints</a> in the Amazon Web Services General Reference.</p>
        pub fn regions(mut self, input: crate::model::Region) -> Self {
            let mut v = self.regions.unwrap_or_default();
                            v.push(input);
                            self.regions = Some(v);
                            self
        }
        /// <p>Enable Security Lake in the specified Regions. To enable Security Lake in specific Amazon Web Services Regions, such as us-east-1 or ap-northeast-3, provide the Region codes. For a list of Region codes, see <a href="https://docs.aws.amazon.com/general/latest/gr/securitylake.html">Amazon Security Lake endpoints</a> in the Amazon Web Services General Reference.</p>
        pub fn set_regions(mut self, input: std::option::Option<std::vec::Vec<crate::model::Region>>) -> Self {
            self.regions = input; self
        }
        /// Adds a key-value pair to `configurations`.
        ///
        /// To override the contents of this collection use [`set_configurations`](Self::set_configurations).
        ///
        /// <p>Specify the Region or Regions that will contribute data to the rollup region.</p>
        pub fn configurations(mut self, k: crate::model::Region, v: crate::model::LakeConfigurationRequest) -> Self {
            let mut hash_map = self.configurations.unwrap_or_default();
                            hash_map.insert(k, v);
                            self.configurations = Some(hash_map);
                            self
        }
        /// <p>Specify the Region or Regions that will contribute data to the rollup region.</p>
        pub fn set_configurations(mut self, input: std::option::Option<std::collections::HashMap<crate::model::Region, crate::model::LakeConfigurationRequest>>) -> Self {
            self.configurations = input; self
        }
        /// <p>Enable Security Lake in all Regions.</p>
        pub fn enable_all(mut self, input: bool) -> Self {
            self.enable_all = Some(input);
            self
        }
        /// <p>Enable Security Lake in all Regions.</p>
        pub fn set_enable_all(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_all = input; self
        }
        /// <p>The Amazon Resource Name (ARN) used to create and update the Glue table. This table contains partitions generated by the ingestion and normalization of Amazon Web Services log sources and custom sources.</p>
        pub fn meta_store_manager_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.meta_store_manager_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) used to create and update the Glue table. This table contains partitions generated by the ingestion and normalization of Amazon Web Services log sources and custom sources.</p>
        pub fn set_meta_store_manager_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.meta_store_manager_role_arn = input; self
        }
        /// Consumes the builder and constructs a [`CreateDatalakeInput`](crate::input::CreateDatalakeInput).
        pub fn build(self) -> Result<crate::input::CreateDatalakeInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateDatalakeInput {
                    regions: self.regions
                    ,
                    configurations: self.configurations
                    ,
                    enable_all: self.enable_all
                    ,
                    meta_store_manager_role_arn: self.meta_store_manager_role_arn
                    ,
                }
            )
        }
    }
    
    
}
impl CreateDatalakeInput {
    /// Consumes the builder and constructs an Operation<[`CreateDatalake`](crate::operation::CreateDatalake)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateDatalake, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateDatalakeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateDatalakeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_datalake(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateDatalake::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateDatalake", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDatalakeInput`](crate::input::CreateDatalakeInput).
    pub fn builder() -> crate::input::create_datalake_input::Builder {
        crate::input::create_datalake_input::Builder::default()
    }
}

/// See [`CreateDatalakeAutoEnableInput`](crate::input::CreateDatalakeAutoEnableInput).
pub mod create_datalake_auto_enable_input {
    
    /// A builder for [`CreateDatalakeAutoEnableInput`](crate::input::CreateDatalakeAutoEnableInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_for_new_accounts: std::option::Option<std::vec::Vec<crate::model::AutoEnableNewRegionConfiguration>>,
    }
    impl Builder {
        /// Appends an item to `configuration_for_new_accounts`.
        ///
        /// To override the contents of this collection use [`set_configuration_for_new_accounts`](Self::set_configuration_for_new_accounts).
        ///
        /// <p>Enable Security Lake with the specified configuration settings to begin collecting security data for new accounts in your organization. </p>
        pub fn configuration_for_new_accounts(mut self, input: crate::model::AutoEnableNewRegionConfiguration) -> Self {
            let mut v = self.configuration_for_new_accounts.unwrap_or_default();
                            v.push(input);
                            self.configuration_for_new_accounts = Some(v);
                            self
        }
        /// <p>Enable Security Lake with the specified configuration settings to begin collecting security data for new accounts in your organization. </p>
        pub fn set_configuration_for_new_accounts(mut self, input: std::option::Option<std::vec::Vec<crate::model::AutoEnableNewRegionConfiguration>>) -> Self {
            self.configuration_for_new_accounts = input; self
        }
        /// Consumes the builder and constructs a [`CreateDatalakeAutoEnableInput`](crate::input::CreateDatalakeAutoEnableInput).
        pub fn build(self) -> Result<crate::input::CreateDatalakeAutoEnableInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateDatalakeAutoEnableInput {
                    configuration_for_new_accounts: self.configuration_for_new_accounts
                    ,
                }
            )
        }
    }
    
    
}
impl CreateDatalakeAutoEnableInput {
    /// Consumes the builder and constructs an Operation<[`CreateDatalakeAutoEnable`](crate::operation::CreateDatalakeAutoEnable)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateDatalakeAutoEnable, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateDatalakeAutoEnableInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/autoenable").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateDatalakeAutoEnableInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_datalake_auto_enable(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateDatalakeAutoEnable::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateDatalakeAutoEnable", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDatalakeAutoEnableInput`](crate::input::CreateDatalakeAutoEnableInput).
    pub fn builder() -> crate::input::create_datalake_auto_enable_input::Builder {
        crate::input::create_datalake_auto_enable_input::Builder::default()
    }
}

/// See [`CreateDatalakeDelegatedAdminInput`](crate::input::CreateDatalakeDelegatedAdminInput).
pub mod create_datalake_delegated_admin_input {
    
    /// A builder for [`CreateDatalakeDelegatedAdminInput`](crate::input::CreateDatalakeDelegatedAdminInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account ID of the Security Lake delegated administrator.</p>
        pub fn account(mut self, input: impl Into<std::string::String>) -> Self {
            self.account = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the Security Lake delegated administrator.</p>
        pub fn set_account(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account = input; self
        }
        /// Consumes the builder and constructs a [`CreateDatalakeDelegatedAdminInput`](crate::input::CreateDatalakeDelegatedAdminInput).
        pub fn build(self) -> Result<crate::input::CreateDatalakeDelegatedAdminInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateDatalakeDelegatedAdminInput {
                    account: self.account
                    ,
                }
            )
        }
    }
    
    
}
impl CreateDatalakeDelegatedAdminInput {
    /// Consumes the builder and constructs an Operation<[`CreateDatalakeDelegatedAdmin`](crate::operation::CreateDatalakeDelegatedAdmin)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateDatalakeDelegatedAdmin, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateDatalakeDelegatedAdminInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/delegate").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateDatalakeDelegatedAdminInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_datalake_delegated_admin(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateDatalakeDelegatedAdmin::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateDatalakeDelegatedAdmin", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDatalakeDelegatedAdminInput`](crate::input::CreateDatalakeDelegatedAdminInput).
    pub fn builder() -> crate::input::create_datalake_delegated_admin_input::Builder {
        crate::input::create_datalake_delegated_admin_input::Builder::default()
    }
}

/// See [`CreateDatalakeExceptionsSubscriptionInput`](crate::input::CreateDatalakeExceptionsSubscriptionInput).
pub mod create_datalake_exceptions_subscription_input {
    
    /// A builder for [`CreateDatalakeExceptionsSubscriptionInput`](crate::input::CreateDatalakeExceptionsSubscriptionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_protocol: std::option::Option<crate::model::SubscriptionProtocolType>,
        pub(crate) notification_endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The subscription protocol to which exception notifications are posted. </p>
        pub fn subscription_protocol(mut self, input: crate::model::SubscriptionProtocolType) -> Self {
            self.subscription_protocol = Some(input);
            self
        }
        /// <p>The subscription protocol to which exception notifications are posted. </p>
        pub fn set_subscription_protocol(mut self, input: std::option::Option<crate::model::SubscriptionProtocolType>) -> Self {
            self.subscription_protocol = input; self
        }
        /// <p>The Amazon Web Services account where you want to receive exception notifications.</p>
        pub fn notification_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_endpoint = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account where you want to receive exception notifications.</p>
        pub fn set_notification_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notification_endpoint = input; self
        }
        /// Consumes the builder and constructs a [`CreateDatalakeExceptionsSubscriptionInput`](crate::input::CreateDatalakeExceptionsSubscriptionInput).
        pub fn build(self) -> Result<crate::input::CreateDatalakeExceptionsSubscriptionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateDatalakeExceptionsSubscriptionInput {
                    subscription_protocol: self.subscription_protocol
                    ,
                    notification_endpoint: self.notification_endpoint
                    ,
                }
            )
        }
    }
    
    
}
impl CreateDatalakeExceptionsSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`CreateDatalakeExceptionsSubscription`](crate::operation::CreateDatalakeExceptionsSubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateDatalakeExceptionsSubscription, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateDatalakeExceptionsSubscriptionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/exceptions/subscription").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateDatalakeExceptionsSubscriptionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_datalake_exceptions_subscription(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateDatalakeExceptionsSubscription::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateDatalakeExceptionsSubscription", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDatalakeExceptionsSubscriptionInput`](crate::input::CreateDatalakeExceptionsSubscriptionInput).
    pub fn builder() -> crate::input::create_datalake_exceptions_subscription_input::Builder {
        crate::input::create_datalake_exceptions_subscription_input::Builder::default()
    }
}

/// See [`CreateSubscriberInput`](crate::input::CreateSubscriberInput).
pub mod create_subscriber_input {
    
    /// A builder for [`CreateSubscriberInput`](crate::input::CreateSubscriberInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_types: std::option::Option<std::vec::Vec<crate::model::SourceType>>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) access_types: std::option::Option<std::vec::Vec<crate::model::AccessType>>,
        pub(crate) subscriber_name: std::option::Option<std::string::String>,
        pub(crate) subscriber_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `source_types`.
        ///
        /// To override the contents of this collection use [`set_source_types`](Self::set_source_types).
        ///
        /// <p>The supported Amazon Web Services from which logs and events are collected. Security Lake supports log and event collection for natively supported Amazon Web Services.</p>
        pub fn source_types(mut self, input: crate::model::SourceType) -> Self {
            let mut v = self.source_types.unwrap_or_default();
                            v.push(input);
                            self.source_types = Some(v);
                            self
        }
        /// <p>The supported Amazon Web Services from which logs and events are collected. Security Lake supports log and event collection for natively supported Amazon Web Services.</p>
        pub fn set_source_types(mut self, input: std::option::Option<std::vec::Vec<crate::model::SourceType>>) -> Self {
            self.source_types = input; self
        }
        /// <p>The Amazon Web Services account ID used to access your data.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID used to access your data.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The external ID of the subscriber. This lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        /// <p>The external ID of the subscriber. This lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input; self
        }
        /// Appends an item to `access_types`.
        ///
        /// To override the contents of this collection use [`set_access_types`](Self::set_access_types).
        ///
        /// <p>The Amazon S3 or Lake Formation access type.</p>
        pub fn access_types(mut self, input: crate::model::AccessType) -> Self {
            let mut v = self.access_types.unwrap_or_default();
                            v.push(input);
                            self.access_types = Some(v);
                            self
        }
        /// <p>The Amazon S3 or Lake Formation access type.</p>
        pub fn set_access_types(mut self, input: std::option::Option<std::vec::Vec<crate::model::AccessType>>) -> Self {
            self.access_types = input; self
        }
        /// <p>The name of your Security Lake subscriber account.</p>
        pub fn subscriber_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscriber_name = Some(input.into());
            self
        }
        /// <p>The name of your Security Lake subscriber account.</p>
        pub fn set_subscriber_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscriber_name = input; self
        }
        /// <p>The description for your subscriber account in Security Lake. </p>
        pub fn subscriber_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscriber_description = Some(input.into());
            self
        }
        /// <p>The description for your subscriber account in Security Lake. </p>
        pub fn set_subscriber_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscriber_description = input; self
        }
        /// Consumes the builder and constructs a [`CreateSubscriberInput`](crate::input::CreateSubscriberInput).
        pub fn build(self) -> Result<crate::input::CreateSubscriberInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateSubscriberInput {
                    source_types: self.source_types
                    ,
                    account_id: self.account_id
                    ,
                    external_id: self.external_id
                    ,
                    access_types: self.access_types
                    ,
                    subscriber_name: self.subscriber_name
                    ,
                    subscriber_description: self.subscriber_description
                    ,
                }
            )
        }
    }
    
    
}
impl CreateSubscriberInput {
    /// Consumes the builder and constructs an Operation<[`CreateSubscriber`](crate::operation::CreateSubscriber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateSubscriber, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateSubscriberInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/subscribers").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateSubscriberInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_subscriber(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateSubscriber::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateSubscriber", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSubscriberInput`](crate::input::CreateSubscriberInput).
    pub fn builder() -> crate::input::create_subscriber_input::Builder {
        crate::input::create_subscriber_input::Builder::default()
    }
}

/// See [`CreateSubscriptionNotificationConfigurationInput`](crate::input::CreateSubscriptionNotificationConfigurationInput).
pub mod create_subscription_notification_configuration_input {
    
    /// A builder for [`CreateSubscriptionNotificationConfigurationInput`](crate::input::CreateSubscriptionNotificationConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_id: std::option::Option<std::string::String>,
        pub(crate) subscription_endpoint: std::option::Option<std::string::String>,
        pub(crate) https_api_key_name: std::option::Option<std::string::String>,
        pub(crate) https_api_key_value: std::option::Option<std::string::String>,
        pub(crate) https_method: std::option::Option<crate::model::HttpsMethod>,
        pub(crate) create_sqs: std::option::Option<bool>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The subscription ID for the notification subscription/</p>
        pub fn subscription_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_id = Some(input.into());
            self
        }
        /// <p>The subscription ID for the notification subscription/</p>
        pub fn set_subscription_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_id = input; self
        }
        /// <p>The subscription endpoint in Security Lake. If you prefer notification with an HTTPs endpoint, populate this field.</p>
        pub fn subscription_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_endpoint = Some(input.into());
            self
        }
        /// <p>The subscription endpoint in Security Lake. If you prefer notification with an HTTPs endpoint, populate this field.</p>
        pub fn set_subscription_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_endpoint = input; self
        }
        /// <p>The key name for the notification subscription.</p>
        pub fn https_api_key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.https_api_key_name = Some(input.into());
            self
        }
        /// <p>The key name for the notification subscription.</p>
        pub fn set_https_api_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.https_api_key_name = input; self
        }
        /// <p>The key value for the notification subscription.</p>
        pub fn https_api_key_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.https_api_key_value = Some(input.into());
            self
        }
        /// <p>The key value for the notification subscription.</p>
        pub fn set_https_api_key_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.https_api_key_value = input; self
        }
        /// <p>The HTTPS method used for the notification subscription. </p>
        pub fn https_method(mut self, input: crate::model::HttpsMethod) -> Self {
            self.https_method = Some(input);
            self
        }
        /// <p>The HTTPS method used for the notification subscription. </p>
        pub fn set_https_method(mut self, input: std::option::Option<crate::model::HttpsMethod>) -> Self {
            self.https_method = input; self
        }
        /// <p>Create an Amazon Simple Queue Service queue.</p>
        pub fn create_sqs(mut self, input: bool) -> Self {
            self.create_sqs = Some(input);
            self
        }
        /// <p>Create an Amazon Simple Queue Service queue.</p>
        pub fn set_create_sqs(mut self, input: std::option::Option<bool>) -> Self {
            self.create_sqs = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the EventBridge API destinations IAM role that you created.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the EventBridge API destinations IAM role that you created.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// Consumes the builder and constructs a [`CreateSubscriptionNotificationConfigurationInput`](crate::input::CreateSubscriptionNotificationConfigurationInput).
        pub fn build(self) -> Result<crate::input::CreateSubscriptionNotificationConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateSubscriptionNotificationConfigurationInput {
                    subscription_id: self.subscription_id
                    ,
                    subscription_endpoint: self.subscription_endpoint
                    ,
                    https_api_key_name: self.https_api_key_name
                    ,
                    https_api_key_value: self.https_api_key_value
                    ,
                    https_method: self.https_method
                    ,
                    create_sqs: self.create_sqs
                    ,
                    role_arn: self.role_arn
                    ,
                }
            )
        }
    }
    
    
}
impl CreateSubscriptionNotificationConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`CreateSubscriptionNotificationConfiguration`](crate::operation::CreateSubscriptionNotificationConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateSubscriptionNotificationConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateSubscriptionNotificationConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.subscription_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_id", "cannot be empty or unset"))?;
                let subscription_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_id", "cannot be empty or unset"))
                            }
                write!(output, "/subscription-notifications/{subscriptionId}", subscriptionId = subscription_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateSubscriptionNotificationConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_subscription_notification_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateSubscriptionNotificationConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateSubscriptionNotificationConfiguration", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSubscriptionNotificationConfigurationInput`](crate::input::CreateSubscriptionNotificationConfigurationInput).
    pub fn builder() -> crate::input::create_subscription_notification_configuration_input::Builder {
        crate::input::create_subscription_notification_configuration_input::Builder::default()
    }
}

/// See [`DeleteAwsLogSourceInput`](crate::input::DeleteAwsLogSourceInput).
pub mod delete_aws_log_source_input {
    
    /// A builder for [`DeleteAwsLogSourceInput`](crate::input::DeleteAwsLogSourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_order: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        pub(crate) disable_all_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>>,
        pub(crate) disable_two_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>,
        pub(crate) disable_single_dimension: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `input_order`.
        ///
        /// To override the contents of this collection use [`set_input_order`](Self::set_input_order).
        ///
        /// <p>This is a mandatory input. Specify the input order to disable dimensions in Security Lake, namely Region (Amazon Web Services Region code, source type, and member (account ID of a specific Amazon Web Services account). </p>
        pub fn input_order(mut self, input: crate::model::Dimension) -> Self {
            let mut v = self.input_order.unwrap_or_default();
                            v.push(input);
                            self.input_order = Some(v);
                            self
        }
        /// <p>This is a mandatory input. Specify the input order to disable dimensions in Security Lake, namely Region (Amazon Web Services Region code, source type, and member (account ID of a specific Amazon Web Services account). </p>
        pub fn set_input_order(mut self, input: std::option::Option<std::vec::Vec<crate::model::Dimension>>) -> Self {
            self.input_order = input; self
        }
        /// Adds a key-value pair to `disable_all_dimensions`.
        ///
        /// To override the contents of this collection use [`set_disable_all_dimensions`](Self::set_disable_all_dimensions).
        ///
        /// <p>Removes the specific Amazon Web Services sources from specific accounts and specific Regions.</p>
        pub fn disable_all_dimensions(mut self, k: impl Into<std::string::String>, v: std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>) -> Self {
            let mut hash_map = self.disable_all_dimensions.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.disable_all_dimensions = Some(hash_map);
                            self
        }
        /// <p>Removes the specific Amazon Web Services sources from specific accounts and specific Regions.</p>
        pub fn set_disable_all_dimensions(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>>) -> Self {
            self.disable_all_dimensions = input; self
        }
        /// Adds a key-value pair to `disable_two_dimensions`.
        ///
        /// To override the contents of this collection use [`set_disable_two_dimensions`](Self::set_disable_two_dimensions).
        ///
        /// <p>Remove a specific Amazon Web Services source from specific accounts or Regions.</p>
        pub fn disable_two_dimensions(mut self, k: impl Into<std::string::String>, v: std::vec::Vec<std::string::String>) -> Self {
            let mut hash_map = self.disable_two_dimensions.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.disable_two_dimensions = Some(hash_map);
                            self
        }
        /// <p>Remove a specific Amazon Web Services source from specific accounts or Regions.</p>
        pub fn set_disable_two_dimensions(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>) -> Self {
            self.disable_two_dimensions = input; self
        }
        /// Appends an item to `disable_single_dimension`.
        ///
        /// To override the contents of this collection use [`set_disable_single_dimension`](Self::set_disable_single_dimension).
        ///
        /// <p>Removes all Amazon Web Services sources from specific accounts or Regions.</p>
        pub fn disable_single_dimension(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.disable_single_dimension.unwrap_or_default();
                            v.push(input.into());
                            self.disable_single_dimension = Some(v);
                            self
        }
        /// <p>Removes all Amazon Web Services sources from specific accounts or Regions.</p>
        pub fn set_disable_single_dimension(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.disable_single_dimension = input; self
        }
        /// Consumes the builder and constructs a [`DeleteAwsLogSourceInput`](crate::input::DeleteAwsLogSourceInput).
        pub fn build(self) -> Result<crate::input::DeleteAwsLogSourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteAwsLogSourceInput {
                    input_order: self.input_order
                    ,
                    disable_all_dimensions: self.disable_all_dimensions
                    ,
                    disable_two_dimensions: self.disable_two_dimensions
                    ,
                    disable_single_dimension: self.disable_single_dimension
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteAwsLogSourceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAwsLogSource`](crate::operation::DeleteAwsLogSource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteAwsLogSource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteAwsLogSourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/logsources/aws/delete").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteAwsLogSourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_aws_log_source(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteAwsLogSource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteAwsLogSource", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAwsLogSourceInput`](crate::input::DeleteAwsLogSourceInput).
    pub fn builder() -> crate::input::delete_aws_log_source_input::Builder {
        crate::input::delete_aws_log_source_input::Builder::default()
    }
}

/// See [`DeleteCustomLogSourceInput`](crate::input::DeleteCustomLogSourceInput).
pub mod delete_custom_log_source_input {
    
    /// A builder for [`DeleteCustomLogSourceInput`](crate::input::DeleteCustomLogSourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_source_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The custom source name for the custom log source.</p>
        pub fn custom_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_source_name = Some(input.into());
            self
        }
        /// <p>The custom source name for the custom log source.</p>
        pub fn set_custom_source_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.custom_source_name = input; self
        }
        /// Consumes the builder and constructs a [`DeleteCustomLogSourceInput`](crate::input::DeleteCustomLogSourceInput).
        pub fn build(self) -> Result<crate::input::DeleteCustomLogSourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteCustomLogSourceInput {
                    custom_source_name: self.custom_source_name
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteCustomLogSourceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCustomLogSource`](crate::operation::DeleteCustomLogSource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteCustomLogSource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteCustomLogSourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/logsources/custom").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteCustomLogSourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_2 = &_input.custom_source_name;
                let inner_2 = inner_2.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("custom_source_name", "cannot be empty or unset"))?;
                if inner_2.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("custom_source_name", "cannot be empty or unset"));
                }
                query.push_kv("customSourceName", &aws_smithy_http::query::fmt_string(&inner_2));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteCustomLogSourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteCustomLogSource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteCustomLogSource", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteCustomLogSourceInput`](crate::input::DeleteCustomLogSourceInput).
    pub fn builder() -> crate::input::delete_custom_log_source_input::Builder {
        crate::input::delete_custom_log_source_input::Builder::default()
    }
}

/// See [`DeleteDatalakeInput`](crate::input::DeleteDatalakeInput).
pub mod delete_datalake_input {
    
    /// A builder for [`DeleteDatalakeInput`](crate::input::DeleteDatalakeInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteDatalakeInput`](crate::input::DeleteDatalakeInput).
        pub fn build(self) -> Result<crate::input::DeleteDatalakeInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteDatalakeInput {
                }
            )
        }
    }
    
    
}
impl DeleteDatalakeInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDatalake`](crate::operation::DeleteDatalake)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteDatalake, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteDatalakeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteDatalakeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteDatalake::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteDatalake", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDatalakeInput`](crate::input::DeleteDatalakeInput).
    pub fn builder() -> crate::input::delete_datalake_input::Builder {
        crate::input::delete_datalake_input::Builder::default()
    }
}

/// See [`DeleteDatalakeAutoEnableInput`](crate::input::DeleteDatalakeAutoEnableInput).
pub mod delete_datalake_auto_enable_input {
    
    /// A builder for [`DeleteDatalakeAutoEnableInput`](crate::input::DeleteDatalakeAutoEnableInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) remove_from_configuration_for_new_accounts: std::option::Option<std::vec::Vec<crate::model::AutoEnableNewRegionConfiguration>>,
    }
    impl Builder {
        /// Appends an item to `remove_from_configuration_for_new_accounts`.
        ///
        /// To override the contents of this collection use [`set_remove_from_configuration_for_new_accounts`](Self::set_remove_from_configuration_for_new_accounts).
        ///
        /// <p>Delete Amazon Security Lake with the specified configuration settings to stop ingesting security data for new accounts in Security Lake. </p>
        pub fn remove_from_configuration_for_new_accounts(mut self, input: crate::model::AutoEnableNewRegionConfiguration) -> Self {
            let mut v = self.remove_from_configuration_for_new_accounts.unwrap_or_default();
                            v.push(input);
                            self.remove_from_configuration_for_new_accounts = Some(v);
                            self
        }
        /// <p>Delete Amazon Security Lake with the specified configuration settings to stop ingesting security data for new accounts in Security Lake. </p>
        pub fn set_remove_from_configuration_for_new_accounts(mut self, input: std::option::Option<std::vec::Vec<crate::model::AutoEnableNewRegionConfiguration>>) -> Self {
            self.remove_from_configuration_for_new_accounts = input; self
        }
        /// Consumes the builder and constructs a [`DeleteDatalakeAutoEnableInput`](crate::input::DeleteDatalakeAutoEnableInput).
        pub fn build(self) -> Result<crate::input::DeleteDatalakeAutoEnableInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteDatalakeAutoEnableInput {
                    remove_from_configuration_for_new_accounts: self.remove_from_configuration_for_new_accounts
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteDatalakeAutoEnableInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDatalakeAutoEnable`](crate::operation::DeleteDatalakeAutoEnable)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteDatalakeAutoEnable, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteDatalakeAutoEnableInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/autoenable/delete").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteDatalakeAutoEnableInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_datalake_auto_enable(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteDatalakeAutoEnable::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteDatalakeAutoEnable", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDatalakeAutoEnableInput`](crate::input::DeleteDatalakeAutoEnableInput).
    pub fn builder() -> crate::input::delete_datalake_auto_enable_input::Builder {
        crate::input::delete_datalake_auto_enable_input::Builder::default()
    }
}

/// See [`DeleteDatalakeDelegatedAdminInput`](crate::input::DeleteDatalakeDelegatedAdminInput).
pub mod delete_datalake_delegated_admin_input {
    
    /// A builder for [`DeleteDatalakeDelegatedAdminInput`](crate::input::DeleteDatalakeDelegatedAdminInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID the Security Lake delegated administrator.</p>
        pub fn account(mut self, input: impl Into<std::string::String>) -> Self {
            self.account = Some(input.into());
            self
        }
        /// <p>The account ID the Security Lake delegated administrator.</p>
        pub fn set_account(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account = input; self
        }
        /// Consumes the builder and constructs a [`DeleteDatalakeDelegatedAdminInput`](crate::input::DeleteDatalakeDelegatedAdminInput).
        pub fn build(self) -> Result<crate::input::DeleteDatalakeDelegatedAdminInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteDatalakeDelegatedAdminInput {
                    account: self.account
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteDatalakeDelegatedAdminInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDatalakeDelegatedAdmin`](crate::operation::DeleteDatalakeDelegatedAdmin)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteDatalakeDelegatedAdmin, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteDatalakeDelegatedAdminInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.account;
                let input_3 = input_3.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("account", "cannot be empty or unset"))?;
                let account = aws_smithy_http::label::fmt_string(input_3, aws_smithy_http::label::EncodingStrategy::Default);
                if account.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("account", "cannot be empty or unset"))
                            }
                write!(output, "/v1/datalake/delegate/{account}", account = account).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteDatalakeDelegatedAdminInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteDatalakeDelegatedAdmin::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteDatalakeDelegatedAdmin", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDatalakeDelegatedAdminInput`](crate::input::DeleteDatalakeDelegatedAdminInput).
    pub fn builder() -> crate::input::delete_datalake_delegated_admin_input::Builder {
        crate::input::delete_datalake_delegated_admin_input::Builder::default()
    }
}

/// See [`DeleteDatalakeExceptionsSubscriptionInput`](crate::input::DeleteDatalakeExceptionsSubscriptionInput).
pub mod delete_datalake_exceptions_subscription_input {
    
    /// A builder for [`DeleteDatalakeExceptionsSubscriptionInput`](crate::input::DeleteDatalakeExceptionsSubscriptionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteDatalakeExceptionsSubscriptionInput`](crate::input::DeleteDatalakeExceptionsSubscriptionInput).
        pub fn build(self) -> Result<crate::input::DeleteDatalakeExceptionsSubscriptionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteDatalakeExceptionsSubscriptionInput {
                }
            )
        }
    }
    
    
}
impl DeleteDatalakeExceptionsSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDatalakeExceptionsSubscription`](crate::operation::DeleteDatalakeExceptionsSubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteDatalakeExceptionsSubscription, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteDatalakeExceptionsSubscriptionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/exceptions/subscription").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteDatalakeExceptionsSubscriptionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteDatalakeExceptionsSubscription::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteDatalakeExceptionsSubscription", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDatalakeExceptionsSubscriptionInput`](crate::input::DeleteDatalakeExceptionsSubscriptionInput).
    pub fn builder() -> crate::input::delete_datalake_exceptions_subscription_input::Builder {
        crate::input::delete_datalake_exceptions_subscription_input::Builder::default()
    }
}

/// See [`DeleteSubscriberInput`](crate::input::DeleteSubscriberInput).
pub mod delete_subscriber_input {
    
    /// A builder for [`DeleteSubscriberInput`](crate::input::DeleteSubscriberInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A value created by Security Lake that uniquely identifies your <code>DeleteSubscriber</code> API request. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A value created by Security Lake that uniquely identifies your <code>DeleteSubscriber</code> API request. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteSubscriberInput`](crate::input::DeleteSubscriberInput).
        pub fn build(self) -> Result<crate::input::DeleteSubscriberInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteSubscriberInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteSubscriberInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSubscriber`](crate::operation::DeleteSubscriber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteSubscriber, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteSubscriberInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/subscribers").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::DeleteSubscriberInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_4 = &_input.id;
                let inner_4 = inner_4.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                if inner_4.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"));
                }
                query.push_kv("id", &aws_smithy_http::query::fmt_string(&inner_4));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteSubscriberInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteSubscriber::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteSubscriber", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteSubscriberInput`](crate::input::DeleteSubscriberInput).
    pub fn builder() -> crate::input::delete_subscriber_input::Builder {
        crate::input::delete_subscriber_input::Builder::default()
    }
}

/// See [`DeleteSubscriptionNotificationConfigurationInput`](crate::input::DeleteSubscriptionNotificationConfigurationInput).
pub mod delete_subscription_notification_configuration_input {
    
    /// A builder for [`DeleteSubscriptionNotificationConfigurationInput`](crate::input::DeleteSubscriptionNotificationConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Security Lake subscriber account.</p>
        pub fn subscription_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_id = Some(input.into());
            self
        }
        /// <p>The ID of the Security Lake subscriber account.</p>
        pub fn set_subscription_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteSubscriptionNotificationConfigurationInput`](crate::input::DeleteSubscriptionNotificationConfigurationInput).
        pub fn build(self) -> Result<crate::input::DeleteSubscriptionNotificationConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteSubscriptionNotificationConfigurationInput {
                    subscription_id: self.subscription_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteSubscriptionNotificationConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSubscriptionNotificationConfiguration`](crate::operation::DeleteSubscriptionNotificationConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteSubscriptionNotificationConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteSubscriptionNotificationConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.subscription_id;
                let input_5 = input_5.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_id", "cannot be empty or unset"))?;
                let subscription_id = aws_smithy_http::label::fmt_string(input_5, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_id", "cannot be empty or unset"))
                            }
                write!(output, "/subscription-notifications/{subscriptionId}", subscriptionId = subscription_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteSubscriptionNotificationConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteSubscriptionNotificationConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteSubscriptionNotificationConfiguration", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteSubscriptionNotificationConfigurationInput`](crate::input::DeleteSubscriptionNotificationConfigurationInput).
    pub fn builder() -> crate::input::delete_subscription_notification_configuration_input::Builder {
        crate::input::delete_subscription_notification_configuration_input::Builder::default()
    }
}

/// See [`GetDatalakeInput`](crate::input::GetDatalakeInput).
pub mod get_datalake_input {
    
    /// A builder for [`GetDatalakeInput`](crate::input::GetDatalakeInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`GetDatalakeInput`](crate::input::GetDatalakeInput).
        pub fn build(self) -> Result<crate::input::GetDatalakeInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDatalakeInput {
                }
            )
        }
    }
    
    
}
impl GetDatalakeInput {
    /// Consumes the builder and constructs an Operation<[`GetDatalake`](crate::operation::GetDatalake)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDatalake, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDatalakeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDatalakeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDatalake::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDatalake", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDatalakeInput`](crate::input::GetDatalakeInput).
    pub fn builder() -> crate::input::get_datalake_input::Builder {
        crate::input::get_datalake_input::Builder::default()
    }
}

/// See [`GetDatalakeAutoEnableInput`](crate::input::GetDatalakeAutoEnableInput).
pub mod get_datalake_auto_enable_input {
    
    /// A builder for [`GetDatalakeAutoEnableInput`](crate::input::GetDatalakeAutoEnableInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`GetDatalakeAutoEnableInput`](crate::input::GetDatalakeAutoEnableInput).
        pub fn build(self) -> Result<crate::input::GetDatalakeAutoEnableInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDatalakeAutoEnableInput {
                }
            )
        }
    }
    
    
}
impl GetDatalakeAutoEnableInput {
    /// Consumes the builder and constructs an Operation<[`GetDatalakeAutoEnable`](crate::operation::GetDatalakeAutoEnable)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDatalakeAutoEnable, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDatalakeAutoEnableInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/autoenable").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDatalakeAutoEnableInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDatalakeAutoEnable::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDatalakeAutoEnable", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDatalakeAutoEnableInput`](crate::input::GetDatalakeAutoEnableInput).
    pub fn builder() -> crate::input::get_datalake_auto_enable_input::Builder {
        crate::input::get_datalake_auto_enable_input::Builder::default()
    }
}

/// See [`GetDatalakeExceptionsExpiryInput`](crate::input::GetDatalakeExceptionsExpiryInput).
pub mod get_datalake_exceptions_expiry_input {
    
    /// A builder for [`GetDatalakeExceptionsExpiryInput`](crate::input::GetDatalakeExceptionsExpiryInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`GetDatalakeExceptionsExpiryInput`](crate::input::GetDatalakeExceptionsExpiryInput).
        pub fn build(self) -> Result<crate::input::GetDatalakeExceptionsExpiryInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDatalakeExceptionsExpiryInput {
                }
            )
        }
    }
    
    
}
impl GetDatalakeExceptionsExpiryInput {
    /// Consumes the builder and constructs an Operation<[`GetDatalakeExceptionsExpiry`](crate::operation::GetDatalakeExceptionsExpiry)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDatalakeExceptionsExpiry, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDatalakeExceptionsExpiryInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/exceptions/expiry").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDatalakeExceptionsExpiryInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDatalakeExceptionsExpiry::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDatalakeExceptionsExpiry", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDatalakeExceptionsExpiryInput`](crate::input::GetDatalakeExceptionsExpiryInput).
    pub fn builder() -> crate::input::get_datalake_exceptions_expiry_input::Builder {
        crate::input::get_datalake_exceptions_expiry_input::Builder::default()
    }
}

/// See [`GetDatalakeExceptionsSubscriptionInput`](crate::input::GetDatalakeExceptionsSubscriptionInput).
pub mod get_datalake_exceptions_subscription_input {
    
    /// A builder for [`GetDatalakeExceptionsSubscriptionInput`](crate::input::GetDatalakeExceptionsSubscriptionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`GetDatalakeExceptionsSubscriptionInput`](crate::input::GetDatalakeExceptionsSubscriptionInput).
        pub fn build(self) -> Result<crate::input::GetDatalakeExceptionsSubscriptionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDatalakeExceptionsSubscriptionInput {
                }
            )
        }
    }
    
    
}
impl GetDatalakeExceptionsSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`GetDatalakeExceptionsSubscription`](crate::operation::GetDatalakeExceptionsSubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDatalakeExceptionsSubscription, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDatalakeExceptionsSubscriptionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/exceptions/subscription").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDatalakeExceptionsSubscriptionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDatalakeExceptionsSubscription::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDatalakeExceptionsSubscription", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDatalakeExceptionsSubscriptionInput`](crate::input::GetDatalakeExceptionsSubscriptionInput).
    pub fn builder() -> crate::input::get_datalake_exceptions_subscription_input::Builder {
        crate::input::get_datalake_exceptions_subscription_input::Builder::default()
    }
}

/// See [`GetDatalakeStatusInput`](crate::input::GetDatalakeStatusInput).
pub mod get_datalake_status_input {
    
    /// A builder for [`GetDatalakeStatusInput`](crate::input::GetDatalakeStatusInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_set: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_account_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `account_set`.
        ///
        /// To override the contents of this collection use [`set_account_set`](Self::set_account_set).
        ///
        /// <p>The Amazon Web Services account ID for which a static snapshot of the current Amazon Web Services Region, including enabled accounts and log sources, is retrieved.</p>
        pub fn account_set(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.account_set.unwrap_or_default();
                            v.push(input.into());
                            self.account_set = Some(v);
                            self
        }
        /// <p>The Amazon Web Services account ID for which a static snapshot of the current Amazon Web Services Region, including enabled accounts and log sources, is retrieved.</p>
        pub fn set_account_set(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.account_set = input; self
        }
        /// <p>The maximum limit of accounts for which the static snapshot of the current Region, including enabled accounts and log sources, is retrieved.</p>
        pub fn max_account_results(mut self, input: i32) -> Self {
            self.max_account_results = Some(input);
            self
        }
        /// <p>The maximum limit of accounts for which the static snapshot of the current Region, including enabled accounts and log sources, is retrieved.</p>
        pub fn set_max_account_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_account_results = input; self
        }
        /// <p>Lists if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. </p> 
        /// <p>Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Lists if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. </p> 
        /// <p>Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`GetDatalakeStatusInput`](crate::input::GetDatalakeStatusInput).
        pub fn build(self) -> Result<crate::input::GetDatalakeStatusInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDatalakeStatusInput {
                    account_set: self.account_set
                    ,
                    max_account_results: self.max_account_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl GetDatalakeStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetDatalakeStatus`](crate::operation::GetDatalakeStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDatalakeStatus, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDatalakeStatusInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/status").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDatalakeStatusInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_get_datalake_status(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDatalakeStatus::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDatalakeStatus", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDatalakeStatusInput`](crate::input::GetDatalakeStatusInput).
    pub fn builder() -> crate::input::get_datalake_status_input::Builder {
        crate::input::get_datalake_status_input::Builder::default()
    }
}

/// See [`GetSubscriberInput`](crate::input::GetSubscriberInput).
pub mod get_subscriber_input {
    
    /// A builder for [`GetSubscriberInput`](crate::input::GetSubscriberInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A value created by Amazon Security Lake that uniquely identifies your <code>GetSubscriber</code> API request.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A value created by Amazon Security Lake that uniquely identifies your <code>GetSubscriber</code> API request.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`GetSubscriberInput`](crate::input::GetSubscriberInput).
        pub fn build(self) -> Result<crate::input::GetSubscriberInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetSubscriberInput {
                    id: self.id
                    ,
                }
            )
        }
    }
    
    
}
impl GetSubscriberInput {
    /// Consumes the builder and constructs an Operation<[`GetSubscriber`](crate::operation::GetSubscriber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetSubscriber, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetSubscriberInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.id;
                let input_6 = input_6.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_6, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/v1/subscribers/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetSubscriberInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetSubscriber::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetSubscriber", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSubscriberInput`](crate::input::GetSubscriberInput).
    pub fn builder() -> crate::input::get_subscriber_input::Builder {
        crate::input::get_subscriber_input::Builder::default()
    }
}

/// See [`ListDatalakeExceptionsInput`](crate::input::ListDatalakeExceptionsInput).
pub mod list_datalake_exceptions_input {
    
    /// A builder for [`ListDatalakeExceptionsInput`](crate::input::ListDatalakeExceptionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_set: std::option::Option<std::vec::Vec<crate::model::Region>>,
        pub(crate) max_failures: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `region_set`.
        ///
        /// To override the contents of this collection use [`set_region_set`](Self::set_region_set).
        ///
        /// <p>List the Amazon Web Services Regions from which exceptions are retrieved.</p>
        pub fn region_set(mut self, input: crate::model::Region) -> Self {
            let mut v = self.region_set.unwrap_or_default();
                            v.push(input);
                            self.region_set = Some(v);
                            self
        }
        /// <p>List the Amazon Web Services Regions from which exceptions are retrieved.</p>
        pub fn set_region_set(mut self, input: std::option::Option<std::vec::Vec<crate::model::Region>>) -> Self {
            self.region_set = input; self
        }
        /// <p>List the maximum number of failures in Security Lake.</p>
        pub fn max_failures(mut self, input: i32) -> Self {
            self.max_failures = Some(input);
            self
        }
        /// <p>List the maximum number of failures in Security Lake.</p>
        pub fn set_max_failures(mut self, input: std::option::Option<i32>) -> Self {
            self.max_failures = input; self
        }
        /// <p>List if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. </p> 
        /// <p>Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>List if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. </p> 
        /// <p>Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListDatalakeExceptionsInput`](crate::input::ListDatalakeExceptionsInput).
        pub fn build(self) -> Result<crate::input::ListDatalakeExceptionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListDatalakeExceptionsInput {
                    region_set: self.region_set
                    ,
                    max_failures: self.max_failures
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListDatalakeExceptionsInput {
    /// Consumes the builder and constructs an Operation<[`ListDatalakeExceptions`](crate::operation::ListDatalakeExceptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListDatalakeExceptions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListDatalakeExceptionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/exceptions").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListDatalakeExceptionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_datalake_exceptions(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListDatalakeExceptions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListDatalakeExceptions", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDatalakeExceptionsInput`](crate::input::ListDatalakeExceptionsInput).
    pub fn builder() -> crate::input::list_datalake_exceptions_input::Builder {
        crate::input::list_datalake_exceptions_input::Builder::default()
    }
}

/// See [`ListLogSourcesInput`](crate::input::ListLogSourcesInput).
pub mod list_log_sources_input {
    
    /// A builder for [`ListLogSourcesInput`](crate::input::ListLogSourcesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) input_order: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        pub(crate) list_all_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>>,
        pub(crate) list_two_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>,
        pub(crate) list_single_dimension: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `input_order`.
        ///
        /// To override the contents of this collection use [`set_input_order`](Self::set_input_order).
        ///
        /// <p>Lists the log sources in input order, namely Region, source type, and member account.</p>
        pub fn input_order(mut self, input: crate::model::Dimension) -> Self {
            let mut v = self.input_order.unwrap_or_default();
                            v.push(input);
                            self.input_order = Some(v);
                            self
        }
        /// <p>Lists the log sources in input order, namely Region, source type, and member account.</p>
        pub fn set_input_order(mut self, input: std::option::Option<std::vec::Vec<crate::model::Dimension>>) -> Self {
            self.input_order = input; self
        }
        /// Adds a key-value pair to `list_all_dimensions`.
        ///
        /// To override the contents of this collection use [`set_list_all_dimensions`](Self::set_list_all_dimensions).
        ///
        /// <p>List the view of log sources for enabled Amazon Security Lake accounts for specific Amazon Web Services sources from specific accounts and specific Regions.</p>
        pub fn list_all_dimensions(mut self, k: impl Into<std::string::String>, v: std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>) -> Self {
            let mut hash_map = self.list_all_dimensions.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.list_all_dimensions = Some(hash_map);
                            self
        }
        /// <p>List the view of log sources for enabled Amazon Security Lake accounts for specific Amazon Web Services sources from specific accounts and specific Regions.</p>
        pub fn set_list_all_dimensions(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>>) -> Self {
            self.list_all_dimensions = input; self
        }
        /// Adds a key-value pair to `list_two_dimensions`.
        ///
        /// To override the contents of this collection use [`set_list_two_dimensions`](Self::set_list_two_dimensions).
        ///
        /// <p>Lists the view of log sources for enabled Security Lake accounts for specific Amazon Web Services sources from specific accounts or specific Regions.</p>
        pub fn list_two_dimensions(mut self, k: impl Into<std::string::String>, v: std::vec::Vec<std::string::String>) -> Self {
            let mut hash_map = self.list_two_dimensions.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.list_two_dimensions = Some(hash_map);
                            self
        }
        /// <p>Lists the view of log sources for enabled Security Lake accounts for specific Amazon Web Services sources from specific accounts or specific Regions.</p>
        pub fn set_list_two_dimensions(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>) -> Self {
            self.list_two_dimensions = input; self
        }
        /// Appends an item to `list_single_dimension`.
        ///
        /// To override the contents of this collection use [`set_list_single_dimension`](Self::set_list_single_dimension).
        ///
        /// <p>List the view of log sources for enabled Security Lake accounts for all Amazon Web Services sources from specific accounts or specific Regions.</p>
        pub fn list_single_dimension(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.list_single_dimension.unwrap_or_default();
                            v.push(input.into());
                            self.list_single_dimension = Some(v);
                            self
        }
        /// <p>List the view of log sources for enabled Security Lake accounts for all Amazon Web Services sources from specific accounts or specific Regions.</p>
        pub fn set_list_single_dimension(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.list_single_dimension = input; self
        }
        /// <p>The maximum number of accounts for which the log sources are displayed.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of accounts for which the log sources are displayed.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListLogSourcesInput`](crate::input::ListLogSourcesInput).
        pub fn build(self) -> Result<crate::input::ListLogSourcesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListLogSourcesInput {
                    input_order: self.input_order
                    ,
                    list_all_dimensions: self.list_all_dimensions
                    ,
                    list_two_dimensions: self.list_two_dimensions
                    ,
                    list_single_dimension: self.list_single_dimension
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListLogSourcesInput {
    /// Consumes the builder and constructs an Operation<[`ListLogSources`](crate::operation::ListLogSources)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListLogSources, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListLogSourcesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/logsources/list").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListLogSourcesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_log_sources(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListLogSources::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListLogSources", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListLogSourcesInput`](crate::input::ListLogSourcesInput).
    pub fn builder() -> crate::input::list_log_sources_input::Builder {
        crate::input::list_log_sources_input::Builder::default()
    }
}

/// See [`ListSubscribersInput`](crate::input::ListSubscribersInput).
pub mod list_subscribers_input {
    
    /// A builder for [`ListSubscribersInput`](crate::input::ListSubscribersInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The maximum number of accounts for which the configuration is displayed.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of accounts for which the configuration is displayed.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Consumes the builder and constructs a [`ListSubscribersInput`](crate::input::ListSubscribersInput).
        pub fn build(self) -> Result<crate::input::ListSubscribersInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListSubscribersInput {
                    next_token: self.next_token
                    ,
                    max_results: self.max_results
                    ,
                }
            )
        }
    }
    
    
}
impl ListSubscribersInput {
    /// Consumes the builder and constructs an Operation<[`ListSubscribers`](crate::operation::ListSubscribers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListSubscribers, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListSubscribersInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/subscribers").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListSubscribersInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_7) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_7));
                    }
                }
                if let Some(inner_8) = &_input.max_results {
                    if *inner_8 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_8).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListSubscribersInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListSubscribers::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListSubscribers", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSubscribersInput`](crate::input::ListSubscribersInput).
    pub fn builder() -> crate::input::list_subscribers_input::Builder {
        crate::input::list_subscribers_input::Builder::default()
    }
}

/// See [`UpdateDatalakeInput`](crate::input::UpdateDatalakeInput).
pub mod update_datalake_input {
    
    /// A builder for [`UpdateDatalakeInput`](crate::input::UpdateDatalakeInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configurations: std::option::Option<std::collections::HashMap<crate::model::Region, crate::model::LakeConfigurationRequest>>,
    }
    impl Builder {
        /// Adds a key-value pair to `configurations`.
        ///
        /// To override the contents of this collection use [`set_configurations`](Self::set_configurations).
        ///
        /// <p>Specify the Region or Regions that will contribute data to the rollup region.</p>
        pub fn configurations(mut self, k: crate::model::Region, v: crate::model::LakeConfigurationRequest) -> Self {
            let mut hash_map = self.configurations.unwrap_or_default();
                            hash_map.insert(k, v);
                            self.configurations = Some(hash_map);
                            self
        }
        /// <p>Specify the Region or Regions that will contribute data to the rollup region.</p>
        pub fn set_configurations(mut self, input: std::option::Option<std::collections::HashMap<crate::model::Region, crate::model::LakeConfigurationRequest>>) -> Self {
            self.configurations = input; self
        }
        /// Consumes the builder and constructs a [`UpdateDatalakeInput`](crate::input::UpdateDatalakeInput).
        pub fn build(self) -> Result<crate::input::UpdateDatalakeInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateDatalakeInput {
                    configurations: self.configurations
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateDatalakeInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDatalake`](crate::operation::UpdateDatalake)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateDatalake, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateDatalakeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateDatalakeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_datalake(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateDatalake::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateDatalake", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateDatalakeInput`](crate::input::UpdateDatalakeInput).
    pub fn builder() -> crate::input::update_datalake_input::Builder {
        crate::input::update_datalake_input::Builder::default()
    }
}

/// See [`UpdateDatalakeExceptionsExpiryInput`](crate::input::UpdateDatalakeExceptionsExpiryInput).
pub mod update_datalake_exceptions_expiry_input {
    
    /// A builder for [`UpdateDatalakeExceptionsExpiryInput`](crate::input::UpdateDatalakeExceptionsExpiryInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) exception_message_expiry: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The time-to-live (TTL) for the exception message to remain.</p>
        pub fn exception_message_expiry(mut self, input: i64) -> Self {
            self.exception_message_expiry = Some(input);
            self
        }
        /// <p>The time-to-live (TTL) for the exception message to remain.</p>
        pub fn set_exception_message_expiry(mut self, input: std::option::Option<i64>) -> Self {
            self.exception_message_expiry = input; self
        }
        /// Consumes the builder and constructs a [`UpdateDatalakeExceptionsExpiryInput`](crate::input::UpdateDatalakeExceptionsExpiryInput).
        pub fn build(self) -> Result<crate::input::UpdateDatalakeExceptionsExpiryInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateDatalakeExceptionsExpiryInput {
                    exception_message_expiry: self.exception_message_expiry
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateDatalakeExceptionsExpiryInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDatalakeExceptionsExpiry`](crate::operation::UpdateDatalakeExceptionsExpiry)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateDatalakeExceptionsExpiry, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateDatalakeExceptionsExpiryInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/exceptions/expiry").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateDatalakeExceptionsExpiryInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_datalake_exceptions_expiry(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateDatalakeExceptionsExpiry::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateDatalakeExceptionsExpiry", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateDatalakeExceptionsExpiryInput`](crate::input::UpdateDatalakeExceptionsExpiryInput).
    pub fn builder() -> crate::input::update_datalake_exceptions_expiry_input::Builder {
        crate::input::update_datalake_exceptions_expiry_input::Builder::default()
    }
}

/// See [`UpdateDatalakeExceptionsSubscriptionInput`](crate::input::UpdateDatalakeExceptionsSubscriptionInput).
pub mod update_datalake_exceptions_subscription_input {
    
    /// A builder for [`UpdateDatalakeExceptionsSubscriptionInput`](crate::input::UpdateDatalakeExceptionsSubscriptionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_protocol: std::option::Option<crate::model::SubscriptionProtocolType>,
        pub(crate) notification_endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The subscription protocol to which exception messages are posted. </p>
        pub fn subscription_protocol(mut self, input: crate::model::SubscriptionProtocolType) -> Self {
            self.subscription_protocol = Some(input);
            self
        }
        /// <p>The subscription protocol to which exception messages are posted. </p>
        pub fn set_subscription_protocol(mut self, input: std::option::Option<crate::model::SubscriptionProtocolType>) -> Self {
            self.subscription_protocol = input; self
        }
        /// <p>The account that is subscribed to receive exception notifications.</p>
        pub fn notification_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_endpoint = Some(input.into());
            self
        }
        /// <p>The account that is subscribed to receive exception notifications.</p>
        pub fn set_notification_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.notification_endpoint = input; self
        }
        /// Consumes the builder and constructs a [`UpdateDatalakeExceptionsSubscriptionInput`](crate::input::UpdateDatalakeExceptionsSubscriptionInput).
        pub fn build(self) -> Result<crate::input::UpdateDatalakeExceptionsSubscriptionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateDatalakeExceptionsSubscriptionInput {
                    subscription_protocol: self.subscription_protocol
                    ,
                    notification_endpoint: self.notification_endpoint
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateDatalakeExceptionsSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDatalakeExceptionsSubscription`](crate::operation::UpdateDatalakeExceptionsSubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateDatalakeExceptionsSubscription, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateDatalakeExceptionsSubscriptionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/datalake/exceptions/subscription").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateDatalakeExceptionsSubscriptionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_datalake_exceptions_subscription(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateDatalakeExceptionsSubscription::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateDatalakeExceptionsSubscription", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateDatalakeExceptionsSubscriptionInput`](crate::input::UpdateDatalakeExceptionsSubscriptionInput).
    pub fn builder() -> crate::input::update_datalake_exceptions_subscription_input::Builder {
        crate::input::update_datalake_exceptions_subscription_input::Builder::default()
    }
}

/// See [`UpdateSubscriberInput`](crate::input::UpdateSubscriberInput).
pub mod update_subscriber_input {
    
    /// A builder for [`UpdateSubscriberInput`](crate::input::UpdateSubscriberInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) source_types: std::option::Option<std::vec::Vec<crate::model::SourceType>>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) subscriber_name: std::option::Option<std::string::String>,
        pub(crate) subscriber_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A value created by Security Lake that uniquely identifies your subscription. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A value created by Security Lake that uniquely identifies your subscription. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Appends an item to `source_types`.
        ///
        /// To override the contents of this collection use [`set_source_types`](Self::set_source_types).
        ///
        /// <p>The supported Amazon Web Services from which logs and events are collected. For the list of supported Amazon Web Services, see the <a href="https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html">Amazon Security Lake User Guide</a>.</p>
        pub fn source_types(mut self, input: crate::model::SourceType) -> Self {
            let mut v = self.source_types.unwrap_or_default();
                            v.push(input);
                            self.source_types = Some(v);
                            self
        }
        /// <p>The supported Amazon Web Services from which logs and events are collected. For the list of supported Amazon Web Services, see the <a href="https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html">Amazon Security Lake User Guide</a>.</p>
        pub fn set_source_types(mut self, input: std::option::Option<std::vec::Vec<crate::model::SourceType>>) -> Self {
            self.source_types = input; self
        }
        /// <p>The external ID of the Security Lake account.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        /// <p>The external ID of the Security Lake account.</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input; self
        }
        /// <p>The name of the Security Lake account subscriber. </p>
        pub fn subscriber_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscriber_name = Some(input.into());
            self
        }
        /// <p>The name of the Security Lake account subscriber. </p>
        pub fn set_subscriber_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscriber_name = input; self
        }
        /// <p>The description of the Security Lake account subscriber.</p>
        pub fn subscriber_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscriber_description = Some(input.into());
            self
        }
        /// <p>The description of the Security Lake account subscriber.</p>
        pub fn set_subscriber_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscriber_description = input; self
        }
        /// Consumes the builder and constructs a [`UpdateSubscriberInput`](crate::input::UpdateSubscriberInput).
        pub fn build(self) -> Result<crate::input::UpdateSubscriberInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateSubscriberInput {
                    id: self.id
                    ,
                    source_types: self.source_types
                    ,
                    external_id: self.external_id
                    ,
                    subscriber_name: self.subscriber_name
                    ,
                    subscriber_description: self.subscriber_description
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateSubscriberInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSubscriber`](crate::operation::UpdateSubscriber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateSubscriber, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateSubscriberInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.id;
                let input_9 = input_9.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))?;
                let id = aws_smithy_http::label::fmt_string(input_9, aws_smithy_http::label::EncodingStrategy::Default);
                if id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("id", "cannot be empty or unset"))
                            }
                write!(output, "/v1/subscribers/{id}", id = id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateSubscriberInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_subscriber(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateSubscriber::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateSubscriber", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateSubscriberInput`](crate::input::UpdateSubscriberInput).
    pub fn builder() -> crate::input::update_subscriber_input::Builder {
        crate::input::update_subscriber_input::Builder::default()
    }
}

/// See [`UpdateSubscriptionNotificationConfigurationInput`](crate::input::UpdateSubscriptionNotificationConfigurationInput).
pub mod update_subscription_notification_configuration_input {
    
    /// A builder for [`UpdateSubscriptionNotificationConfigurationInput`](crate::input::UpdateSubscriptionNotificationConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_id: std::option::Option<std::string::String>,
        pub(crate) subscription_endpoint: std::option::Option<std::string::String>,
        pub(crate) https_api_key_name: std::option::Option<std::string::String>,
        pub(crate) https_api_key_value: std::option::Option<std::string::String>,
        pub(crate) https_method: std::option::Option<crate::model::HttpsMethod>,
        pub(crate) create_sqs: std::option::Option<bool>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The subscription ID for which the subscription notification is specified. </p>
        pub fn subscription_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_id = Some(input.into());
            self
        }
        /// <p>The subscription ID for which the subscription notification is specified. </p>
        pub fn set_subscription_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_id = input; self
        }
        /// <p>The subscription endpoint in Security Lake.</p>
        pub fn subscription_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_endpoint = Some(input.into());
            self
        }
        /// <p>The subscription endpoint in Security Lake.</p>
        pub fn set_subscription_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subscription_endpoint = input; self
        }
        /// <p>The key name for the subscription notification.</p>
        pub fn https_api_key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.https_api_key_name = Some(input.into());
            self
        }
        /// <p>The key name for the subscription notification.</p>
        pub fn set_https_api_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.https_api_key_name = input; self
        }
        /// <p>The key value for the subscription notification.</p>
        pub fn https_api_key_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.https_api_key_value = Some(input.into());
            self
        }
        /// <p>The key value for the subscription notification.</p>
        pub fn set_https_api_key_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.https_api_key_value = input; self
        }
        /// <p>The HTTPS method used for the subscription notification. </p>
        pub fn https_method(mut self, input: crate::model::HttpsMethod) -> Self {
            self.https_method = Some(input);
            self
        }
        /// <p>The HTTPS method used for the subscription notification. </p>
        pub fn set_https_method(mut self, input: std::option::Option<crate::model::HttpsMethod>) -> Self {
            self.https_method = input; self
        }
        /// <p>Create a new subscription notification for the specified subscription ID in Amazon Security Lake.</p>
        pub fn create_sqs(mut self, input: bool) -> Self {
            self.create_sqs = Some(input);
            self
        }
        /// <p>Create a new subscription notification for the specified subscription ID in Amazon Security Lake.</p>
        pub fn set_create_sqs(mut self, input: std::option::Option<bool>) -> Self {
            self.create_sqs = input; self
        }
        /// <p>The Amazon Resource Name (ARN) specifying the role of the subscriber. </p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) specifying the role of the subscriber. </p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input; self
        }
        /// Consumes the builder and constructs a [`UpdateSubscriptionNotificationConfigurationInput`](crate::input::UpdateSubscriptionNotificationConfigurationInput).
        pub fn build(self) -> Result<crate::input::UpdateSubscriptionNotificationConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateSubscriptionNotificationConfigurationInput {
                    subscription_id: self.subscription_id
                    ,
                    subscription_endpoint: self.subscription_endpoint
                    ,
                    https_api_key_name: self.https_api_key_name
                    ,
                    https_api_key_value: self.https_api_key_value
                    ,
                    https_method: self.https_method
                    ,
                    create_sqs: self.create_sqs
                    ,
                    role_arn: self.role_arn
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateSubscriptionNotificationConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSubscriptionNotificationConfiguration`](crate::operation::UpdateSubscriptionNotificationConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateSubscriptionNotificationConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateSubscriptionNotificationConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.subscription_id;
                let input_10 = input_10.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subscription_id", "cannot be empty or unset"))?;
                let subscription_id = aws_smithy_http::label::fmt_string(input_10, aws_smithy_http::label::EncodingStrategy::Default);
                if subscription_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subscription_id", "cannot be empty or unset"))
                            }
                write!(output, "/subscription-notifications/{subscriptionId}", subscriptionId = subscription_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateSubscriptionNotificationConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_subscription_notification_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateSubscriptionNotificationConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateSubscriptionNotificationConfiguration", "securitylake"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateSubscriptionNotificationConfigurationInput`](crate::input::UpdateSubscriptionNotificationConfigurationInput).
    pub fn builder() -> crate::input::update_subscription_notification_configuration_input::Builder {
        crate::input::update_subscription_notification_configuration_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateSubscriptionNotificationConfigurationInput  {
    /// <p>The subscription ID for which the subscription notification is specified. </p>
    #[doc(hidden)]
    pub subscription_id: std::option::Option<std::string::String>,
    /// <p>The subscription endpoint in Security Lake.</p>
    #[doc(hidden)]
    pub subscription_endpoint: std::option::Option<std::string::String>,
    /// <p>The key name for the subscription notification.</p>
    #[doc(hidden)]
    pub https_api_key_name: std::option::Option<std::string::String>,
    /// <p>The key value for the subscription notification.</p>
    #[doc(hidden)]
    pub https_api_key_value: std::option::Option<std::string::String>,
    /// <p>The HTTPS method used for the subscription notification. </p>
    #[doc(hidden)]
    pub https_method: std::option::Option<crate::model::HttpsMethod>,
    /// <p>Create a new subscription notification for the specified subscription ID in Amazon Security Lake.</p>
    #[doc(hidden)]
    pub create_sqs: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) specifying the role of the subscriber. </p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl UpdateSubscriptionNotificationConfigurationInput {
    /// <p>The subscription ID for which the subscription notification is specified. </p>
    pub fn subscription_id(&self) -> std::option::Option<& str> {
        self.subscription_id.as_deref()
    }
    /// <p>The subscription endpoint in Security Lake.</p>
    pub fn subscription_endpoint(&self) -> std::option::Option<& str> {
        self.subscription_endpoint.as_deref()
    }
    /// <p>The key name for the subscription notification.</p>
    pub fn https_api_key_name(&self) -> std::option::Option<& str> {
        self.https_api_key_name.as_deref()
    }
    /// <p>The key value for the subscription notification.</p>
    pub fn https_api_key_value(&self) -> std::option::Option<& str> {
        self.https_api_key_value.as_deref()
    }
    /// <p>The HTTPS method used for the subscription notification. </p>
    pub fn https_method(&self) -> std::option::Option<& crate::model::HttpsMethod> {
        self.https_method.as_ref()
    }
    /// <p>Create a new subscription notification for the specified subscription ID in Amazon Security Lake.</p>
    pub fn create_sqs(&self) -> std::option::Option<bool> {
        self.create_sqs
    }
    /// <p>The Amazon Resource Name (ARN) specifying the role of the subscriber. </p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateSubscriberInput  {
    /// <p>A value created by Security Lake that uniquely identifies your subscription. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The supported Amazon Web Services from which logs and events are collected. For the list of supported Amazon Web Services, see the <a href="https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html">Amazon Security Lake User Guide</a>.</p>
    #[doc(hidden)]
    pub source_types: std::option::Option<std::vec::Vec<crate::model::SourceType>>,
    /// <p>The external ID of the Security Lake account.</p>
    #[doc(hidden)]
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The name of the Security Lake account subscriber. </p>
    #[doc(hidden)]
    pub subscriber_name: std::option::Option<std::string::String>,
    /// <p>The description of the Security Lake account subscriber.</p>
    #[doc(hidden)]
    pub subscriber_description: std::option::Option<std::string::String>,
}
impl UpdateSubscriberInput {
    /// <p>A value created by Security Lake that uniquely identifies your subscription. </p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The supported Amazon Web Services from which logs and events are collected. For the list of supported Amazon Web Services, see the <a href="https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html">Amazon Security Lake User Guide</a>.</p>
    pub fn source_types(&self) -> std::option::Option<& [crate::model::SourceType]> {
        self.source_types.as_deref()
    }
    /// <p>The external ID of the Security Lake account.</p>
    pub fn external_id(&self) -> std::option::Option<& str> {
        self.external_id.as_deref()
    }
    /// <p>The name of the Security Lake account subscriber. </p>
    pub fn subscriber_name(&self) -> std::option::Option<& str> {
        self.subscriber_name.as_deref()
    }
    /// <p>The description of the Security Lake account subscriber.</p>
    pub fn subscriber_description(&self) -> std::option::Option<& str> {
        self.subscriber_description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateDatalakeExceptionsSubscriptionInput  {
    /// <p>The subscription protocol to which exception messages are posted. </p>
    #[doc(hidden)]
    pub subscription_protocol: std::option::Option<crate::model::SubscriptionProtocolType>,
    /// <p>The account that is subscribed to receive exception notifications.</p>
    #[doc(hidden)]
    pub notification_endpoint: std::option::Option<std::string::String>,
}
impl UpdateDatalakeExceptionsSubscriptionInput {
    /// <p>The subscription protocol to which exception messages are posted. </p>
    pub fn subscription_protocol(&self) -> std::option::Option<& crate::model::SubscriptionProtocolType> {
        self.subscription_protocol.as_ref()
    }
    /// <p>The account that is subscribed to receive exception notifications.</p>
    pub fn notification_endpoint(&self) -> std::option::Option<& str> {
        self.notification_endpoint.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateDatalakeExceptionsExpiryInput  {
    /// <p>The time-to-live (TTL) for the exception message to remain.</p>
    #[doc(hidden)]
    pub exception_message_expiry: std::option::Option<i64>,
}
impl UpdateDatalakeExceptionsExpiryInput {
    /// <p>The time-to-live (TTL) for the exception message to remain.</p>
    pub fn exception_message_expiry(&self) -> std::option::Option<i64> {
        self.exception_message_expiry
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateDatalakeInput  {
    /// <p>Specify the Region or Regions that will contribute data to the rollup region.</p>
    #[doc(hidden)]
    pub configurations: std::option::Option<std::collections::HashMap<crate::model::Region, crate::model::LakeConfigurationRequest>>,
}
impl UpdateDatalakeInput {
    /// <p>Specify the Region or Regions that will contribute data to the rollup region.</p>
    pub fn configurations(&self) -> std::option::Option<& std::collections::HashMap<crate::model::Region, crate::model::LakeConfigurationRequest>> {
        self.configurations.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSubscribersInput  {
    /// <p>If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of accounts for which the configuration is displayed.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListSubscribersInput {
    /// <p>If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of accounts for which the configuration is displayed.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListLogSourcesInput  {
    /// <p>Lists the log sources in input order, namely Region, source type, and member account.</p>
    #[doc(hidden)]
    pub input_order: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
    /// <p>List the view of log sources for enabled Amazon Security Lake accounts for specific Amazon Web Services sources from specific accounts and specific Regions.</p>
    #[doc(hidden)]
    pub list_all_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>>,
    /// <p>Lists the view of log sources for enabled Security Lake accounts for specific Amazon Web Services sources from specific accounts or specific Regions.</p>
    #[doc(hidden)]
    pub list_two_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>,
    /// <p>List the view of log sources for enabled Security Lake accounts for all Amazon Web Services sources from specific accounts or specific Regions.</p>
    #[doc(hidden)]
    pub list_single_dimension: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of accounts for which the log sources are displayed.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListLogSourcesInput {
    /// <p>Lists the log sources in input order, namely Region, source type, and member account.</p>
    pub fn input_order(&self) -> std::option::Option<& [crate::model::Dimension]> {
        self.input_order.as_deref()
    }
    /// <p>List the view of log sources for enabled Amazon Security Lake accounts for specific Amazon Web Services sources from specific accounts and specific Regions.</p>
    pub fn list_all_dimensions(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>> {
        self.list_all_dimensions.as_ref()
    }
    /// <p>Lists the view of log sources for enabled Security Lake accounts for specific Amazon Web Services sources from specific accounts or specific Regions.</p>
    pub fn list_two_dimensions(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>> {
        self.list_two_dimensions.as_ref()
    }
    /// <p>List the view of log sources for enabled Security Lake accounts for all Amazon Web Services sources from specific accounts or specific Regions.</p>
    pub fn list_single_dimension(&self) -> std::option::Option<& [std::string::String]> {
        self.list_single_dimension.as_deref()
    }
    /// <p>The maximum number of accounts for which the log sources are displayed.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDatalakeExceptionsInput  {
    /// <p>List the Amazon Web Services Regions from which exceptions are retrieved.</p>
    #[doc(hidden)]
    pub region_set: std::option::Option<std::vec::Vec<crate::model::Region>>,
    /// <p>List the maximum number of failures in Security Lake.</p>
    #[doc(hidden)]
    pub max_failures: std::option::Option<i32>,
    /// <p>List if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. </p> 
    /// <p>Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDatalakeExceptionsInput {
    /// <p>List the Amazon Web Services Regions from which exceptions are retrieved.</p>
    pub fn region_set(&self) -> std::option::Option<& [crate::model::Region]> {
        self.region_set.as_deref()
    }
    /// <p>List the maximum number of failures in Security Lake.</p>
    pub fn max_failures(&self) -> std::option::Option<i32> {
        self.max_failures
    }
    /// <p>List if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. </p> 
    /// <p>Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSubscriberInput  {
    /// <p>A value created by Amazon Security Lake that uniquely identifies your <code>GetSubscriber</code> API request.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetSubscriberInput {
    /// <p>A value created by Amazon Security Lake that uniquely identifies your <code>GetSubscriber</code> API request.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDatalakeStatusInput  {
    /// <p>The Amazon Web Services account ID for which a static snapshot of the current Amazon Web Services Region, including enabled accounts and log sources, is retrieved.</p>
    #[doc(hidden)]
    pub account_set: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum limit of accounts for which the static snapshot of the current Region, including enabled accounts and log sources, is retrieved.</p>
    #[doc(hidden)]
    pub max_account_results: std::option::Option<i32>,
    /// <p>Lists if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. </p> 
    /// <p>Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetDatalakeStatusInput {
    /// <p>The Amazon Web Services account ID for which a static snapshot of the current Amazon Web Services Region, including enabled accounts and log sources, is retrieved.</p>
    pub fn account_set(&self) -> std::option::Option<& [std::string::String]> {
        self.account_set.as_deref()
    }
    /// <p>The maximum limit of accounts for which the static snapshot of the current Region, including enabled accounts and log sources, is retrieved.</p>
    pub fn max_account_results(&self) -> std::option::Option<i32> {
        self.max_account_results
    }
    /// <p>Lists if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. </p> 
    /// <p>Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDatalakeExceptionsSubscriptionInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDatalakeExceptionsExpiryInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDatalakeAutoEnableInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDatalakeInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteSubscriptionNotificationConfigurationInput  {
    /// <p>The ID of the Security Lake subscriber account.</p>
    #[doc(hidden)]
    pub subscription_id: std::option::Option<std::string::String>,
}
impl DeleteSubscriptionNotificationConfigurationInput {
    /// <p>The ID of the Security Lake subscriber account.</p>
    pub fn subscription_id(&self) -> std::option::Option<& str> {
        self.subscription_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteSubscriberInput  {
    /// <p>A value created by Security Lake that uniquely identifies your <code>DeleteSubscriber</code> API request. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteSubscriberInput {
    /// <p>A value created by Security Lake that uniquely identifies your <code>DeleteSubscriber</code> API request. </p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDatalakeExceptionsSubscriptionInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDatalakeDelegatedAdminInput  {
    /// <p>The account ID the Security Lake delegated administrator.</p>
    #[doc(hidden)]
    pub account: std::option::Option<std::string::String>,
}
impl DeleteDatalakeDelegatedAdminInput {
    /// <p>The account ID the Security Lake delegated administrator.</p>
    pub fn account(&self) -> std::option::Option<& str> {
        self.account.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDatalakeAutoEnableInput  {
    /// <p>Delete Amazon Security Lake with the specified configuration settings to stop ingesting security data for new accounts in Security Lake. </p>
    #[doc(hidden)]
    pub remove_from_configuration_for_new_accounts: std::option::Option<std::vec::Vec<crate::model::AutoEnableNewRegionConfiguration>>,
}
impl DeleteDatalakeAutoEnableInput {
    /// <p>Delete Amazon Security Lake with the specified configuration settings to stop ingesting security data for new accounts in Security Lake. </p>
    pub fn remove_from_configuration_for_new_accounts(&self) -> std::option::Option<& [crate::model::AutoEnableNewRegionConfiguration]> {
        self.remove_from_configuration_for_new_accounts.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDatalakeInput  {
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteCustomLogSourceInput  {
    /// <p>The custom source name for the custom log source.</p>
    #[doc(hidden)]
    pub custom_source_name: std::option::Option<std::string::String>,
}
impl DeleteCustomLogSourceInput {
    /// <p>The custom source name for the custom log source.</p>
    pub fn custom_source_name(&self) -> std::option::Option<& str> {
        self.custom_source_name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAwsLogSourceInput  {
    /// <p>This is a mandatory input. Specify the input order to disable dimensions in Security Lake, namely Region (Amazon Web Services Region code, source type, and member (account ID of a specific Amazon Web Services account). </p>
    #[doc(hidden)]
    pub input_order: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
    /// <p>Removes the specific Amazon Web Services sources from specific accounts and specific Regions.</p>
    #[doc(hidden)]
    pub disable_all_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>>,
    /// <p>Remove a specific Amazon Web Services source from specific accounts or Regions.</p>
    #[doc(hidden)]
    pub disable_two_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>,
    /// <p>Removes all Amazon Web Services sources from specific accounts or Regions.</p>
    #[doc(hidden)]
    pub disable_single_dimension: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DeleteAwsLogSourceInput {
    /// <p>This is a mandatory input. Specify the input order to disable dimensions in Security Lake, namely Region (Amazon Web Services Region code, source type, and member (account ID of a specific Amazon Web Services account). </p>
    pub fn input_order(&self) -> std::option::Option<& [crate::model::Dimension]> {
        self.input_order.as_deref()
    }
    /// <p>Removes the specific Amazon Web Services sources from specific accounts and specific Regions.</p>
    pub fn disable_all_dimensions(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>> {
        self.disable_all_dimensions.as_ref()
    }
    /// <p>Remove a specific Amazon Web Services source from specific accounts or Regions.</p>
    pub fn disable_two_dimensions(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>> {
        self.disable_two_dimensions.as_ref()
    }
    /// <p>Removes all Amazon Web Services sources from specific accounts or Regions.</p>
    pub fn disable_single_dimension(&self) -> std::option::Option<& [std::string::String]> {
        self.disable_single_dimension.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSubscriptionNotificationConfigurationInput  {
    /// <p>The subscription ID for the notification subscription/</p>
    #[doc(hidden)]
    pub subscription_id: std::option::Option<std::string::String>,
    /// <p>The subscription endpoint in Security Lake. If you prefer notification with an HTTPs endpoint, populate this field.</p>
    #[doc(hidden)]
    pub subscription_endpoint: std::option::Option<std::string::String>,
    /// <p>The key name for the notification subscription.</p>
    #[doc(hidden)]
    pub https_api_key_name: std::option::Option<std::string::String>,
    /// <p>The key value for the notification subscription.</p>
    #[doc(hidden)]
    pub https_api_key_value: std::option::Option<std::string::String>,
    /// <p>The HTTPS method used for the notification subscription. </p>
    #[doc(hidden)]
    pub https_method: std::option::Option<crate::model::HttpsMethod>,
    /// <p>Create an Amazon Simple Queue Service queue.</p>
    #[doc(hidden)]
    pub create_sqs: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the EventBridge API destinations IAM role that you created.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl CreateSubscriptionNotificationConfigurationInput {
    /// <p>The subscription ID for the notification subscription/</p>
    pub fn subscription_id(&self) -> std::option::Option<& str> {
        self.subscription_id.as_deref()
    }
    /// <p>The subscription endpoint in Security Lake. If you prefer notification with an HTTPs endpoint, populate this field.</p>
    pub fn subscription_endpoint(&self) -> std::option::Option<& str> {
        self.subscription_endpoint.as_deref()
    }
    /// <p>The key name for the notification subscription.</p>
    pub fn https_api_key_name(&self) -> std::option::Option<& str> {
        self.https_api_key_name.as_deref()
    }
    /// <p>The key value for the notification subscription.</p>
    pub fn https_api_key_value(&self) -> std::option::Option<& str> {
        self.https_api_key_value.as_deref()
    }
    /// <p>The HTTPS method used for the notification subscription. </p>
    pub fn https_method(&self) -> std::option::Option<& crate::model::HttpsMethod> {
        self.https_method.as_ref()
    }
    /// <p>Create an Amazon Simple Queue Service queue.</p>
    pub fn create_sqs(&self) -> std::option::Option<bool> {
        self.create_sqs
    }
    /// <p>The Amazon Resource Name (ARN) of the EventBridge API destinations IAM role that you created.</p>
    pub fn role_arn(&self) -> std::option::Option<& str> {
        self.role_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSubscriberInput  {
    /// <p>The supported Amazon Web Services from which logs and events are collected. Security Lake supports log and event collection for natively supported Amazon Web Services.</p>
    #[doc(hidden)]
    pub source_types: std::option::Option<std::vec::Vec<crate::model::SourceType>>,
    /// <p>The Amazon Web Services account ID used to access your data.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The external ID of the subscriber. This lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.</p>
    #[doc(hidden)]
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 or Lake Formation access type.</p>
    #[doc(hidden)]
    pub access_types: std::option::Option<std::vec::Vec<crate::model::AccessType>>,
    /// <p>The name of your Security Lake subscriber account.</p>
    #[doc(hidden)]
    pub subscriber_name: std::option::Option<std::string::String>,
    /// <p>The description for your subscriber account in Security Lake. </p>
    #[doc(hidden)]
    pub subscriber_description: std::option::Option<std::string::String>,
}
impl CreateSubscriberInput {
    /// <p>The supported Amazon Web Services from which logs and events are collected. Security Lake supports log and event collection for natively supported Amazon Web Services.</p>
    pub fn source_types(&self) -> std::option::Option<& [crate::model::SourceType]> {
        self.source_types.as_deref()
    }
    /// <p>The Amazon Web Services account ID used to access your data.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The external ID of the subscriber. This lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.</p>
    pub fn external_id(&self) -> std::option::Option<& str> {
        self.external_id.as_deref()
    }
    /// <p>The Amazon S3 or Lake Formation access type.</p>
    pub fn access_types(&self) -> std::option::Option<& [crate::model::AccessType]> {
        self.access_types.as_deref()
    }
    /// <p>The name of your Security Lake subscriber account.</p>
    pub fn subscriber_name(&self) -> std::option::Option<& str> {
        self.subscriber_name.as_deref()
    }
    /// <p>The description for your subscriber account in Security Lake. </p>
    pub fn subscriber_description(&self) -> std::option::Option<& str> {
        self.subscriber_description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDatalakeExceptionsSubscriptionInput  {
    /// <p>The subscription protocol to which exception notifications are posted. </p>
    #[doc(hidden)]
    pub subscription_protocol: std::option::Option<crate::model::SubscriptionProtocolType>,
    /// <p>The Amazon Web Services account where you want to receive exception notifications.</p>
    #[doc(hidden)]
    pub notification_endpoint: std::option::Option<std::string::String>,
}
impl CreateDatalakeExceptionsSubscriptionInput {
    /// <p>The subscription protocol to which exception notifications are posted. </p>
    pub fn subscription_protocol(&self) -> std::option::Option<& crate::model::SubscriptionProtocolType> {
        self.subscription_protocol.as_ref()
    }
    /// <p>The Amazon Web Services account where you want to receive exception notifications.</p>
    pub fn notification_endpoint(&self) -> std::option::Option<& str> {
        self.notification_endpoint.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDatalakeDelegatedAdminInput  {
    /// <p>The Amazon Web Services account ID of the Security Lake delegated administrator.</p>
    #[doc(hidden)]
    pub account: std::option::Option<std::string::String>,
}
impl CreateDatalakeDelegatedAdminInput {
    /// <p>The Amazon Web Services account ID of the Security Lake delegated administrator.</p>
    pub fn account(&self) -> std::option::Option<& str> {
        self.account.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDatalakeAutoEnableInput  {
    /// <p>Enable Security Lake with the specified configuration settings to begin collecting security data for new accounts in your organization. </p>
    #[doc(hidden)]
    pub configuration_for_new_accounts: std::option::Option<std::vec::Vec<crate::model::AutoEnableNewRegionConfiguration>>,
}
impl CreateDatalakeAutoEnableInput {
    /// <p>Enable Security Lake with the specified configuration settings to begin collecting security data for new accounts in your organization. </p>
    pub fn configuration_for_new_accounts(&self) -> std::option::Option<& [crate::model::AutoEnableNewRegionConfiguration]> {
        self.configuration_for_new_accounts.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDatalakeInput  {
    /// <p>Enable Security Lake in the specified Regions. To enable Security Lake in specific Amazon Web Services Regions, such as us-east-1 or ap-northeast-3, provide the Region codes. For a list of Region codes, see <a href="https://docs.aws.amazon.com/general/latest/gr/securitylake.html">Amazon Security Lake endpoints</a> in the Amazon Web Services General Reference.</p>
    #[doc(hidden)]
    pub regions: std::option::Option<std::vec::Vec<crate::model::Region>>,
    /// <p>Specify the Region or Regions that will contribute data to the rollup region.</p>
    #[doc(hidden)]
    pub configurations: std::option::Option<std::collections::HashMap<crate::model::Region, crate::model::LakeConfigurationRequest>>,
    /// <p>Enable Security Lake in all Regions.</p>
    #[doc(hidden)]
    pub enable_all: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) used to create and update the Glue table. This table contains partitions generated by the ingestion and normalization of Amazon Web Services log sources and custom sources.</p>
    #[doc(hidden)]
    pub meta_store_manager_role_arn: std::option::Option<std::string::String>,
}
impl CreateDatalakeInput {
    /// <p>Enable Security Lake in the specified Regions. To enable Security Lake in specific Amazon Web Services Regions, such as us-east-1 or ap-northeast-3, provide the Region codes. For a list of Region codes, see <a href="https://docs.aws.amazon.com/general/latest/gr/securitylake.html">Amazon Security Lake endpoints</a> in the Amazon Web Services General Reference.</p>
    pub fn regions(&self) -> std::option::Option<& [crate::model::Region]> {
        self.regions.as_deref()
    }
    /// <p>Specify the Region or Regions that will contribute data to the rollup region.</p>
    pub fn configurations(&self) -> std::option::Option<& std::collections::HashMap<crate::model::Region, crate::model::LakeConfigurationRequest>> {
        self.configurations.as_ref()
    }
    /// <p>Enable Security Lake in all Regions.</p>
    pub fn enable_all(&self) -> std::option::Option<bool> {
        self.enable_all
    }
    /// <p>The Amazon Resource Name (ARN) used to create and update the Glue table. This table contains partitions generated by the ingestion and normalization of Amazon Web Services log sources and custom sources.</p>
    pub fn meta_store_manager_role_arn(&self) -> std::option::Option<& str> {
        self.meta_store_manager_role_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateCustomLogSourceInput  {
    /// <p>The name for a third-party custom source. This must be a Regionally unique value.</p>
    #[doc(hidden)]
    pub custom_source_name: std::option::Option<std::string::String>,
    /// <p>The Open Cybersecurity Schema Framework (OCSF) event class which describes the type of data that the custom source will send to Security Lake.</p>
    #[doc(hidden)]
    pub event_class: std::option::Option<crate::model::OcsfEventClass>,
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be used by the Glue crawler. The recommended IAM policies are:</p> 
    /// <ul> 
    /// <li> <p>The managed policy <code>AWSGlueServiceRole</code> </p> </li> 
    /// <li> <p>A custom policy granting access to your Amazon S3 Data Lake</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub glue_invocation_role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the custom source that will write logs and events into the Amazon S3 Data Lake.</p>
    #[doc(hidden)]
    pub log_provider_account_id: std::option::Option<std::string::String>,
}
impl CreateCustomLogSourceInput {
    /// <p>The name for a third-party custom source. This must be a Regionally unique value.</p>
    pub fn custom_source_name(&self) -> std::option::Option<& str> {
        self.custom_source_name.as_deref()
    }
    /// <p>The Open Cybersecurity Schema Framework (OCSF) event class which describes the type of data that the custom source will send to Security Lake.</p>
    pub fn event_class(&self) -> std::option::Option<& crate::model::OcsfEventClass> {
        self.event_class.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be used by the Glue crawler. The recommended IAM policies are:</p> 
    /// <ul> 
    /// <li> <p>The managed policy <code>AWSGlueServiceRole</code> </p> </li> 
    /// <li> <p>A custom policy granting access to your Amazon S3 Data Lake</p> </li> 
    /// </ul>
    pub fn glue_invocation_role_arn(&self) -> std::option::Option<& str> {
        self.glue_invocation_role_arn.as_deref()
    }
    /// <p>The Amazon Web Services account ID of the custom source that will write logs and events into the Amazon S3 Data Lake.</p>
    pub fn log_provider_account_id(&self) -> std::option::Option<& str> {
        self.log_provider_account_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAwsLogSourceInput  {
    /// <p>Specifies the input order to enable dimensions in Security Lake, namely Region, source type, and member account.</p>
    #[doc(hidden)]
    pub input_order: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
    /// <p>Enables data collection from specific Amazon Web Services sources in all specific accounts and specific Regions.</p>
    #[doc(hidden)]
    pub enable_all_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>>,
    /// <p>Enables data collection from specific Amazon Web Services sources in specific accounts or Regions.</p>
    #[doc(hidden)]
    pub enable_two_dimensions: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>,
    /// <p>Enables data collection from all Amazon Web Services sources in specific accounts or Regions.</p>
    #[doc(hidden)]
    pub enable_single_dimension: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CreateAwsLogSourceInput {
    /// <p>Specifies the input order to enable dimensions in Security Lake, namely Region, source type, and member account.</p>
    pub fn input_order(&self) -> std::option::Option<& [crate::model::Dimension]> {
        self.input_order.as_deref()
    }
    /// <p>Enables data collection from specific Amazon Web Services sources in all specific accounts and specific Regions.</p>
    pub fn enable_all_dimensions(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>> {
        self.enable_all_dimensions.as_ref()
    }
    /// <p>Enables data collection from specific Amazon Web Services sources in specific accounts or Regions.</p>
    pub fn enable_two_dimensions(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>> {
        self.enable_two_dimensions.as_ref()
    }
    /// <p>Enables data collection from all Amazon Web Services sources in specific accounts or Regions.</p>
    pub fn enable_single_dimension(&self) -> std::option::Option<& [std::string::String]> {
        self.enable_single_dimension.as_deref()
    }
}

