// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p> The QualificationType data structure represents a
/// Qualification type, a description of a property of a Worker that must
/// match the requirements of a HIT for the Worker to be able to accept
/// the HIT. The type also describes how a Worker can obtain a
/// Qualification of that type, such as through a Qualification test.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QualificationType {
    /// <p> A unique identifier for the Qualification type. A
    /// Qualification type is given a Qualification type ID when you call the
    /// CreateQualificationType operation.
    /// </p>
    pub qualification_type_id: std::option::Option<std::string::String>,
    /// <p> The date and time the Qualification type was created.
    /// </p>
    pub creation_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> The name of the Qualification type. The type name is used to
    /// identify the type, and to find the type using a Qualification type
    /// search.
    /// </p>
    pub name: std::option::Option<std::string::String>,
    /// <p> A long description for the Qualification type.
    /// </p>
    pub description: std::option::Option<std::string::String>,
    /// <p> One or more words or phrases that describe theQualification
    /// type, separated by commas. The Keywords make the type easier to find
    /// using a search.
    /// </p>
    pub keywords: std::option::Option<std::string::String>,
    /// <p> The status of the Qualification type. A Qualification type's
    /// status determines if users can apply to receive a Qualification of
    /// this type, and if HITs can be created with requirements based on this
    /// type. Valid values are Active | Inactive.
    /// </p>
    pub qualification_type_status: std::option::Option<crate::model::QualificationTypeStatus>,
    /// <p> The questions for a Qualification test associated with this
    /// Qualification type that a user can take to obtain a Qualification of
    /// this type. This parameter must be specified if AnswerKey is present.
    /// A Qualification type cannot have both a specified Test parameter and
    /// an AutoGranted value of true.
    /// </p>
    pub test: std::option::Option<std::string::String>,
    /// <p> The amount of time, in seconds, given to a Worker to
    /// complete the Qualification test, beginning from the time the Worker
    /// requests the Qualification.
    /// </p>
    pub test_duration_in_seconds: std::option::Option<i64>,
    /// <p>The answers to the Qualification test specified in the Test
    /// parameter.</p>
    pub answer_key: std::option::Option<std::string::String>,
    /// <p> The amount of time, in seconds, Workers must wait after
    /// taking the Qualification test before they can take it again. Workers
    /// can take a Qualification test multiple times if they were not granted
    /// the Qualification from a previous attempt, or if the test offers a
    /// gradient score and they want a better score. If not specified,
    /// retries are disabled and Workers can request a Qualification only
    /// once.
    /// </p>
    pub retry_delay_in_seconds: std::option::Option<i64>,
    /// <p> Specifies whether the Qualification type is one that a user
    /// can request through the Amazon Mechanical Turk web site, such as by
    /// taking a Qualification test. This value is False for Qualifications
    /// assigned automatically by the system. Valid values are True | False.
    /// </p>
    pub is_requestable: std::option::Option<bool>,
    /// <p>Specifies that requests for the Qualification type are
    /// granted immediately, without prompting the Worker with a
    /// Qualification test. Valid values are True | False.</p>
    pub auto_granted: std::option::Option<bool>,
    /// <p> The Qualification integer value to use for automatically
    /// granted Qualifications, if AutoGranted is true. This is 1 by default.
    /// </p>
    pub auto_granted_value: std::option::Option<i32>,
}
impl QualificationType {
    /// <p> A unique identifier for the Qualification type. A
    /// Qualification type is given a Qualification type ID when you call the
    /// CreateQualificationType operation.
    /// </p>
    pub fn qualification_type_id(&self) -> std::option::Option<&str> {
        self.qualification_type_id.as_deref()
    }
    /// <p> The date and time the Qualification type was created.
    /// </p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.creation_time.as_ref()
    }
    /// <p> The name of the Qualification type. The type name is used to
    /// identify the type, and to find the type using a Qualification type
    /// search.
    /// </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A long description for the Qualification type.
    /// </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> One or more words or phrases that describe theQualification
    /// type, separated by commas. The Keywords make the type easier to find
    /// using a search.
    /// </p>
    pub fn keywords(&self) -> std::option::Option<&str> {
        self.keywords.as_deref()
    }
    /// <p> The status of the Qualification type. A Qualification type's
    /// status determines if users can apply to receive a Qualification of
    /// this type, and if HITs can be created with requirements based on this
    /// type. Valid values are Active | Inactive.
    /// </p>
    pub fn qualification_type_status(
        &self,
    ) -> std::option::Option<&crate::model::QualificationTypeStatus> {
        self.qualification_type_status.as_ref()
    }
    /// <p> The questions for a Qualification test associated with this
    /// Qualification type that a user can take to obtain a Qualification of
    /// this type. This parameter must be specified if AnswerKey is present.
    /// A Qualification type cannot have both a specified Test parameter and
    /// an AutoGranted value of true.
    /// </p>
    pub fn test(&self) -> std::option::Option<&str> {
        self.test.as_deref()
    }
    /// <p> The amount of time, in seconds, given to a Worker to
    /// complete the Qualification test, beginning from the time the Worker
    /// requests the Qualification.
    /// </p>
    pub fn test_duration_in_seconds(&self) -> std::option::Option<i64> {
        self.test_duration_in_seconds
    }
    /// <p>The answers to the Qualification test specified in the Test
    /// parameter.</p>
    pub fn answer_key(&self) -> std::option::Option<&str> {
        self.answer_key.as_deref()
    }
    /// <p> The amount of time, in seconds, Workers must wait after
    /// taking the Qualification test before they can take it again. Workers
    /// can take a Qualification test multiple times if they were not granted
    /// the Qualification from a previous attempt, or if the test offers a
    /// gradient score and they want a better score. If not specified,
    /// retries are disabled and Workers can request a Qualification only
    /// once.
    /// </p>
    pub fn retry_delay_in_seconds(&self) -> std::option::Option<i64> {
        self.retry_delay_in_seconds
    }
    /// <p> Specifies whether the Qualification type is one that a user
    /// can request through the Amazon Mechanical Turk web site, such as by
    /// taking a Qualification test. This value is False for Qualifications
    /// assigned automatically by the system. Valid values are True | False.
    /// </p>
    pub fn is_requestable(&self) -> std::option::Option<bool> {
        self.is_requestable
    }
    /// <p>Specifies that requests for the Qualification type are
    /// granted immediately, without prompting the Worker with a
    /// Qualification test. Valid values are True | False.</p>
    pub fn auto_granted(&self) -> std::option::Option<bool> {
        self.auto_granted
    }
    /// <p> The Qualification integer value to use for automatically
    /// granted Qualifications, if AutoGranted is true. This is 1 by default.
    /// </p>
    pub fn auto_granted_value(&self) -> std::option::Option<i32> {
        self.auto_granted_value
    }
}
impl std::fmt::Debug for QualificationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QualificationType");
        formatter.field("qualification_type_id", &self.qualification_type_id);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("keywords", &self.keywords);
        formatter.field("qualification_type_status", &self.qualification_type_status);
        formatter.field("test", &self.test);
        formatter.field("test_duration_in_seconds", &self.test_duration_in_seconds);
        formatter.field("answer_key", &self.answer_key);
        formatter.field("retry_delay_in_seconds", &self.retry_delay_in_seconds);
        formatter.field("is_requestable", &self.is_requestable);
        formatter.field("auto_granted", &self.auto_granted);
        formatter.field("auto_granted_value", &self.auto_granted_value);
        formatter.finish()
    }
}
/// See [`QualificationType`](crate::model::QualificationType)
pub mod qualification_type {
    /// A builder for [`QualificationType`](crate::model::QualificationType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) qualification_type_id: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) keywords: std::option::Option<std::string::String>,
        pub(crate) qualification_type_status:
            std::option::Option<crate::model::QualificationTypeStatus>,
        pub(crate) test: std::option::Option<std::string::String>,
        pub(crate) test_duration_in_seconds: std::option::Option<i64>,
        pub(crate) answer_key: std::option::Option<std::string::String>,
        pub(crate) retry_delay_in_seconds: std::option::Option<i64>,
        pub(crate) is_requestable: std::option::Option<bool>,
        pub(crate) auto_granted: std::option::Option<bool>,
        pub(crate) auto_granted_value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> A unique identifier for the Qualification type. A
        /// Qualification type is given a Qualification type ID when you call the
        /// CreateQualificationType operation.
        /// </p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.qualification_type_id = Some(input.into());
            self
        }
        /// <p> A unique identifier for the Qualification type. A
        /// Qualification type is given a Qualification type ID when you call the
        /// CreateQualificationType operation.
        /// </p>
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.qualification_type_id = input;
            self
        }
        /// <p> The date and time the Qualification type was created.
        /// </p>
        pub fn creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p> The date and time the Qualification type was created.
        /// </p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p> The name of the Qualification type. The type name is used to
        /// identify the type, and to find the type using a Qualification type
        /// search.
        /// </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the Qualification type. The type name is used to
        /// identify the type, and to find the type using a Qualification type
        /// search.
        /// </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A long description for the Qualification type.
        /// </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A long description for the Qualification type.
        /// </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> One or more words or phrases that describe theQualification
        /// type, separated by commas. The Keywords make the type easier to find
        /// using a search.
        /// </p>
        pub fn keywords(mut self, input: impl Into<std::string::String>) -> Self {
            self.keywords = Some(input.into());
            self
        }
        /// <p> One or more words or phrases that describe theQualification
        /// type, separated by commas. The Keywords make the type easier to find
        /// using a search.
        /// </p>
        pub fn set_keywords(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.keywords = input;
            self
        }
        /// <p> The status of the Qualification type. A Qualification type's
        /// status determines if users can apply to receive a Qualification of
        /// this type, and if HITs can be created with requirements based on this
        /// type. Valid values are Active | Inactive.
        /// </p>
        pub fn qualification_type_status(
            mut self,
            input: crate::model::QualificationTypeStatus,
        ) -> Self {
            self.qualification_type_status = Some(input);
            self
        }
        /// <p> The status of the Qualification type. A Qualification type's
        /// status determines if users can apply to receive a Qualification of
        /// this type, and if HITs can be created with requirements based on this
        /// type. Valid values are Active | Inactive.
        /// </p>
        pub fn set_qualification_type_status(
            mut self,
            input: std::option::Option<crate::model::QualificationTypeStatus>,
        ) -> Self {
            self.qualification_type_status = input;
            self
        }
        /// <p> The questions for a Qualification test associated with this
        /// Qualification type that a user can take to obtain a Qualification of
        /// this type. This parameter must be specified if AnswerKey is present.
        /// A Qualification type cannot have both a specified Test parameter and
        /// an AutoGranted value of true.
        /// </p>
        pub fn test(mut self, input: impl Into<std::string::String>) -> Self {
            self.test = Some(input.into());
            self
        }
        /// <p> The questions for a Qualification test associated with this
        /// Qualification type that a user can take to obtain a Qualification of
        /// this type. This parameter must be specified if AnswerKey is present.
        /// A Qualification type cannot have both a specified Test parameter and
        /// an AutoGranted value of true.
        /// </p>
        pub fn set_test(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.test = input;
            self
        }
        /// <p> The amount of time, in seconds, given to a Worker to
        /// complete the Qualification test, beginning from the time the Worker
        /// requests the Qualification.
        /// </p>
        pub fn test_duration_in_seconds(mut self, input: i64) -> Self {
            self.test_duration_in_seconds = Some(input);
            self
        }
        /// <p> The amount of time, in seconds, given to a Worker to
        /// complete the Qualification test, beginning from the time the Worker
        /// requests the Qualification.
        /// </p>
        pub fn set_test_duration_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.test_duration_in_seconds = input;
            self
        }
        /// <p>The answers to the Qualification test specified in the Test
        /// parameter.</p>
        pub fn answer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.answer_key = Some(input.into());
            self
        }
        /// <p>The answers to the Qualification test specified in the Test
        /// parameter.</p>
        pub fn set_answer_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.answer_key = input;
            self
        }
        /// <p> The amount of time, in seconds, Workers must wait after
        /// taking the Qualification test before they can take it again. Workers
        /// can take a Qualification test multiple times if they were not granted
        /// the Qualification from a previous attempt, or if the test offers a
        /// gradient score and they want a better score. If not specified,
        /// retries are disabled and Workers can request a Qualification only
        /// once.
        /// </p>
        pub fn retry_delay_in_seconds(mut self, input: i64) -> Self {
            self.retry_delay_in_seconds = Some(input);
            self
        }
        /// <p> The amount of time, in seconds, Workers must wait after
        /// taking the Qualification test before they can take it again. Workers
        /// can take a Qualification test multiple times if they were not granted
        /// the Qualification from a previous attempt, or if the test offers a
        /// gradient score and they want a better score. If not specified,
        /// retries are disabled and Workers can request a Qualification only
        /// once.
        /// </p>
        pub fn set_retry_delay_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.retry_delay_in_seconds = input;
            self
        }
        /// <p> Specifies whether the Qualification type is one that a user
        /// can request through the Amazon Mechanical Turk web site, such as by
        /// taking a Qualification test. This value is False for Qualifications
        /// assigned automatically by the system. Valid values are True | False.
        /// </p>
        pub fn is_requestable(mut self, input: bool) -> Self {
            self.is_requestable = Some(input);
            self
        }
        /// <p> Specifies whether the Qualification type is one that a user
        /// can request through the Amazon Mechanical Turk web site, such as by
        /// taking a Qualification test. This value is False for Qualifications
        /// assigned automatically by the system. Valid values are True | False.
        /// </p>
        pub fn set_is_requestable(mut self, input: std::option::Option<bool>) -> Self {
            self.is_requestable = input;
            self
        }
        /// <p>Specifies that requests for the Qualification type are
        /// granted immediately, without prompting the Worker with a
        /// Qualification test. Valid values are True | False.</p>
        pub fn auto_granted(mut self, input: bool) -> Self {
            self.auto_granted = Some(input);
            self
        }
        /// <p>Specifies that requests for the Qualification type are
        /// granted immediately, without prompting the Worker with a
        /// Qualification test. Valid values are True | False.</p>
        pub fn set_auto_granted(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_granted = input;
            self
        }
        /// <p> The Qualification integer value to use for automatically
        /// granted Qualifications, if AutoGranted is true. This is 1 by default.
        /// </p>
        pub fn auto_granted_value(mut self, input: i32) -> Self {
            self.auto_granted_value = Some(input);
            self
        }
        /// <p> The Qualification integer value to use for automatically
        /// granted Qualifications, if AutoGranted is true. This is 1 by default.
        /// </p>
        pub fn set_auto_granted_value(mut self, input: std::option::Option<i32>) -> Self {
            self.auto_granted_value = input;
            self
        }
        /// Consumes the builder and constructs a [`QualificationType`](crate::model::QualificationType)
        pub fn build(self) -> crate::model::QualificationType {
            crate::model::QualificationType {
                qualification_type_id: self.qualification_type_id,
                creation_time: self.creation_time,
                name: self.name,
                description: self.description,
                keywords: self.keywords,
                qualification_type_status: self.qualification_type_status,
                test: self.test,
                test_duration_in_seconds: self.test_duration_in_seconds,
                answer_key: self.answer_key,
                retry_delay_in_seconds: self.retry_delay_in_seconds,
                is_requestable: self.is_requestable,
                auto_granted: self.auto_granted,
                auto_granted_value: self.auto_granted_value,
            }
        }
    }
}
impl QualificationType {
    /// Creates a new builder-style object to manufacture [`QualificationType`](crate::model::QualificationType)
    pub fn builder() -> crate::model::qualification_type::Builder {
        crate::model::qualification_type::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QualificationTypeStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for QualificationTypeStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => QualificationTypeStatus::Active,
            "Inactive" => QualificationTypeStatus::Inactive,
            other => QualificationTypeStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for QualificationTypeStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QualificationTypeStatus::from(s))
    }
}
impl QualificationTypeStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QualificationTypeStatus::Active => "Active",
            QualificationTypeStatus::Inactive => "Inactive",
            QualificationTypeStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Active", "Inactive"]
    }
}
impl AsRef<str> for QualificationTypeStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The NotificationSpecification data structure describes a HIT
/// event notification for a HIT type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotificationSpecification {
    /// <p>
    /// The target for notification messages. The Destination’s format is determined by the specified Transport:
    /// </p>
    /// <ul>
    /// <li>
    /// <p>When Transport is Email, the Destination is your email address.</p>
    /// </li>
    /// <li>
    /// <p>When Transport is SQS, the Destination is your queue URL.</p>
    /// </li>
    /// <li>
    /// <p>When Transport is SNS, the Destination is the ARN of your topic.</p>
    /// </li>
    /// </ul>
    pub destination: std::option::Option<std::string::String>,
    /// <p> The method Amazon Mechanical Turk uses to send the
    /// notification. Valid Values: Email | SQS | SNS.
    /// </p>
    pub transport: std::option::Option<crate::model::NotificationTransport>,
    /// <p>The version of the Notification API to use. Valid value is
    /// 2006-05-05.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p> The list of events that should cause notifications to be
    /// sent. Valid Values: AssignmentAccepted | AssignmentAbandoned |
    /// AssignmentReturned | AssignmentSubmitted | AssignmentRejected |
    /// AssignmentApproved | HITCreated | HITExtended | HITDisposed |
    /// HITReviewable | HITExpired | Ping. The Ping event is only valid for
    /// the SendTestEventNotification operation.
    /// </p>
    pub event_types: std::option::Option<std::vec::Vec<crate::model::EventType>>,
}
impl NotificationSpecification {
    /// <p>
    /// The target for notification messages. The Destination’s format is determined by the specified Transport:
    /// </p>
    /// <ul>
    /// <li>
    /// <p>When Transport is Email, the Destination is your email address.</p>
    /// </li>
    /// <li>
    /// <p>When Transport is SQS, the Destination is your queue URL.</p>
    /// </li>
    /// <li>
    /// <p>When Transport is SNS, the Destination is the ARN of your topic.</p>
    /// </li>
    /// </ul>
    pub fn destination(&self) -> std::option::Option<&str> {
        self.destination.as_deref()
    }
    /// <p> The method Amazon Mechanical Turk uses to send the
    /// notification. Valid Values: Email | SQS | SNS.
    /// </p>
    pub fn transport(&self) -> std::option::Option<&crate::model::NotificationTransport> {
        self.transport.as_ref()
    }
    /// <p>The version of the Notification API to use. Valid value is
    /// 2006-05-05.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p> The list of events that should cause notifications to be
    /// sent. Valid Values: AssignmentAccepted | AssignmentAbandoned |
    /// AssignmentReturned | AssignmentSubmitted | AssignmentRejected |
    /// AssignmentApproved | HITCreated | HITExtended | HITDisposed |
    /// HITReviewable | HITExpired | Ping. The Ping event is only valid for
    /// the SendTestEventNotification operation.
    /// </p>
    pub fn event_types(&self) -> std::option::Option<&[crate::model::EventType]> {
        self.event_types.as_deref()
    }
}
impl std::fmt::Debug for NotificationSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotificationSpecification");
        formatter.field("destination", &self.destination);
        formatter.field("transport", &self.transport);
        formatter.field("version", &self.version);
        formatter.field("event_types", &self.event_types);
        formatter.finish()
    }
}
/// See [`NotificationSpecification`](crate::model::NotificationSpecification)
pub mod notification_specification {
    /// A builder for [`NotificationSpecification`](crate::model::NotificationSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination: std::option::Option<std::string::String>,
        pub(crate) transport: std::option::Option<crate::model::NotificationTransport>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) event_types: std::option::Option<std::vec::Vec<crate::model::EventType>>,
    }
    impl Builder {
        /// <p>
        /// The target for notification messages. The Destination’s format is determined by the specified Transport:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>When Transport is Email, the Destination is your email address.</p>
        /// </li>
        /// <li>
        /// <p>When Transport is SQS, the Destination is your queue URL.</p>
        /// </li>
        /// <li>
        /// <p>When Transport is SNS, the Destination is the ARN of your topic.</p>
        /// </li>
        /// </ul>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>
        /// The target for notification messages. The Destination’s format is determined by the specified Transport:
        /// </p>
        /// <ul>
        /// <li>
        /// <p>When Transport is Email, the Destination is your email address.</p>
        /// </li>
        /// <li>
        /// <p>When Transport is SQS, the Destination is your queue URL.</p>
        /// </li>
        /// <li>
        /// <p>When Transport is SNS, the Destination is the ARN of your topic.</p>
        /// </li>
        /// </ul>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// <p> The method Amazon Mechanical Turk uses to send the
        /// notification. Valid Values: Email | SQS | SNS.
        /// </p>
        pub fn transport(mut self, input: crate::model::NotificationTransport) -> Self {
            self.transport = Some(input);
            self
        }
        /// <p> The method Amazon Mechanical Turk uses to send the
        /// notification. Valid Values: Email | SQS | SNS.
        /// </p>
        pub fn set_transport(
            mut self,
            input: std::option::Option<crate::model::NotificationTransport>,
        ) -> Self {
            self.transport = input;
            self
        }
        /// <p>The version of the Notification API to use. Valid value is
        /// 2006-05-05.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the Notification API to use. Valid value is
        /// 2006-05-05.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Appends an item to `event_types`.
        ///
        /// To override the contents of this collection use [`set_event_types`](Self::set_event_types).
        ///
        /// <p> The list of events that should cause notifications to be
        /// sent. Valid Values: AssignmentAccepted | AssignmentAbandoned |
        /// AssignmentReturned | AssignmentSubmitted | AssignmentRejected |
        /// AssignmentApproved | HITCreated | HITExtended | HITDisposed |
        /// HITReviewable | HITExpired | Ping. The Ping event is only valid for
        /// the SendTestEventNotification operation.
        /// </p>
        pub fn event_types(mut self, input: impl Into<crate::model::EventType>) -> Self {
            let mut v = self.event_types.unwrap_or_default();
            v.push(input.into());
            self.event_types = Some(v);
            self
        }
        /// <p> The list of events that should cause notifications to be
        /// sent. Valid Values: AssignmentAccepted | AssignmentAbandoned |
        /// AssignmentReturned | AssignmentSubmitted | AssignmentRejected |
        /// AssignmentApproved | HITCreated | HITExtended | HITDisposed |
        /// HITReviewable | HITExpired | Ping. The Ping event is only valid for
        /// the SendTestEventNotification operation.
        /// </p>
        pub fn set_event_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EventType>>,
        ) -> Self {
            self.event_types = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationSpecification`](crate::model::NotificationSpecification)
        pub fn build(self) -> crate::model::NotificationSpecification {
            crate::model::NotificationSpecification {
                destination: self.destination,
                transport: self.transport,
                version: self.version,
                event_types: self.event_types,
            }
        }
    }
}
impl NotificationSpecification {
    /// Creates a new builder-style object to manufacture [`NotificationSpecification`](crate::model::NotificationSpecification)
    pub fn builder() -> crate::model::notification_specification::Builder {
        crate::model::notification_specification::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventType {
    #[allow(missing_docs)] // documentation missing in model
    AssignmentAbandoned,
    #[allow(missing_docs)] // documentation missing in model
    AssignmentAccepted,
    #[allow(missing_docs)] // documentation missing in model
    AssignmentApproved,
    #[allow(missing_docs)] // documentation missing in model
    AssignmentRejected,
    #[allow(missing_docs)] // documentation missing in model
    AssignmentReturned,
    #[allow(missing_docs)] // documentation missing in model
    AssignmentSubmitted,
    #[allow(missing_docs)] // documentation missing in model
    HitCreated,
    #[allow(missing_docs)] // documentation missing in model
    HitDisposed,
    #[allow(missing_docs)] // documentation missing in model
    HitExpired,
    #[allow(missing_docs)] // documentation missing in model
    HitExtended,
    #[allow(missing_docs)] // documentation missing in model
    HitReviewable,
    #[allow(missing_docs)] // documentation missing in model
    Ping,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EventType {
    fn from(s: &str) -> Self {
        match s {
            "AssignmentAbandoned" => EventType::AssignmentAbandoned,
            "AssignmentAccepted" => EventType::AssignmentAccepted,
            "AssignmentApproved" => EventType::AssignmentApproved,
            "AssignmentRejected" => EventType::AssignmentRejected,
            "AssignmentReturned" => EventType::AssignmentReturned,
            "AssignmentSubmitted" => EventType::AssignmentSubmitted,
            "HITCreated" => EventType::HitCreated,
            "HITDisposed" => EventType::HitDisposed,
            "HITExpired" => EventType::HitExpired,
            "HITExtended" => EventType::HitExtended,
            "HITReviewable" => EventType::HitReviewable,
            "Ping" => EventType::Ping,
            other => EventType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EventType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventType::from(s))
    }
}
impl EventType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EventType::AssignmentAbandoned => "AssignmentAbandoned",
            EventType::AssignmentAccepted => "AssignmentAccepted",
            EventType::AssignmentApproved => "AssignmentApproved",
            EventType::AssignmentRejected => "AssignmentRejected",
            EventType::AssignmentReturned => "AssignmentReturned",
            EventType::AssignmentSubmitted => "AssignmentSubmitted",
            EventType::HitCreated => "HITCreated",
            EventType::HitDisposed => "HITDisposed",
            EventType::HitExpired => "HITExpired",
            EventType::HitExtended => "HITExtended",
            EventType::HitReviewable => "HITReviewable",
            EventType::Ping => "Ping",
            EventType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AssignmentAbandoned",
            "AssignmentAccepted",
            "AssignmentApproved",
            "AssignmentRejected",
            "AssignmentReturned",
            "AssignmentSubmitted",
            "HITCreated",
            "HITDisposed",
            "HITExpired",
            "HITExtended",
            "HITReviewable",
            "Ping",
        ]
    }
}
impl AsRef<str> for EventType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotificationTransport {
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    Sns,
    #[allow(missing_docs)] // documentation missing in model
    Sqs,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotificationTransport {
    fn from(s: &str) -> Self {
        match s {
            "Email" => NotificationTransport::Email,
            "SNS" => NotificationTransport::Sns,
            "SQS" => NotificationTransport::Sqs,
            other => NotificationTransport::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotificationTransport {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotificationTransport::from(s))
    }
}
impl NotificationTransport {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotificationTransport::Email => "Email",
            NotificationTransport::Sns => "SNS",
            NotificationTransport::Sqs => "SQS",
            NotificationTransport::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Email", "SNS", "SQS"]
    }
}
impl AsRef<str> for NotificationTransport {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> When MTurk encounters an issue with notifying the Workers
/// you specified, it returns back this object with failure details.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotifyWorkersFailureStatus {
    /// <p> Encoded value for the failure type.
    /// </p>
    pub notify_workers_failure_code: std::option::Option<crate::model::NotifyWorkersFailureCode>,
    /// <p> A message detailing the reason the Worker could not be
    /// notified.
    /// </p>
    pub notify_workers_failure_message: std::option::Option<std::string::String>,
    /// <p> The ID of the Worker.</p>
    pub worker_id: std::option::Option<std::string::String>,
}
impl NotifyWorkersFailureStatus {
    /// <p> Encoded value for the failure type.
    /// </p>
    pub fn notify_workers_failure_code(
        &self,
    ) -> std::option::Option<&crate::model::NotifyWorkersFailureCode> {
        self.notify_workers_failure_code.as_ref()
    }
    /// <p> A message detailing the reason the Worker could not be
    /// notified.
    /// </p>
    pub fn notify_workers_failure_message(&self) -> std::option::Option<&str> {
        self.notify_workers_failure_message.as_deref()
    }
    /// <p> The ID of the Worker.</p>
    pub fn worker_id(&self) -> std::option::Option<&str> {
        self.worker_id.as_deref()
    }
}
impl std::fmt::Debug for NotifyWorkersFailureStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotifyWorkersFailureStatus");
        formatter.field(
            "notify_workers_failure_code",
            &self.notify_workers_failure_code,
        );
        formatter.field(
            "notify_workers_failure_message",
            &self.notify_workers_failure_message,
        );
        formatter.field("worker_id", &self.worker_id);
        formatter.finish()
    }
}
/// See [`NotifyWorkersFailureStatus`](crate::model::NotifyWorkersFailureStatus)
pub mod notify_workers_failure_status {
    /// A builder for [`NotifyWorkersFailureStatus`](crate::model::NotifyWorkersFailureStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notify_workers_failure_code:
            std::option::Option<crate::model::NotifyWorkersFailureCode>,
        pub(crate) notify_workers_failure_message: std::option::Option<std::string::String>,
        pub(crate) worker_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Encoded value for the failure type.
        /// </p>
        pub fn notify_workers_failure_code(
            mut self,
            input: crate::model::NotifyWorkersFailureCode,
        ) -> Self {
            self.notify_workers_failure_code = Some(input);
            self
        }
        /// <p> Encoded value for the failure type.
        /// </p>
        pub fn set_notify_workers_failure_code(
            mut self,
            input: std::option::Option<crate::model::NotifyWorkersFailureCode>,
        ) -> Self {
            self.notify_workers_failure_code = input;
            self
        }
        /// <p> A message detailing the reason the Worker could not be
        /// notified.
        /// </p>
        pub fn notify_workers_failure_message(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.notify_workers_failure_message = Some(input.into());
            self
        }
        /// <p> A message detailing the reason the Worker could not be
        /// notified.
        /// </p>
        pub fn set_notify_workers_failure_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notify_workers_failure_message = input;
            self
        }
        /// <p> The ID of the Worker.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.worker_id = Some(input.into());
            self
        }
        /// <p> The ID of the Worker.</p>
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.worker_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NotifyWorkersFailureStatus`](crate::model::NotifyWorkersFailureStatus)
        pub fn build(self) -> crate::model::NotifyWorkersFailureStatus {
            crate::model::NotifyWorkersFailureStatus {
                notify_workers_failure_code: self.notify_workers_failure_code,
                notify_workers_failure_message: self.notify_workers_failure_message,
                worker_id: self.worker_id,
            }
        }
    }
}
impl NotifyWorkersFailureStatus {
    /// Creates a new builder-style object to manufacture [`NotifyWorkersFailureStatus`](crate::model::NotifyWorkersFailureStatus)
    pub fn builder() -> crate::model::notify_workers_failure_status::Builder {
        crate::model::notify_workers_failure_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NotifyWorkersFailureCode {
    #[allow(missing_docs)] // documentation missing in model
    HardFailure,
    #[allow(missing_docs)] // documentation missing in model
    SoftFailure,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NotifyWorkersFailureCode {
    fn from(s: &str) -> Self {
        match s {
            "HardFailure" => NotifyWorkersFailureCode::HardFailure,
            "SoftFailure" => NotifyWorkersFailureCode::SoftFailure,
            other => NotifyWorkersFailureCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NotifyWorkersFailureCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NotifyWorkersFailureCode::from(s))
    }
}
impl NotifyWorkersFailureCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NotifyWorkersFailureCode::HardFailure => "HardFailure",
            NotifyWorkersFailureCode::SoftFailure => "SoftFailure",
            NotifyWorkersFailureCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["HardFailure", "SoftFailure"]
    }
}
impl AsRef<str> for NotifyWorkersFailureCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Qualification data structure represents a Qualification
/// assigned to a user, including the Qualification type and the value
/// (score).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Qualification {
    /// <p> The ID of the Qualification type for the Qualification.</p>
    pub qualification_type_id: std::option::Option<std::string::String>,
    /// <p> The ID of the Worker who possesses the Qualification.
    /// </p>
    pub worker_id: std::option::Option<std::string::String>,
    /// <p> The date and time the Qualification was granted to the
    /// Worker. If the Worker's Qualification was revoked, and then
    /// re-granted based on a new Qualification request, GrantTime is the
    /// date and time of the last call to the AcceptQualificationRequest
    /// operation.</p>
    pub grant_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> The value (score) of the Qualification, if the Qualification
    /// has an integer value.</p>
    pub integer_value: std::option::Option<i32>,
    /// <p>The Locale data structure represents a geographical region or location.</p>
    pub locale_value: std::option::Option<crate::model::Locale>,
    /// <p> The status of the Qualification. Valid values are Granted |
    /// Revoked.</p>
    pub status: std::option::Option<crate::model::QualificationStatus>,
}
impl Qualification {
    /// <p> The ID of the Qualification type for the Qualification.</p>
    pub fn qualification_type_id(&self) -> std::option::Option<&str> {
        self.qualification_type_id.as_deref()
    }
    /// <p> The ID of the Worker who possesses the Qualification.
    /// </p>
    pub fn worker_id(&self) -> std::option::Option<&str> {
        self.worker_id.as_deref()
    }
    /// <p> The date and time the Qualification was granted to the
    /// Worker. If the Worker's Qualification was revoked, and then
    /// re-granted based on a new Qualification request, GrantTime is the
    /// date and time of the last call to the AcceptQualificationRequest
    /// operation.</p>
    pub fn grant_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.grant_time.as_ref()
    }
    /// <p> The value (score) of the Qualification, if the Qualification
    /// has an integer value.</p>
    pub fn integer_value(&self) -> std::option::Option<i32> {
        self.integer_value
    }
    /// <p>The Locale data structure represents a geographical region or location.</p>
    pub fn locale_value(&self) -> std::option::Option<&crate::model::Locale> {
        self.locale_value.as_ref()
    }
    /// <p> The status of the Qualification. Valid values are Granted |
    /// Revoked.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::QualificationStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for Qualification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Qualification");
        formatter.field("qualification_type_id", &self.qualification_type_id);
        formatter.field("worker_id", &self.worker_id);
        formatter.field("grant_time", &self.grant_time);
        formatter.field("integer_value", &self.integer_value);
        formatter.field("locale_value", &self.locale_value);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`Qualification`](crate::model::Qualification)
pub mod qualification {
    /// A builder for [`Qualification`](crate::model::Qualification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) qualification_type_id: std::option::Option<std::string::String>,
        pub(crate) worker_id: std::option::Option<std::string::String>,
        pub(crate) grant_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) integer_value: std::option::Option<i32>,
        pub(crate) locale_value: std::option::Option<crate::model::Locale>,
        pub(crate) status: std::option::Option<crate::model::QualificationStatus>,
    }
    impl Builder {
        /// <p> The ID of the Qualification type for the Qualification.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.qualification_type_id = Some(input.into());
            self
        }
        /// <p> The ID of the Qualification type for the Qualification.</p>
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.qualification_type_id = input;
            self
        }
        /// <p> The ID of the Worker who possesses the Qualification.
        /// </p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.worker_id = Some(input.into());
            self
        }
        /// <p> The ID of the Worker who possesses the Qualification.
        /// </p>
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.worker_id = input;
            self
        }
        /// <p> The date and time the Qualification was granted to the
        /// Worker. If the Worker's Qualification was revoked, and then
        /// re-granted based on a new Qualification request, GrantTime is the
        /// date and time of the last call to the AcceptQualificationRequest
        /// operation.</p>
        pub fn grant_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.grant_time = Some(input);
            self
        }
        /// <p> The date and time the Qualification was granted to the
        /// Worker. If the Worker's Qualification was revoked, and then
        /// re-granted based on a new Qualification request, GrantTime is the
        /// date and time of the last call to the AcceptQualificationRequest
        /// operation.</p>
        pub fn set_grant_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.grant_time = input;
            self
        }
        /// <p> The value (score) of the Qualification, if the Qualification
        /// has an integer value.</p>
        pub fn integer_value(mut self, input: i32) -> Self {
            self.integer_value = Some(input);
            self
        }
        /// <p> The value (score) of the Qualification, if the Qualification
        /// has an integer value.</p>
        pub fn set_integer_value(mut self, input: std::option::Option<i32>) -> Self {
            self.integer_value = input;
            self
        }
        /// <p>The Locale data structure represents a geographical region or location.</p>
        pub fn locale_value(mut self, input: crate::model::Locale) -> Self {
            self.locale_value = Some(input);
            self
        }
        /// <p>The Locale data structure represents a geographical region or location.</p>
        pub fn set_locale_value(
            mut self,
            input: std::option::Option<crate::model::Locale>,
        ) -> Self {
            self.locale_value = input;
            self
        }
        /// <p> The status of the Qualification. Valid values are Granted |
        /// Revoked.</p>
        pub fn status(mut self, input: crate::model::QualificationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The status of the Qualification. Valid values are Granted |
        /// Revoked.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::QualificationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`Qualification`](crate::model::Qualification)
        pub fn build(self) -> crate::model::Qualification {
            crate::model::Qualification {
                qualification_type_id: self.qualification_type_id,
                worker_id: self.worker_id,
                grant_time: self.grant_time,
                integer_value: self.integer_value,
                locale_value: self.locale_value,
                status: self.status,
            }
        }
    }
}
impl Qualification {
    /// Creates a new builder-style object to manufacture [`Qualification`](crate::model::Qualification)
    pub fn builder() -> crate::model::qualification::Builder {
        crate::model::qualification::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QualificationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Granted,
    #[allow(missing_docs)] // documentation missing in model
    Revoked,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for QualificationStatus {
    fn from(s: &str) -> Self {
        match s {
            "Granted" => QualificationStatus::Granted,
            "Revoked" => QualificationStatus::Revoked,
            other => QualificationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for QualificationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QualificationStatus::from(s))
    }
}
impl QualificationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QualificationStatus::Granted => "Granted",
            QualificationStatus::Revoked => "Revoked",
            QualificationStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Granted", "Revoked"]
    }
}
impl AsRef<str> for QualificationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Locale data structure represents a geographical region or location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Locale {
    /// <p> The country of the locale. Must be a valid ISO 3166 country
    /// code. For example, the code US refers to the United States of
    /// America.
    /// </p>
    pub country: std::option::Option<std::string::String>,
    /// <p>The state or subdivision of the locale. A valid ISO 3166-2
    /// subdivision code. For example, the code WA refers to the state of
    /// Washington.</p>
    pub subdivision: std::option::Option<std::string::String>,
}
impl Locale {
    /// <p> The country of the locale. Must be a valid ISO 3166 country
    /// code. For example, the code US refers to the United States of
    /// America.
    /// </p>
    pub fn country(&self) -> std::option::Option<&str> {
        self.country.as_deref()
    }
    /// <p>The state or subdivision of the locale. A valid ISO 3166-2
    /// subdivision code. For example, the code WA refers to the state of
    /// Washington.</p>
    pub fn subdivision(&self) -> std::option::Option<&str> {
        self.subdivision.as_deref()
    }
}
impl std::fmt::Debug for Locale {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Locale");
        formatter.field("country", &self.country);
        formatter.field("subdivision", &self.subdivision);
        formatter.finish()
    }
}
/// See [`Locale`](crate::model::Locale)
pub mod locale {
    /// A builder for [`Locale`](crate::model::Locale)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) subdivision: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The country of the locale. Must be a valid ISO 3166 country
        /// code. For example, the code US refers to the United States of
        /// America.
        /// </p>
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        /// <p> The country of the locale. Must be a valid ISO 3166 country
        /// code. For example, the code US refers to the United States of
        /// America.
        /// </p>
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// <p>The state or subdivision of the locale. A valid ISO 3166-2
        /// subdivision code. For example, the code WA refers to the state of
        /// Washington.</p>
        pub fn subdivision(mut self, input: impl Into<std::string::String>) -> Self {
            self.subdivision = Some(input.into());
            self
        }
        /// <p>The state or subdivision of the locale. A valid ISO 3166-2
        /// subdivision code. For example, the code WA refers to the state of
        /// Washington.</p>
        pub fn set_subdivision(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subdivision = input;
            self
        }
        /// Consumes the builder and constructs a [`Locale`](crate::model::Locale)
        pub fn build(self) -> crate::model::Locale {
            crate::model::Locale {
                country: self.country,
                subdivision: self.subdivision,
            }
        }
    }
}
impl Locale {
    /// Creates a new builder-style object to manufacture [`Locale`](crate::model::Locale)
    pub fn builder() -> crate::model::locale::Builder {
        crate::model::locale::Builder::default()
    }
}

/// <p> The WorkerBlock data structure represents a Worker who has
/// been blocked. It has two elements: the WorkerId and the Reason for
/// the block.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorkerBlock {
    /// <p> The ID of the Worker who accepted the HIT.</p>
    pub worker_id: std::option::Option<std::string::String>,
    /// <p> A message explaining the reason the Worker was blocked.
    /// </p>
    pub reason: std::option::Option<std::string::String>,
}
impl WorkerBlock {
    /// <p> The ID of the Worker who accepted the HIT.</p>
    pub fn worker_id(&self) -> std::option::Option<&str> {
        self.worker_id.as_deref()
    }
    /// <p> A message explaining the reason the Worker was blocked.
    /// </p>
    pub fn reason(&self) -> std::option::Option<&str> {
        self.reason.as_deref()
    }
}
impl std::fmt::Debug for WorkerBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorkerBlock");
        formatter.field("worker_id", &self.worker_id);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}
/// See [`WorkerBlock`](crate::model::WorkerBlock)
pub mod worker_block {
    /// A builder for [`WorkerBlock`](crate::model::WorkerBlock)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) worker_id: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ID of the Worker who accepted the HIT.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.worker_id = Some(input.into());
            self
        }
        /// <p> The ID of the Worker who accepted the HIT.</p>
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.worker_id = input;
            self
        }
        /// <p> A message explaining the reason the Worker was blocked.
        /// </p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason = Some(input.into());
            self
        }
        /// <p> A message explaining the reason the Worker was blocked.
        /// </p>
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkerBlock`](crate::model::WorkerBlock)
        pub fn build(self) -> crate::model::WorkerBlock {
            crate::model::WorkerBlock {
                worker_id: self.worker_id,
                reason: self.reason,
            }
        }
    }
}
impl WorkerBlock {
    /// Creates a new builder-style object to manufacture [`WorkerBlock`](crate::model::WorkerBlock)
    pub fn builder() -> crate::model::worker_block::Builder {
        crate::model::worker_block::Builder::default()
    }
}

/// <p> Contains both ReviewResult and ReviewAction elements for a
/// particular HIT.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReviewReport {
    /// <p> A list of ReviewResults objects for each action specified in
    /// the Review Policy.
    /// </p>
    pub review_results: std::option::Option<std::vec::Vec<crate::model::ReviewResultDetail>>,
    /// <p> A list of ReviewAction objects for each action specified in
    /// the Review Policy.
    /// </p>
    pub review_actions: std::option::Option<std::vec::Vec<crate::model::ReviewActionDetail>>,
}
impl ReviewReport {
    /// <p> A list of ReviewResults objects for each action specified in
    /// the Review Policy.
    /// </p>
    pub fn review_results(&self) -> std::option::Option<&[crate::model::ReviewResultDetail]> {
        self.review_results.as_deref()
    }
    /// <p> A list of ReviewAction objects for each action specified in
    /// the Review Policy.
    /// </p>
    pub fn review_actions(&self) -> std::option::Option<&[crate::model::ReviewActionDetail]> {
        self.review_actions.as_deref()
    }
}
impl std::fmt::Debug for ReviewReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReviewReport");
        formatter.field("review_results", &self.review_results);
        formatter.field("review_actions", &self.review_actions);
        formatter.finish()
    }
}
/// See [`ReviewReport`](crate::model::ReviewReport)
pub mod review_report {
    /// A builder for [`ReviewReport`](crate::model::ReviewReport)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) review_results:
            std::option::Option<std::vec::Vec<crate::model::ReviewResultDetail>>,
        pub(crate) review_actions:
            std::option::Option<std::vec::Vec<crate::model::ReviewActionDetail>>,
    }
    impl Builder {
        /// Appends an item to `review_results`.
        ///
        /// To override the contents of this collection use [`set_review_results`](Self::set_review_results).
        ///
        /// <p> A list of ReviewResults objects for each action specified in
        /// the Review Policy.
        /// </p>
        pub fn review_results(
            mut self,
            input: impl Into<crate::model::ReviewResultDetail>,
        ) -> Self {
            let mut v = self.review_results.unwrap_or_default();
            v.push(input.into());
            self.review_results = Some(v);
            self
        }
        /// <p> A list of ReviewResults objects for each action specified in
        /// the Review Policy.
        /// </p>
        pub fn set_review_results(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReviewResultDetail>>,
        ) -> Self {
            self.review_results = input;
            self
        }
        /// Appends an item to `review_actions`.
        ///
        /// To override the contents of this collection use [`set_review_actions`](Self::set_review_actions).
        ///
        /// <p> A list of ReviewAction objects for each action specified in
        /// the Review Policy.
        /// </p>
        pub fn review_actions(
            mut self,
            input: impl Into<crate::model::ReviewActionDetail>,
        ) -> Self {
            let mut v = self.review_actions.unwrap_or_default();
            v.push(input.into());
            self.review_actions = Some(v);
            self
        }
        /// <p> A list of ReviewAction objects for each action specified in
        /// the Review Policy.
        /// </p>
        pub fn set_review_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReviewActionDetail>>,
        ) -> Self {
            self.review_actions = input;
            self
        }
        /// Consumes the builder and constructs a [`ReviewReport`](crate::model::ReviewReport)
        pub fn build(self) -> crate::model::ReviewReport {
            crate::model::ReviewReport {
                review_results: self.review_results,
                review_actions: self.review_actions,
            }
        }
    }
}
impl ReviewReport {
    /// Creates a new builder-style object to manufacture [`ReviewReport`](crate::model::ReviewReport)
    pub fn builder() -> crate::model::review_report::Builder {
        crate::model::review_report::Builder::default()
    }
}

/// <p> Both the AssignmentReviewReport and the HITReviewReport
/// elements contains the ReviewActionDetail data structure. This
/// structure is returned multiple times for each action specified in the
/// Review Policy.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReviewActionDetail {
    /// <p>The unique identifier for the action.</p>
    pub action_id: std::option::Option<std::string::String>,
    /// <p> The nature of the action itself. The Review Policy is
    /// responsible for examining the HIT and Assignments, emitting results,
    /// and deciding which other actions will be necessary. </p>
    pub action_name: std::option::Option<std::string::String>,
    /// <p> The specific HITId or AssignmentID targeted by the action.</p>
    pub target_id: std::option::Option<std::string::String>,
    /// <p> The type of object in TargetId.</p>
    pub target_type: std::option::Option<std::string::String>,
    /// <p> The current disposition of the action: INTENDED, SUCCEEDED,
    /// FAILED, or CANCELLED.
    /// </p>
    pub status: std::option::Option<crate::model::ReviewActionStatus>,
    /// <p> The date when the action was completed.</p>
    pub complete_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> A description of the outcome of the review.</p>
    pub result: std::option::Option<std::string::String>,
    /// <p> Present only when the Results have a FAILED Status.</p>
    pub error_code: std::option::Option<std::string::String>,
}
impl ReviewActionDetail {
    /// <p>The unique identifier for the action.</p>
    pub fn action_id(&self) -> std::option::Option<&str> {
        self.action_id.as_deref()
    }
    /// <p> The nature of the action itself. The Review Policy is
    /// responsible for examining the HIT and Assignments, emitting results,
    /// and deciding which other actions will be necessary. </p>
    pub fn action_name(&self) -> std::option::Option<&str> {
        self.action_name.as_deref()
    }
    /// <p> The specific HITId or AssignmentID targeted by the action.</p>
    pub fn target_id(&self) -> std::option::Option<&str> {
        self.target_id.as_deref()
    }
    /// <p> The type of object in TargetId.</p>
    pub fn target_type(&self) -> std::option::Option<&str> {
        self.target_type.as_deref()
    }
    /// <p> The current disposition of the action: INTENDED, SUCCEEDED,
    /// FAILED, or CANCELLED.
    /// </p>
    pub fn status(&self) -> std::option::Option<&crate::model::ReviewActionStatus> {
        self.status.as_ref()
    }
    /// <p> The date when the action was completed.</p>
    pub fn complete_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.complete_time.as_ref()
    }
    /// <p> A description of the outcome of the review.</p>
    pub fn result(&self) -> std::option::Option<&str> {
        self.result.as_deref()
    }
    /// <p> Present only when the Results have a FAILED Status.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
}
impl std::fmt::Debug for ReviewActionDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReviewActionDetail");
        formatter.field("action_id", &self.action_id);
        formatter.field("action_name", &self.action_name);
        formatter.field("target_id", &self.target_id);
        formatter.field("target_type", &self.target_type);
        formatter.field("status", &self.status);
        formatter.field("complete_time", &self.complete_time);
        formatter.field("result", &self.result);
        formatter.field("error_code", &self.error_code);
        formatter.finish()
    }
}
/// See [`ReviewActionDetail`](crate::model::ReviewActionDetail)
pub mod review_action_detail {
    /// A builder for [`ReviewActionDetail`](crate::model::ReviewActionDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_id: std::option::Option<std::string::String>,
        pub(crate) action_name: std::option::Option<std::string::String>,
        pub(crate) target_id: std::option::Option<std::string::String>,
        pub(crate) target_type: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ReviewActionStatus>,
        pub(crate) complete_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) result: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the action.</p>
        pub fn action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the action.</p>
        pub fn set_action_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_id = input;
            self
        }
        /// <p> The nature of the action itself. The Review Policy is
        /// responsible for examining the HIT and Assignments, emitting results,
        /// and deciding which other actions will be necessary. </p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p> The nature of the action itself. The Review Policy is
        /// responsible for examining the HIT and Assignments, emitting results,
        /// and deciding which other actions will be necessary. </p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input;
            self
        }
        /// <p> The specific HITId or AssignmentID targeted by the action.</p>
        pub fn target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_id = Some(input.into());
            self
        }
        /// <p> The specific HITId or AssignmentID targeted by the action.</p>
        pub fn set_target_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_id = input;
            self
        }
        /// <p> The type of object in TargetId.</p>
        pub fn target_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_type = Some(input.into());
            self
        }
        /// <p> The type of object in TargetId.</p>
        pub fn set_target_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_type = input;
            self
        }
        /// <p> The current disposition of the action: INTENDED, SUCCEEDED,
        /// FAILED, or CANCELLED.
        /// </p>
        pub fn status(mut self, input: crate::model::ReviewActionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The current disposition of the action: INTENDED, SUCCEEDED,
        /// FAILED, or CANCELLED.
        /// </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReviewActionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p> The date when the action was completed.</p>
        pub fn complete_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.complete_time = Some(input);
            self
        }
        /// <p> The date when the action was completed.</p>
        pub fn set_complete_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.complete_time = input;
            self
        }
        /// <p> A description of the outcome of the review.</p>
        pub fn result(mut self, input: impl Into<std::string::String>) -> Self {
            self.result = Some(input.into());
            self
        }
        /// <p> A description of the outcome of the review.</p>
        pub fn set_result(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result = input;
            self
        }
        /// <p> Present only when the Results have a FAILED Status.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p> Present only when the Results have a FAILED Status.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// Consumes the builder and constructs a [`ReviewActionDetail`](crate::model::ReviewActionDetail)
        pub fn build(self) -> crate::model::ReviewActionDetail {
            crate::model::ReviewActionDetail {
                action_id: self.action_id,
                action_name: self.action_name,
                target_id: self.target_id,
                target_type: self.target_type,
                status: self.status,
                complete_time: self.complete_time,
                result: self.result,
                error_code: self.error_code,
            }
        }
    }
}
impl ReviewActionDetail {
    /// Creates a new builder-style object to manufacture [`ReviewActionDetail`](crate::model::ReviewActionDetail)
    pub fn builder() -> crate::model::review_action_detail::Builder {
        crate::model::review_action_detail::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReviewActionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Intended,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReviewActionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Cancelled" => ReviewActionStatus::Cancelled,
            "Failed" => ReviewActionStatus::Failed,
            "Intended" => ReviewActionStatus::Intended,
            "Succeeded" => ReviewActionStatus::Succeeded,
            other => ReviewActionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReviewActionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReviewActionStatus::from(s))
    }
}
impl ReviewActionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReviewActionStatus::Cancelled => "Cancelled",
            ReviewActionStatus::Failed => "Failed",
            ReviewActionStatus::Intended => "Intended",
            ReviewActionStatus::Succeeded => "Succeeded",
            ReviewActionStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Cancelled", "Failed", "Intended", "Succeeded"]
    }
}
impl AsRef<str> for ReviewActionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> This data structure is returned multiple times for each
/// result specified in the Review Policy.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReviewResultDetail {
    /// <p> A unique identifier of the Review action result.
    /// </p>
    pub action_id: std::option::Option<std::string::String>,
    /// <p>The HITID or AssignmentId about which this result was taken.
    /// Note that HIT-level Review Policies will often emit results about
    /// both the HIT itself and its Assignments, while Assignment-level
    /// review policies generally only emit results about the Assignment
    /// itself.
    /// </p>
    pub subject_id: std::option::Option<std::string::String>,
    /// <p> The type of the object from the SubjectId field.</p>
    pub subject_type: std::option::Option<std::string::String>,
    /// <p> Specifies the QuestionId the result is describing. Depending
    /// on whether the TargetType is a HIT or Assignment this results could
    /// specify multiple values. If TargetType is HIT and QuestionId is
    /// absent, then the result describes results of the HIT, including the
    /// HIT agreement score. If ObjectType is Assignment and QuestionId is
    /// absent, then the result describes the Worker's performance on the
    /// HIT.
    /// </p>
    pub question_id: std::option::Option<std::string::String>,
    /// <p> Key identifies the particular piece of reviewed information.
    /// </p>
    pub key: std::option::Option<std::string::String>,
    /// <p> The values of Key provided by the review policies you have
    /// selected.
    /// </p>
    pub value: std::option::Option<std::string::String>,
}
impl ReviewResultDetail {
    /// <p> A unique identifier of the Review action result.
    /// </p>
    pub fn action_id(&self) -> std::option::Option<&str> {
        self.action_id.as_deref()
    }
    /// <p>The HITID or AssignmentId about which this result was taken.
    /// Note that HIT-level Review Policies will often emit results about
    /// both the HIT itself and its Assignments, while Assignment-level
    /// review policies generally only emit results about the Assignment
    /// itself.
    /// </p>
    pub fn subject_id(&self) -> std::option::Option<&str> {
        self.subject_id.as_deref()
    }
    /// <p> The type of the object from the SubjectId field.</p>
    pub fn subject_type(&self) -> std::option::Option<&str> {
        self.subject_type.as_deref()
    }
    /// <p> Specifies the QuestionId the result is describing. Depending
    /// on whether the TargetType is a HIT or Assignment this results could
    /// specify multiple values. If TargetType is HIT and QuestionId is
    /// absent, then the result describes results of the HIT, including the
    /// HIT agreement score. If ObjectType is Assignment and QuestionId is
    /// absent, then the result describes the Worker's performance on the
    /// HIT.
    /// </p>
    pub fn question_id(&self) -> std::option::Option<&str> {
        self.question_id.as_deref()
    }
    /// <p> Key identifies the particular piece of reviewed information.
    /// </p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p> The values of Key provided by the review policies you have
    /// selected.
    /// </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for ReviewResultDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReviewResultDetail");
        formatter.field("action_id", &self.action_id);
        formatter.field("subject_id", &self.subject_id);
        formatter.field("subject_type", &self.subject_type);
        formatter.field("question_id", &self.question_id);
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ReviewResultDetail`](crate::model::ReviewResultDetail)
pub mod review_result_detail {
    /// A builder for [`ReviewResultDetail`](crate::model::ReviewResultDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_id: std::option::Option<std::string::String>,
        pub(crate) subject_id: std::option::Option<std::string::String>,
        pub(crate) subject_type: std::option::Option<std::string::String>,
        pub(crate) question_id: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> A unique identifier of the Review action result.
        /// </p>
        pub fn action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_id = Some(input.into());
            self
        }
        /// <p> A unique identifier of the Review action result.
        /// </p>
        pub fn set_action_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_id = input;
            self
        }
        /// <p>The HITID or AssignmentId about which this result was taken.
        /// Note that HIT-level Review Policies will often emit results about
        /// both the HIT itself and its Assignments, while Assignment-level
        /// review policies generally only emit results about the Assignment
        /// itself.
        /// </p>
        pub fn subject_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_id = Some(input.into());
            self
        }
        /// <p>The HITID or AssignmentId about which this result was taken.
        /// Note that HIT-level Review Policies will often emit results about
        /// both the HIT itself and its Assignments, while Assignment-level
        /// review policies generally only emit results about the Assignment
        /// itself.
        /// </p>
        pub fn set_subject_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_id = input;
            self
        }
        /// <p> The type of the object from the SubjectId field.</p>
        pub fn subject_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_type = Some(input.into());
            self
        }
        /// <p> The type of the object from the SubjectId field.</p>
        pub fn set_subject_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_type = input;
            self
        }
        /// <p> Specifies the QuestionId the result is describing. Depending
        /// on whether the TargetType is a HIT or Assignment this results could
        /// specify multiple values. If TargetType is HIT and QuestionId is
        /// absent, then the result describes results of the HIT, including the
        /// HIT agreement score. If ObjectType is Assignment and QuestionId is
        /// absent, then the result describes the Worker's performance on the
        /// HIT.
        /// </p>
        pub fn question_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.question_id = Some(input.into());
            self
        }
        /// <p> Specifies the QuestionId the result is describing. Depending
        /// on whether the TargetType is a HIT or Assignment this results could
        /// specify multiple values. If TargetType is HIT and QuestionId is
        /// absent, then the result describes results of the HIT, including the
        /// HIT agreement score. If ObjectType is Assignment and QuestionId is
        /// absent, then the result describes the Worker's performance on the
        /// HIT.
        /// </p>
        pub fn set_question_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question_id = input;
            self
        }
        /// <p> Key identifies the particular piece of reviewed information.
        /// </p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p> Key identifies the particular piece of reviewed information.
        /// </p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p> The values of Key provided by the review policies you have
        /// selected.
        /// </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p> The values of Key provided by the review policies you have
        /// selected.
        /// </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ReviewResultDetail`](crate::model::ReviewResultDetail)
        pub fn build(self) -> crate::model::ReviewResultDetail {
            crate::model::ReviewResultDetail {
                action_id: self.action_id,
                subject_id: self.subject_id,
                subject_type: self.subject_type,
                question_id: self.question_id,
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl ReviewResultDetail {
    /// Creates a new builder-style object to manufacture [`ReviewResultDetail`](crate::model::ReviewResultDetail)
    pub fn builder() -> crate::model::review_result_detail::Builder {
        crate::model::review_result_detail::Builder::default()
    }
}

/// <p> HIT Review Policy data structures represent HIT review
/// policies, which you specify when you create a HIT.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReviewPolicy {
    /// <p> Name of a Review Policy: SimplePlurality/2011-09-01 or
    /// ScoreMyKnownAnswers/2011-09-01
    /// </p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>Name of the parameter from the Review policy.</p>
    pub parameters: std::option::Option<std::vec::Vec<crate::model::PolicyParameter>>,
}
impl ReviewPolicy {
    /// <p> Name of a Review Policy: SimplePlurality/2011-09-01 or
    /// ScoreMyKnownAnswers/2011-09-01
    /// </p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>Name of the parameter from the Review policy.</p>
    pub fn parameters(&self) -> std::option::Option<&[crate::model::PolicyParameter]> {
        self.parameters.as_deref()
    }
}
impl std::fmt::Debug for ReviewPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReviewPolicy");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}
/// See [`ReviewPolicy`](crate::model::ReviewPolicy)
pub mod review_policy {
    /// A builder for [`ReviewPolicy`](crate::model::ReviewPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::vec::Vec<crate::model::PolicyParameter>>,
    }
    impl Builder {
        /// <p> Name of a Review Policy: SimplePlurality/2011-09-01 or
        /// ScoreMyKnownAnswers/2011-09-01
        /// </p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p> Name of a Review Policy: SimplePlurality/2011-09-01 or
        /// ScoreMyKnownAnswers/2011-09-01
        /// </p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Appends an item to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>Name of the parameter from the Review policy.</p>
        pub fn parameters(mut self, input: impl Into<crate::model::PolicyParameter>) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(input.into());
            self.parameters = Some(v);
            self
        }
        /// <p>Name of the parameter from the Review policy.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PolicyParameter>>,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`ReviewPolicy`](crate::model::ReviewPolicy)
        pub fn build(self) -> crate::model::ReviewPolicy {
            crate::model::ReviewPolicy {
                policy_name: self.policy_name,
                parameters: self.parameters,
            }
        }
    }
}
impl ReviewPolicy {
    /// Creates a new builder-style object to manufacture [`ReviewPolicy`](crate::model::ReviewPolicy)
    pub fn builder() -> crate::model::review_policy::Builder {
        crate::model::review_policy::Builder::default()
    }
}

/// <p> Name of the parameter from the Review policy.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyParameter {
    /// <p> Name of the parameter from the list of Review Polices.
    /// </p>
    pub key: std::option::Option<std::string::String>,
    /// <p> The list of values of the Parameter</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> List of ParameterMapEntry objects.
    /// </p>
    pub map_entries: std::option::Option<std::vec::Vec<crate::model::ParameterMapEntry>>,
}
impl PolicyParameter {
    /// <p> Name of the parameter from the list of Review Polices.
    /// </p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p> The list of values of the Parameter</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
    /// <p> List of ParameterMapEntry objects.
    /// </p>
    pub fn map_entries(&self) -> std::option::Option<&[crate::model::ParameterMapEntry]> {
        self.map_entries.as_deref()
    }
}
impl std::fmt::Debug for PolicyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyParameter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("map_entries", &self.map_entries);
        formatter.finish()
    }
}
/// See [`PolicyParameter`](crate::model::PolicyParameter)
pub mod policy_parameter {
    /// A builder for [`PolicyParameter`](crate::model::PolicyParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) map_entries: std::option::Option<std::vec::Vec<crate::model::ParameterMapEntry>>,
    }
    impl Builder {
        /// <p> Name of the parameter from the list of Review Polices.
        /// </p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p> Name of the parameter from the list of Review Polices.
        /// </p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p> The list of values of the Parameter</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p> The list of values of the Parameter</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Appends an item to `map_entries`.
        ///
        /// To override the contents of this collection use [`set_map_entries`](Self::set_map_entries).
        ///
        /// <p> List of ParameterMapEntry objects.
        /// </p>
        pub fn map_entries(mut self, input: impl Into<crate::model::ParameterMapEntry>) -> Self {
            let mut v = self.map_entries.unwrap_or_default();
            v.push(input.into());
            self.map_entries = Some(v);
            self
        }
        /// <p> List of ParameterMapEntry objects.
        /// </p>
        pub fn set_map_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParameterMapEntry>>,
        ) -> Self {
            self.map_entries = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyParameter`](crate::model::PolicyParameter)
        pub fn build(self) -> crate::model::PolicyParameter {
            crate::model::PolicyParameter {
                key: self.key,
                values: self.values,
                map_entries: self.map_entries,
            }
        }
    }
}
impl PolicyParameter {
    /// Creates a new builder-style object to manufacture [`PolicyParameter`](crate::model::PolicyParameter)
    pub fn builder() -> crate::model::policy_parameter::Builder {
        crate::model::policy_parameter::Builder::default()
    }
}

/// <p> This data structure is the data type for the AnswerKey
/// parameter of the ScoreMyKnownAnswers/2011-09-01 Review Policy.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterMapEntry {
    /// <p> The QuestionID from the HIT that is used to identify which
    /// question requires Mechanical Turk to score as part of the
    /// ScoreMyKnownAnswers/2011-09-01 Review Policy.
    /// </p>
    pub key: std::option::Option<std::string::String>,
    /// <p> The list of answers to the question specified in the
    /// MapEntry Key element. The Worker must match all values in order for
    /// the answer to be scored correctly.
    /// </p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ParameterMapEntry {
    /// <p> The QuestionID from the HIT that is used to identify which
    /// question requires Mechanical Turk to score as part of the
    /// ScoreMyKnownAnswers/2011-09-01 Review Policy.
    /// </p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p> The list of answers to the question specified in the
    /// MapEntry Key element. The Worker must match all values in order for
    /// the answer to be scored correctly.
    /// </p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl std::fmt::Debug for ParameterMapEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterMapEntry");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`ParameterMapEntry`](crate::model::ParameterMapEntry)
pub mod parameter_map_entry {
    /// A builder for [`ParameterMapEntry`](crate::model::ParameterMapEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The QuestionID from the HIT that is used to identify which
        /// question requires Mechanical Turk to score as part of the
        /// ScoreMyKnownAnswers/2011-09-01 Review Policy.
        /// </p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p> The QuestionID from the HIT that is used to identify which
        /// question requires Mechanical Turk to score as part of the
        /// ScoreMyKnownAnswers/2011-09-01 Review Policy.
        /// </p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p> The list of answers to the question specified in the
        /// MapEntry Key element. The Worker must match all values in order for
        /// the answer to be scored correctly.
        /// </p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p> The list of answers to the question specified in the
        /// MapEntry Key element. The Worker must match all values in order for
        /// the answer to be scored correctly.
        /// </p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterMapEntry`](crate::model::ParameterMapEntry)
        pub fn build(self) -> crate::model::ParameterMapEntry {
            crate::model::ParameterMapEntry {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl ParameterMapEntry {
    /// Creates a new builder-style object to manufacture [`ParameterMapEntry`](crate::model::ParameterMapEntry)
    pub fn builder() -> crate::model::parameter_map_entry::Builder {
        crate::model::parameter_map_entry::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReviewPolicyLevel {
    #[allow(missing_docs)] // documentation missing in model
    Assignment,
    #[allow(missing_docs)] // documentation missing in model
    Hit,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReviewPolicyLevel {
    fn from(s: &str) -> Self {
        match s {
            "Assignment" => ReviewPolicyLevel::Assignment,
            "HIT" => ReviewPolicyLevel::Hit,
            other => ReviewPolicyLevel::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReviewPolicyLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReviewPolicyLevel::from(s))
    }
}
impl ReviewPolicyLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReviewPolicyLevel::Assignment => "Assignment",
            ReviewPolicyLevel::Hit => "HIT",
            ReviewPolicyLevel::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Assignment", "HIT"]
    }
}
impl AsRef<str> for ReviewPolicyLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The HIT data structure represents a single HIT, including
/// all the information necessary for a Worker to accept and complete the
/// HIT.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Hit {
    /// <p> A unique identifier for the HIT.</p>
    pub hit_id: std::option::Option<std::string::String>,
    /// <p>The ID of the HIT type of this HIT</p>
    pub hit_type_id: std::option::Option<std::string::String>,
    /// <p> The ID of the HIT Group of this HIT.</p>
    pub hit_group_id: std::option::Option<std::string::String>,
    /// <p> The ID of the HIT Layout of this HIT.</p>
    pub hit_layout_id: std::option::Option<std::string::String>,
    /// <p> The date and time the HIT was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> The title of the HIT.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p> A general description of the HIT.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p> The data the Worker completing the HIT uses produce the
    /// results. This is either either a QuestionForm, HTMLQuestion or an
    /// ExternalQuestion data structure.</p>
    pub question: std::option::Option<std::string::String>,
    /// <p> One or more words or phrases that describe the HIT,
    /// separated by commas. Search terms similar to the keywords of a HIT
    /// are more likely to have the HIT in the search results.</p>
    pub keywords: std::option::Option<std::string::String>,
    /// <p>The status of the HIT and its assignments. Valid Values are
    /// Assignable | Unassignable | Reviewable | Reviewing | Disposed.
    /// </p>
    pub hit_status: std::option::Option<crate::model::HitStatus>,
    /// <p>The number of times the HIT can be accepted and completed
    /// before the HIT becomes unavailable.
    /// </p>
    pub max_assignments: std::option::Option<i32>,
    /// <p>A string representing a currency amount.</p>
    pub reward: std::option::Option<std::string::String>,
    /// <p>The amount of time, in seconds, after the Worker submits an
    /// assignment for the HIT that the results are automatically approved by
    /// Amazon Mechanical Turk. This is the amount of time the Requester has
    /// to reject an assignment submitted by a Worker before the assignment
    /// is auto-approved and the Worker is paid.
    /// </p>
    pub auto_approval_delay_in_seconds: std::option::Option<i64>,
    /// <p>The date and time the HIT expires.</p>
    pub expiration: std::option::Option<aws_smithy_types::Instant>,
    /// <p> The length of time, in seconds, that a Worker has to
    /// complete the HIT after accepting it.</p>
    pub assignment_duration_in_seconds: std::option::Option<i64>,
    /// <p> An arbitrary data field the Requester who created the HIT
    /// can use. This field is visible only to the creator of the HIT.</p>
    pub requester_annotation: std::option::Option<std::string::String>,
    /// <p>
    /// Conditions that a Worker's Qualifications must meet in order
    /// to accept the HIT. A HIT can have between zero and ten
    /// Qualification requirements. All requirements must be met in
    /// order for a Worker to accept the HIT. Additionally, other
    /// actions can be restricted using the <code>ActionsGuarded</code>
    /// field on each <code>QualificationRequirement</code> structure.
    /// </p>
    pub qualification_requirements:
        std::option::Option<std::vec::Vec<crate::model::QualificationRequirement>>,
    /// <p> Indicates the review status of the HIT. Valid Values are
    /// NotReviewed | MarkedForReview | ReviewedAppropriate |
    /// ReviewedInappropriate.</p>
    pub hit_review_status: std::option::Option<crate::model::HitReviewStatus>,
    /// <p> The number of assignments for this HIT that are being
    /// previewed or have been accepted by Workers, but have not yet been
    /// submitted, returned, or abandoned.</p>
    pub number_of_assignments_pending: std::option::Option<i32>,
    /// <p> The number of assignments for this HIT that are available
    /// for Workers to accept.</p>
    pub number_of_assignments_available: std::option::Option<i32>,
    /// <p> The number of assignments for this HIT that have been
    /// approved or rejected.</p>
    pub number_of_assignments_completed: std::option::Option<i32>,
}
impl Hit {
    /// <p> A unique identifier for the HIT.</p>
    pub fn hit_id(&self) -> std::option::Option<&str> {
        self.hit_id.as_deref()
    }
    /// <p>The ID of the HIT type of this HIT</p>
    pub fn hit_type_id(&self) -> std::option::Option<&str> {
        self.hit_type_id.as_deref()
    }
    /// <p> The ID of the HIT Group of this HIT.</p>
    pub fn hit_group_id(&self) -> std::option::Option<&str> {
        self.hit_group_id.as_deref()
    }
    /// <p> The ID of the HIT Layout of this HIT.</p>
    pub fn hit_layout_id(&self) -> std::option::Option<&str> {
        self.hit_layout_id.as_deref()
    }
    /// <p> The date and time the HIT was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.creation_time.as_ref()
    }
    /// <p> The title of the HIT.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p> A general description of the HIT.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The data the Worker completing the HIT uses produce the
    /// results. This is either either a QuestionForm, HTMLQuestion or an
    /// ExternalQuestion data structure.</p>
    pub fn question(&self) -> std::option::Option<&str> {
        self.question.as_deref()
    }
    /// <p> One or more words or phrases that describe the HIT,
    /// separated by commas. Search terms similar to the keywords of a HIT
    /// are more likely to have the HIT in the search results.</p>
    pub fn keywords(&self) -> std::option::Option<&str> {
        self.keywords.as_deref()
    }
    /// <p>The status of the HIT and its assignments. Valid Values are
    /// Assignable | Unassignable | Reviewable | Reviewing | Disposed.
    /// </p>
    pub fn hit_status(&self) -> std::option::Option<&crate::model::HitStatus> {
        self.hit_status.as_ref()
    }
    /// <p>The number of times the HIT can be accepted and completed
    /// before the HIT becomes unavailable.
    /// </p>
    pub fn max_assignments(&self) -> std::option::Option<i32> {
        self.max_assignments
    }
    /// <p>A string representing a currency amount.</p>
    pub fn reward(&self) -> std::option::Option<&str> {
        self.reward.as_deref()
    }
    /// <p>The amount of time, in seconds, after the Worker submits an
    /// assignment for the HIT that the results are automatically approved by
    /// Amazon Mechanical Turk. This is the amount of time the Requester has
    /// to reject an assignment submitted by a Worker before the assignment
    /// is auto-approved and the Worker is paid.
    /// </p>
    pub fn auto_approval_delay_in_seconds(&self) -> std::option::Option<i64> {
        self.auto_approval_delay_in_seconds
    }
    /// <p>The date and time the HIT expires.</p>
    pub fn expiration(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.expiration.as_ref()
    }
    /// <p> The length of time, in seconds, that a Worker has to
    /// complete the HIT after accepting it.</p>
    pub fn assignment_duration_in_seconds(&self) -> std::option::Option<i64> {
        self.assignment_duration_in_seconds
    }
    /// <p> An arbitrary data field the Requester who created the HIT
    /// can use. This field is visible only to the creator of the HIT.</p>
    pub fn requester_annotation(&self) -> std::option::Option<&str> {
        self.requester_annotation.as_deref()
    }
    /// <p>
    /// Conditions that a Worker's Qualifications must meet in order
    /// to accept the HIT. A HIT can have between zero and ten
    /// Qualification requirements. All requirements must be met in
    /// order for a Worker to accept the HIT. Additionally, other
    /// actions can be restricted using the <code>ActionsGuarded</code>
    /// field on each <code>QualificationRequirement</code> structure.
    /// </p>
    pub fn qualification_requirements(
        &self,
    ) -> std::option::Option<&[crate::model::QualificationRequirement]> {
        self.qualification_requirements.as_deref()
    }
    /// <p> Indicates the review status of the HIT. Valid Values are
    /// NotReviewed | MarkedForReview | ReviewedAppropriate |
    /// ReviewedInappropriate.</p>
    pub fn hit_review_status(&self) -> std::option::Option<&crate::model::HitReviewStatus> {
        self.hit_review_status.as_ref()
    }
    /// <p> The number of assignments for this HIT that are being
    /// previewed or have been accepted by Workers, but have not yet been
    /// submitted, returned, or abandoned.</p>
    pub fn number_of_assignments_pending(&self) -> std::option::Option<i32> {
        self.number_of_assignments_pending
    }
    /// <p> The number of assignments for this HIT that are available
    /// for Workers to accept.</p>
    pub fn number_of_assignments_available(&self) -> std::option::Option<i32> {
        self.number_of_assignments_available
    }
    /// <p> The number of assignments for this HIT that have been
    /// approved or rejected.</p>
    pub fn number_of_assignments_completed(&self) -> std::option::Option<i32> {
        self.number_of_assignments_completed
    }
}
impl std::fmt::Debug for Hit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Hit");
        formatter.field("hit_id", &self.hit_id);
        formatter.field("hit_type_id", &self.hit_type_id);
        formatter.field("hit_group_id", &self.hit_group_id);
        formatter.field("hit_layout_id", &self.hit_layout_id);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("title", &self.title);
        formatter.field("description", &self.description);
        formatter.field("question", &self.question);
        formatter.field("keywords", &self.keywords);
        formatter.field("hit_status", &self.hit_status);
        formatter.field("max_assignments", &self.max_assignments);
        formatter.field("reward", &self.reward);
        formatter.field(
            "auto_approval_delay_in_seconds",
            &self.auto_approval_delay_in_seconds,
        );
        formatter.field("expiration", &self.expiration);
        formatter.field(
            "assignment_duration_in_seconds",
            &self.assignment_duration_in_seconds,
        );
        formatter.field("requester_annotation", &self.requester_annotation);
        formatter.field(
            "qualification_requirements",
            &self.qualification_requirements,
        );
        formatter.field("hit_review_status", &self.hit_review_status);
        formatter.field(
            "number_of_assignments_pending",
            &self.number_of_assignments_pending,
        );
        formatter.field(
            "number_of_assignments_available",
            &self.number_of_assignments_available,
        );
        formatter.field(
            "number_of_assignments_completed",
            &self.number_of_assignments_completed,
        );
        formatter.finish()
    }
}
/// See [`Hit`](crate::model::Hit)
pub mod hit {
    /// A builder for [`Hit`](crate::model::Hit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hit_id: std::option::Option<std::string::String>,
        pub(crate) hit_type_id: std::option::Option<std::string::String>,
        pub(crate) hit_group_id: std::option::Option<std::string::String>,
        pub(crate) hit_layout_id: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) question: std::option::Option<std::string::String>,
        pub(crate) keywords: std::option::Option<std::string::String>,
        pub(crate) hit_status: std::option::Option<crate::model::HitStatus>,
        pub(crate) max_assignments: std::option::Option<i32>,
        pub(crate) reward: std::option::Option<std::string::String>,
        pub(crate) auto_approval_delay_in_seconds: std::option::Option<i64>,
        pub(crate) expiration: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) assignment_duration_in_seconds: std::option::Option<i64>,
        pub(crate) requester_annotation: std::option::Option<std::string::String>,
        pub(crate) qualification_requirements:
            std::option::Option<std::vec::Vec<crate::model::QualificationRequirement>>,
        pub(crate) hit_review_status: std::option::Option<crate::model::HitReviewStatus>,
        pub(crate) number_of_assignments_pending: std::option::Option<i32>,
        pub(crate) number_of_assignments_available: std::option::Option<i32>,
        pub(crate) number_of_assignments_completed: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> A unique identifier for the HIT.</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hit_id = Some(input.into());
            self
        }
        /// <p> A unique identifier for the HIT.</p>
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hit_id = input;
            self
        }
        /// <p>The ID of the HIT type of this HIT</p>
        pub fn hit_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hit_type_id = Some(input.into());
            self
        }
        /// <p>The ID of the HIT type of this HIT</p>
        pub fn set_hit_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hit_type_id = input;
            self
        }
        /// <p> The ID of the HIT Group of this HIT.</p>
        pub fn hit_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hit_group_id = Some(input.into());
            self
        }
        /// <p> The ID of the HIT Group of this HIT.</p>
        pub fn set_hit_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hit_group_id = input;
            self
        }
        /// <p> The ID of the HIT Layout of this HIT.</p>
        pub fn hit_layout_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hit_layout_id = Some(input.into());
            self
        }
        /// <p> The ID of the HIT Layout of this HIT.</p>
        pub fn set_hit_layout_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hit_layout_id = input;
            self
        }
        /// <p> The date and time the HIT was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p> The date and time the HIT was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p> The title of the HIT.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p> The title of the HIT.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p> A general description of the HIT.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A general description of the HIT.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The data the Worker completing the HIT uses produce the
        /// results. This is either either a QuestionForm, HTMLQuestion or an
        /// ExternalQuestion data structure.</p>
        pub fn question(mut self, input: impl Into<std::string::String>) -> Self {
            self.question = Some(input.into());
            self
        }
        /// <p> The data the Worker completing the HIT uses produce the
        /// results. This is either either a QuestionForm, HTMLQuestion or an
        /// ExternalQuestion data structure.</p>
        pub fn set_question(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.question = input;
            self
        }
        /// <p> One or more words or phrases that describe the HIT,
        /// separated by commas. Search terms similar to the keywords of a HIT
        /// are more likely to have the HIT in the search results.</p>
        pub fn keywords(mut self, input: impl Into<std::string::String>) -> Self {
            self.keywords = Some(input.into());
            self
        }
        /// <p> One or more words or phrases that describe the HIT,
        /// separated by commas. Search terms similar to the keywords of a HIT
        /// are more likely to have the HIT in the search results.</p>
        pub fn set_keywords(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.keywords = input;
            self
        }
        /// <p>The status of the HIT and its assignments. Valid Values are
        /// Assignable | Unassignable | Reviewable | Reviewing | Disposed.
        /// </p>
        pub fn hit_status(mut self, input: crate::model::HitStatus) -> Self {
            self.hit_status = Some(input);
            self
        }
        /// <p>The status of the HIT and its assignments. Valid Values are
        /// Assignable | Unassignable | Reviewable | Reviewing | Disposed.
        /// </p>
        pub fn set_hit_status(
            mut self,
            input: std::option::Option<crate::model::HitStatus>,
        ) -> Self {
            self.hit_status = input;
            self
        }
        /// <p>The number of times the HIT can be accepted and completed
        /// before the HIT becomes unavailable.
        /// </p>
        pub fn max_assignments(mut self, input: i32) -> Self {
            self.max_assignments = Some(input);
            self
        }
        /// <p>The number of times the HIT can be accepted and completed
        /// before the HIT becomes unavailable.
        /// </p>
        pub fn set_max_assignments(mut self, input: std::option::Option<i32>) -> Self {
            self.max_assignments = input;
            self
        }
        /// <p>A string representing a currency amount.</p>
        pub fn reward(mut self, input: impl Into<std::string::String>) -> Self {
            self.reward = Some(input.into());
            self
        }
        /// <p>A string representing a currency amount.</p>
        pub fn set_reward(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reward = input;
            self
        }
        /// <p>The amount of time, in seconds, after the Worker submits an
        /// assignment for the HIT that the results are automatically approved by
        /// Amazon Mechanical Turk. This is the amount of time the Requester has
        /// to reject an assignment submitted by a Worker before the assignment
        /// is auto-approved and the Worker is paid.
        /// </p>
        pub fn auto_approval_delay_in_seconds(mut self, input: i64) -> Self {
            self.auto_approval_delay_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, after the Worker submits an
        /// assignment for the HIT that the results are automatically approved by
        /// Amazon Mechanical Turk. This is the amount of time the Requester has
        /// to reject an assignment submitted by a Worker before the assignment
        /// is auto-approved and the Worker is paid.
        /// </p>
        pub fn set_auto_approval_delay_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.auto_approval_delay_in_seconds = input;
            self
        }
        /// <p>The date and time the HIT expires.</p>
        pub fn expiration(mut self, input: aws_smithy_types::Instant) -> Self {
            self.expiration = Some(input);
            self
        }
        /// <p>The date and time the HIT expires.</p>
        pub fn set_expiration(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.expiration = input;
            self
        }
        /// <p> The length of time, in seconds, that a Worker has to
        /// complete the HIT after accepting it.</p>
        pub fn assignment_duration_in_seconds(mut self, input: i64) -> Self {
            self.assignment_duration_in_seconds = Some(input);
            self
        }
        /// <p> The length of time, in seconds, that a Worker has to
        /// complete the HIT after accepting it.</p>
        pub fn set_assignment_duration_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.assignment_duration_in_seconds = input;
            self
        }
        /// <p> An arbitrary data field the Requester who created the HIT
        /// can use. This field is visible only to the creator of the HIT.</p>
        pub fn requester_annotation(mut self, input: impl Into<std::string::String>) -> Self {
            self.requester_annotation = Some(input.into());
            self
        }
        /// <p> An arbitrary data field the Requester who created the HIT
        /// can use. This field is visible only to the creator of the HIT.</p>
        pub fn set_requester_annotation(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.requester_annotation = input;
            self
        }
        /// Appends an item to `qualification_requirements`.
        ///
        /// To override the contents of this collection use [`set_qualification_requirements`](Self::set_qualification_requirements).
        ///
        /// <p>
        /// Conditions that a Worker's Qualifications must meet in order
        /// to accept the HIT. A HIT can have between zero and ten
        /// Qualification requirements. All requirements must be met in
        /// order for a Worker to accept the HIT. Additionally, other
        /// actions can be restricted using the <code>ActionsGuarded</code>
        /// field on each <code>QualificationRequirement</code> structure.
        /// </p>
        pub fn qualification_requirements(
            mut self,
            input: impl Into<crate::model::QualificationRequirement>,
        ) -> Self {
            let mut v = self.qualification_requirements.unwrap_or_default();
            v.push(input.into());
            self.qualification_requirements = Some(v);
            self
        }
        /// <p>
        /// Conditions that a Worker's Qualifications must meet in order
        /// to accept the HIT. A HIT can have between zero and ten
        /// Qualification requirements. All requirements must be met in
        /// order for a Worker to accept the HIT. Additionally, other
        /// actions can be restricted using the <code>ActionsGuarded</code>
        /// field on each <code>QualificationRequirement</code> structure.
        /// </p>
        pub fn set_qualification_requirements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QualificationRequirement>>,
        ) -> Self {
            self.qualification_requirements = input;
            self
        }
        /// <p> Indicates the review status of the HIT. Valid Values are
        /// NotReviewed | MarkedForReview | ReviewedAppropriate |
        /// ReviewedInappropriate.</p>
        pub fn hit_review_status(mut self, input: crate::model::HitReviewStatus) -> Self {
            self.hit_review_status = Some(input);
            self
        }
        /// <p> Indicates the review status of the HIT. Valid Values are
        /// NotReviewed | MarkedForReview | ReviewedAppropriate |
        /// ReviewedInappropriate.</p>
        pub fn set_hit_review_status(
            mut self,
            input: std::option::Option<crate::model::HitReviewStatus>,
        ) -> Self {
            self.hit_review_status = input;
            self
        }
        /// <p> The number of assignments for this HIT that are being
        /// previewed or have been accepted by Workers, but have not yet been
        /// submitted, returned, or abandoned.</p>
        pub fn number_of_assignments_pending(mut self, input: i32) -> Self {
            self.number_of_assignments_pending = Some(input);
            self
        }
        /// <p> The number of assignments for this HIT that are being
        /// previewed or have been accepted by Workers, but have not yet been
        /// submitted, returned, or abandoned.</p>
        pub fn set_number_of_assignments_pending(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.number_of_assignments_pending = input;
            self
        }
        /// <p> The number of assignments for this HIT that are available
        /// for Workers to accept.</p>
        pub fn number_of_assignments_available(mut self, input: i32) -> Self {
            self.number_of_assignments_available = Some(input);
            self
        }
        /// <p> The number of assignments for this HIT that are available
        /// for Workers to accept.</p>
        pub fn set_number_of_assignments_available(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.number_of_assignments_available = input;
            self
        }
        /// <p> The number of assignments for this HIT that have been
        /// approved or rejected.</p>
        pub fn number_of_assignments_completed(mut self, input: i32) -> Self {
            self.number_of_assignments_completed = Some(input);
            self
        }
        /// <p> The number of assignments for this HIT that have been
        /// approved or rejected.</p>
        pub fn set_number_of_assignments_completed(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.number_of_assignments_completed = input;
            self
        }
        /// Consumes the builder and constructs a [`Hit`](crate::model::Hit)
        pub fn build(self) -> crate::model::Hit {
            crate::model::Hit {
                hit_id: self.hit_id,
                hit_type_id: self.hit_type_id,
                hit_group_id: self.hit_group_id,
                hit_layout_id: self.hit_layout_id,
                creation_time: self.creation_time,
                title: self.title,
                description: self.description,
                question: self.question,
                keywords: self.keywords,
                hit_status: self.hit_status,
                max_assignments: self.max_assignments,
                reward: self.reward,
                auto_approval_delay_in_seconds: self.auto_approval_delay_in_seconds,
                expiration: self.expiration,
                assignment_duration_in_seconds: self.assignment_duration_in_seconds,
                requester_annotation: self.requester_annotation,
                qualification_requirements: self.qualification_requirements,
                hit_review_status: self.hit_review_status,
                number_of_assignments_pending: self.number_of_assignments_pending,
                number_of_assignments_available: self.number_of_assignments_available,
                number_of_assignments_completed: self.number_of_assignments_completed,
            }
        }
    }
}
impl Hit {
    /// Creates a new builder-style object to manufacture [`Hit`](crate::model::Hit)
    pub fn builder() -> crate::model::hit::Builder {
        crate::model::hit::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HitReviewStatus {
    #[allow(missing_docs)] // documentation missing in model
    MarkedForReview,
    #[allow(missing_docs)] // documentation missing in model
    NotReviewed,
    #[allow(missing_docs)] // documentation missing in model
    ReviewedAppropriate,
    #[allow(missing_docs)] // documentation missing in model
    ReviewedInappropriate,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HitReviewStatus {
    fn from(s: &str) -> Self {
        match s {
            "MarkedForReview" => HitReviewStatus::MarkedForReview,
            "NotReviewed" => HitReviewStatus::NotReviewed,
            "ReviewedAppropriate" => HitReviewStatus::ReviewedAppropriate,
            "ReviewedInappropriate" => HitReviewStatus::ReviewedInappropriate,
            other => HitReviewStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HitReviewStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HitReviewStatus::from(s))
    }
}
impl HitReviewStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HitReviewStatus::MarkedForReview => "MarkedForReview",
            HitReviewStatus::NotReviewed => "NotReviewed",
            HitReviewStatus::ReviewedAppropriate => "ReviewedAppropriate",
            HitReviewStatus::ReviewedInappropriate => "ReviewedInappropriate",
            HitReviewStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "MarkedForReview",
            "NotReviewed",
            "ReviewedAppropriate",
            "ReviewedInappropriate",
        ]
    }
}
impl AsRef<str> for HitReviewStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>
/// The QualificationRequirement data structure describes a Qualification that a Worker must have
/// before the Worker is allowed to accept a HIT.
/// A requirement may optionally state that a Worker must have the Qualification in order to preview the HIT, or
/// see the HIT in search results.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QualificationRequirement {
    /// <p> The ID of the Qualification type for the requirement.</p>
    pub qualification_type_id: std::option::Option<std::string::String>,
    /// <p>The kind of comparison to make against a Qualification's
    /// value. You can compare a Qualification's value to an IntegerValue to
    /// see if it is LessThan, LessThanOrEqualTo, GreaterThan,
    /// GreaterThanOrEqualTo, EqualTo, or NotEqualTo the IntegerValue. You
    /// can compare it to a LocaleValue to see if it is EqualTo, or
    /// NotEqualTo the LocaleValue. You can check to see if the value is In
    /// or NotIn a set of IntegerValue
    /// or LocaleValue values. Lastly, a
    /// Qualification requirement can also
    /// test if a Qualification Exists or
    /// DoesNotExist in the user's profile,
    /// regardless of its value.
    /// </p>
    pub comparator: std::option::Option<crate::model::Comparator>,
    /// <p> The integer value to compare against the Qualification's
    /// value. IntegerValue must not be present if Comparator is Exists or
    /// DoesNotExist. IntegerValue can only be used if the Qualification type
    /// has an integer value; it cannot be used with the Worker_Locale
    /// QualificationType ID. When performing a set comparison by using the
    /// In or the NotIn comparator, you can use up to 15 IntegerValue
    /// elements in a QualificationRequirement data structure.
    /// </p>
    pub integer_values: std::option::Option<std::vec::Vec<i32>>,
    /// <p> The locale value to compare against the Qualification's
    /// value. The local value must be a valid ISO 3166 country code or
    /// supports ISO 3166-2 subdivisions. LocaleValue can only be used with a
    /// Worker_Locale QualificationType ID. LocaleValue can only be used with
    /// the EqualTo, NotEqualTo, In, and NotIn comparators. You must only use
    /// a single LocaleValue element when using the EqualTo or NotEqualTo
    /// comparators. When performing a set comparison by using the In or the
    /// NotIn comparator, you can use up to 30 LocaleValue elements in a
    /// QualificationRequirement data structure.
    /// </p>
    pub locale_values: std::option::Option<std::vec::Vec<crate::model::Locale>>,
    /// <p> DEPRECATED: Use the <code>ActionsGuarded</code> field instead.
    /// If RequiredToPreview is true, the question data for the HIT will not be shown
    /// when a Worker whose Qualifications do not meet this requirement tries
    /// to preview the HIT. That is, a Worker's Qualifications must meet all
    /// of the requirements for which RequiredToPreview is true in order to
    /// preview the HIT. If a Worker meets all of the requirements where
    /// RequiredToPreview is true (or if there are no such requirements), but
    /// does not meet all of the requirements for the HIT, the Worker will be
    /// allowed to preview the HIT's question data, but will not be allowed
    /// to accept and complete the HIT. The default is false. This should not
    /// be used in combination with the <code>ActionsGuarded</code> field.
    /// </p>
    pub required_to_preview: std::option::Option<bool>,
    /// <p> Setting this attribute prevents Workers whose Qualifications do not meet
    /// this QualificationRequirement from taking the specified action. Valid arguments include
    /// "Accept" (Worker cannot accept the HIT, but can preview the HIT and see it in their search results),
    /// "PreviewAndAccept" (Worker cannot accept or preview the HIT, but can see the HIT in their search results),
    /// and "DiscoverPreviewAndAccept" (Worker cannot accept, preview, or see the HIT in their search results). It's possible for you to create a HIT with multiple
    /// QualificationRequirements (which can have different values for the ActionGuarded attribute). In this case,
    /// the Worker is only permitted to perform an action when they have met all QualificationRequirements guarding
    /// the action. The actions in the order of least restrictive to most restrictive are Discover, Preview and Accept.
    /// For example, if a Worker meets all QualificationRequirements that are set to DiscoverPreviewAndAccept, but do
    /// not meet all requirements that are set with PreviewAndAccept, then the Worker will be able to Discover, i.e. see the
    /// HIT in their search result, but will not be able to Preview or Accept the HIT. ActionsGuarded should not be used in combination with the
    /// <code>RequiredToPreview</code> field.
    /// </p>
    pub actions_guarded: std::option::Option<crate::model::HitAccessActions>,
}
impl QualificationRequirement {
    /// <p> The ID of the Qualification type for the requirement.</p>
    pub fn qualification_type_id(&self) -> std::option::Option<&str> {
        self.qualification_type_id.as_deref()
    }
    /// <p>The kind of comparison to make against a Qualification's
    /// value. You can compare a Qualification's value to an IntegerValue to
    /// see if it is LessThan, LessThanOrEqualTo, GreaterThan,
    /// GreaterThanOrEqualTo, EqualTo, or NotEqualTo the IntegerValue. You
    /// can compare it to a LocaleValue to see if it is EqualTo, or
    /// NotEqualTo the LocaleValue. You can check to see if the value is In
    /// or NotIn a set of IntegerValue
    /// or LocaleValue values. Lastly, a
    /// Qualification requirement can also
    /// test if a Qualification Exists or
    /// DoesNotExist in the user's profile,
    /// regardless of its value.
    /// </p>
    pub fn comparator(&self) -> std::option::Option<&crate::model::Comparator> {
        self.comparator.as_ref()
    }
    /// <p> The integer value to compare against the Qualification's
    /// value. IntegerValue must not be present if Comparator is Exists or
    /// DoesNotExist. IntegerValue can only be used if the Qualification type
    /// has an integer value; it cannot be used with the Worker_Locale
    /// QualificationType ID. When performing a set comparison by using the
    /// In or the NotIn comparator, you can use up to 15 IntegerValue
    /// elements in a QualificationRequirement data structure.
    /// </p>
    pub fn integer_values(&self) -> std::option::Option<&[i32]> {
        self.integer_values.as_deref()
    }
    /// <p> The locale value to compare against the Qualification's
    /// value. The local value must be a valid ISO 3166 country code or
    /// supports ISO 3166-2 subdivisions. LocaleValue can only be used with a
    /// Worker_Locale QualificationType ID. LocaleValue can only be used with
    /// the EqualTo, NotEqualTo, In, and NotIn comparators. You must only use
    /// a single LocaleValue element when using the EqualTo or NotEqualTo
    /// comparators. When performing a set comparison by using the In or the
    /// NotIn comparator, you can use up to 30 LocaleValue elements in a
    /// QualificationRequirement data structure.
    /// </p>
    pub fn locale_values(&self) -> std::option::Option<&[crate::model::Locale]> {
        self.locale_values.as_deref()
    }
    /// <p> DEPRECATED: Use the <code>ActionsGuarded</code> field instead.
    /// If RequiredToPreview is true, the question data for the HIT will not be shown
    /// when a Worker whose Qualifications do not meet this requirement tries
    /// to preview the HIT. That is, a Worker's Qualifications must meet all
    /// of the requirements for which RequiredToPreview is true in order to
    /// preview the HIT. If a Worker meets all of the requirements where
    /// RequiredToPreview is true (or if there are no such requirements), but
    /// does not meet all of the requirements for the HIT, the Worker will be
    /// allowed to preview the HIT's question data, but will not be allowed
    /// to accept and complete the HIT. The default is false. This should not
    /// be used in combination with the <code>ActionsGuarded</code> field.
    /// </p>
    pub fn required_to_preview(&self) -> std::option::Option<bool> {
        self.required_to_preview
    }
    /// <p> Setting this attribute prevents Workers whose Qualifications do not meet
    /// this QualificationRequirement from taking the specified action. Valid arguments include
    /// "Accept" (Worker cannot accept the HIT, but can preview the HIT and see it in their search results),
    /// "PreviewAndAccept" (Worker cannot accept or preview the HIT, but can see the HIT in their search results),
    /// and "DiscoverPreviewAndAccept" (Worker cannot accept, preview, or see the HIT in their search results). It's possible for you to create a HIT with multiple
    /// QualificationRequirements (which can have different values for the ActionGuarded attribute). In this case,
    /// the Worker is only permitted to perform an action when they have met all QualificationRequirements guarding
    /// the action. The actions in the order of least restrictive to most restrictive are Discover, Preview and Accept.
    /// For example, if a Worker meets all QualificationRequirements that are set to DiscoverPreviewAndAccept, but do
    /// not meet all requirements that are set with PreviewAndAccept, then the Worker will be able to Discover, i.e. see the
    /// HIT in their search result, but will not be able to Preview or Accept the HIT. ActionsGuarded should not be used in combination with the
    /// <code>RequiredToPreview</code> field.
    /// </p>
    pub fn actions_guarded(&self) -> std::option::Option<&crate::model::HitAccessActions> {
        self.actions_guarded.as_ref()
    }
}
impl std::fmt::Debug for QualificationRequirement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QualificationRequirement");
        formatter.field("qualification_type_id", &self.qualification_type_id);
        formatter.field("comparator", &self.comparator);
        formatter.field("integer_values", &self.integer_values);
        formatter.field("locale_values", &self.locale_values);
        formatter.field("required_to_preview", &self.required_to_preview);
        formatter.field("actions_guarded", &self.actions_guarded);
        formatter.finish()
    }
}
/// See [`QualificationRequirement`](crate::model::QualificationRequirement)
pub mod qualification_requirement {
    /// A builder for [`QualificationRequirement`](crate::model::QualificationRequirement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) qualification_type_id: std::option::Option<std::string::String>,
        pub(crate) comparator: std::option::Option<crate::model::Comparator>,
        pub(crate) integer_values: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) locale_values: std::option::Option<std::vec::Vec<crate::model::Locale>>,
        pub(crate) required_to_preview: std::option::Option<bool>,
        pub(crate) actions_guarded: std::option::Option<crate::model::HitAccessActions>,
    }
    impl Builder {
        /// <p> The ID of the Qualification type for the requirement.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.qualification_type_id = Some(input.into());
            self
        }
        /// <p> The ID of the Qualification type for the requirement.</p>
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.qualification_type_id = input;
            self
        }
        /// <p>The kind of comparison to make against a Qualification's
        /// value. You can compare a Qualification's value to an IntegerValue to
        /// see if it is LessThan, LessThanOrEqualTo, GreaterThan,
        /// GreaterThanOrEqualTo, EqualTo, or NotEqualTo the IntegerValue. You
        /// can compare it to a LocaleValue to see if it is EqualTo, or
        /// NotEqualTo the LocaleValue. You can check to see if the value is In
        /// or NotIn a set of IntegerValue
        /// or LocaleValue values. Lastly, a
        /// Qualification requirement can also
        /// test if a Qualification Exists or
        /// DoesNotExist in the user's profile,
        /// regardless of its value.
        /// </p>
        pub fn comparator(mut self, input: crate::model::Comparator) -> Self {
            self.comparator = Some(input);
            self
        }
        /// <p>The kind of comparison to make against a Qualification's
        /// value. You can compare a Qualification's value to an IntegerValue to
        /// see if it is LessThan, LessThanOrEqualTo, GreaterThan,
        /// GreaterThanOrEqualTo, EqualTo, or NotEqualTo the IntegerValue. You
        /// can compare it to a LocaleValue to see if it is EqualTo, or
        /// NotEqualTo the LocaleValue. You can check to see if the value is In
        /// or NotIn a set of IntegerValue
        /// or LocaleValue values. Lastly, a
        /// Qualification requirement can also
        /// test if a Qualification Exists or
        /// DoesNotExist in the user's profile,
        /// regardless of its value.
        /// </p>
        pub fn set_comparator(
            mut self,
            input: std::option::Option<crate::model::Comparator>,
        ) -> Self {
            self.comparator = input;
            self
        }
        /// Appends an item to `integer_values`.
        ///
        /// To override the contents of this collection use [`set_integer_values`](Self::set_integer_values).
        ///
        /// <p> The integer value to compare against the Qualification's
        /// value. IntegerValue must not be present if Comparator is Exists or
        /// DoesNotExist. IntegerValue can only be used if the Qualification type
        /// has an integer value; it cannot be used with the Worker_Locale
        /// QualificationType ID. When performing a set comparison by using the
        /// In or the NotIn comparator, you can use up to 15 IntegerValue
        /// elements in a QualificationRequirement data structure.
        /// </p>
        pub fn integer_values(mut self, input: impl Into<i32>) -> Self {
            let mut v = self.integer_values.unwrap_or_default();
            v.push(input.into());
            self.integer_values = Some(v);
            self
        }
        /// <p> The integer value to compare against the Qualification's
        /// value. IntegerValue must not be present if Comparator is Exists or
        /// DoesNotExist. IntegerValue can only be used if the Qualification type
        /// has an integer value; it cannot be used with the Worker_Locale
        /// QualificationType ID. When performing a set comparison by using the
        /// In or the NotIn comparator, you can use up to 15 IntegerValue
        /// elements in a QualificationRequirement data structure.
        /// </p>
        pub fn set_integer_values(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.integer_values = input;
            self
        }
        /// Appends an item to `locale_values`.
        ///
        /// To override the contents of this collection use [`set_locale_values`](Self::set_locale_values).
        ///
        /// <p> The locale value to compare against the Qualification's
        /// value. The local value must be a valid ISO 3166 country code or
        /// supports ISO 3166-2 subdivisions. LocaleValue can only be used with a
        /// Worker_Locale QualificationType ID. LocaleValue can only be used with
        /// the EqualTo, NotEqualTo, In, and NotIn comparators. You must only use
        /// a single LocaleValue element when using the EqualTo or NotEqualTo
        /// comparators. When performing a set comparison by using the In or the
        /// NotIn comparator, you can use up to 30 LocaleValue elements in a
        /// QualificationRequirement data structure.
        /// </p>
        pub fn locale_values(mut self, input: impl Into<crate::model::Locale>) -> Self {
            let mut v = self.locale_values.unwrap_or_default();
            v.push(input.into());
            self.locale_values = Some(v);
            self
        }
        /// <p> The locale value to compare against the Qualification's
        /// value. The local value must be a valid ISO 3166 country code or
        /// supports ISO 3166-2 subdivisions. LocaleValue can only be used with a
        /// Worker_Locale QualificationType ID. LocaleValue can only be used with
        /// the EqualTo, NotEqualTo, In, and NotIn comparators. You must only use
        /// a single LocaleValue element when using the EqualTo or NotEqualTo
        /// comparators. When performing a set comparison by using the In or the
        /// NotIn comparator, you can use up to 30 LocaleValue elements in a
        /// QualificationRequirement data structure.
        /// </p>
        pub fn set_locale_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Locale>>,
        ) -> Self {
            self.locale_values = input;
            self
        }
        /// <p> DEPRECATED: Use the <code>ActionsGuarded</code> field instead.
        /// If RequiredToPreview is true, the question data for the HIT will not be shown
        /// when a Worker whose Qualifications do not meet this requirement tries
        /// to preview the HIT. That is, a Worker's Qualifications must meet all
        /// of the requirements for which RequiredToPreview is true in order to
        /// preview the HIT. If a Worker meets all of the requirements where
        /// RequiredToPreview is true (or if there are no such requirements), but
        /// does not meet all of the requirements for the HIT, the Worker will be
        /// allowed to preview the HIT's question data, but will not be allowed
        /// to accept and complete the HIT. The default is false. This should not
        /// be used in combination with the <code>ActionsGuarded</code> field.
        /// </p>
        pub fn required_to_preview(mut self, input: bool) -> Self {
            self.required_to_preview = Some(input);
            self
        }
        /// <p> DEPRECATED: Use the <code>ActionsGuarded</code> field instead.
        /// If RequiredToPreview is true, the question data for the HIT will not be shown
        /// when a Worker whose Qualifications do not meet this requirement tries
        /// to preview the HIT. That is, a Worker's Qualifications must meet all
        /// of the requirements for which RequiredToPreview is true in order to
        /// preview the HIT. If a Worker meets all of the requirements where
        /// RequiredToPreview is true (or if there are no such requirements), but
        /// does not meet all of the requirements for the HIT, the Worker will be
        /// allowed to preview the HIT's question data, but will not be allowed
        /// to accept and complete the HIT. The default is false. This should not
        /// be used in combination with the <code>ActionsGuarded</code> field.
        /// </p>
        pub fn set_required_to_preview(mut self, input: std::option::Option<bool>) -> Self {
            self.required_to_preview = input;
            self
        }
        /// <p> Setting this attribute prevents Workers whose Qualifications do not meet
        /// this QualificationRequirement from taking the specified action. Valid arguments include
        /// "Accept" (Worker cannot accept the HIT, but can preview the HIT and see it in their search results),
        /// "PreviewAndAccept" (Worker cannot accept or preview the HIT, but can see the HIT in their search results),
        /// and "DiscoverPreviewAndAccept" (Worker cannot accept, preview, or see the HIT in their search results). It's possible for you to create a HIT with multiple
        /// QualificationRequirements (which can have different values for the ActionGuarded attribute). In this case,
        /// the Worker is only permitted to perform an action when they have met all QualificationRequirements guarding
        /// the action. The actions in the order of least restrictive to most restrictive are Discover, Preview and Accept.
        /// For example, if a Worker meets all QualificationRequirements that are set to DiscoverPreviewAndAccept, but do
        /// not meet all requirements that are set with PreviewAndAccept, then the Worker will be able to Discover, i.e. see the
        /// HIT in their search result, but will not be able to Preview or Accept the HIT. ActionsGuarded should not be used in combination with the
        /// <code>RequiredToPreview</code> field.
        /// </p>
        pub fn actions_guarded(mut self, input: crate::model::HitAccessActions) -> Self {
            self.actions_guarded = Some(input);
            self
        }
        /// <p> Setting this attribute prevents Workers whose Qualifications do not meet
        /// this QualificationRequirement from taking the specified action. Valid arguments include
        /// "Accept" (Worker cannot accept the HIT, but can preview the HIT and see it in their search results),
        /// "PreviewAndAccept" (Worker cannot accept or preview the HIT, but can see the HIT in their search results),
        /// and "DiscoverPreviewAndAccept" (Worker cannot accept, preview, or see the HIT in their search results). It's possible for you to create a HIT with multiple
        /// QualificationRequirements (which can have different values for the ActionGuarded attribute). In this case,
        /// the Worker is only permitted to perform an action when they have met all QualificationRequirements guarding
        /// the action. The actions in the order of least restrictive to most restrictive are Discover, Preview and Accept.
        /// For example, if a Worker meets all QualificationRequirements that are set to DiscoverPreviewAndAccept, but do
        /// not meet all requirements that are set with PreviewAndAccept, then the Worker will be able to Discover, i.e. see the
        /// HIT in their search result, but will not be able to Preview or Accept the HIT. ActionsGuarded should not be used in combination with the
        /// <code>RequiredToPreview</code> field.
        /// </p>
        pub fn set_actions_guarded(
            mut self,
            input: std::option::Option<crate::model::HitAccessActions>,
        ) -> Self {
            self.actions_guarded = input;
            self
        }
        /// Consumes the builder and constructs a [`QualificationRequirement`](crate::model::QualificationRequirement)
        pub fn build(self) -> crate::model::QualificationRequirement {
            crate::model::QualificationRequirement {
                qualification_type_id: self.qualification_type_id,
                comparator: self.comparator,
                integer_values: self.integer_values,
                locale_values: self.locale_values,
                required_to_preview: self.required_to_preview,
                actions_guarded: self.actions_guarded,
            }
        }
    }
}
impl QualificationRequirement {
    /// Creates a new builder-style object to manufacture [`QualificationRequirement`](crate::model::QualificationRequirement)
    pub fn builder() -> crate::model::qualification_requirement::Builder {
        crate::model::qualification_requirement::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HitAccessActions {
    #[allow(missing_docs)] // documentation missing in model
    Accept,
    #[allow(missing_docs)] // documentation missing in model
    DiscoverPreviewAndAccept,
    #[allow(missing_docs)] // documentation missing in model
    PreviewAndAccept,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HitAccessActions {
    fn from(s: &str) -> Self {
        match s {
            "Accept" => HitAccessActions::Accept,
            "DiscoverPreviewAndAccept" => HitAccessActions::DiscoverPreviewAndAccept,
            "PreviewAndAccept" => HitAccessActions::PreviewAndAccept,
            other => HitAccessActions::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HitAccessActions {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HitAccessActions::from(s))
    }
}
impl HitAccessActions {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HitAccessActions::Accept => "Accept",
            HitAccessActions::DiscoverPreviewAndAccept => "DiscoverPreviewAndAccept",
            HitAccessActions::PreviewAndAccept => "PreviewAndAccept",
            HitAccessActions::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Accept", "DiscoverPreviewAndAccept", "PreviewAndAccept"]
    }
}
impl AsRef<str> for HitAccessActions {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Comparator {
    #[allow(missing_docs)] // documentation missing in model
    DoesNotExist,
    #[allow(missing_docs)] // documentation missing in model
    EqualTo,
    #[allow(missing_docs)] // documentation missing in model
    Exists,
    #[allow(missing_docs)] // documentation missing in model
    GreaterThan,
    #[allow(missing_docs)] // documentation missing in model
    GreaterThanOrEqualTo,
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    LessThan,
    #[allow(missing_docs)] // documentation missing in model
    LessThanOrEqualTo,
    #[allow(missing_docs)] // documentation missing in model
    NotEqualTo,
    #[allow(missing_docs)] // documentation missing in model
    NotIn,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Comparator {
    fn from(s: &str) -> Self {
        match s {
            "DoesNotExist" => Comparator::DoesNotExist,
            "EqualTo" => Comparator::EqualTo,
            "Exists" => Comparator::Exists,
            "GreaterThan" => Comparator::GreaterThan,
            "GreaterThanOrEqualTo" => Comparator::GreaterThanOrEqualTo,
            "In" => Comparator::In,
            "LessThan" => Comparator::LessThan,
            "LessThanOrEqualTo" => Comparator::LessThanOrEqualTo,
            "NotEqualTo" => Comparator::NotEqualTo,
            "NotIn" => Comparator::NotIn,
            other => Comparator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Comparator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Comparator::from(s))
    }
}
impl Comparator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Comparator::DoesNotExist => "DoesNotExist",
            Comparator::EqualTo => "EqualTo",
            Comparator::Exists => "Exists",
            Comparator::GreaterThan => "GreaterThan",
            Comparator::GreaterThanOrEqualTo => "GreaterThanOrEqualTo",
            Comparator::In => "In",
            Comparator::LessThan => "LessThan",
            Comparator::LessThanOrEqualTo => "LessThanOrEqualTo",
            Comparator::NotEqualTo => "NotEqualTo",
            Comparator::NotIn => "NotIn",
            Comparator::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "DoesNotExist",
            "EqualTo",
            "Exists",
            "GreaterThan",
            "GreaterThanOrEqualTo",
            "In",
            "LessThan",
            "LessThanOrEqualTo",
            "NotEqualTo",
            "NotIn",
        ]
    }
}
impl AsRef<str> for Comparator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HitStatus {
    #[allow(missing_docs)] // documentation missing in model
    Assignable,
    #[allow(missing_docs)] // documentation missing in model
    Disposed,
    #[allow(missing_docs)] // documentation missing in model
    Reviewable,
    #[allow(missing_docs)] // documentation missing in model
    Reviewing,
    #[allow(missing_docs)] // documentation missing in model
    Unassignable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HitStatus {
    fn from(s: &str) -> Self {
        match s {
            "Assignable" => HitStatus::Assignable,
            "Disposed" => HitStatus::Disposed,
            "Reviewable" => HitStatus::Reviewable,
            "Reviewing" => HitStatus::Reviewing,
            "Unassignable" => HitStatus::Unassignable,
            other => HitStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HitStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HitStatus::from(s))
    }
}
impl HitStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            HitStatus::Assignable => "Assignable",
            HitStatus::Disposed => "Disposed",
            HitStatus::Reviewable => "Reviewable",
            HitStatus::Reviewing => "Reviewing",
            HitStatus::Unassignable => "Unassignable",
            HitStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Assignable",
            "Disposed",
            "Reviewable",
            "Reviewing",
            "Unassignable",
        ]
    }
}
impl AsRef<str> for HitStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReviewableHitStatus {
    #[allow(missing_docs)] // documentation missing in model
    Reviewable,
    #[allow(missing_docs)] // documentation missing in model
    Reviewing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReviewableHitStatus {
    fn from(s: &str) -> Self {
        match s {
            "Reviewable" => ReviewableHitStatus::Reviewable,
            "Reviewing" => ReviewableHitStatus::Reviewing,
            other => ReviewableHitStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReviewableHitStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReviewableHitStatus::from(s))
    }
}
impl ReviewableHitStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReviewableHitStatus::Reviewable => "Reviewable",
            ReviewableHitStatus::Reviewing => "Reviewing",
            ReviewableHitStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Reviewable", "Reviewing"]
    }
}
impl AsRef<str> for ReviewableHitStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The QualificationRequest data structure represents a request
/// a Worker has made for a Qualification.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QualificationRequest {
    /// <p>The ID of the Qualification request, a unique identifier
    /// generated when the request was submitted.
    ///
    /// </p>
    pub qualification_request_id: std::option::Option<std::string::String>,
    /// <p> The ID of the Qualification type the Worker is requesting,
    /// as returned by the CreateQualificationType operation.
    /// </p>
    pub qualification_type_id: std::option::Option<std::string::String>,
    /// <p> The ID of the Worker requesting the Qualification.</p>
    pub worker_id: std::option::Option<std::string::String>,
    /// <p> The contents of the Qualification test that was presented to
    /// the Worker, if the type has a test and the Worker has submitted
    /// answers. This value is identical to the QuestionForm associated with
    /// the Qualification type at the time the Worker requests the
    /// Qualification.</p>
    pub test: std::option::Option<std::string::String>,
    /// <p> The Worker's answers for the Qualification type's test
    /// contained in a QuestionFormAnswers document, if the type has a test
    /// and the Worker has submitted answers. If the Worker does not provide
    /// any answers, Answer may be empty.
    /// </p>
    pub answer: std::option::Option<std::string::String>,
    /// <p>The date and time the Qualification request had a status of
    /// Submitted. This is either the time the Worker submitted answers for a
    /// Qualification test, or the time the Worker requested the
    /// Qualification if the Qualification type does not have a test.
    /// </p>
    pub submit_time: std::option::Option<aws_smithy_types::Instant>,
}
impl QualificationRequest {
    /// <p>The ID of the Qualification request, a unique identifier
    /// generated when the request was submitted.
    ///
    /// </p>
    pub fn qualification_request_id(&self) -> std::option::Option<&str> {
        self.qualification_request_id.as_deref()
    }
    /// <p> The ID of the Qualification type the Worker is requesting,
    /// as returned by the CreateQualificationType operation.
    /// </p>
    pub fn qualification_type_id(&self) -> std::option::Option<&str> {
        self.qualification_type_id.as_deref()
    }
    /// <p> The ID of the Worker requesting the Qualification.</p>
    pub fn worker_id(&self) -> std::option::Option<&str> {
        self.worker_id.as_deref()
    }
    /// <p> The contents of the Qualification test that was presented to
    /// the Worker, if the type has a test and the Worker has submitted
    /// answers. This value is identical to the QuestionForm associated with
    /// the Qualification type at the time the Worker requests the
    /// Qualification.</p>
    pub fn test(&self) -> std::option::Option<&str> {
        self.test.as_deref()
    }
    /// <p> The Worker's answers for the Qualification type's test
    /// contained in a QuestionFormAnswers document, if the type has a test
    /// and the Worker has submitted answers. If the Worker does not provide
    /// any answers, Answer may be empty.
    /// </p>
    pub fn answer(&self) -> std::option::Option<&str> {
        self.answer.as_deref()
    }
    /// <p>The date and time the Qualification request had a status of
    /// Submitted. This is either the time the Worker submitted answers for a
    /// Qualification test, or the time the Worker requested the
    /// Qualification if the Qualification type does not have a test.
    /// </p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.submit_time.as_ref()
    }
}
impl std::fmt::Debug for QualificationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QualificationRequest");
        formatter.field("qualification_request_id", &self.qualification_request_id);
        formatter.field("qualification_type_id", &self.qualification_type_id);
        formatter.field("worker_id", &self.worker_id);
        formatter.field("test", &self.test);
        formatter.field("answer", &self.answer);
        formatter.field("submit_time", &self.submit_time);
        formatter.finish()
    }
}
/// See [`QualificationRequest`](crate::model::QualificationRequest)
pub mod qualification_request {
    /// A builder for [`QualificationRequest`](crate::model::QualificationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) qualification_request_id: std::option::Option<std::string::String>,
        pub(crate) qualification_type_id: std::option::Option<std::string::String>,
        pub(crate) worker_id: std::option::Option<std::string::String>,
        pub(crate) test: std::option::Option<std::string::String>,
        pub(crate) answer: std::option::Option<std::string::String>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the Qualification request, a unique identifier
        /// generated when the request was submitted.
        ///
        /// </p>
        pub fn qualification_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.qualification_request_id = Some(input.into());
            self
        }
        /// <p>The ID of the Qualification request, a unique identifier
        /// generated when the request was submitted.
        ///
        /// </p>
        pub fn set_qualification_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.qualification_request_id = input;
            self
        }
        /// <p> The ID of the Qualification type the Worker is requesting,
        /// as returned by the CreateQualificationType operation.
        /// </p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.qualification_type_id = Some(input.into());
            self
        }
        /// <p> The ID of the Qualification type the Worker is requesting,
        /// as returned by the CreateQualificationType operation.
        /// </p>
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.qualification_type_id = input;
            self
        }
        /// <p> The ID of the Worker requesting the Qualification.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.worker_id = Some(input.into());
            self
        }
        /// <p> The ID of the Worker requesting the Qualification.</p>
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.worker_id = input;
            self
        }
        /// <p> The contents of the Qualification test that was presented to
        /// the Worker, if the type has a test and the Worker has submitted
        /// answers. This value is identical to the QuestionForm associated with
        /// the Qualification type at the time the Worker requests the
        /// Qualification.</p>
        pub fn test(mut self, input: impl Into<std::string::String>) -> Self {
            self.test = Some(input.into());
            self
        }
        /// <p> The contents of the Qualification test that was presented to
        /// the Worker, if the type has a test and the Worker has submitted
        /// answers. This value is identical to the QuestionForm associated with
        /// the Qualification type at the time the Worker requests the
        /// Qualification.</p>
        pub fn set_test(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.test = input;
            self
        }
        /// <p> The Worker's answers for the Qualification type's test
        /// contained in a QuestionFormAnswers document, if the type has a test
        /// and the Worker has submitted answers. If the Worker does not provide
        /// any answers, Answer may be empty.
        /// </p>
        pub fn answer(mut self, input: impl Into<std::string::String>) -> Self {
            self.answer = Some(input.into());
            self
        }
        /// <p> The Worker's answers for the Qualification type's test
        /// contained in a QuestionFormAnswers document, if the type has a test
        /// and the Worker has submitted answers. If the Worker does not provide
        /// any answers, Answer may be empty.
        /// </p>
        pub fn set_answer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.answer = input;
            self
        }
        /// <p>The date and time the Qualification request had a status of
        /// Submitted. This is either the time the Worker submitted answers for a
        /// Qualification test, or the time the Worker requested the
        /// Qualification if the Qualification type does not have a test.
        /// </p>
        pub fn submit_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p>The date and time the Qualification request had a status of
        /// Submitted. This is either the time the Worker submitted answers for a
        /// Qualification test, or the time the Worker requested the
        /// Qualification if the Qualification type does not have a test.
        /// </p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// Consumes the builder and constructs a [`QualificationRequest`](crate::model::QualificationRequest)
        pub fn build(self) -> crate::model::QualificationRequest {
            crate::model::QualificationRequest {
                qualification_request_id: self.qualification_request_id,
                qualification_type_id: self.qualification_type_id,
                worker_id: self.worker_id,
                test: self.test,
                answer: self.answer,
                submit_time: self.submit_time,
            }
        }
    }
}
impl QualificationRequest {
    /// Creates a new builder-style object to manufacture [`QualificationRequest`](crate::model::QualificationRequest)
    pub fn builder() -> crate::model::qualification_request::Builder {
        crate::model::qualification_request::Builder::default()
    }
}

/// <p>An object representing a Bonus payment paid to a Worker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BonusPayment {
    /// <p>The ID of the Worker to whom the bonus was paid.</p>
    pub worker_id: std::option::Option<std::string::String>,
    /// <p>A string representing a currency amount.</p>
    pub bonus_amount: std::option::Option<std::string::String>,
    /// <p>The ID of the assignment associated with this bonus payment.</p>
    pub assignment_id: std::option::Option<std::string::String>,
    /// <p>The Reason text given when the bonus was granted, if any.</p>
    pub reason: std::option::Option<std::string::String>,
    /// <p>The date and time of when the bonus was granted.</p>
    pub grant_time: std::option::Option<aws_smithy_types::Instant>,
}
impl BonusPayment {
    /// <p>The ID of the Worker to whom the bonus was paid.</p>
    pub fn worker_id(&self) -> std::option::Option<&str> {
        self.worker_id.as_deref()
    }
    /// <p>A string representing a currency amount.</p>
    pub fn bonus_amount(&self) -> std::option::Option<&str> {
        self.bonus_amount.as_deref()
    }
    /// <p>The ID of the assignment associated with this bonus payment.</p>
    pub fn assignment_id(&self) -> std::option::Option<&str> {
        self.assignment_id.as_deref()
    }
    /// <p>The Reason text given when the bonus was granted, if any.</p>
    pub fn reason(&self) -> std::option::Option<&str> {
        self.reason.as_deref()
    }
    /// <p>The date and time of when the bonus was granted.</p>
    pub fn grant_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.grant_time.as_ref()
    }
}
impl std::fmt::Debug for BonusPayment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BonusPayment");
        formatter.field("worker_id", &self.worker_id);
        formatter.field("bonus_amount", &self.bonus_amount);
        formatter.field("assignment_id", &self.assignment_id);
        formatter.field("reason", &self.reason);
        formatter.field("grant_time", &self.grant_time);
        formatter.finish()
    }
}
/// See [`BonusPayment`](crate::model::BonusPayment)
pub mod bonus_payment {
    /// A builder for [`BonusPayment`](crate::model::BonusPayment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) worker_id: std::option::Option<std::string::String>,
        pub(crate) bonus_amount: std::option::Option<std::string::String>,
        pub(crate) assignment_id: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<std::string::String>,
        pub(crate) grant_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The ID of the Worker to whom the bonus was paid.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.worker_id = Some(input.into());
            self
        }
        /// <p>The ID of the Worker to whom the bonus was paid.</p>
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.worker_id = input;
            self
        }
        /// <p>A string representing a currency amount.</p>
        pub fn bonus_amount(mut self, input: impl Into<std::string::String>) -> Self {
            self.bonus_amount = Some(input.into());
            self
        }
        /// <p>A string representing a currency amount.</p>
        pub fn set_bonus_amount(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bonus_amount = input;
            self
        }
        /// <p>The ID of the assignment associated with this bonus payment.</p>
        pub fn assignment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assignment_id = Some(input.into());
            self
        }
        /// <p>The ID of the assignment associated with this bonus payment.</p>
        pub fn set_assignment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assignment_id = input;
            self
        }
        /// <p>The Reason text given when the bonus was granted, if any.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason = Some(input.into());
            self
        }
        /// <p>The Reason text given when the bonus was granted, if any.</p>
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason = input;
            self
        }
        /// <p>The date and time of when the bonus was granted.</p>
        pub fn grant_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.grant_time = Some(input);
            self
        }
        /// <p>The date and time of when the bonus was granted.</p>
        pub fn set_grant_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.grant_time = input;
            self
        }
        /// Consumes the builder and constructs a [`BonusPayment`](crate::model::BonusPayment)
        pub fn build(self) -> crate::model::BonusPayment {
            crate::model::BonusPayment {
                worker_id: self.worker_id,
                bonus_amount: self.bonus_amount,
                assignment_id: self.assignment_id,
                reason: self.reason,
                grant_time: self.grant_time,
            }
        }
    }
}
impl BonusPayment {
    /// Creates a new builder-style object to manufacture [`BonusPayment`](crate::model::BonusPayment)
    pub fn builder() -> crate::model::bonus_payment::Builder {
        crate::model::bonus_payment::Builder::default()
    }
}

/// <p> The Assignment data structure represents a single assignment
/// of a HIT to a Worker. The assignment tracks the Worker's efforts to
/// complete the HIT, and contains the results for later retrieval.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Assignment {
    /// <p> A unique identifier for the assignment.</p>
    pub assignment_id: std::option::Option<std::string::String>,
    /// <p> The ID of the Worker who accepted the HIT.</p>
    pub worker_id: std::option::Option<std::string::String>,
    /// <p> The ID of the HIT.</p>
    pub hit_id: std::option::Option<std::string::String>,
    /// <p> The status of the assignment.</p>
    pub assignment_status: std::option::Option<crate::model::AssignmentStatus>,
    /// <p> If results have been submitted, AutoApprovalTime is the date
    /// and time the results of the assignment results are considered
    /// Approved automatically if they have not already been explicitly
    /// approved or rejected by the Requester. This value is derived from the
    /// auto-approval delay specified by the Requester in the HIT. This value
    /// is omitted from the assignment if the Worker has not yet submitted
    /// results.</p>
    pub auto_approval_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> The date and time the Worker accepted the assignment.</p>
    pub accept_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> If the Worker has submitted results, SubmitTime is the date
    /// and time the assignment was submitted. This value is omitted from the
    /// assignment if the Worker has not yet submitted results.</p>
    pub submit_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> If the Worker has submitted results and the Requester has
    /// approved the results, ApprovalTime is the date and time the Requester
    /// approved the results. This value is omitted from the assignment if
    /// the Requester has not yet approved the results.</p>
    pub approval_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> If the Worker has submitted results and the Requester has
    /// rejected the results, RejectionTime is the date and time the
    /// Requester rejected the results.</p>
    pub rejection_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> The date and time of the deadline for the assignment. This
    /// value is derived from the deadline specification for the HIT and the
    /// date and time the Worker accepted the HIT.</p>
    pub deadline: std::option::Option<aws_smithy_types::Instant>,
    /// <p> The Worker's answers submitted for the HIT contained in a
    /// QuestionFormAnswers document, if the Worker provides an answer. If
    /// the Worker does not provide any answers, Answer may contain a
    /// QuestionFormAnswers document, or Answer may be empty.</p>
    pub answer: std::option::Option<std::string::String>,
    /// <p> The feedback string included with the call to the
    /// ApproveAssignment operation or the RejectAssignment operation, if the
    /// Requester approved or rejected the assignment and specified feedback.</p>
    pub requester_feedback: std::option::Option<std::string::String>,
}
impl Assignment {
    /// <p> A unique identifier for the assignment.</p>
    pub fn assignment_id(&self) -> std::option::Option<&str> {
        self.assignment_id.as_deref()
    }
    /// <p> The ID of the Worker who accepted the HIT.</p>
    pub fn worker_id(&self) -> std::option::Option<&str> {
        self.worker_id.as_deref()
    }
    /// <p> The ID of the HIT.</p>
    pub fn hit_id(&self) -> std::option::Option<&str> {
        self.hit_id.as_deref()
    }
    /// <p> The status of the assignment.</p>
    pub fn assignment_status(&self) -> std::option::Option<&crate::model::AssignmentStatus> {
        self.assignment_status.as_ref()
    }
    /// <p> If results have been submitted, AutoApprovalTime is the date
    /// and time the results of the assignment results are considered
    /// Approved automatically if they have not already been explicitly
    /// approved or rejected by the Requester. This value is derived from the
    /// auto-approval delay specified by the Requester in the HIT. This value
    /// is omitted from the assignment if the Worker has not yet submitted
    /// results.</p>
    pub fn auto_approval_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.auto_approval_time.as_ref()
    }
    /// <p> The date and time the Worker accepted the assignment.</p>
    pub fn accept_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.accept_time.as_ref()
    }
    /// <p> If the Worker has submitted results, SubmitTime is the date
    /// and time the assignment was submitted. This value is omitted from the
    /// assignment if the Worker has not yet submitted results.</p>
    pub fn submit_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.submit_time.as_ref()
    }
    /// <p> If the Worker has submitted results and the Requester has
    /// approved the results, ApprovalTime is the date and time the Requester
    /// approved the results. This value is omitted from the assignment if
    /// the Requester has not yet approved the results.</p>
    pub fn approval_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.approval_time.as_ref()
    }
    /// <p> If the Worker has submitted results and the Requester has
    /// rejected the results, RejectionTime is the date and time the
    /// Requester rejected the results.</p>
    pub fn rejection_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.rejection_time.as_ref()
    }
    /// <p> The date and time of the deadline for the assignment. This
    /// value is derived from the deadline specification for the HIT and the
    /// date and time the Worker accepted the HIT.</p>
    pub fn deadline(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.deadline.as_ref()
    }
    /// <p> The Worker's answers submitted for the HIT contained in a
    /// QuestionFormAnswers document, if the Worker provides an answer. If
    /// the Worker does not provide any answers, Answer may contain a
    /// QuestionFormAnswers document, or Answer may be empty.</p>
    pub fn answer(&self) -> std::option::Option<&str> {
        self.answer.as_deref()
    }
    /// <p> The feedback string included with the call to the
    /// ApproveAssignment operation or the RejectAssignment operation, if the
    /// Requester approved or rejected the assignment and specified feedback.</p>
    pub fn requester_feedback(&self) -> std::option::Option<&str> {
        self.requester_feedback.as_deref()
    }
}
impl std::fmt::Debug for Assignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Assignment");
        formatter.field("assignment_id", &self.assignment_id);
        formatter.field("worker_id", &self.worker_id);
        formatter.field("hit_id", &self.hit_id);
        formatter.field("assignment_status", &self.assignment_status);
        formatter.field("auto_approval_time", &self.auto_approval_time);
        formatter.field("accept_time", &self.accept_time);
        formatter.field("submit_time", &self.submit_time);
        formatter.field("approval_time", &self.approval_time);
        formatter.field("rejection_time", &self.rejection_time);
        formatter.field("deadline", &self.deadline);
        formatter.field("answer", &self.answer);
        formatter.field("requester_feedback", &self.requester_feedback);
        formatter.finish()
    }
}
/// See [`Assignment`](crate::model::Assignment)
pub mod assignment {
    /// A builder for [`Assignment`](crate::model::Assignment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assignment_id: std::option::Option<std::string::String>,
        pub(crate) worker_id: std::option::Option<std::string::String>,
        pub(crate) hit_id: std::option::Option<std::string::String>,
        pub(crate) assignment_status: std::option::Option<crate::model::AssignmentStatus>,
        pub(crate) auto_approval_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) accept_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) submit_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) approval_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) rejection_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) deadline: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) answer: std::option::Option<std::string::String>,
        pub(crate) requester_feedback: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> A unique identifier for the assignment.</p>
        pub fn assignment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.assignment_id = Some(input.into());
            self
        }
        /// <p> A unique identifier for the assignment.</p>
        pub fn set_assignment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assignment_id = input;
            self
        }
        /// <p> The ID of the Worker who accepted the HIT.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.worker_id = Some(input.into());
            self
        }
        /// <p> The ID of the Worker who accepted the HIT.</p>
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.worker_id = input;
            self
        }
        /// <p> The ID of the HIT.</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hit_id = Some(input.into());
            self
        }
        /// <p> The ID of the HIT.</p>
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hit_id = input;
            self
        }
        /// <p> The status of the assignment.</p>
        pub fn assignment_status(mut self, input: crate::model::AssignmentStatus) -> Self {
            self.assignment_status = Some(input);
            self
        }
        /// <p> The status of the assignment.</p>
        pub fn set_assignment_status(
            mut self,
            input: std::option::Option<crate::model::AssignmentStatus>,
        ) -> Self {
            self.assignment_status = input;
            self
        }
        /// <p> If results have been submitted, AutoApprovalTime is the date
        /// and time the results of the assignment results are considered
        /// Approved automatically if they have not already been explicitly
        /// approved or rejected by the Requester. This value is derived from the
        /// auto-approval delay specified by the Requester in the HIT. This value
        /// is omitted from the assignment if the Worker has not yet submitted
        /// results.</p>
        pub fn auto_approval_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.auto_approval_time = Some(input);
            self
        }
        /// <p> If results have been submitted, AutoApprovalTime is the date
        /// and time the results of the assignment results are considered
        /// Approved automatically if they have not already been explicitly
        /// approved or rejected by the Requester. This value is derived from the
        /// auto-approval delay specified by the Requester in the HIT. This value
        /// is omitted from the assignment if the Worker has not yet submitted
        /// results.</p>
        pub fn set_auto_approval_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.auto_approval_time = input;
            self
        }
        /// <p> The date and time the Worker accepted the assignment.</p>
        pub fn accept_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.accept_time = Some(input);
            self
        }
        /// <p> The date and time the Worker accepted the assignment.</p>
        pub fn set_accept_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.accept_time = input;
            self
        }
        /// <p> If the Worker has submitted results, SubmitTime is the date
        /// and time the assignment was submitted. This value is omitted from the
        /// assignment if the Worker has not yet submitted results.</p>
        pub fn submit_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.submit_time = Some(input);
            self
        }
        /// <p> If the Worker has submitted results, SubmitTime is the date
        /// and time the assignment was submitted. This value is omitted from the
        /// assignment if the Worker has not yet submitted results.</p>
        pub fn set_submit_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.submit_time = input;
            self
        }
        /// <p> If the Worker has submitted results and the Requester has
        /// approved the results, ApprovalTime is the date and time the Requester
        /// approved the results. This value is omitted from the assignment if
        /// the Requester has not yet approved the results.</p>
        pub fn approval_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.approval_time = Some(input);
            self
        }
        /// <p> If the Worker has submitted results and the Requester has
        /// approved the results, ApprovalTime is the date and time the Requester
        /// approved the results. This value is omitted from the assignment if
        /// the Requester has not yet approved the results.</p>
        pub fn set_approval_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.approval_time = input;
            self
        }
        /// <p> If the Worker has submitted results and the Requester has
        /// rejected the results, RejectionTime is the date and time the
        /// Requester rejected the results.</p>
        pub fn rejection_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.rejection_time = Some(input);
            self
        }
        /// <p> If the Worker has submitted results and the Requester has
        /// rejected the results, RejectionTime is the date and time the
        /// Requester rejected the results.</p>
        pub fn set_rejection_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.rejection_time = input;
            self
        }
        /// <p> The date and time of the deadline for the assignment. This
        /// value is derived from the deadline specification for the HIT and the
        /// date and time the Worker accepted the HIT.</p>
        pub fn deadline(mut self, input: aws_smithy_types::Instant) -> Self {
            self.deadline = Some(input);
            self
        }
        /// <p> The date and time of the deadline for the assignment. This
        /// value is derived from the deadline specification for the HIT and the
        /// date and time the Worker accepted the HIT.</p>
        pub fn set_deadline(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.deadline = input;
            self
        }
        /// <p> The Worker's answers submitted for the HIT contained in a
        /// QuestionFormAnswers document, if the Worker provides an answer. If
        /// the Worker does not provide any answers, Answer may contain a
        /// QuestionFormAnswers document, or Answer may be empty.</p>
        pub fn answer(mut self, input: impl Into<std::string::String>) -> Self {
            self.answer = Some(input.into());
            self
        }
        /// <p> The Worker's answers submitted for the HIT contained in a
        /// QuestionFormAnswers document, if the Worker provides an answer. If
        /// the Worker does not provide any answers, Answer may contain a
        /// QuestionFormAnswers document, or Answer may be empty.</p>
        pub fn set_answer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.answer = input;
            self
        }
        /// <p> The feedback string included with the call to the
        /// ApproveAssignment operation or the RejectAssignment operation, if the
        /// Requester approved or rejected the assignment and specified feedback.</p>
        pub fn requester_feedback(mut self, input: impl Into<std::string::String>) -> Self {
            self.requester_feedback = Some(input.into());
            self
        }
        /// <p> The feedback string included with the call to the
        /// ApproveAssignment operation or the RejectAssignment operation, if the
        /// Requester approved or rejected the assignment and specified feedback.</p>
        pub fn set_requester_feedback(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.requester_feedback = input;
            self
        }
        /// Consumes the builder and constructs a [`Assignment`](crate::model::Assignment)
        pub fn build(self) -> crate::model::Assignment {
            crate::model::Assignment {
                assignment_id: self.assignment_id,
                worker_id: self.worker_id,
                hit_id: self.hit_id,
                assignment_status: self.assignment_status,
                auto_approval_time: self.auto_approval_time,
                accept_time: self.accept_time,
                submit_time: self.submit_time,
                approval_time: self.approval_time,
                rejection_time: self.rejection_time,
                deadline: self.deadline,
                answer: self.answer,
                requester_feedback: self.requester_feedback,
            }
        }
    }
}
impl Assignment {
    /// Creates a new builder-style object to manufacture [`Assignment`](crate::model::Assignment)
    pub fn builder() -> crate::model::assignment::Builder {
        crate::model::assignment::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssignmentStatus {
    #[allow(missing_docs)] // documentation missing in model
    Approved,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AssignmentStatus {
    fn from(s: &str) -> Self {
        match s {
            "Approved" => AssignmentStatus::Approved,
            "Rejected" => AssignmentStatus::Rejected,
            "Submitted" => AssignmentStatus::Submitted,
            other => AssignmentStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AssignmentStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssignmentStatus::from(s))
    }
}
impl AssignmentStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssignmentStatus::Approved => "Approved",
            AssignmentStatus::Rejected => "Rejected",
            AssignmentStatus::Submitted => "Submitted",
            AssignmentStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Approved", "Rejected", "Submitted"]
    }
}
impl AsRef<str> for AssignmentStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> The HITLayoutParameter data structure defines parameter
/// values used with a HITLayout. A HITLayout is a reusable Amazon
/// Mechanical Turk project template used to provide Human Intelligence
/// Task (HIT) question data for CreateHIT.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HitLayoutParameter {
    /// <p> The name of the parameter in the HITLayout.
    /// </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value substituted for the parameter referenced in the
    /// HITLayout.
    /// </p>
    pub value: std::option::Option<std::string::String>,
}
impl HitLayoutParameter {
    /// <p> The name of the parameter in the HITLayout.
    /// </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value substituted for the parameter referenced in the
    /// HITLayout.
    /// </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for HitLayoutParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HitLayoutParameter");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`HitLayoutParameter`](crate::model::HitLayoutParameter)
pub mod hit_layout_parameter {
    /// A builder for [`HitLayoutParameter`](crate::model::HitLayoutParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the parameter in the HITLayout.
        /// </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the parameter in the HITLayout.
        /// </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value substituted for the parameter referenced in the
        /// HITLayout.
        /// </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value substituted for the parameter referenced in the
        /// HITLayout.
        /// </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`HitLayoutParameter`](crate::model::HitLayoutParameter)
        pub fn build(self) -> crate::model::HitLayoutParameter {
            crate::model::HitLayoutParameter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl HitLayoutParameter {
    /// Creates a new builder-style object to manufacture [`HitLayoutParameter`](crate::model::HitLayoutParameter)
    pub fn builder() -> crate::model::hit_layout_parameter::Builder {
        crate::model::hit_layout_parameter::Builder::default()
    }
}
