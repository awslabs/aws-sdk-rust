// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateQualificationTypeOutput {
    /// <p> Contains a QualificationType data structure.</p>
    pub qualification_type: std::option::Option<crate::model::QualificationType>,
}
impl UpdateQualificationTypeOutput {
    /// <p> Contains a QualificationType data structure.</p>
    pub fn qualification_type(&self) -> std::option::Option<&crate::model::QualificationType> {
        self.qualification_type.as_ref()
    }
}
impl std::fmt::Debug for UpdateQualificationTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateQualificationTypeOutput");
        formatter.field("qualification_type", &self.qualification_type);
        formatter.finish()
    }
}
/// See [`UpdateQualificationTypeOutput`](crate::output::UpdateQualificationTypeOutput)
pub mod update_qualification_type_output {
    /// A builder for [`UpdateQualificationTypeOutput`](crate::output::UpdateQualificationTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) qualification_type: std::option::Option<crate::model::QualificationType>,
    }
    impl Builder {
        /// <p> Contains a QualificationType data structure.</p>
        pub fn qualification_type(mut self, input: crate::model::QualificationType) -> Self {
            self.qualification_type = Some(input);
            self
        }
        /// <p> Contains a QualificationType data structure.</p>
        pub fn set_qualification_type(
            mut self,
            input: std::option::Option<crate::model::QualificationType>,
        ) -> Self {
            self.qualification_type = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateQualificationTypeOutput`](crate::output::UpdateQualificationTypeOutput)
        pub fn build(self) -> crate::output::UpdateQualificationTypeOutput {
            crate::output::UpdateQualificationTypeOutput {
                qualification_type: self.qualification_type,
            }
        }
    }
}
impl UpdateQualificationTypeOutput {
    /// Creates a new builder-style object to manufacture [`UpdateQualificationTypeOutput`](crate::output::UpdateQualificationTypeOutput)
    pub fn builder() -> crate::output::update_qualification_type_output::Builder {
        crate::output::update_qualification_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateNotificationSettingsOutput {}
impl std::fmt::Debug for UpdateNotificationSettingsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateNotificationSettingsOutput");
        formatter.finish()
    }
}
/// See [`UpdateNotificationSettingsOutput`](crate::output::UpdateNotificationSettingsOutput)
pub mod update_notification_settings_output {
    /// A builder for [`UpdateNotificationSettingsOutput`](crate::output::UpdateNotificationSettingsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateNotificationSettingsOutput`](crate::output::UpdateNotificationSettingsOutput)
        pub fn build(self) -> crate::output::UpdateNotificationSettingsOutput {
            crate::output::UpdateNotificationSettingsOutput {}
        }
    }
}
impl UpdateNotificationSettingsOutput {
    /// Creates a new builder-style object to manufacture [`UpdateNotificationSettingsOutput`](crate::output::UpdateNotificationSettingsOutput)
    pub fn builder() -> crate::output::update_notification_settings_output::Builder {
        crate::output::update_notification_settings_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateHitTypeOfHitOutput {}
impl std::fmt::Debug for UpdateHitTypeOfHitOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateHitTypeOfHitOutput");
        formatter.finish()
    }
}
/// See [`UpdateHitTypeOfHitOutput`](crate::output::UpdateHitTypeOfHitOutput)
pub mod update_hit_type_of_hit_output {
    /// A builder for [`UpdateHitTypeOfHitOutput`](crate::output::UpdateHitTypeOfHitOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateHitTypeOfHitOutput`](crate::output::UpdateHitTypeOfHitOutput)
        pub fn build(self) -> crate::output::UpdateHitTypeOfHitOutput {
            crate::output::UpdateHitTypeOfHitOutput {}
        }
    }
}
impl UpdateHitTypeOfHitOutput {
    /// Creates a new builder-style object to manufacture [`UpdateHitTypeOfHitOutput`](crate::output::UpdateHitTypeOfHitOutput)
    pub fn builder() -> crate::output::update_hit_type_of_hit_output::Builder {
        crate::output::update_hit_type_of_hit_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateHitReviewStatusOutput {}
impl std::fmt::Debug for UpdateHitReviewStatusOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateHitReviewStatusOutput");
        formatter.finish()
    }
}
/// See [`UpdateHitReviewStatusOutput`](crate::output::UpdateHitReviewStatusOutput)
pub mod update_hit_review_status_output {
    /// A builder for [`UpdateHitReviewStatusOutput`](crate::output::UpdateHitReviewStatusOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateHitReviewStatusOutput`](crate::output::UpdateHitReviewStatusOutput)
        pub fn build(self) -> crate::output::UpdateHitReviewStatusOutput {
            crate::output::UpdateHitReviewStatusOutput {}
        }
    }
}
impl UpdateHitReviewStatusOutput {
    /// Creates a new builder-style object to manufacture [`UpdateHitReviewStatusOutput`](crate::output::UpdateHitReviewStatusOutput)
    pub fn builder() -> crate::output::update_hit_review_status_output::Builder {
        crate::output::update_hit_review_status_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateExpirationForHitOutput {}
impl std::fmt::Debug for UpdateExpirationForHitOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateExpirationForHitOutput");
        formatter.finish()
    }
}
/// See [`UpdateExpirationForHitOutput`](crate::output::UpdateExpirationForHitOutput)
pub mod update_expiration_for_hit_output {
    /// A builder for [`UpdateExpirationForHitOutput`](crate::output::UpdateExpirationForHitOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UpdateExpirationForHitOutput`](crate::output::UpdateExpirationForHitOutput)
        pub fn build(self) -> crate::output::UpdateExpirationForHitOutput {
            crate::output::UpdateExpirationForHitOutput {}
        }
    }
}
impl UpdateExpirationForHitOutput {
    /// Creates a new builder-style object to manufacture [`UpdateExpirationForHitOutput`](crate::output::UpdateExpirationForHitOutput)
    pub fn builder() -> crate::output::update_expiration_for_hit_output::Builder {
        crate::output::update_expiration_for_hit_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendTestEventNotificationOutput {}
impl std::fmt::Debug for SendTestEventNotificationOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendTestEventNotificationOutput");
        formatter.finish()
    }
}
/// See [`SendTestEventNotificationOutput`](crate::output::SendTestEventNotificationOutput)
pub mod send_test_event_notification_output {
    /// A builder for [`SendTestEventNotificationOutput`](crate::output::SendTestEventNotificationOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`SendTestEventNotificationOutput`](crate::output::SendTestEventNotificationOutput)
        pub fn build(self) -> crate::output::SendTestEventNotificationOutput {
            crate::output::SendTestEventNotificationOutput {}
        }
    }
}
impl SendTestEventNotificationOutput {
    /// Creates a new builder-style object to manufacture [`SendTestEventNotificationOutput`](crate::output::SendTestEventNotificationOutput)
    pub fn builder() -> crate::output::send_test_event_notification_output::Builder {
        crate::output::send_test_event_notification_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendBonusOutput {}
impl std::fmt::Debug for SendBonusOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendBonusOutput");
        formatter.finish()
    }
}
/// See [`SendBonusOutput`](crate::output::SendBonusOutput)
pub mod send_bonus_output {
    /// A builder for [`SendBonusOutput`](crate::output::SendBonusOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`SendBonusOutput`](crate::output::SendBonusOutput)
        pub fn build(self) -> crate::output::SendBonusOutput {
            crate::output::SendBonusOutput {}
        }
    }
}
impl SendBonusOutput {
    /// Creates a new builder-style object to manufacture [`SendBonusOutput`](crate::output::SendBonusOutput)
    pub fn builder() -> crate::output::send_bonus_output::Builder {
        crate::output::send_bonus_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RejectQualificationRequestOutput {}
impl std::fmt::Debug for RejectQualificationRequestOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RejectQualificationRequestOutput");
        formatter.finish()
    }
}
/// See [`RejectQualificationRequestOutput`](crate::output::RejectQualificationRequestOutput)
pub mod reject_qualification_request_output {
    /// A builder for [`RejectQualificationRequestOutput`](crate::output::RejectQualificationRequestOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RejectQualificationRequestOutput`](crate::output::RejectQualificationRequestOutput)
        pub fn build(self) -> crate::output::RejectQualificationRequestOutput {
            crate::output::RejectQualificationRequestOutput {}
        }
    }
}
impl RejectQualificationRequestOutput {
    /// Creates a new builder-style object to manufacture [`RejectQualificationRequestOutput`](crate::output::RejectQualificationRequestOutput)
    pub fn builder() -> crate::output::reject_qualification_request_output::Builder {
        crate::output::reject_qualification_request_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RejectAssignmentOutput {}
impl std::fmt::Debug for RejectAssignmentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RejectAssignmentOutput");
        formatter.finish()
    }
}
/// See [`RejectAssignmentOutput`](crate::output::RejectAssignmentOutput)
pub mod reject_assignment_output {
    /// A builder for [`RejectAssignmentOutput`](crate::output::RejectAssignmentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RejectAssignmentOutput`](crate::output::RejectAssignmentOutput)
        pub fn build(self) -> crate::output::RejectAssignmentOutput {
            crate::output::RejectAssignmentOutput {}
        }
    }
}
impl RejectAssignmentOutput {
    /// Creates a new builder-style object to manufacture [`RejectAssignmentOutput`](crate::output::RejectAssignmentOutput)
    pub fn builder() -> crate::output::reject_assignment_output::Builder {
        crate::output::reject_assignment_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotifyWorkersOutput {
    /// <p> When MTurk sends notifications to the list of Workers, it returns back any failures it encounters in this list of NotifyWorkersFailureStatus objects. </p>
    pub notify_workers_failure_statuses:
        std::option::Option<std::vec::Vec<crate::model::NotifyWorkersFailureStatus>>,
}
impl NotifyWorkersOutput {
    /// <p> When MTurk sends notifications to the list of Workers, it returns back any failures it encounters in this list of NotifyWorkersFailureStatus objects. </p>
    pub fn notify_workers_failure_statuses(
        &self,
    ) -> std::option::Option<&[crate::model::NotifyWorkersFailureStatus]> {
        self.notify_workers_failure_statuses.as_deref()
    }
}
impl std::fmt::Debug for NotifyWorkersOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotifyWorkersOutput");
        formatter.field(
            "notify_workers_failure_statuses",
            &self.notify_workers_failure_statuses,
        );
        formatter.finish()
    }
}
/// See [`NotifyWorkersOutput`](crate::output::NotifyWorkersOutput)
pub mod notify_workers_output {
    /// A builder for [`NotifyWorkersOutput`](crate::output::NotifyWorkersOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) notify_workers_failure_statuses:
            std::option::Option<std::vec::Vec<crate::model::NotifyWorkersFailureStatus>>,
    }
    impl Builder {
        /// Appends an item to `notify_workers_failure_statuses`.
        ///
        /// To override the contents of this collection use [`set_notify_workers_failure_statuses`](Self::set_notify_workers_failure_statuses).
        ///
        /// <p> When MTurk sends notifications to the list of Workers, it returns back any failures it encounters in this list of NotifyWorkersFailureStatus objects. </p>
        pub fn notify_workers_failure_statuses(
            mut self,
            input: crate::model::NotifyWorkersFailureStatus,
        ) -> Self {
            let mut v = self.notify_workers_failure_statuses.unwrap_or_default();
            v.push(input);
            self.notify_workers_failure_statuses = Some(v);
            self
        }
        /// <p> When MTurk sends notifications to the list of Workers, it returns back any failures it encounters in this list of NotifyWorkersFailureStatus objects. </p>
        pub fn set_notify_workers_failure_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NotifyWorkersFailureStatus>>,
        ) -> Self {
            self.notify_workers_failure_statuses = input;
            self
        }
        /// Consumes the builder and constructs a [`NotifyWorkersOutput`](crate::output::NotifyWorkersOutput)
        pub fn build(self) -> crate::output::NotifyWorkersOutput {
            crate::output::NotifyWorkersOutput {
                notify_workers_failure_statuses: self.notify_workers_failure_statuses,
            }
        }
    }
}
impl NotifyWorkersOutput {
    /// Creates a new builder-style object to manufacture [`NotifyWorkersOutput`](crate::output::NotifyWorkersOutput)
    pub fn builder() -> crate::output::notify_workers_output::Builder {
        crate::output::notify_workers_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWorkersWithQualificationTypeOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The number of Qualifications on this page in the filtered results list, equivalent to the number of Qualifications being returned by this call.</p>
    pub num_results: std::option::Option<i32>,
    /// <p> The list of Qualification elements returned by this call. </p>
    pub qualifications: std::option::Option<std::vec::Vec<crate::model::Qualification>>,
}
impl ListWorkersWithQualificationTypeOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The number of Qualifications on this page in the filtered results list, equivalent to the number of Qualifications being returned by this call.</p>
    pub fn num_results(&self) -> std::option::Option<i32> {
        self.num_results
    }
    /// <p> The list of Qualification elements returned by this call. </p>
    pub fn qualifications(&self) -> std::option::Option<&[crate::model::Qualification]> {
        self.qualifications.as_deref()
    }
}
impl std::fmt::Debug for ListWorkersWithQualificationTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWorkersWithQualificationTypeOutput");
        formatter.field("next_token", &self.next_token);
        formatter.field("num_results", &self.num_results);
        formatter.field("qualifications", &self.qualifications);
        formatter.finish()
    }
}
/// See [`ListWorkersWithQualificationTypeOutput`](crate::output::ListWorkersWithQualificationTypeOutput)
pub mod list_workers_with_qualification_type_output {
    /// A builder for [`ListWorkersWithQualificationTypeOutput`](crate::output::ListWorkersWithQualificationTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) num_results: std::option::Option<i32>,
        pub(crate) qualifications: std::option::Option<std::vec::Vec<crate::model::Qualification>>,
    }
    impl Builder {
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The number of Qualifications on this page in the filtered results list, equivalent to the number of Qualifications being returned by this call.</p>
        pub fn num_results(mut self, input: i32) -> Self {
            self.num_results = Some(input);
            self
        }
        /// <p> The number of Qualifications on this page in the filtered results list, equivalent to the number of Qualifications being returned by this call.</p>
        pub fn set_num_results(mut self, input: std::option::Option<i32>) -> Self {
            self.num_results = input;
            self
        }
        /// Appends an item to `qualifications`.
        ///
        /// To override the contents of this collection use [`set_qualifications`](Self::set_qualifications).
        ///
        /// <p> The list of Qualification elements returned by this call. </p>
        pub fn qualifications(mut self, input: crate::model::Qualification) -> Self {
            let mut v = self.qualifications.unwrap_or_default();
            v.push(input);
            self.qualifications = Some(v);
            self
        }
        /// <p> The list of Qualification elements returned by this call. </p>
        pub fn set_qualifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Qualification>>,
        ) -> Self {
            self.qualifications = input;
            self
        }
        /// Consumes the builder and constructs a [`ListWorkersWithQualificationTypeOutput`](crate::output::ListWorkersWithQualificationTypeOutput)
        pub fn build(self) -> crate::output::ListWorkersWithQualificationTypeOutput {
            crate::output::ListWorkersWithQualificationTypeOutput {
                next_token: self.next_token,
                num_results: self.num_results,
                qualifications: self.qualifications,
            }
        }
    }
}
impl ListWorkersWithQualificationTypeOutput {
    /// Creates a new builder-style object to manufacture [`ListWorkersWithQualificationTypeOutput`](crate::output::ListWorkersWithQualificationTypeOutput)
    pub fn builder() -> crate::output::list_workers_with_qualification_type_output::Builder {
        crate::output::list_workers_with_qualification_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWorkerBlocksOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.</p>
    pub num_results: std::option::Option<i32>,
    /// <p> The list of WorkerBlocks, containing the collection of Worker IDs and reasons for blocking.</p>
    pub worker_blocks: std::option::Option<std::vec::Vec<crate::model::WorkerBlock>>,
}
impl ListWorkerBlocksOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.</p>
    pub fn num_results(&self) -> std::option::Option<i32> {
        self.num_results
    }
    /// <p> The list of WorkerBlocks, containing the collection of Worker IDs and reasons for blocking.</p>
    pub fn worker_blocks(&self) -> std::option::Option<&[crate::model::WorkerBlock]> {
        self.worker_blocks.as_deref()
    }
}
impl std::fmt::Debug for ListWorkerBlocksOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWorkerBlocksOutput");
        formatter.field("next_token", &self.next_token);
        formatter.field("num_results", &self.num_results);
        formatter.field("worker_blocks", &self.worker_blocks);
        formatter.finish()
    }
}
/// See [`ListWorkerBlocksOutput`](crate::output::ListWorkerBlocksOutput)
pub mod list_worker_blocks_output {
    /// A builder for [`ListWorkerBlocksOutput`](crate::output::ListWorkerBlocksOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) num_results: std::option::Option<i32>,
        pub(crate) worker_blocks: std::option::Option<std::vec::Vec<crate::model::WorkerBlock>>,
    }
    impl Builder {
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.</p>
        pub fn num_results(mut self, input: i32) -> Self {
            self.num_results = Some(input);
            self
        }
        /// <p> The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.</p>
        pub fn set_num_results(mut self, input: std::option::Option<i32>) -> Self {
            self.num_results = input;
            self
        }
        /// Appends an item to `worker_blocks`.
        ///
        /// To override the contents of this collection use [`set_worker_blocks`](Self::set_worker_blocks).
        ///
        /// <p> The list of WorkerBlocks, containing the collection of Worker IDs and reasons for blocking.</p>
        pub fn worker_blocks(mut self, input: crate::model::WorkerBlock) -> Self {
            let mut v = self.worker_blocks.unwrap_or_default();
            v.push(input);
            self.worker_blocks = Some(v);
            self
        }
        /// <p> The list of WorkerBlocks, containing the collection of Worker IDs and reasons for blocking.</p>
        pub fn set_worker_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorkerBlock>>,
        ) -> Self {
            self.worker_blocks = input;
            self
        }
        /// Consumes the builder and constructs a [`ListWorkerBlocksOutput`](crate::output::ListWorkerBlocksOutput)
        pub fn build(self) -> crate::output::ListWorkerBlocksOutput {
            crate::output::ListWorkerBlocksOutput {
                next_token: self.next_token,
                num_results: self.num_results,
                worker_blocks: self.worker_blocks,
            }
        }
    }
}
impl ListWorkerBlocksOutput {
    /// Creates a new builder-style object to manufacture [`ListWorkerBlocksOutput`](crate::output::ListWorkerBlocksOutput)
    pub fn builder() -> crate::output::list_worker_blocks_output::Builder {
        crate::output::list_worker_blocks_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListReviewPolicyResultsForHitOutput {
    /// <p>The HITId of the HIT for which results have been returned.</p>
    pub hit_id: std::option::Option<std::string::String>,
    /// <p> The name of the Assignment-level Review Policy. This contains only the PolicyName element. </p>
    pub assignment_review_policy: std::option::Option<crate::model::ReviewPolicy>,
    /// <p>The name of the HIT-level Review Policy. This contains only the PolicyName element.</p>
    pub hit_review_policy: std::option::Option<crate::model::ReviewPolicy>,
    /// <p> Contains both ReviewResult and ReviewAction elements for an Assignment. </p>
    pub assignment_review_report: std::option::Option<crate::model::ReviewReport>,
    /// <p>Contains both ReviewResult and ReviewAction elements for a particular HIT. </p>
    pub hit_review_report: std::option::Option<crate::model::ReviewReport>,
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListReviewPolicyResultsForHitOutput {
    /// <p>The HITId of the HIT for which results have been returned.</p>
    pub fn hit_id(&self) -> std::option::Option<&str> {
        self.hit_id.as_deref()
    }
    /// <p> The name of the Assignment-level Review Policy. This contains only the PolicyName element. </p>
    pub fn assignment_review_policy(&self) -> std::option::Option<&crate::model::ReviewPolicy> {
        self.assignment_review_policy.as_ref()
    }
    /// <p>The name of the HIT-level Review Policy. This contains only the PolicyName element.</p>
    pub fn hit_review_policy(&self) -> std::option::Option<&crate::model::ReviewPolicy> {
        self.hit_review_policy.as_ref()
    }
    /// <p> Contains both ReviewResult and ReviewAction elements for an Assignment. </p>
    pub fn assignment_review_report(&self) -> std::option::Option<&crate::model::ReviewReport> {
        self.assignment_review_report.as_ref()
    }
    /// <p>Contains both ReviewResult and ReviewAction elements for a particular HIT. </p>
    pub fn hit_review_report(&self) -> std::option::Option<&crate::model::ReviewReport> {
        self.hit_review_report.as_ref()
    }
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListReviewPolicyResultsForHitOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListReviewPolicyResultsForHitOutput");
        formatter.field("hit_id", &self.hit_id);
        formatter.field("assignment_review_policy", &self.assignment_review_policy);
        formatter.field("hit_review_policy", &self.hit_review_policy);
        formatter.field("assignment_review_report", &self.assignment_review_report);
        formatter.field("hit_review_report", &self.hit_review_report);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListReviewPolicyResultsForHitOutput`](crate::output::ListReviewPolicyResultsForHitOutput)
pub mod list_review_policy_results_for_hit_output {
    /// A builder for [`ListReviewPolicyResultsForHitOutput`](crate::output::ListReviewPolicyResultsForHitOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hit_id: std::option::Option<std::string::String>,
        pub(crate) assignment_review_policy: std::option::Option<crate::model::ReviewPolicy>,
        pub(crate) hit_review_policy: std::option::Option<crate::model::ReviewPolicy>,
        pub(crate) assignment_review_report: std::option::Option<crate::model::ReviewReport>,
        pub(crate) hit_review_report: std::option::Option<crate::model::ReviewReport>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The HITId of the HIT for which results have been returned.</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hit_id = Some(input.into());
            self
        }
        /// <p>The HITId of the HIT for which results have been returned.</p>
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hit_id = input;
            self
        }
        /// <p> The name of the Assignment-level Review Policy. This contains only the PolicyName element. </p>
        pub fn assignment_review_policy(mut self, input: crate::model::ReviewPolicy) -> Self {
            self.assignment_review_policy = Some(input);
            self
        }
        /// <p> The name of the Assignment-level Review Policy. This contains only the PolicyName element. </p>
        pub fn set_assignment_review_policy(
            mut self,
            input: std::option::Option<crate::model::ReviewPolicy>,
        ) -> Self {
            self.assignment_review_policy = input;
            self
        }
        /// <p>The name of the HIT-level Review Policy. This contains only the PolicyName element.</p>
        pub fn hit_review_policy(mut self, input: crate::model::ReviewPolicy) -> Self {
            self.hit_review_policy = Some(input);
            self
        }
        /// <p>The name of the HIT-level Review Policy. This contains only the PolicyName element.</p>
        pub fn set_hit_review_policy(
            mut self,
            input: std::option::Option<crate::model::ReviewPolicy>,
        ) -> Self {
            self.hit_review_policy = input;
            self
        }
        /// <p> Contains both ReviewResult and ReviewAction elements for an Assignment. </p>
        pub fn assignment_review_report(mut self, input: crate::model::ReviewReport) -> Self {
            self.assignment_review_report = Some(input);
            self
        }
        /// <p> Contains both ReviewResult and ReviewAction elements for an Assignment. </p>
        pub fn set_assignment_review_report(
            mut self,
            input: std::option::Option<crate::model::ReviewReport>,
        ) -> Self {
            self.assignment_review_report = input;
            self
        }
        /// <p>Contains both ReviewResult and ReviewAction elements for a particular HIT. </p>
        pub fn hit_review_report(mut self, input: crate::model::ReviewReport) -> Self {
            self.hit_review_report = Some(input);
            self
        }
        /// <p>Contains both ReviewResult and ReviewAction elements for a particular HIT. </p>
        pub fn set_hit_review_report(
            mut self,
            input: std::option::Option<crate::model::ReviewReport>,
        ) -> Self {
            self.hit_review_report = input;
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListReviewPolicyResultsForHitOutput`](crate::output::ListReviewPolicyResultsForHitOutput)
        pub fn build(self) -> crate::output::ListReviewPolicyResultsForHitOutput {
            crate::output::ListReviewPolicyResultsForHitOutput {
                hit_id: self.hit_id,
                assignment_review_policy: self.assignment_review_policy,
                hit_review_policy: self.hit_review_policy,
                assignment_review_report: self.assignment_review_report,
                hit_review_report: self.hit_review_report,
                next_token: self.next_token,
            }
        }
    }
}
impl ListReviewPolicyResultsForHitOutput {
    /// Creates a new builder-style object to manufacture [`ListReviewPolicyResultsForHitOutput`](crate::output::ListReviewPolicyResultsForHitOutput)
    pub fn builder() -> crate::output::list_review_policy_results_for_hit_output::Builder {
        crate::output::list_review_policy_results_for_hit_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListReviewableHiTsOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. </p>
    pub num_results: std::option::Option<i32>,
    /// <p> The list of HIT elements returned by the query.</p>
    pub hi_ts: std::option::Option<std::vec::Vec<crate::model::Hit>>,
}
impl ListReviewableHiTsOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. </p>
    pub fn num_results(&self) -> std::option::Option<i32> {
        self.num_results
    }
    /// <p> The list of HIT elements returned by the query.</p>
    pub fn hi_ts(&self) -> std::option::Option<&[crate::model::Hit]> {
        self.hi_ts.as_deref()
    }
}
impl std::fmt::Debug for ListReviewableHiTsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListReviewableHiTsOutput");
        formatter.field("next_token", &self.next_token);
        formatter.field("num_results", &self.num_results);
        formatter.field("hi_ts", &self.hi_ts);
        formatter.finish()
    }
}
/// See [`ListReviewableHiTsOutput`](crate::output::ListReviewableHiTsOutput)
pub mod list_reviewable_hi_ts_output {
    /// A builder for [`ListReviewableHiTsOutput`](crate::output::ListReviewableHiTsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) num_results: std::option::Option<i32>,
        pub(crate) hi_ts: std::option::Option<std::vec::Vec<crate::model::Hit>>,
    }
    impl Builder {
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. </p>
        pub fn num_results(mut self, input: i32) -> Self {
            self.num_results = Some(input);
            self
        }
        /// <p> The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. </p>
        pub fn set_num_results(mut self, input: std::option::Option<i32>) -> Self {
            self.num_results = input;
            self
        }
        /// Appends an item to `hi_ts`.
        ///
        /// To override the contents of this collection use [`set_hi_ts`](Self::set_hi_ts).
        ///
        /// <p> The list of HIT elements returned by the query.</p>
        pub fn hi_ts(mut self, input: crate::model::Hit) -> Self {
            let mut v = self.hi_ts.unwrap_or_default();
            v.push(input);
            self.hi_ts = Some(v);
            self
        }
        /// <p> The list of HIT elements returned by the query.</p>
        pub fn set_hi_ts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Hit>>,
        ) -> Self {
            self.hi_ts = input;
            self
        }
        /// Consumes the builder and constructs a [`ListReviewableHiTsOutput`](crate::output::ListReviewableHiTsOutput)
        pub fn build(self) -> crate::output::ListReviewableHiTsOutput {
            crate::output::ListReviewableHiTsOutput {
                next_token: self.next_token,
                num_results: self.num_results,
                hi_ts: self.hi_ts,
            }
        }
    }
}
impl ListReviewableHiTsOutput {
    /// Creates a new builder-style object to manufacture [`ListReviewableHiTsOutput`](crate::output::ListReviewableHiTsOutput)
    pub fn builder() -> crate::output::list_reviewable_hi_ts_output::Builder {
        crate::output::list_reviewable_hi_ts_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListQualificationTypesOutput {
    /// <p> The number of Qualification types on this page in the filtered results list, equivalent to the number of types this operation returns. </p>
    pub num_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The list of QualificationType elements returned by the query. </p>
    pub qualification_types: std::option::Option<std::vec::Vec<crate::model::QualificationType>>,
}
impl ListQualificationTypesOutput {
    /// <p> The number of Qualification types on this page in the filtered results list, equivalent to the number of types this operation returns. </p>
    pub fn num_results(&self) -> std::option::Option<i32> {
        self.num_results
    }
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The list of QualificationType elements returned by the query. </p>
    pub fn qualification_types(&self) -> std::option::Option<&[crate::model::QualificationType]> {
        self.qualification_types.as_deref()
    }
}
impl std::fmt::Debug for ListQualificationTypesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListQualificationTypesOutput");
        formatter.field("num_results", &self.num_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("qualification_types", &self.qualification_types);
        formatter.finish()
    }
}
/// See [`ListQualificationTypesOutput`](crate::output::ListQualificationTypesOutput)
pub mod list_qualification_types_output {
    /// A builder for [`ListQualificationTypesOutput`](crate::output::ListQualificationTypesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) num_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) qualification_types:
            std::option::Option<std::vec::Vec<crate::model::QualificationType>>,
    }
    impl Builder {
        /// <p> The number of Qualification types on this page in the filtered results list, equivalent to the number of types this operation returns. </p>
        pub fn num_results(mut self, input: i32) -> Self {
            self.num_results = Some(input);
            self
        }
        /// <p> The number of Qualification types on this page in the filtered results list, equivalent to the number of types this operation returns. </p>
        pub fn set_num_results(mut self, input: std::option::Option<i32>) -> Self {
            self.num_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `qualification_types`.
        ///
        /// To override the contents of this collection use [`set_qualification_types`](Self::set_qualification_types).
        ///
        /// <p> The list of QualificationType elements returned by the query. </p>
        pub fn qualification_types(mut self, input: crate::model::QualificationType) -> Self {
            let mut v = self.qualification_types.unwrap_or_default();
            v.push(input);
            self.qualification_types = Some(v);
            self
        }
        /// <p> The list of QualificationType elements returned by the query. </p>
        pub fn set_qualification_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QualificationType>>,
        ) -> Self {
            self.qualification_types = input;
            self
        }
        /// Consumes the builder and constructs a [`ListQualificationTypesOutput`](crate::output::ListQualificationTypesOutput)
        pub fn build(self) -> crate::output::ListQualificationTypesOutput {
            crate::output::ListQualificationTypesOutput {
                num_results: self.num_results,
                next_token: self.next_token,
                qualification_types: self.qualification_types,
            }
        }
    }
}
impl ListQualificationTypesOutput {
    /// Creates a new builder-style object to manufacture [`ListQualificationTypesOutput`](crate::output::ListQualificationTypesOutput)
    pub fn builder() -> crate::output::list_qualification_types_output::Builder {
        crate::output::list_qualification_types_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListQualificationRequestsOutput {
    /// <p>The number of Qualification requests on this page in the filtered results list, equivalent to the number of Qualification requests being returned by this call.</p>
    pub num_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The Qualification request. The response includes one QualificationRequest element for each Qualification request returned by the query.</p>
    pub qualification_requests:
        std::option::Option<std::vec::Vec<crate::model::QualificationRequest>>,
}
impl ListQualificationRequestsOutput {
    /// <p>The number of Qualification requests on this page in the filtered results list, equivalent to the number of Qualification requests being returned by this call.</p>
    pub fn num_results(&self) -> std::option::Option<i32> {
        self.num_results
    }
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The Qualification request. The response includes one QualificationRequest element for each Qualification request returned by the query.</p>
    pub fn qualification_requests(
        &self,
    ) -> std::option::Option<&[crate::model::QualificationRequest]> {
        self.qualification_requests.as_deref()
    }
}
impl std::fmt::Debug for ListQualificationRequestsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListQualificationRequestsOutput");
        formatter.field("num_results", &self.num_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("qualification_requests", &self.qualification_requests);
        formatter.finish()
    }
}
/// See [`ListQualificationRequestsOutput`](crate::output::ListQualificationRequestsOutput)
pub mod list_qualification_requests_output {
    /// A builder for [`ListQualificationRequestsOutput`](crate::output::ListQualificationRequestsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) num_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) qualification_requests:
            std::option::Option<std::vec::Vec<crate::model::QualificationRequest>>,
    }
    impl Builder {
        /// <p>The number of Qualification requests on this page in the filtered results list, equivalent to the number of Qualification requests being returned by this call.</p>
        pub fn num_results(mut self, input: i32) -> Self {
            self.num_results = Some(input);
            self
        }
        /// <p>The number of Qualification requests on this page in the filtered results list, equivalent to the number of Qualification requests being returned by this call.</p>
        pub fn set_num_results(mut self, input: std::option::Option<i32>) -> Self {
            self.num_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `qualification_requests`.
        ///
        /// To override the contents of this collection use [`set_qualification_requests`](Self::set_qualification_requests).
        ///
        /// <p>The Qualification request. The response includes one QualificationRequest element for each Qualification request returned by the query.</p>
        pub fn qualification_requests(mut self, input: crate::model::QualificationRequest) -> Self {
            let mut v = self.qualification_requests.unwrap_or_default();
            v.push(input);
            self.qualification_requests = Some(v);
            self
        }
        /// <p>The Qualification request. The response includes one QualificationRequest element for each Qualification request returned by the query.</p>
        pub fn set_qualification_requests(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QualificationRequest>>,
        ) -> Self {
            self.qualification_requests = input;
            self
        }
        /// Consumes the builder and constructs a [`ListQualificationRequestsOutput`](crate::output::ListQualificationRequestsOutput)
        pub fn build(self) -> crate::output::ListQualificationRequestsOutput {
            crate::output::ListQualificationRequestsOutput {
                num_results: self.num_results,
                next_token: self.next_token,
                qualification_requests: self.qualification_requests,
            }
        }
    }
}
impl ListQualificationRequestsOutput {
    /// Creates a new builder-style object to manufacture [`ListQualificationRequestsOutput`](crate::output::ListQualificationRequestsOutput)
    pub fn builder() -> crate::output::list_qualification_requests_output::Builder {
        crate::output::list_qualification_requests_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListHiTsForQualificationTypeOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. </p>
    pub num_results: std::option::Option<i32>,
    /// <p> The list of HIT elements returned by the query.</p>
    pub hi_ts: std::option::Option<std::vec::Vec<crate::model::Hit>>,
}
impl ListHiTsForQualificationTypeOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. </p>
    pub fn num_results(&self) -> std::option::Option<i32> {
        self.num_results
    }
    /// <p> The list of HIT elements returned by the query.</p>
    pub fn hi_ts(&self) -> std::option::Option<&[crate::model::Hit]> {
        self.hi_ts.as_deref()
    }
}
impl std::fmt::Debug for ListHiTsForQualificationTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListHiTsForQualificationTypeOutput");
        formatter.field("next_token", &self.next_token);
        formatter.field("num_results", &self.num_results);
        formatter.field("hi_ts", &self.hi_ts);
        formatter.finish()
    }
}
/// See [`ListHiTsForQualificationTypeOutput`](crate::output::ListHiTsForQualificationTypeOutput)
pub mod list_hi_ts_for_qualification_type_output {
    /// A builder for [`ListHiTsForQualificationTypeOutput`](crate::output::ListHiTsForQualificationTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) num_results: std::option::Option<i32>,
        pub(crate) hi_ts: std::option::Option<std::vec::Vec<crate::model::Hit>>,
    }
    impl Builder {
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. </p>
        pub fn num_results(mut self, input: i32) -> Self {
            self.num_results = Some(input);
            self
        }
        /// <p> The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. </p>
        pub fn set_num_results(mut self, input: std::option::Option<i32>) -> Self {
            self.num_results = input;
            self
        }
        /// Appends an item to `hi_ts`.
        ///
        /// To override the contents of this collection use [`set_hi_ts`](Self::set_hi_ts).
        ///
        /// <p> The list of HIT elements returned by the query.</p>
        pub fn hi_ts(mut self, input: crate::model::Hit) -> Self {
            let mut v = self.hi_ts.unwrap_or_default();
            v.push(input);
            self.hi_ts = Some(v);
            self
        }
        /// <p> The list of HIT elements returned by the query.</p>
        pub fn set_hi_ts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Hit>>,
        ) -> Self {
            self.hi_ts = input;
            self
        }
        /// Consumes the builder and constructs a [`ListHiTsForQualificationTypeOutput`](crate::output::ListHiTsForQualificationTypeOutput)
        pub fn build(self) -> crate::output::ListHiTsForQualificationTypeOutput {
            crate::output::ListHiTsForQualificationTypeOutput {
                next_token: self.next_token,
                num_results: self.num_results,
                hi_ts: self.hi_ts,
            }
        }
    }
}
impl ListHiTsForQualificationTypeOutput {
    /// Creates a new builder-style object to manufacture [`ListHiTsForQualificationTypeOutput`](crate::output::ListHiTsForQualificationTypeOutput)
    pub fn builder() -> crate::output::list_hi_ts_for_qualification_type_output::Builder {
        crate::output::list_hi_ts_for_qualification_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListHiTsOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call.</p>
    pub num_results: std::option::Option<i32>,
    /// <p> The list of HIT elements returned by the query.</p>
    pub hi_ts: std::option::Option<std::vec::Vec<crate::model::Hit>>,
}
impl ListHiTsOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call.</p>
    pub fn num_results(&self) -> std::option::Option<i32> {
        self.num_results
    }
    /// <p> The list of HIT elements returned by the query.</p>
    pub fn hi_ts(&self) -> std::option::Option<&[crate::model::Hit]> {
        self.hi_ts.as_deref()
    }
}
impl std::fmt::Debug for ListHiTsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListHiTsOutput");
        formatter.field("next_token", &self.next_token);
        formatter.field("num_results", &self.num_results);
        formatter.field("hi_ts", &self.hi_ts);
        formatter.finish()
    }
}
/// See [`ListHiTsOutput`](crate::output::ListHiTsOutput)
pub mod list_hi_ts_output {
    /// A builder for [`ListHiTsOutput`](crate::output::ListHiTsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) num_results: std::option::Option<i32>,
        pub(crate) hi_ts: std::option::Option<std::vec::Vec<crate::model::Hit>>,
    }
    impl Builder {
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call.</p>
        pub fn num_results(mut self, input: i32) -> Self {
            self.num_results = Some(input);
            self
        }
        /// <p>The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call.</p>
        pub fn set_num_results(mut self, input: std::option::Option<i32>) -> Self {
            self.num_results = input;
            self
        }
        /// Appends an item to `hi_ts`.
        ///
        /// To override the contents of this collection use [`set_hi_ts`](Self::set_hi_ts).
        ///
        /// <p> The list of HIT elements returned by the query.</p>
        pub fn hi_ts(mut self, input: crate::model::Hit) -> Self {
            let mut v = self.hi_ts.unwrap_or_default();
            v.push(input);
            self.hi_ts = Some(v);
            self
        }
        /// <p> The list of HIT elements returned by the query.</p>
        pub fn set_hi_ts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Hit>>,
        ) -> Self {
            self.hi_ts = input;
            self
        }
        /// Consumes the builder and constructs a [`ListHiTsOutput`](crate::output::ListHiTsOutput)
        pub fn build(self) -> crate::output::ListHiTsOutput {
            crate::output::ListHiTsOutput {
                next_token: self.next_token,
                num_results: self.num_results,
                hi_ts: self.hi_ts,
            }
        }
    }
}
impl ListHiTsOutput {
    /// Creates a new builder-style object to manufacture [`ListHiTsOutput`](crate::output::ListHiTsOutput)
    pub fn builder() -> crate::output::list_hi_ts_output::Builder {
        crate::output::list_hi_ts_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListBonusPaymentsOutput {
    /// <p>The number of bonus payments on this page in the filtered results list, equivalent to the number of bonus payments being returned by this call. </p>
    pub num_results: std::option::Option<i32>,
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A successful request to the ListBonusPayments operation returns a list of BonusPayment objects. </p>
    pub bonus_payments: std::option::Option<std::vec::Vec<crate::model::BonusPayment>>,
}
impl ListBonusPaymentsOutput {
    /// <p>The number of bonus payments on this page in the filtered results list, equivalent to the number of bonus payments being returned by this call. </p>
    pub fn num_results(&self) -> std::option::Option<i32> {
        self.num_results
    }
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>A successful request to the ListBonusPayments operation returns a list of BonusPayment objects. </p>
    pub fn bonus_payments(&self) -> std::option::Option<&[crate::model::BonusPayment]> {
        self.bonus_payments.as_deref()
    }
}
impl std::fmt::Debug for ListBonusPaymentsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListBonusPaymentsOutput");
        formatter.field("num_results", &self.num_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("bonus_payments", &self.bonus_payments);
        formatter.finish()
    }
}
/// See [`ListBonusPaymentsOutput`](crate::output::ListBonusPaymentsOutput)
pub mod list_bonus_payments_output {
    /// A builder for [`ListBonusPaymentsOutput`](crate::output::ListBonusPaymentsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) num_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) bonus_payments: std::option::Option<std::vec::Vec<crate::model::BonusPayment>>,
    }
    impl Builder {
        /// <p>The number of bonus payments on this page in the filtered results list, equivalent to the number of bonus payments being returned by this call. </p>
        pub fn num_results(mut self, input: i32) -> Self {
            self.num_results = Some(input);
            self
        }
        /// <p>The number of bonus payments on this page in the filtered results list, equivalent to the number of bonus payments being returned by this call. </p>
        pub fn set_num_results(mut self, input: std::option::Option<i32>) -> Self {
            self.num_results = input;
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `bonus_payments`.
        ///
        /// To override the contents of this collection use [`set_bonus_payments`](Self::set_bonus_payments).
        ///
        /// <p>A successful request to the ListBonusPayments operation returns a list of BonusPayment objects. </p>
        pub fn bonus_payments(mut self, input: crate::model::BonusPayment) -> Self {
            let mut v = self.bonus_payments.unwrap_or_default();
            v.push(input);
            self.bonus_payments = Some(v);
            self
        }
        /// <p>A successful request to the ListBonusPayments operation returns a list of BonusPayment objects. </p>
        pub fn set_bonus_payments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BonusPayment>>,
        ) -> Self {
            self.bonus_payments = input;
            self
        }
        /// Consumes the builder and constructs a [`ListBonusPaymentsOutput`](crate::output::ListBonusPaymentsOutput)
        pub fn build(self) -> crate::output::ListBonusPaymentsOutput {
            crate::output::ListBonusPaymentsOutput {
                num_results: self.num_results,
                next_token: self.next_token,
                bonus_payments: self.bonus_payments,
            }
        }
    }
}
impl ListBonusPaymentsOutput {
    /// Creates a new builder-style object to manufacture [`ListBonusPaymentsOutput`](crate::output::ListBonusPaymentsOutput)
    pub fn builder() -> crate::output::list_bonus_payments_output::Builder {
        crate::output::list_bonus_payments_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAssignmentsForHitOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.</p>
    pub num_results: std::option::Option<i32>,
    /// <p> The collection of Assignment data structures returned by this call.</p>
    pub assignments: std::option::Option<std::vec::Vec<crate::model::Assignment>>,
}
impl ListAssignmentsForHitOutput {
    /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.</p>
    pub fn num_results(&self) -> std::option::Option<i32> {
        self.num_results
    }
    /// <p> The collection of Assignment data structures returned by this call.</p>
    pub fn assignments(&self) -> std::option::Option<&[crate::model::Assignment]> {
        self.assignments.as_deref()
    }
}
impl std::fmt::Debug for ListAssignmentsForHitOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAssignmentsForHitOutput");
        formatter.field("next_token", &self.next_token);
        formatter.field("num_results", &self.num_results);
        formatter.field("assignments", &self.assignments);
        formatter.finish()
    }
}
/// See [`ListAssignmentsForHitOutput`](crate::output::ListAssignmentsForHitOutput)
pub mod list_assignments_for_hit_output {
    /// A builder for [`ListAssignmentsForHitOutput`](crate::output::ListAssignmentsForHitOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) num_results: std::option::Option<i32>,
        pub(crate) assignments: std::option::Option<std::vec::Vec<crate::model::Assignment>>,
    }
    impl Builder {
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk returns a pagination token in the response. You can use this pagination token to retrieve the next set of results. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.</p>
        pub fn num_results(mut self, input: i32) -> Self {
            self.num_results = Some(input);
            self
        }
        /// <p> The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.</p>
        pub fn set_num_results(mut self, input: std::option::Option<i32>) -> Self {
            self.num_results = input;
            self
        }
        /// Appends an item to `assignments`.
        ///
        /// To override the contents of this collection use [`set_assignments`](Self::set_assignments).
        ///
        /// <p> The collection of Assignment data structures returned by this call.</p>
        pub fn assignments(mut self, input: crate::model::Assignment) -> Self {
            let mut v = self.assignments.unwrap_or_default();
            v.push(input);
            self.assignments = Some(v);
            self
        }
        /// <p> The collection of Assignment data structures returned by this call.</p>
        pub fn set_assignments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Assignment>>,
        ) -> Self {
            self.assignments = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAssignmentsForHitOutput`](crate::output::ListAssignmentsForHitOutput)
        pub fn build(self) -> crate::output::ListAssignmentsForHitOutput {
            crate::output::ListAssignmentsForHitOutput {
                next_token: self.next_token,
                num_results: self.num_results,
                assignments: self.assignments,
            }
        }
    }
}
impl ListAssignmentsForHitOutput {
    /// Creates a new builder-style object to manufacture [`ListAssignmentsForHitOutput`](crate::output::ListAssignmentsForHitOutput)
    pub fn builder() -> crate::output::list_assignments_for_hit_output::Builder {
        crate::output::list_assignments_for_hit_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetQualificationTypeOutput {
    /// <p> The returned Qualification Type</p>
    pub qualification_type: std::option::Option<crate::model::QualificationType>,
}
impl GetQualificationTypeOutput {
    /// <p> The returned Qualification Type</p>
    pub fn qualification_type(&self) -> std::option::Option<&crate::model::QualificationType> {
        self.qualification_type.as_ref()
    }
}
impl std::fmt::Debug for GetQualificationTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetQualificationTypeOutput");
        formatter.field("qualification_type", &self.qualification_type);
        formatter.finish()
    }
}
/// See [`GetQualificationTypeOutput`](crate::output::GetQualificationTypeOutput)
pub mod get_qualification_type_output {
    /// A builder for [`GetQualificationTypeOutput`](crate::output::GetQualificationTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) qualification_type: std::option::Option<crate::model::QualificationType>,
    }
    impl Builder {
        /// <p> The returned Qualification Type</p>
        pub fn qualification_type(mut self, input: crate::model::QualificationType) -> Self {
            self.qualification_type = Some(input);
            self
        }
        /// <p> The returned Qualification Type</p>
        pub fn set_qualification_type(
            mut self,
            input: std::option::Option<crate::model::QualificationType>,
        ) -> Self {
            self.qualification_type = input;
            self
        }
        /// Consumes the builder and constructs a [`GetQualificationTypeOutput`](crate::output::GetQualificationTypeOutput)
        pub fn build(self) -> crate::output::GetQualificationTypeOutput {
            crate::output::GetQualificationTypeOutput {
                qualification_type: self.qualification_type,
            }
        }
    }
}
impl GetQualificationTypeOutput {
    /// Creates a new builder-style object to manufacture [`GetQualificationTypeOutput`](crate::output::GetQualificationTypeOutput)
    pub fn builder() -> crate::output::get_qualification_type_output::Builder {
        crate::output::get_qualification_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetQualificationScoreOutput {
    /// <p> The Qualification data structure of the Qualification assigned to a user, including the Qualification type and the value (score). </p>
    pub qualification: std::option::Option<crate::model::Qualification>,
}
impl GetQualificationScoreOutput {
    /// <p> The Qualification data structure of the Qualification assigned to a user, including the Qualification type and the value (score). </p>
    pub fn qualification(&self) -> std::option::Option<&crate::model::Qualification> {
        self.qualification.as_ref()
    }
}
impl std::fmt::Debug for GetQualificationScoreOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetQualificationScoreOutput");
        formatter.field("qualification", &self.qualification);
        formatter.finish()
    }
}
/// See [`GetQualificationScoreOutput`](crate::output::GetQualificationScoreOutput)
pub mod get_qualification_score_output {
    /// A builder for [`GetQualificationScoreOutput`](crate::output::GetQualificationScoreOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) qualification: std::option::Option<crate::model::Qualification>,
    }
    impl Builder {
        /// <p> The Qualification data structure of the Qualification assigned to a user, including the Qualification type and the value (score). </p>
        pub fn qualification(mut self, input: crate::model::Qualification) -> Self {
            self.qualification = Some(input);
            self
        }
        /// <p> The Qualification data structure of the Qualification assigned to a user, including the Qualification type and the value (score). </p>
        pub fn set_qualification(
            mut self,
            input: std::option::Option<crate::model::Qualification>,
        ) -> Self {
            self.qualification = input;
            self
        }
        /// Consumes the builder and constructs a [`GetQualificationScoreOutput`](crate::output::GetQualificationScoreOutput)
        pub fn build(self) -> crate::output::GetQualificationScoreOutput {
            crate::output::GetQualificationScoreOutput {
                qualification: self.qualification,
            }
        }
    }
}
impl GetQualificationScoreOutput {
    /// Creates a new builder-style object to manufacture [`GetQualificationScoreOutput`](crate::output::GetQualificationScoreOutput)
    pub fn builder() -> crate::output::get_qualification_score_output::Builder {
        crate::output::get_qualification_score_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetHitOutput {
    /// <p> Contains the requested HIT data.</p>
    pub hit: std::option::Option<crate::model::Hit>,
}
impl GetHitOutput {
    /// <p> Contains the requested HIT data.</p>
    pub fn hit(&self) -> std::option::Option<&crate::model::Hit> {
        self.hit.as_ref()
    }
}
impl std::fmt::Debug for GetHitOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetHitOutput");
        formatter.field("hit", &self.hit);
        formatter.finish()
    }
}
/// See [`GetHitOutput`](crate::output::GetHitOutput)
pub mod get_hit_output {
    /// A builder for [`GetHitOutput`](crate::output::GetHitOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hit: std::option::Option<crate::model::Hit>,
    }
    impl Builder {
        /// <p> Contains the requested HIT data.</p>
        pub fn hit(mut self, input: crate::model::Hit) -> Self {
            self.hit = Some(input);
            self
        }
        /// <p> Contains the requested HIT data.</p>
        pub fn set_hit(mut self, input: std::option::Option<crate::model::Hit>) -> Self {
            self.hit = input;
            self
        }
        /// Consumes the builder and constructs a [`GetHitOutput`](crate::output::GetHitOutput)
        pub fn build(self) -> crate::output::GetHitOutput {
            crate::output::GetHitOutput { hit: self.hit }
        }
    }
}
impl GetHitOutput {
    /// Creates a new builder-style object to manufacture [`GetHitOutput`](crate::output::GetHitOutput)
    pub fn builder() -> crate::output::get_hit_output::Builder {
        crate::output::get_hit_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetFileUploadUrlOutput {
    /// <p> A temporary URL for the file that the Worker uploaded for the answer. </p>
    pub file_upload_url: std::option::Option<std::string::String>,
}
impl GetFileUploadUrlOutput {
    /// <p> A temporary URL for the file that the Worker uploaded for the answer. </p>
    pub fn file_upload_url(&self) -> std::option::Option<&str> {
        self.file_upload_url.as_deref()
    }
}
impl std::fmt::Debug for GetFileUploadUrlOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetFileUploadUrlOutput");
        formatter.field("file_upload_url", &self.file_upload_url);
        formatter.finish()
    }
}
/// See [`GetFileUploadUrlOutput`](crate::output::GetFileUploadUrlOutput)
pub mod get_file_upload_url_output {
    /// A builder for [`GetFileUploadUrlOutput`](crate::output::GetFileUploadUrlOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_upload_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> A temporary URL for the file that the Worker uploaded for the answer. </p>
        pub fn file_upload_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_upload_url = Some(input.into());
            self
        }
        /// <p> A temporary URL for the file that the Worker uploaded for the answer. </p>
        pub fn set_file_upload_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_upload_url = input;
            self
        }
        /// Consumes the builder and constructs a [`GetFileUploadUrlOutput`](crate::output::GetFileUploadUrlOutput)
        pub fn build(self) -> crate::output::GetFileUploadUrlOutput {
            crate::output::GetFileUploadUrlOutput {
                file_upload_url: self.file_upload_url,
            }
        }
    }
}
impl GetFileUploadUrlOutput {
    /// Creates a new builder-style object to manufacture [`GetFileUploadUrlOutput`](crate::output::GetFileUploadUrlOutput)
    pub fn builder() -> crate::output::get_file_upload_url_output::Builder {
        crate::output::get_file_upload_url_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAssignmentOutput {
    /// <p> The assignment. The response includes one Assignment element. </p>
    pub assignment: std::option::Option<crate::model::Assignment>,
    /// <p> The HIT associated with this assignment. The response includes one HIT element.</p>
    pub hit: std::option::Option<crate::model::Hit>,
}
impl GetAssignmentOutput {
    /// <p> The assignment. The response includes one Assignment element. </p>
    pub fn assignment(&self) -> std::option::Option<&crate::model::Assignment> {
        self.assignment.as_ref()
    }
    /// <p> The HIT associated with this assignment. The response includes one HIT element.</p>
    pub fn hit(&self) -> std::option::Option<&crate::model::Hit> {
        self.hit.as_ref()
    }
}
impl std::fmt::Debug for GetAssignmentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAssignmentOutput");
        formatter.field("assignment", &self.assignment);
        formatter.field("hit", &self.hit);
        formatter.finish()
    }
}
/// See [`GetAssignmentOutput`](crate::output::GetAssignmentOutput)
pub mod get_assignment_output {
    /// A builder for [`GetAssignmentOutput`](crate::output::GetAssignmentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) assignment: std::option::Option<crate::model::Assignment>,
        pub(crate) hit: std::option::Option<crate::model::Hit>,
    }
    impl Builder {
        /// <p> The assignment. The response includes one Assignment element. </p>
        pub fn assignment(mut self, input: crate::model::Assignment) -> Self {
            self.assignment = Some(input);
            self
        }
        /// <p> The assignment. The response includes one Assignment element. </p>
        pub fn set_assignment(
            mut self,
            input: std::option::Option<crate::model::Assignment>,
        ) -> Self {
            self.assignment = input;
            self
        }
        /// <p> The HIT associated with this assignment. The response includes one HIT element.</p>
        pub fn hit(mut self, input: crate::model::Hit) -> Self {
            self.hit = Some(input);
            self
        }
        /// <p> The HIT associated with this assignment. The response includes one HIT element.</p>
        pub fn set_hit(mut self, input: std::option::Option<crate::model::Hit>) -> Self {
            self.hit = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAssignmentOutput`](crate::output::GetAssignmentOutput)
        pub fn build(self) -> crate::output::GetAssignmentOutput {
            crate::output::GetAssignmentOutput {
                assignment: self.assignment,
                hit: self.hit,
            }
        }
    }
}
impl GetAssignmentOutput {
    /// Creates a new builder-style object to manufacture [`GetAssignmentOutput`](crate::output::GetAssignmentOutput)
    pub fn builder() -> crate::output::get_assignment_output::Builder {
        crate::output::get_assignment_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccountBalanceOutput {
    /// <p>A string representing a currency amount.</p>
    pub available_balance: std::option::Option<std::string::String>,
    /// <p>A string representing a currency amount.</p>
    pub on_hold_balance: std::option::Option<std::string::String>,
}
impl GetAccountBalanceOutput {
    /// <p>A string representing a currency amount.</p>
    pub fn available_balance(&self) -> std::option::Option<&str> {
        self.available_balance.as_deref()
    }
    /// <p>A string representing a currency amount.</p>
    pub fn on_hold_balance(&self) -> std::option::Option<&str> {
        self.on_hold_balance.as_deref()
    }
}
impl std::fmt::Debug for GetAccountBalanceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccountBalanceOutput");
        formatter.field("available_balance", &self.available_balance);
        formatter.field("on_hold_balance", &self.on_hold_balance);
        formatter.finish()
    }
}
/// See [`GetAccountBalanceOutput`](crate::output::GetAccountBalanceOutput)
pub mod get_account_balance_output {
    /// A builder for [`GetAccountBalanceOutput`](crate::output::GetAccountBalanceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) available_balance: std::option::Option<std::string::String>,
        pub(crate) on_hold_balance: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A string representing a currency amount.</p>
        pub fn available_balance(mut self, input: impl Into<std::string::String>) -> Self {
            self.available_balance = Some(input.into());
            self
        }
        /// <p>A string representing a currency amount.</p>
        pub fn set_available_balance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.available_balance = input;
            self
        }
        /// <p>A string representing a currency amount.</p>
        pub fn on_hold_balance(mut self, input: impl Into<std::string::String>) -> Self {
            self.on_hold_balance = Some(input.into());
            self
        }
        /// <p>A string representing a currency amount.</p>
        pub fn set_on_hold_balance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_hold_balance = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAccountBalanceOutput`](crate::output::GetAccountBalanceOutput)
        pub fn build(self) -> crate::output::GetAccountBalanceOutput {
            crate::output::GetAccountBalanceOutput {
                available_balance: self.available_balance,
                on_hold_balance: self.on_hold_balance,
            }
        }
    }
}
impl GetAccountBalanceOutput {
    /// Creates a new builder-style object to manufacture [`GetAccountBalanceOutput`](crate::output::GetAccountBalanceOutput)
    pub fn builder() -> crate::output::get_account_balance_output::Builder {
        crate::output::get_account_balance_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateQualificationFromWorkerOutput {}
impl std::fmt::Debug for DisassociateQualificationFromWorkerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateQualificationFromWorkerOutput");
        formatter.finish()
    }
}
/// See [`DisassociateQualificationFromWorkerOutput`](crate::output::DisassociateQualificationFromWorkerOutput)
pub mod disassociate_qualification_from_worker_output {
    /// A builder for [`DisassociateQualificationFromWorkerOutput`](crate::output::DisassociateQualificationFromWorkerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DisassociateQualificationFromWorkerOutput`](crate::output::DisassociateQualificationFromWorkerOutput)
        pub fn build(self) -> crate::output::DisassociateQualificationFromWorkerOutput {
            crate::output::DisassociateQualificationFromWorkerOutput {}
        }
    }
}
impl DisassociateQualificationFromWorkerOutput {
    /// Creates a new builder-style object to manufacture [`DisassociateQualificationFromWorkerOutput`](crate::output::DisassociateQualificationFromWorkerOutput)
    pub fn builder() -> crate::output::disassociate_qualification_from_worker_output::Builder {
        crate::output::disassociate_qualification_from_worker_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteWorkerBlockOutput {}
impl std::fmt::Debug for DeleteWorkerBlockOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteWorkerBlockOutput");
        formatter.finish()
    }
}
/// See [`DeleteWorkerBlockOutput`](crate::output::DeleteWorkerBlockOutput)
pub mod delete_worker_block_output {
    /// A builder for [`DeleteWorkerBlockOutput`](crate::output::DeleteWorkerBlockOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteWorkerBlockOutput`](crate::output::DeleteWorkerBlockOutput)
        pub fn build(self) -> crate::output::DeleteWorkerBlockOutput {
            crate::output::DeleteWorkerBlockOutput {}
        }
    }
}
impl DeleteWorkerBlockOutput {
    /// Creates a new builder-style object to manufacture [`DeleteWorkerBlockOutput`](crate::output::DeleteWorkerBlockOutput)
    pub fn builder() -> crate::output::delete_worker_block_output::Builder {
        crate::output::delete_worker_block_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteQualificationTypeOutput {}
impl std::fmt::Debug for DeleteQualificationTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteQualificationTypeOutput");
        formatter.finish()
    }
}
/// See [`DeleteQualificationTypeOutput`](crate::output::DeleteQualificationTypeOutput)
pub mod delete_qualification_type_output {
    /// A builder for [`DeleteQualificationTypeOutput`](crate::output::DeleteQualificationTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteQualificationTypeOutput`](crate::output::DeleteQualificationTypeOutput)
        pub fn build(self) -> crate::output::DeleteQualificationTypeOutput {
            crate::output::DeleteQualificationTypeOutput {}
        }
    }
}
impl DeleteQualificationTypeOutput {
    /// Creates a new builder-style object to manufacture [`DeleteQualificationTypeOutput`](crate::output::DeleteQualificationTypeOutput)
    pub fn builder() -> crate::output::delete_qualification_type_output::Builder {
        crate::output::delete_qualification_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteHitOutput {}
impl std::fmt::Debug for DeleteHitOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteHitOutput");
        formatter.finish()
    }
}
/// See [`DeleteHitOutput`](crate::output::DeleteHitOutput)
pub mod delete_hit_output {
    /// A builder for [`DeleteHitOutput`](crate::output::DeleteHitOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteHitOutput`](crate::output::DeleteHitOutput)
        pub fn build(self) -> crate::output::DeleteHitOutput {
            crate::output::DeleteHitOutput {}
        }
    }
}
impl DeleteHitOutput {
    /// Creates a new builder-style object to manufacture [`DeleteHitOutput`](crate::output::DeleteHitOutput)
    pub fn builder() -> crate::output::delete_hit_output::Builder {
        crate::output::delete_hit_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWorkerBlockOutput {}
impl std::fmt::Debug for CreateWorkerBlockOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWorkerBlockOutput");
        formatter.finish()
    }
}
/// See [`CreateWorkerBlockOutput`](crate::output::CreateWorkerBlockOutput)
pub mod create_worker_block_output {
    /// A builder for [`CreateWorkerBlockOutput`](crate::output::CreateWorkerBlockOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CreateWorkerBlockOutput`](crate::output::CreateWorkerBlockOutput)
        pub fn build(self) -> crate::output::CreateWorkerBlockOutput {
            crate::output::CreateWorkerBlockOutput {}
        }
    }
}
impl CreateWorkerBlockOutput {
    /// Creates a new builder-style object to manufacture [`CreateWorkerBlockOutput`](crate::output::CreateWorkerBlockOutput)
    pub fn builder() -> crate::output::create_worker_block_output::Builder {
        crate::output::create_worker_block_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateQualificationTypeOutput {
    /// <p>The created Qualification type, returned as a QualificationType data structure.</p>
    pub qualification_type: std::option::Option<crate::model::QualificationType>,
}
impl CreateQualificationTypeOutput {
    /// <p>The created Qualification type, returned as a QualificationType data structure.</p>
    pub fn qualification_type(&self) -> std::option::Option<&crate::model::QualificationType> {
        self.qualification_type.as_ref()
    }
}
impl std::fmt::Debug for CreateQualificationTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateQualificationTypeOutput");
        formatter.field("qualification_type", &self.qualification_type);
        formatter.finish()
    }
}
/// See [`CreateQualificationTypeOutput`](crate::output::CreateQualificationTypeOutput)
pub mod create_qualification_type_output {
    /// A builder for [`CreateQualificationTypeOutput`](crate::output::CreateQualificationTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) qualification_type: std::option::Option<crate::model::QualificationType>,
    }
    impl Builder {
        /// <p>The created Qualification type, returned as a QualificationType data structure.</p>
        pub fn qualification_type(mut self, input: crate::model::QualificationType) -> Self {
            self.qualification_type = Some(input);
            self
        }
        /// <p>The created Qualification type, returned as a QualificationType data structure.</p>
        pub fn set_qualification_type(
            mut self,
            input: std::option::Option<crate::model::QualificationType>,
        ) -> Self {
            self.qualification_type = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateQualificationTypeOutput`](crate::output::CreateQualificationTypeOutput)
        pub fn build(self) -> crate::output::CreateQualificationTypeOutput {
            crate::output::CreateQualificationTypeOutput {
                qualification_type: self.qualification_type,
            }
        }
    }
}
impl CreateQualificationTypeOutput {
    /// Creates a new builder-style object to manufacture [`CreateQualificationTypeOutput`](crate::output::CreateQualificationTypeOutput)
    pub fn builder() -> crate::output::create_qualification_type_output::Builder {
        crate::output::create_qualification_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHitWithHitTypeOutput {
    /// <p> Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. </p>
    pub hit: std::option::Option<crate::model::Hit>,
}
impl CreateHitWithHitTypeOutput {
    /// <p> Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. </p>
    pub fn hit(&self) -> std::option::Option<&crate::model::Hit> {
        self.hit.as_ref()
    }
}
impl std::fmt::Debug for CreateHitWithHitTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHitWithHitTypeOutput");
        formatter.field("hit", &self.hit);
        formatter.finish()
    }
}
/// See [`CreateHitWithHitTypeOutput`](crate::output::CreateHitWithHitTypeOutput)
pub mod create_hit_with_hit_type_output {
    /// A builder for [`CreateHitWithHitTypeOutput`](crate::output::CreateHitWithHitTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hit: std::option::Option<crate::model::Hit>,
    }
    impl Builder {
        /// <p> Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. </p>
        pub fn hit(mut self, input: crate::model::Hit) -> Self {
            self.hit = Some(input);
            self
        }
        /// <p> Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. </p>
        pub fn set_hit(mut self, input: std::option::Option<crate::model::Hit>) -> Self {
            self.hit = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateHitWithHitTypeOutput`](crate::output::CreateHitWithHitTypeOutput)
        pub fn build(self) -> crate::output::CreateHitWithHitTypeOutput {
            crate::output::CreateHitWithHitTypeOutput { hit: self.hit }
        }
    }
}
impl CreateHitWithHitTypeOutput {
    /// Creates a new builder-style object to manufacture [`CreateHitWithHitTypeOutput`](crate::output::CreateHitWithHitTypeOutput)
    pub fn builder() -> crate::output::create_hit_with_hit_type_output::Builder {
        crate::output::create_hit_with_hit_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHitTypeOutput {
    /// <p> The ID of the newly registered HIT type.</p>
    pub hit_type_id: std::option::Option<std::string::String>,
}
impl CreateHitTypeOutput {
    /// <p> The ID of the newly registered HIT type.</p>
    pub fn hit_type_id(&self) -> std::option::Option<&str> {
        self.hit_type_id.as_deref()
    }
}
impl std::fmt::Debug for CreateHitTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHitTypeOutput");
        formatter.field("hit_type_id", &self.hit_type_id);
        formatter.finish()
    }
}
/// See [`CreateHitTypeOutput`](crate::output::CreateHitTypeOutput)
pub mod create_hit_type_output {
    /// A builder for [`CreateHitTypeOutput`](crate::output::CreateHitTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hit_type_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ID of the newly registered HIT type.</p>
        pub fn hit_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hit_type_id = Some(input.into());
            self
        }
        /// <p> The ID of the newly registered HIT type.</p>
        pub fn set_hit_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hit_type_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateHitTypeOutput`](crate::output::CreateHitTypeOutput)
        pub fn build(self) -> crate::output::CreateHitTypeOutput {
            crate::output::CreateHitTypeOutput {
                hit_type_id: self.hit_type_id,
            }
        }
    }
}
impl CreateHitTypeOutput {
    /// Creates a new builder-style object to manufacture [`CreateHitTypeOutput`](crate::output::CreateHitTypeOutput)
    pub fn builder() -> crate::output::create_hit_type_output::Builder {
        crate::output::create_hit_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHitOutput {
    /// <p> Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. </p>
    pub hit: std::option::Option<crate::model::Hit>,
}
impl CreateHitOutput {
    /// <p> Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. </p>
    pub fn hit(&self) -> std::option::Option<&crate::model::Hit> {
        self.hit.as_ref()
    }
}
impl std::fmt::Debug for CreateHitOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHitOutput");
        formatter.field("hit", &self.hit);
        formatter.finish()
    }
}
/// See [`CreateHitOutput`](crate::output::CreateHitOutput)
pub mod create_hit_output {
    /// A builder for [`CreateHitOutput`](crate::output::CreateHitOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hit: std::option::Option<crate::model::Hit>,
    }
    impl Builder {
        /// <p> Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. </p>
        pub fn hit(mut self, input: crate::model::Hit) -> Self {
            self.hit = Some(input);
            self
        }
        /// <p> Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. </p>
        pub fn set_hit(mut self, input: std::option::Option<crate::model::Hit>) -> Self {
            self.hit = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateHitOutput`](crate::output::CreateHitOutput)
        pub fn build(self) -> crate::output::CreateHitOutput {
            crate::output::CreateHitOutput { hit: self.hit }
        }
    }
}
impl CreateHitOutput {
    /// Creates a new builder-style object to manufacture [`CreateHitOutput`](crate::output::CreateHitOutput)
    pub fn builder() -> crate::output::create_hit_output::Builder {
        crate::output::create_hit_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateAdditionalAssignmentsForHitOutput {}
impl std::fmt::Debug for CreateAdditionalAssignmentsForHitOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateAdditionalAssignmentsForHitOutput");
        formatter.finish()
    }
}
/// See [`CreateAdditionalAssignmentsForHitOutput`](crate::output::CreateAdditionalAssignmentsForHitOutput)
pub mod create_additional_assignments_for_hit_output {
    /// A builder for [`CreateAdditionalAssignmentsForHitOutput`](crate::output::CreateAdditionalAssignmentsForHitOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CreateAdditionalAssignmentsForHitOutput`](crate::output::CreateAdditionalAssignmentsForHitOutput)
        pub fn build(self) -> crate::output::CreateAdditionalAssignmentsForHitOutput {
            crate::output::CreateAdditionalAssignmentsForHitOutput {}
        }
    }
}
impl CreateAdditionalAssignmentsForHitOutput {
    /// Creates a new builder-style object to manufacture [`CreateAdditionalAssignmentsForHitOutput`](crate::output::CreateAdditionalAssignmentsForHitOutput)
    pub fn builder() -> crate::output::create_additional_assignments_for_hit_output::Builder {
        crate::output::create_additional_assignments_for_hit_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateQualificationWithWorkerOutput {}
impl std::fmt::Debug for AssociateQualificationWithWorkerOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateQualificationWithWorkerOutput");
        formatter.finish()
    }
}
/// See [`AssociateQualificationWithWorkerOutput`](crate::output::AssociateQualificationWithWorkerOutput)
pub mod associate_qualification_with_worker_output {
    /// A builder for [`AssociateQualificationWithWorkerOutput`](crate::output::AssociateQualificationWithWorkerOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AssociateQualificationWithWorkerOutput`](crate::output::AssociateQualificationWithWorkerOutput)
        pub fn build(self) -> crate::output::AssociateQualificationWithWorkerOutput {
            crate::output::AssociateQualificationWithWorkerOutput {}
        }
    }
}
impl AssociateQualificationWithWorkerOutput {
    /// Creates a new builder-style object to manufacture [`AssociateQualificationWithWorkerOutput`](crate::output::AssociateQualificationWithWorkerOutput)
    pub fn builder() -> crate::output::associate_qualification_with_worker_output::Builder {
        crate::output::associate_qualification_with_worker_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApproveAssignmentOutput {}
impl std::fmt::Debug for ApproveAssignmentOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApproveAssignmentOutput");
        formatter.finish()
    }
}
/// See [`ApproveAssignmentOutput`](crate::output::ApproveAssignmentOutput)
pub mod approve_assignment_output {
    /// A builder for [`ApproveAssignmentOutput`](crate::output::ApproveAssignmentOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ApproveAssignmentOutput`](crate::output::ApproveAssignmentOutput)
        pub fn build(self) -> crate::output::ApproveAssignmentOutput {
            crate::output::ApproveAssignmentOutput {}
        }
    }
}
impl ApproveAssignmentOutput {
    /// Creates a new builder-style object to manufacture [`ApproveAssignmentOutput`](crate::output::ApproveAssignmentOutput)
    pub fn builder() -> crate::output::approve_assignment_output::Builder {
        crate::output::approve_assignment_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AcceptQualificationRequestOutput {}
impl std::fmt::Debug for AcceptQualificationRequestOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AcceptQualificationRequestOutput");
        formatter.finish()
    }
}
/// See [`AcceptQualificationRequestOutput`](crate::output::AcceptQualificationRequestOutput)
pub mod accept_qualification_request_output {
    /// A builder for [`AcceptQualificationRequestOutput`](crate::output::AcceptQualificationRequestOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AcceptQualificationRequestOutput`](crate::output::AcceptQualificationRequestOutput)
        pub fn build(self) -> crate::output::AcceptQualificationRequestOutput {
            crate::output::AcceptQualificationRequestOutput {}
        }
    }
}
impl AcceptQualificationRequestOutput {
    /// Creates a new builder-style object to manufacture [`AcceptQualificationRequestOutput`](crate::output::AcceptQualificationRequestOutput)
    pub fn builder() -> crate::output::accept_qualification_request_output::Builder {
        crate::output::accept_qualification_request_output::Builder::default()
    }
}
