// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn accept_qualification_request(&self) -> fluent_builders::AcceptQualificationRequest<C> {
        fluent_builders::AcceptQualificationRequest::new(self.handle.clone())
    }
    pub fn approve_assignment(&self) -> fluent_builders::ApproveAssignment<C> {
        fluent_builders::ApproveAssignment::new(self.handle.clone())
    }
    pub fn associate_qualification_with_worker(
        &self,
    ) -> fluent_builders::AssociateQualificationWithWorker<C> {
        fluent_builders::AssociateQualificationWithWorker::new(self.handle.clone())
    }
    pub fn create_additional_assignments_for_hit(
        &self,
    ) -> fluent_builders::CreateAdditionalAssignmentsForHIT<C> {
        fluent_builders::CreateAdditionalAssignmentsForHIT::new(self.handle.clone())
    }
    pub fn create_hit(&self) -> fluent_builders::CreateHIT<C> {
        fluent_builders::CreateHIT::new(self.handle.clone())
    }
    pub fn create_hit_type(&self) -> fluent_builders::CreateHITType<C> {
        fluent_builders::CreateHITType::new(self.handle.clone())
    }
    pub fn create_hit_with_hit_type(&self) -> fluent_builders::CreateHITWithHITType<C> {
        fluent_builders::CreateHITWithHITType::new(self.handle.clone())
    }
    pub fn create_qualification_type(&self) -> fluent_builders::CreateQualificationType<C> {
        fluent_builders::CreateQualificationType::new(self.handle.clone())
    }
    pub fn create_worker_block(&self) -> fluent_builders::CreateWorkerBlock<C> {
        fluent_builders::CreateWorkerBlock::new(self.handle.clone())
    }
    pub fn delete_hit(&self) -> fluent_builders::DeleteHIT<C> {
        fluent_builders::DeleteHIT::new(self.handle.clone())
    }
    pub fn delete_qualification_type(&self) -> fluent_builders::DeleteQualificationType<C> {
        fluent_builders::DeleteQualificationType::new(self.handle.clone())
    }
    pub fn delete_worker_block(&self) -> fluent_builders::DeleteWorkerBlock<C> {
        fluent_builders::DeleteWorkerBlock::new(self.handle.clone())
    }
    pub fn disassociate_qualification_from_worker(
        &self,
    ) -> fluent_builders::DisassociateQualificationFromWorker<C> {
        fluent_builders::DisassociateQualificationFromWorker::new(self.handle.clone())
    }
    pub fn get_account_balance(&self) -> fluent_builders::GetAccountBalance<C> {
        fluent_builders::GetAccountBalance::new(self.handle.clone())
    }
    pub fn get_assignment(&self) -> fluent_builders::GetAssignment<C> {
        fluent_builders::GetAssignment::new(self.handle.clone())
    }
    pub fn get_file_upload_url(&self) -> fluent_builders::GetFileUploadURL<C> {
        fluent_builders::GetFileUploadURL::new(self.handle.clone())
    }
    pub fn get_hit(&self) -> fluent_builders::GetHIT<C> {
        fluent_builders::GetHIT::new(self.handle.clone())
    }
    pub fn get_qualification_score(&self) -> fluent_builders::GetQualificationScore<C> {
        fluent_builders::GetQualificationScore::new(self.handle.clone())
    }
    pub fn get_qualification_type(&self) -> fluent_builders::GetQualificationType<C> {
        fluent_builders::GetQualificationType::new(self.handle.clone())
    }
    pub fn list_assignments_for_hit(&self) -> fluent_builders::ListAssignmentsForHIT<C> {
        fluent_builders::ListAssignmentsForHIT::new(self.handle.clone())
    }
    pub fn list_bonus_payments(&self) -> fluent_builders::ListBonusPayments<C> {
        fluent_builders::ListBonusPayments::new(self.handle.clone())
    }
    pub fn list_hi_ts(&self) -> fluent_builders::ListHITs<C> {
        fluent_builders::ListHITs::new(self.handle.clone())
    }
    pub fn list_hi_ts_for_qualification_type(
        &self,
    ) -> fluent_builders::ListHITsForQualificationType<C> {
        fluent_builders::ListHITsForQualificationType::new(self.handle.clone())
    }
    pub fn list_qualification_requests(&self) -> fluent_builders::ListQualificationRequests<C> {
        fluent_builders::ListQualificationRequests::new(self.handle.clone())
    }
    pub fn list_qualification_types(&self) -> fluent_builders::ListQualificationTypes<C> {
        fluent_builders::ListQualificationTypes::new(self.handle.clone())
    }
    pub fn list_reviewable_hi_ts(&self) -> fluent_builders::ListReviewableHITs<C> {
        fluent_builders::ListReviewableHITs::new(self.handle.clone())
    }
    pub fn list_review_policy_results_for_hit(
        &self,
    ) -> fluent_builders::ListReviewPolicyResultsForHIT<C> {
        fluent_builders::ListReviewPolicyResultsForHIT::new(self.handle.clone())
    }
    pub fn list_worker_blocks(&self) -> fluent_builders::ListWorkerBlocks<C> {
        fluent_builders::ListWorkerBlocks::new(self.handle.clone())
    }
    pub fn list_workers_with_qualification_type(
        &self,
    ) -> fluent_builders::ListWorkersWithQualificationType<C> {
        fluent_builders::ListWorkersWithQualificationType::new(self.handle.clone())
    }
    pub fn notify_workers(&self) -> fluent_builders::NotifyWorkers<C> {
        fluent_builders::NotifyWorkers::new(self.handle.clone())
    }
    pub fn reject_assignment(&self) -> fluent_builders::RejectAssignment<C> {
        fluent_builders::RejectAssignment::new(self.handle.clone())
    }
    pub fn reject_qualification_request(&self) -> fluent_builders::RejectQualificationRequest<C> {
        fluent_builders::RejectQualificationRequest::new(self.handle.clone())
    }
    pub fn send_bonus(&self) -> fluent_builders::SendBonus<C> {
        fluent_builders::SendBonus::new(self.handle.clone())
    }
    pub fn send_test_event_notification(&self) -> fluent_builders::SendTestEventNotification<C> {
        fluent_builders::SendTestEventNotification::new(self.handle.clone())
    }
    pub fn update_expiration_for_hit(&self) -> fluent_builders::UpdateExpirationForHIT<C> {
        fluent_builders::UpdateExpirationForHIT::new(self.handle.clone())
    }
    pub fn update_hit_review_status(&self) -> fluent_builders::UpdateHITReviewStatus<C> {
        fluent_builders::UpdateHITReviewStatus::new(self.handle.clone())
    }
    pub fn update_hit_type_of_hit(&self) -> fluent_builders::UpdateHITTypeOfHIT<C> {
        fluent_builders::UpdateHITTypeOfHIT::new(self.handle.clone())
    }
    pub fn update_notification_settings(&self) -> fluent_builders::UpdateNotificationSettings<C> {
        fluent_builders::UpdateNotificationSettings::new(self.handle.clone())
    }
    pub fn update_qualification_type(&self) -> fluent_builders::UpdateQualificationType<C> {
        fluent_builders::UpdateQualificationType::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptQualificationRequest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_qualification_request_input::Builder,
    }
    impl<C> AcceptQualificationRequest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptQualificationRequestOutput,
            smithy_http::result::SdkError<crate::error::AcceptQualificationRequestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Qualification request, as returned by the <code>GetQualificationRequests</code> operation.</p>
        pub fn qualification_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_request_id(input);
            self
        }
        pub fn set_qualification_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_request_id(input);
            self
        }
        /// <p>
        /// The value of the Qualification. You can omit this value if you are using the
        /// presence or absence of the Qualification as the basis for a HIT requirement.
        /// </p>
        pub fn integer_value(mut self, input: i32) -> Self {
            self.inner = self.inner.integer_value(input);
            self
        }
        pub fn set_integer_value(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_integer_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ApproveAssignment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::approve_assignment_input::Builder,
    }
    impl<C> ApproveAssignment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ApproveAssignmentOutput,
            smithy_http::result::SdkError<crate::error::ApproveAssignmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The ID of the assignment. The assignment must correspond to a HIT created by the Requester.
        /// </p>
        pub fn assignment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.assignment_id(input);
            self
        }
        pub fn set_assignment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_assignment_id(input);
            self
        }
        /// <p>
        /// A message for the Worker, which the Worker can see in the Status section of the web site.
        /// </p>
        pub fn requester_feedback(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.requester_feedback(input);
            self
        }
        pub fn set_requester_feedback(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_requester_feedback(input);
            self
        }
        /// <p>
        /// A flag indicating that an assignment should be approved even if it was previously rejected. Defaults to <code>False</code>.
        /// </p>
        pub fn override_rejection(mut self, input: bool) -> Self {
            self.inner = self.inner.override_rejection(input);
            self
        }
        pub fn set_override_rejection(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_override_rejection(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateQualificationWithWorker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_qualification_with_worker_input::Builder,
    }
    impl<C> AssociateQualificationWithWorker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateQualificationWithWorkerOutput,
            smithy_http::result::SdkError<crate::error::AssociateQualificationWithWorkerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Qualification type to use for the assigned Qualification.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_type_id(input);
            self
        }
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_id(input);
            self
        }
        /// <p>
        /// The ID of the Worker to whom the Qualification is being assigned.
        /// Worker IDs are included with submitted HIT assignments and Qualification requests.
        /// </p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.worker_id(input);
            self
        }
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_worker_id(input);
            self
        }
        /// <p>The value of the Qualification to assign.</p>
        pub fn integer_value(mut self, input: i32) -> Self {
            self.inner = self.inner.integer_value(input);
            self
        }
        pub fn set_integer_value(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_integer_value(input);
            self
        }
        /// <p>
        /// Specifies whether to send a notification email message to the Worker
        /// saying that the qualification was assigned to the Worker.
        /// Note: this is true by default.
        /// </p>
        pub fn send_notification(mut self, input: bool) -> Self {
            self.inner = self.inner.send_notification(input);
            self
        }
        pub fn set_send_notification(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_send_notification(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAdditionalAssignmentsForHIT<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_additional_assignments_for_hit_input::Builder,
    }
    impl<C> CreateAdditionalAssignmentsForHIT<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAdditionalAssignmentsForHitOutput,
            smithy_http::result::SdkError<crate::error::CreateAdditionalAssignmentsForHITError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the HIT to extend.</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_id(input);
            self
        }
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_id(input);
            self
        }
        /// <p>The number of additional assignments to request for this HIT.</p>
        pub fn number_of_additional_assignments(mut self, input: i32) -> Self {
            self.inner = self.inner.number_of_additional_assignments(input);
            self
        }
        pub fn set_number_of_additional_assignments(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_number_of_additional_assignments(input);
            self
        }
        /// <p>
        /// A unique identifier for this request, which allows you to retry the call on error
        /// without extending the HIT multiple times.
        /// This is useful in cases such as network timeouts where it is unclear whether or not
        /// the call succeeded on the server. If the extend HIT already exists in the system
        /// from a previous call using the same <code>UniqueRequestToken</code>,
        /// subsequent calls will return an error with a message containing the request ID.
        /// </p>
        pub fn unique_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.unique_request_token(input);
            self
        }
        pub fn set_unique_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_unique_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateHIT<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_hit_input::Builder,
    }
    impl<C> CreateHIT<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateHitOutput,
            smithy_http::result::SdkError<crate::error::CreateHITError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The number of times the HIT can be accepted and completed before the HIT becomes unavailable.
        /// </p>
        pub fn max_assignments(mut self, input: i32) -> Self {
            self.inner = self.inner.max_assignments(input);
            self
        }
        pub fn set_max_assignments(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_assignments(input);
            self
        }
        /// <p>
        /// The number of seconds after an assignment for the HIT has been submitted,
        /// after which the assignment is considered Approved automatically
        /// unless the Requester explicitly rejects it.
        /// </p>
        pub fn auto_approval_delay_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.auto_approval_delay_in_seconds(input);
            self
        }
        pub fn set_auto_approval_delay_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_auto_approval_delay_in_seconds(input);
            self
        }
        /// <p>
        /// An amount of time, in seconds, after which the HIT is no longer available for users to accept.
        /// After the lifetime of the HIT elapses, the HIT no longer appears in HIT searches,
        /// even if not all of the assignments for the HIT have been accepted.
        /// </p>
        pub fn lifetime_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.lifetime_in_seconds(input);
            self
        }
        pub fn set_lifetime_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_lifetime_in_seconds(input);
            self
        }
        /// <p>
        /// The amount of time, in seconds, that a Worker has to complete the HIT after accepting it.
        /// If a Worker does not complete the assignment within the specified duration,
        /// the assignment is considered abandoned. If the HIT is still active
        /// (that is, its lifetime has not elapsed), the assignment becomes available
        /// for other users to find and accept.
        /// </p>
        pub fn assignment_duration_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.assignment_duration_in_seconds(input);
            self
        }
        pub fn set_assignment_duration_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_assignment_duration_in_seconds(input);
            self
        }
        /// <p>
        /// The amount of money the Requester will pay a Worker for successfully completing the HIT.
        /// </p>
        pub fn reward(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reward(input);
            self
        }
        pub fn set_reward(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reward(input);
            self
        }
        /// <p>
        /// The title of the HIT. A title should be short and descriptive about the kind of task the HIT contains.
        /// On the Amazon Mechanical Turk web site, the HIT title appears in search results,
        /// and everywhere the HIT is mentioned.
        /// </p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.title(input);
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_title(input);
            self
        }
        /// <p>
        /// One or more words or phrases that describe the HIT, separated by commas.
        /// These words are used in searches to find HITs.
        /// </p>
        pub fn keywords(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.keywords(input);
            self
        }
        pub fn set_keywords(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_keywords(input);
            self
        }
        /// <p>
        /// A general description of the HIT. A description includes detailed information about the kind of task
        /// the HIT contains. On the Amazon Mechanical Turk web site, the HIT description appears in the expanded
        /// view of search results, and in the HIT and assignment screens. A good description gives the user enough
        /// information to evaluate the HIT before accepting it.
        /// </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>
        /// The data the person completing the HIT uses to produce the results.
        /// </p>
        /// <p>
        /// Constraints: Must be a QuestionForm data structure, an ExternalQuestion data structure,
        /// or an HTMLQuestion data structure. The XML question data must not be larger than
        /// 64 kilobytes (65,535 bytes) in size, including whitespace.
        /// </p>
        /// <p>Either a Question parameter or a HITLayoutId parameter must be provided.</p>
        pub fn question(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.question(input);
            self
        }
        pub fn set_question(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_question(input);
            self
        }
        /// <p>
        /// An arbitrary data field.
        /// The RequesterAnnotation parameter lets your application attach arbitrary data
        /// to the HIT for tracking purposes.
        /// For example, this parameter could be an identifier internal to the Requester's application
        /// that corresponds with the HIT.
        /// </p>
        /// <p>
        /// The RequesterAnnotation parameter for a HIT is only visible to the Requester who created the HIT.
        /// It is not shown to the Worker, or any other Requester.
        /// </p>
        /// <p>
        /// The RequesterAnnotation parameter may be different for each HIT you submit.
        /// It does not affect how your HITs are grouped.
        /// </p>
        pub fn requester_annotation(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.requester_annotation(input);
            self
        }
        pub fn set_requester_annotation(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_requester_annotation(input);
            self
        }
        /// <p>
        /// Conditions that a Worker's Qualifications must meet in order
        /// to accept the HIT. A HIT can have between zero and ten
        /// Qualification requirements. All requirements must be met in
        /// order for a Worker to accept the HIT. Additionally, other
        /// actions can be restricted using the <code>ActionsGuarded</code>
        /// field on each <code>QualificationRequirement</code> structure.
        /// </p>
        pub fn qualification_requirements(
            mut self,
            inp: impl Into<crate::model::QualificationRequirement>,
        ) -> Self {
            self.inner = self.inner.qualification_requirements(inp);
            self
        }
        pub fn set_qualification_requirements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QualificationRequirement>>,
        ) -> Self {
            self.inner = self.inner.set_qualification_requirements(input);
            self
        }
        /// <p>
        /// A unique identifier for this request which allows you to retry the call
        /// on error without creating duplicate HITs.
        /// This is useful in cases such as network timeouts where it is unclear whether or not
        /// the call succeeded on the server.
        /// If the HIT already exists in the system from a previous call using the same UniqueRequestToken,
        /// subsequent calls will return a AWS.MechanicalTurk.HitAlreadyExists error
        /// with a message containing the HITId.
        /// </p>
        /// <note>
        /// <p>
        /// Note: It is your responsibility to ensure uniqueness of the token.
        /// The unique token expires after 24 hours. Subsequent calls using the same
        /// UniqueRequestToken made after the 24 hour limit could create duplicate HITs.
        /// </p>
        /// </note>
        pub fn unique_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.unique_request_token(input);
            self
        }
        pub fn set_unique_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_unique_request_token(input);
            self
        }
        /// <p>
        /// The Assignment-level Review Policy applies to the assignments under the HIT.
        /// You can specify for Mechanical Turk to take various actions based on the policy.
        /// </p>
        pub fn assignment_review_policy(mut self, input: crate::model::ReviewPolicy) -> Self {
            self.inner = self.inner.assignment_review_policy(input);
            self
        }
        pub fn set_assignment_review_policy(
            mut self,
            input: std::option::Option<crate::model::ReviewPolicy>,
        ) -> Self {
            self.inner = self.inner.set_assignment_review_policy(input);
            self
        }
        /// <p>
        /// The HIT-level Review Policy applies to the HIT.
        /// You can specify for Mechanical Turk to take various actions based on the policy.
        /// </p>
        pub fn hit_review_policy(mut self, input: crate::model::ReviewPolicy) -> Self {
            self.inner = self.inner.hit_review_policy(input);
            self
        }
        pub fn set_hit_review_policy(
            mut self,
            input: std::option::Option<crate::model::ReviewPolicy>,
        ) -> Self {
            self.inner = self.inner.set_hit_review_policy(input);
            self
        }
        /// <p>
        /// The HITLayoutId allows you to use a pre-existing HIT design with placeholder values
        /// and create an additional HIT by providing those values as HITLayoutParameters.
        /// </p>
        /// <p>
        /// Constraints: Either a Question parameter or a HITLayoutId parameter must be provided.
        /// </p>
        pub fn hit_layout_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_layout_id(input);
            self
        }
        pub fn set_hit_layout_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_hit_layout_id(input);
            self
        }
        /// <p>
        /// If the HITLayoutId is provided, any placeholder values must be filled in with values
        /// using the HITLayoutParameter structure. For more information, see HITLayout.
        /// </p>
        pub fn hit_layout_parameters(
            mut self,
            inp: impl Into<crate::model::HitLayoutParameter>,
        ) -> Self {
            self.inner = self.inner.hit_layout_parameters(inp);
            self
        }
        pub fn set_hit_layout_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HitLayoutParameter>>,
        ) -> Self {
            self.inner = self.inner.set_hit_layout_parameters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateHITType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_hit_type_input::Builder,
    }
    impl<C> CreateHITType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateHitTypeOutput,
            smithy_http::result::SdkError<crate::error::CreateHITTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The number of seconds after an assignment for the HIT has been submitted,
        /// after which the assignment is considered Approved automatically
        /// unless the Requester explicitly rejects it.
        /// </p>
        pub fn auto_approval_delay_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.auto_approval_delay_in_seconds(input);
            self
        }
        pub fn set_auto_approval_delay_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_auto_approval_delay_in_seconds(input);
            self
        }
        /// <p>
        /// The amount of time, in seconds, that a Worker has to complete the HIT after accepting it.
        /// If a Worker does not complete the assignment within the specified duration,
        /// the assignment is considered abandoned. If the HIT is still active
        /// (that is, its lifetime has not elapsed), the assignment becomes available
        /// for other users to find and accept.
        /// </p>
        pub fn assignment_duration_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.assignment_duration_in_seconds(input);
            self
        }
        pub fn set_assignment_duration_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_assignment_duration_in_seconds(input);
            self
        }
        /// <p>
        /// The amount of money the Requester will pay a Worker for successfully completing the HIT.
        /// </p>
        pub fn reward(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reward(input);
            self
        }
        pub fn set_reward(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reward(input);
            self
        }
        /// <p>
        /// The title of the HIT. A title should be short and descriptive about the kind of task the HIT contains.
        /// On the Amazon Mechanical Turk web site, the HIT title appears in search results,
        /// and everywhere the HIT is mentioned.
        /// </p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.title(input);
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_title(input);
            self
        }
        /// <p>
        /// One or more words or phrases that describe the HIT, separated by commas.
        /// These words are used in searches to find HITs.
        /// </p>
        pub fn keywords(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.keywords(input);
            self
        }
        pub fn set_keywords(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_keywords(input);
            self
        }
        /// <p>
        /// A general description of the HIT. A description includes detailed information about the kind of task
        /// the HIT contains. On the Amazon Mechanical Turk web site, the HIT description appears in the expanded
        /// view of search results, and in the HIT and assignment screens. A good description gives the user enough
        /// information to evaluate the HIT before accepting it.
        /// </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>
        /// Conditions that a Worker's Qualifications must meet in order
        /// to accept the HIT. A HIT can have between zero and ten
        /// Qualification requirements. All requirements must be met in
        /// order for a Worker to accept the HIT. Additionally, other
        /// actions can be restricted using the <code>ActionsGuarded</code>
        /// field on each <code>QualificationRequirement</code> structure.
        /// </p>
        pub fn qualification_requirements(
            mut self,
            inp: impl Into<crate::model::QualificationRequirement>,
        ) -> Self {
            self.inner = self.inner.qualification_requirements(inp);
            self
        }
        pub fn set_qualification_requirements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::QualificationRequirement>>,
        ) -> Self {
            self.inner = self.inner.set_qualification_requirements(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateHITWithHITType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_hit_with_hit_type_input::Builder,
    }
    impl<C> CreateHITWithHITType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateHitWithHitTypeOutput,
            smithy_http::result::SdkError<crate::error::CreateHITWithHITTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The HIT type ID you want to create this HIT with.</p>
        pub fn hit_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_type_id(input);
            self
        }
        pub fn set_hit_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_type_id(input);
            self
        }
        /// <p>
        /// The number of times the HIT can be accepted and completed before the HIT becomes unavailable.
        /// </p>
        pub fn max_assignments(mut self, input: i32) -> Self {
            self.inner = self.inner.max_assignments(input);
            self
        }
        pub fn set_max_assignments(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_assignments(input);
            self
        }
        /// <p>
        /// An amount of time, in seconds, after which the HIT is no longer available for users to accept.
        /// After the lifetime of the HIT elapses, the HIT no longer appears in HIT searches,
        /// even if not all of the assignments for the HIT have been accepted.
        /// </p>
        pub fn lifetime_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.lifetime_in_seconds(input);
            self
        }
        pub fn set_lifetime_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_lifetime_in_seconds(input);
            self
        }
        /// <p>
        /// The data the person completing the HIT uses to produce the results.
        /// </p>
        /// <p>
        /// Constraints: Must be a QuestionForm data structure, an ExternalQuestion data structure,
        /// or an HTMLQuestion data structure. The XML question data must not be larger than
        /// 64 kilobytes (65,535 bytes) in size, including whitespace.
        /// </p>
        /// <p>Either a Question parameter or a HITLayoutId parameter must be provided.</p>
        pub fn question(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.question(input);
            self
        }
        pub fn set_question(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_question(input);
            self
        }
        /// <p>
        /// An arbitrary data field.
        /// The RequesterAnnotation parameter lets your application attach arbitrary data
        /// to the HIT for tracking purposes.
        /// For example, this parameter could be an identifier internal to the Requester's application
        /// that corresponds with the HIT.
        /// </p>
        /// <p>
        /// The RequesterAnnotation parameter for a HIT is only visible to the Requester who created the HIT.
        /// It is not shown to the Worker, or any other Requester.
        /// </p>
        /// <p>
        /// The RequesterAnnotation parameter may be different for each HIT you submit.
        /// It does not affect how your HITs are grouped.
        /// </p>
        pub fn requester_annotation(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.requester_annotation(input);
            self
        }
        pub fn set_requester_annotation(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_requester_annotation(input);
            self
        }
        /// <p>
        /// A unique identifier for this request which allows you to retry the call
        /// on error without creating duplicate HITs.
        /// This is useful in cases such as network timeouts where it is unclear whether or not
        /// the call succeeded on the server.
        /// If the HIT already exists in the system from a previous call using the same UniqueRequestToken,
        /// subsequent calls will return a AWS.MechanicalTurk.HitAlreadyExists error
        /// with a message containing the HITId.
        /// </p>
        /// <note>
        /// <p>
        /// Note: It is your responsibility to ensure uniqueness of the token.
        /// The unique token expires after 24 hours. Subsequent calls using the same
        /// UniqueRequestToken made after the 24 hour limit could create duplicate HITs.
        /// </p>
        /// </note>
        pub fn unique_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.unique_request_token(input);
            self
        }
        pub fn set_unique_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_unique_request_token(input);
            self
        }
        /// <p>
        /// The Assignment-level Review Policy applies to the assignments under the HIT.
        /// You can specify for Mechanical Turk to take various actions based on the policy.
        /// </p>
        pub fn assignment_review_policy(mut self, input: crate::model::ReviewPolicy) -> Self {
            self.inner = self.inner.assignment_review_policy(input);
            self
        }
        pub fn set_assignment_review_policy(
            mut self,
            input: std::option::Option<crate::model::ReviewPolicy>,
        ) -> Self {
            self.inner = self.inner.set_assignment_review_policy(input);
            self
        }
        /// <p>
        /// The HIT-level Review Policy applies to the HIT.
        /// You can specify for Mechanical Turk to take various actions based on the policy.
        /// </p>
        pub fn hit_review_policy(mut self, input: crate::model::ReviewPolicy) -> Self {
            self.inner = self.inner.hit_review_policy(input);
            self
        }
        pub fn set_hit_review_policy(
            mut self,
            input: std::option::Option<crate::model::ReviewPolicy>,
        ) -> Self {
            self.inner = self.inner.set_hit_review_policy(input);
            self
        }
        /// <p>
        /// The HITLayoutId allows you to use a pre-existing HIT design with placeholder values
        /// and create an additional HIT by providing those values as HITLayoutParameters.
        /// </p>
        /// <p>
        /// Constraints: Either a Question parameter or a HITLayoutId parameter must be provided.
        /// </p>
        pub fn hit_layout_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_layout_id(input);
            self
        }
        pub fn set_hit_layout_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_hit_layout_id(input);
            self
        }
        /// <p>
        /// If the HITLayoutId is provided, any placeholder values must be filled in with values
        /// using the HITLayoutParameter structure. For more information, see HITLayout.
        /// </p>
        pub fn hit_layout_parameters(
            mut self,
            inp: impl Into<crate::model::HitLayoutParameter>,
        ) -> Self {
            self.inner = self.inner.hit_layout_parameters(inp);
            self
        }
        pub fn set_hit_layout_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HitLayoutParameter>>,
        ) -> Self {
            self.inner = self.inner.set_hit_layout_parameters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateQualificationType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_qualification_type_input::Builder,
    }
    impl<C> CreateQualificationType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateQualificationTypeOutput,
            smithy_http::result::SdkError<crate::error::CreateQualificationTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name you give to the Qualification type. The type name
        /// is used to represent the Qualification to Workers, and to find the
        /// type using a Qualification type search. It must be unique across all
        /// of your Qualification types.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>One or more words or phrases that describe the Qualification
        /// type, separated by commas. The keywords of a type make the type
        /// easier to find during a search.</p>
        pub fn keywords(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.keywords(input);
            self
        }
        pub fn set_keywords(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_keywords(input);
            self
        }
        /// <p>A long description for the Qualification type. On the Amazon
        /// Mechanical Turk website, the long description is displayed when a
        /// Worker examines a Qualification type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The initial status of the Qualification type.</p>
        /// <p>Constraints: Valid values are: Active | Inactive</p>
        pub fn qualification_type_status(
            mut self,
            input: crate::model::QualificationTypeStatus,
        ) -> Self {
            self.inner = self.inner.qualification_type_status(input);
            self
        }
        pub fn set_qualification_type_status(
            mut self,
            input: std::option::Option<crate::model::QualificationTypeStatus>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_status(input);
            self
        }
        /// <p>The number of seconds that a Worker must wait after
        /// requesting a Qualification of the Qualification type before the
        /// worker can retry the Qualification request.</p>
        /// <p>Constraints: None. If not specified, retries are disabled and
        /// Workers can request a Qualification of this type only once, even if
        /// the Worker has not been granted the Qualification. It is not possible
        /// to disable retries for a Qualification type after it has been created
        /// with retries enabled. If you want to disable retries, you must delete
        /// existing retry-enabled Qualification type and then create a new
        /// Qualification type with retries disabled.</p>
        pub fn retry_delay_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.retry_delay_in_seconds(input);
            self
        }
        pub fn set_retry_delay_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_retry_delay_in_seconds(input);
            self
        }
        /// <p>
        /// The questions for the Qualification test a Worker must answer
        /// correctly to obtain a Qualification of this type. If this parameter
        /// is specified,
        /// <code>TestDurationInSeconds</code>
        /// must also be specified.
        /// </p>
        /// <p>Constraints: Must not be longer than 65535 bytes. Must be a
        /// QuestionForm data structure. This parameter cannot be specified if
        /// AutoGranted is true.</p>
        /// <p>Constraints: None. If not specified, the Worker may request
        /// the Qualification without answering any questions.</p>
        pub fn test(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.test(input);
            self
        }
        pub fn set_test(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_test(input);
            self
        }
        /// <p>The answers to the Qualification test specified in the Test
        /// parameter, in the form of an AnswerKey data structure.</p>
        /// <p>Constraints: Must not be longer than 65535 bytes.</p>
        /// <p>Constraints: None. If not specified, you must process
        /// Qualification requests manually.</p>
        pub fn answer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.answer_key(input);
            self
        }
        pub fn set_answer_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_answer_key(input);
            self
        }
        /// <p>The number of seconds the Worker has to complete the
        /// Qualification test, starting from the time the Worker requests the
        /// Qualification.</p>
        pub fn test_duration_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.test_duration_in_seconds(input);
            self
        }
        pub fn set_test_duration_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_test_duration_in_seconds(input);
            self
        }
        /// <p>Specifies whether requests for the Qualification type are
        /// granted immediately, without prompting the Worker with a
        /// Qualification test.</p>
        /// <p>Constraints: If the Test parameter is specified, this
        /// parameter cannot be true.</p>
        pub fn auto_granted(mut self, input: bool) -> Self {
            self.inner = self.inner.auto_granted(input);
            self
        }
        pub fn set_auto_granted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_granted(input);
            self
        }
        /// <p>The Qualification value to use for automatically granted
        /// Qualifications. This parameter is used only if the AutoGranted
        /// parameter is true.</p>
        pub fn auto_granted_value(mut self, input: i32) -> Self {
            self.inner = self.inner.auto_granted_value(input);
            self
        }
        pub fn set_auto_granted_value(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_auto_granted_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateWorkerBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_worker_block_input::Builder,
    }
    impl<C> CreateWorkerBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateWorkerBlockOutput,
            smithy_http::result::SdkError<crate::error::CreateWorkerBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Worker to block.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.worker_id(input);
            self
        }
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_worker_id(input);
            self
        }
        /// <p>A message explaining the reason for blocking the Worker. This parameter enables you to keep track of your Workers. The Worker does not see this message.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteHIT<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_hit_input::Builder,
    }
    impl<C> DeleteHIT<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteHitOutput,
            smithy_http::result::SdkError<crate::error::DeleteHITError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the HIT to be deleted.</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_id(input);
            self
        }
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteQualificationType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_qualification_type_input::Builder,
    }
    impl<C> DeleteQualificationType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteQualificationTypeOutput,
            smithy_http::result::SdkError<crate::error::DeleteQualificationTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the QualificationType to dispose.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_type_id(input);
            self
        }
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteWorkerBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_worker_block_input::Builder,
    }
    impl<C> DeleteWorkerBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteWorkerBlockOutput,
            smithy_http::result::SdkError<crate::error::DeleteWorkerBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Worker to unblock.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.worker_id(input);
            self
        }
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_worker_id(input);
            self
        }
        /// <p>A message that explains the reason for unblocking the Worker. The Worker does not see this message.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateQualificationFromWorker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_qualification_from_worker_input::Builder,
    }
    impl<C> DisassociateQualificationFromWorker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateQualificationFromWorkerOutput,
            smithy_http::result::SdkError<crate::error::DisassociateQualificationFromWorkerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Worker who possesses the Qualification to be revoked.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.worker_id(input);
            self
        }
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_worker_id(input);
            self
        }
        /// <p>The ID of the Qualification type of the Qualification to be revoked.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_type_id(input);
            self
        }
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_id(input);
            self
        }
        /// <p>A text message that explains why the Qualification was revoked. The user who had the Qualification sees this message.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountBalance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_account_balance_input::Builder,
    }
    impl<C> GetAccountBalance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccountBalanceOutput,
            smithy_http::result::SdkError<crate::error::GetAccountBalanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAssignment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_assignment_input::Builder,
    }
    impl<C> GetAssignment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAssignmentOutput,
            smithy_http::result::SdkError<crate::error::GetAssignmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Assignment to be retrieved.</p>
        pub fn assignment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.assignment_id(input);
            self
        }
        pub fn set_assignment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_assignment_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFileUploadURL<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_file_upload_url_input::Builder,
    }
    impl<C> GetFileUploadURL<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFileUploadUrlOutput,
            smithy_http::result::SdkError<crate::error::GetFileUploadURLError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the assignment that contains the question with a
        /// FileUploadAnswer.</p>
        pub fn assignment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.assignment_id(input);
            self
        }
        pub fn set_assignment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_assignment_id(input);
            self
        }
        /// <p>The identifier of the question with a FileUploadAnswer, as
        /// specified in the QuestionForm of the HIT.</p>
        pub fn question_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.question_identifier(input);
            self
        }
        pub fn set_question_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_question_identifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHIT<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_hit_input::Builder,
    }
    impl<C> GetHIT<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetHitOutput,
            smithy_http::result::SdkError<crate::error::GetHITError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the HIT to be retrieved.</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_id(input);
            self
        }
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetQualificationScore<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_qualification_score_input::Builder,
    }
    impl<C> GetQualificationScore<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetQualificationScoreOutput,
            smithy_http::result::SdkError<crate::error::GetQualificationScoreError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the QualificationType.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_type_id(input);
            self
        }
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_id(input);
            self
        }
        /// <p>The ID of the Worker whose Qualification is being updated.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.worker_id(input);
            self
        }
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_worker_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetQualificationType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_qualification_type_input::Builder,
    }
    impl<C> GetQualificationType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetQualificationTypeOutput,
            smithy_http::result::SdkError<crate::error::GetQualificationTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the QualificationType.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_type_id(input);
            self
        }
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAssignmentsForHIT<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_assignments_for_hit_input::Builder,
    }
    impl<C> ListAssignmentsForHIT<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAssignmentsForHitOutput,
            smithy_http::result::SdkError<crate::error::ListAssignmentsForHITError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the HIT.</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_id(input);
            self
        }
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_id(input);
            self
        }
        /// <p>Pagination token</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The status of the assignments to return: Submitted | Approved
        /// | Rejected</p>
        pub fn assignment_statuses(
            mut self,
            inp: impl Into<crate::model::AssignmentStatus>,
        ) -> Self {
            self.inner = self.inner.assignment_statuses(inp);
            self
        }
        pub fn set_assignment_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AssignmentStatus>>,
        ) -> Self {
            self.inner = self.inner.set_assignment_statuses(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBonusPayments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_bonus_payments_input::Builder,
    }
    impl<C> ListBonusPayments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBonusPaymentsOutput,
            smithy_http::result::SdkError<crate::error::ListBonusPaymentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the HIT associated with the bonus payments to
        /// retrieve. If not specified, all bonus payments for all assignments
        /// for the given HIT are returned. Either the HITId parameter or the
        /// AssignmentId parameter must be specified</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_id(input);
            self
        }
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_id(input);
            self
        }
        /// <p>The ID of the assignment associated with the bonus payments
        /// to retrieve. If specified, only bonus payments for the given
        /// assignment are returned. Either the HITId parameter or the
        /// AssignmentId parameter must be specified</p>
        pub fn assignment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.assignment_id(input);
            self
        }
        pub fn set_assignment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_assignment_id(input);
            self
        }
        /// <p>Pagination token</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListHITs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_hi_ts_input::Builder,
    }
    impl<C> ListHITs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListHiTsOutput,
            smithy_http::result::SdkError<crate::error::ListHITsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Pagination token</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListHITsForQualificationType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_hi_ts_for_qualification_type_input::Builder,
    }
    impl<C> ListHITsForQualificationType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListHiTsForQualificationTypeOutput,
            smithy_http::result::SdkError<crate::error::ListHITsForQualificationTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The ID of the Qualification type to use when querying HITs.
        /// </p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_type_id(input);
            self
        }
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_id(input);
            self
        }
        /// <p>Pagination Token</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>
        /// Limit the number of results returned.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListQualificationRequests<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_qualification_requests_input::Builder,
    }
    impl<C> ListQualificationRequests<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListQualificationRequestsOutput,
            smithy_http::result::SdkError<crate::error::ListQualificationRequestsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the QualificationType.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_type_id(input);
            self
        }
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_id(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
        /// returns a pagination token in the response. You can use this pagination token
        /// to retrieve the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p> The maximum number of results to return in a single call.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListQualificationTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_qualification_types_input::Builder,
    }
    impl<C> ListQualificationTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListQualificationTypesOutput,
            smithy_http::result::SdkError<crate::error::ListQualificationTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> A text query against all of the searchable attributes of
        /// Qualification types.
        /// </p>
        pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query(input);
            self
        }
        pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query(input);
            self
        }
        /// <p>Specifies that only Qualification types that a user can
        /// request through the Amazon Mechanical Turk web site, such as by
        /// taking a Qualification test, are returned as results of the search.
        /// Some Qualification types, such as those assigned automatically by the
        /// system, cannot be requested directly by users. If false, all
        /// Qualification types, including those managed by the system, are
        /// considered. Valid values are True | False.
        /// </p>
        pub fn must_be_requestable(mut self, input: bool) -> Self {
            self.inner = self.inner.must_be_requestable(input);
            self
        }
        pub fn set_must_be_requestable(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_must_be_requestable(input);
            self
        }
        /// <p> Specifies that only Qualification types that the Requester
        /// created are returned. If false, the operation returns all
        /// Qualification types.
        /// </p>
        pub fn must_be_owned_by_caller(mut self, input: bool) -> Self {
            self.inner = self.inner.must_be_owned_by_caller(input);
            self
        }
        pub fn set_must_be_owned_by_caller(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_must_be_owned_by_caller(input);
            self
        }
        /// <p>If the previous response was incomplete (because there is more data to retrieve), Amazon Mechanical Turk
        /// returns a pagination token in the response. You can use this pagination token
        /// to retrieve the next set of results.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p> The maximum number of results to return in a single call.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReviewableHITs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_reviewable_hi_ts_input::Builder,
    }
    impl<C> ListReviewableHITs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReviewableHiTsOutput,
            smithy_http::result::SdkError<crate::error::ListReviewableHITsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The ID of the HIT type of the HITs to consider for the query.
        /// If not specified, all HITs for the Reviewer are considered
        /// </p>
        pub fn hit_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_type_id(input);
            self
        }
        pub fn set_hit_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_type_id(input);
            self
        }
        /// <p>
        /// Can be either <code>Reviewable</code> or <code>Reviewing</code>.
        /// Reviewable is the default value.
        /// </p>
        pub fn status(mut self, input: crate::model::ReviewableHitStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReviewableHitStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>Pagination Token</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>
        /// Limit the number of results returned.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReviewPolicyResultsForHIT<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_review_policy_results_for_hit_input::Builder,
    }
    impl<C> ListReviewPolicyResultsForHIT<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReviewPolicyResultsForHitOutput,
            smithy_http::result::SdkError<crate::error::ListReviewPolicyResultsForHITError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier of the HIT to retrieve review results for.</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_id(input);
            self
        }
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_id(input);
            self
        }
        /// <p>
        /// The Policy Level(s) to retrieve review results for - HIT or Assignment.
        /// If omitted, the default behavior is to retrieve all data for both policy levels.
        /// For a list of all the described policies, see Review Policies.
        /// </p>
        pub fn policy_levels(mut self, inp: impl Into<crate::model::ReviewPolicyLevel>) -> Self {
            self.inner = self.inner.policy_levels(inp);
            self
        }
        pub fn set_policy_levels(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReviewPolicyLevel>>,
        ) -> Self {
            self.inner = self.inner.set_policy_levels(input);
            self
        }
        /// <p>
        /// Specify if the operation should retrieve a list of the actions taken executing
        /// the Review Policies and their outcomes.
        /// </p>
        pub fn retrieve_actions(mut self, input: bool) -> Self {
            self.inner = self.inner.retrieve_actions(input);
            self
        }
        pub fn set_retrieve_actions(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_retrieve_actions(input);
            self
        }
        /// <p>
        /// Specify if the operation should retrieve a list of the results computed by the Review Policies.
        /// </p>
        pub fn retrieve_results(mut self, input: bool) -> Self {
            self.inner = self.inner.retrieve_results(input);
            self
        }
        pub fn set_retrieve_results(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_retrieve_results(input);
            self
        }
        /// <p>Pagination token</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Limit the number of results returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListWorkerBlocks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_worker_blocks_input::Builder,
    }
    impl<C> ListWorkerBlocks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListWorkerBlocksOutput,
            smithy_http::result::SdkError<crate::error::ListWorkerBlocksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Pagination token</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListWorkersWithQualificationType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_workers_with_qualification_type_input::Builder,
    }
    impl<C> ListWorkersWithQualificationType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListWorkersWithQualificationTypeOutput,
            smithy_http::result::SdkError<crate::error::ListWorkersWithQualificationTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Qualification type of the Qualifications to
        /// return.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_type_id(input);
            self
        }
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_id(input);
            self
        }
        /// <p>
        /// The status of the Qualifications to return.
        /// Can be <code>Granted | Revoked</code>.
        /// </p>
        pub fn status(mut self, input: crate::model::QualificationStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::QualificationStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>Pagination Token</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>
        /// Limit the number of results returned.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct NotifyWorkers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::notify_workers_input::Builder,
    }
    impl<C> NotifyWorkers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::NotifyWorkersOutput,
            smithy_http::result::SdkError<crate::error::NotifyWorkersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The subject line of the email message to send. Can include up
        /// to 200 characters.</p>
        pub fn subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subject(input);
            self
        }
        pub fn set_subject(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subject(input);
            self
        }
        /// <p>The text of the email message to send. Can include up to
        /// 4,096 characters</p>
        pub fn message_text(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.message_text(input);
            self
        }
        pub fn set_message_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_message_text(input);
            self
        }
        /// <p>A list of Worker IDs you wish to notify. You
        /// can notify upto
        /// 100 Workers at a time.</p>
        pub fn worker_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.worker_ids(inp);
            self
        }
        pub fn set_worker_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_worker_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectAssignment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_assignment_input::Builder,
    }
    impl<C> RejectAssignment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectAssignmentOutput,
            smithy_http::result::SdkError<crate::error::RejectAssignmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The ID of the assignment. The assignment must correspond to a HIT created by the Requester.
        /// </p>
        pub fn assignment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.assignment_id(input);
            self
        }
        pub fn set_assignment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_assignment_id(input);
            self
        }
        /// <p>
        /// A message for the Worker, which the Worker can see in the Status section of the web site.
        /// </p>
        pub fn requester_feedback(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.requester_feedback(input);
            self
        }
        pub fn set_requester_feedback(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_requester_feedback(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectQualificationRequest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_qualification_request_input::Builder,
    }
    impl<C> RejectQualificationRequest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectQualificationRequestOutput,
            smithy_http::result::SdkError<crate::error::RejectQualificationRequestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The ID of the Qualification request, as returned by the
        /// <code>ListQualificationRequests</code>
        /// operation.
        /// </p>
        pub fn qualification_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_request_id(input);
            self
        }
        pub fn set_qualification_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_request_id(input);
            self
        }
        /// <p>A text message explaining why the request was rejected, to be
        /// shown to the Worker who made the request.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendBonus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_bonus_input::Builder,
    }
    impl<C> SendBonus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendBonusOutput,
            smithy_http::result::SdkError<crate::error::SendBonusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Worker being paid the bonus.</p>
        pub fn worker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.worker_id(input);
            self
        }
        pub fn set_worker_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_worker_id(input);
            self
        }
        /// <p>
        /// The Bonus amount is a US Dollar amount specified using a string (for example, "5" represents $5.00 USD and
        /// "101.42" represents $101.42 USD). Do not include currency symbols or currency codes.
        /// </p>
        pub fn bonus_amount(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bonus_amount(input);
            self
        }
        pub fn set_bonus_amount(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bonus_amount(input);
            self
        }
        /// <p>The ID of the assignment for which this bonus is paid.</p>
        pub fn assignment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.assignment_id(input);
            self
        }
        pub fn set_assignment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_assignment_id(input);
            self
        }
        /// <p>A message that explains the reason for the bonus payment. The
        /// Worker receiving the bonus can see this message.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
        /// <p>A unique identifier for this request, which allows you to
        /// retry the call on error without granting multiple bonuses. This is
        /// useful in cases such as network timeouts where it is unclear whether
        /// or not the call succeeded on the server. If the bonus already exists
        /// in the system from a previous call using the same UniqueRequestToken,
        /// subsequent calls will return an error with a message containing the
        /// request ID.</p>
        pub fn unique_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.unique_request_token(input);
            self
        }
        pub fn set_unique_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_unique_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendTestEventNotification<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_test_event_notification_input::Builder,
    }
    impl<C> SendTestEventNotification<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendTestEventNotificationOutput,
            smithy_http::result::SdkError<crate::error::SendTestEventNotificationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The notification specification to test. This value is identical to the value
        /// you would provide to the UpdateNotificationSettings operation when you establish
        /// the notification specification for a HIT type.
        /// </p>
        pub fn notification(mut self, input: crate::model::NotificationSpecification) -> Self {
            self.inner = self.inner.notification(input);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::NotificationSpecification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>
        /// The event to simulate to test the notification specification.
        /// This event is included in the test message even if the notification specification
        /// does not include the event type.
        /// The notification specification does not filter out the test event.
        /// </p>
        pub fn test_event_type(mut self, input: crate::model::EventType) -> Self {
            self.inner = self.inner.test_event_type(input);
            self
        }
        pub fn set_test_event_type(
            mut self,
            input: std::option::Option<crate::model::EventType>,
        ) -> Self {
            self.inner = self.inner.set_test_event_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateExpirationForHIT<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_expiration_for_hit_input::Builder,
    }
    impl<C> UpdateExpirationForHIT<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateExpirationForHitOutput,
            smithy_http::result::SdkError<crate::error::UpdateExpirationForHITError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The HIT to update.
        /// </p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_id(input);
            self
        }
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_id(input);
            self
        }
        /// <p>
        /// The date and time at which you want the HIT to expire
        /// </p>
        pub fn expire_at(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.expire_at(input);
            self
        }
        pub fn set_expire_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_expire_at(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateHITReviewStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_hit_review_status_input::Builder,
    }
    impl<C> UpdateHITReviewStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateHitReviewStatusOutput,
            smithy_http::result::SdkError<crate::error::UpdateHITReviewStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The ID of the HIT to update.
        /// </p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_id(input);
            self
        }
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_id(input);
            self
        }
        /// <p>
        /// Specifies how to update the HIT status. Default is <code>False</code>.
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// Setting this to false will only transition a HIT from <code>Reviewable</code> to <code>Reviewing</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// Setting this to true will only transition a HIT from <code>Reviewing</code> to <code>Reviewable</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn revert(mut self, input: bool) -> Self {
            self.inner = self.inner.revert(input);
            self
        }
        pub fn set_revert(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_revert(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateHITTypeOfHIT<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_hit_type_of_hit_input::Builder,
    }
    impl<C> UpdateHITTypeOfHIT<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateHitTypeOfHitOutput,
            smithy_http::result::SdkError<crate::error::UpdateHITTypeOfHITError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The HIT to update.</p>
        pub fn hit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_id(input);
            self
        }
        pub fn set_hit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_id(input);
            self
        }
        /// <p>The ID of the new HIT type.</p>
        pub fn hit_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_type_id(input);
            self
        }
        pub fn set_hit_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_type_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateNotificationSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_notification_settings_input::Builder,
    }
    impl<C> UpdateNotificationSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateNotificationSettingsOutput,
            smithy_http::result::SdkError<crate::error::UpdateNotificationSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The ID of the HIT type whose notification specification is being updated.
        /// </p>
        pub fn hit_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hit_type_id(input);
            self
        }
        pub fn set_hit_type_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hit_type_id(input);
            self
        }
        /// <p>
        /// The notification specification for the HIT type.
        /// </p>
        pub fn notification(mut self, input: crate::model::NotificationSpecification) -> Self {
            self.inner = self.inner.notification(input);
            self
        }
        pub fn set_notification(
            mut self,
            input: std::option::Option<crate::model::NotificationSpecification>,
        ) -> Self {
            self.inner = self.inner.set_notification(input);
            self
        }
        /// <p>
        /// Specifies whether notifications are sent for HITs of this HIT type,
        /// according to the notification specification.
        /// You must specify either the Notification parameter or the Active parameter
        /// for the call to UpdateNotificationSettings to succeed.
        /// </p>
        pub fn active(mut self, input: bool) -> Self {
            self.inner = self.inner.active(input);
            self
        }
        pub fn set_active(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_active(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateQualificationType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_qualification_type_input::Builder,
    }
    impl<C> UpdateQualificationType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateQualificationTypeOutput,
            smithy_http::result::SdkError<crate::error::UpdateQualificationTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Qualification type to update.</p>
        pub fn qualification_type_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.qualification_type_id(input);
            self
        }
        pub fn set_qualification_type_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_id(input);
            self
        }
        /// <p>The new description of the Qualification type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The new status of the Qualification type - Active | Inactive</p>
        pub fn qualification_type_status(
            mut self,
            input: crate::model::QualificationTypeStatus,
        ) -> Self {
            self.inner = self.inner.qualification_type_status(input);
            self
        }
        pub fn set_qualification_type_status(
            mut self,
            input: std::option::Option<crate::model::QualificationTypeStatus>,
        ) -> Self {
            self.inner = self.inner.set_qualification_type_status(input);
            self
        }
        /// <p>The questions for the Qualification test a Worker must answer correctly to obtain a Qualification of this type. If this parameter is specified, <code>TestDurationInSeconds</code> must also be specified.</p>
        /// <p>Constraints: Must not be longer than 65535 bytes. Must be a QuestionForm data structure. This parameter cannot be specified if AutoGranted is true.</p>
        /// <p>Constraints: None. If not specified, the Worker may request the Qualification without answering any questions.</p>
        pub fn test(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.test(input);
            self
        }
        pub fn set_test(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_test(input);
            self
        }
        /// <p>The answers to the Qualification test specified in the Test parameter, in the form of an AnswerKey data structure.</p>
        pub fn answer_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.answer_key(input);
            self
        }
        pub fn set_answer_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_answer_key(input);
            self
        }
        /// <p>The number of seconds the Worker has to complete the Qualification test, starting from the time the Worker requests the Qualification.</p>
        pub fn test_duration_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.test_duration_in_seconds(input);
            self
        }
        pub fn set_test_duration_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_test_duration_in_seconds(input);
            self
        }
        /// <p>The amount of time, in seconds, that Workers must wait
        /// after requesting a Qualification of the specified Qualification type
        /// before they can retry the Qualification request. It is not possible to
        /// disable retries for a Qualification type after it has been created with
        /// retries enabled. If you want to disable retries, you must dispose of
        /// the existing retry-enabled Qualification type using
        /// DisposeQualificationType and then create a new Qualification type with
        /// retries disabled using CreateQualificationType.</p>
        pub fn retry_delay_in_seconds(mut self, input: i64) -> Self {
            self.inner = self.inner.retry_delay_in_seconds(input);
            self
        }
        pub fn set_retry_delay_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_retry_delay_in_seconds(input);
            self
        }
        /// <p>Specifies whether requests for the Qualification type are granted immediately, without prompting the Worker with a Qualification test.</p>
        /// <p>Constraints: If the Test parameter is specified, this parameter cannot be true.</p>
        pub fn auto_granted(mut self, input: bool) -> Self {
            self.inner = self.inner.auto_granted(input);
            self
        }
        pub fn set_auto_granted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_granted(input);
            self
        }
        /// <p>The Qualification value to use for automatically granted Qualifications. This parameter is used only if the AutoGranted parameter is true.</p>
        pub fn auto_granted_value(mut self, input: i32) -> Self {
            self.inner = self.inner.auto_granted_value(input);
            self
        }
        pub fn set_auto_granted_value(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_auto_granted_value(input);
            self
        }
    }
}
