// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptQualificationRequestError {
    pub kind: AcceptQualificationRequestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptQualificationRequestErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptQualificationRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptQualificationRequestErrorKind::RequestError(_inner) => _inner.fmt(f),
            AcceptQualificationRequestErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            AcceptQualificationRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptQualificationRequestError {
    fn code(&self) -> Option<&str> {
        AcceptQualificationRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptQualificationRequestError {
    pub fn new(kind: AcceptQualificationRequestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptQualificationRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptQualificationRequestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            AcceptQualificationRequestErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            AcceptQualificationRequestErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for AcceptQualificationRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptQualificationRequestErrorKind::RequestError(_inner) => Some(_inner),
            AcceptQualificationRequestErrorKind::ServiceFault(_inner) => Some(_inner),
            AcceptQualificationRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ApproveAssignmentError {
    pub kind: ApproveAssignmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ApproveAssignmentErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ApproveAssignmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ApproveAssignmentErrorKind::RequestError(_inner) => _inner.fmt(f),
            ApproveAssignmentErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ApproveAssignmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ApproveAssignmentError {
    fn code(&self) -> Option<&str> {
        ApproveAssignmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ApproveAssignmentError {
    pub fn new(kind: ApproveAssignmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ApproveAssignmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ApproveAssignmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, ApproveAssignmentErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, ApproveAssignmentErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for ApproveAssignmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ApproveAssignmentErrorKind::RequestError(_inner) => Some(_inner),
            ApproveAssignmentErrorKind::ServiceFault(_inner) => Some(_inner),
            ApproveAssignmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateQualificationWithWorkerError {
    pub kind: AssociateQualificationWithWorkerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateQualificationWithWorkerErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateQualificationWithWorkerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateQualificationWithWorkerErrorKind::RequestError(_inner) => _inner.fmt(f),
            AssociateQualificationWithWorkerErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            AssociateQualificationWithWorkerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateQualificationWithWorkerError {
    fn code(&self) -> Option<&str> {
        AssociateQualificationWithWorkerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateQualificationWithWorkerError {
    pub fn new(kind: AssociateQualificationWithWorkerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateQualificationWithWorkerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateQualificationWithWorkerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateQualificationWithWorkerErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            AssociateQualificationWithWorkerErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for AssociateQualificationWithWorkerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateQualificationWithWorkerErrorKind::RequestError(_inner) => Some(_inner),
            AssociateQualificationWithWorkerErrorKind::ServiceFault(_inner) => Some(_inner),
            AssociateQualificationWithWorkerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAdditionalAssignmentsForHITError {
    pub kind: CreateAdditionalAssignmentsForHITErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAdditionalAssignmentsForHITErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAdditionalAssignmentsForHITError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAdditionalAssignmentsForHITErrorKind::RequestError(_inner) => _inner.fmt(f),
            CreateAdditionalAssignmentsForHITErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            CreateAdditionalAssignmentsForHITErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAdditionalAssignmentsForHITError {
    fn code(&self) -> Option<&str> {
        CreateAdditionalAssignmentsForHITError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAdditionalAssignmentsForHITError {
    pub fn new(
        kind: CreateAdditionalAssignmentsForHITErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAdditionalAssignmentsForHITErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAdditionalAssignmentsForHITErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateAdditionalAssignmentsForHITErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateAdditionalAssignmentsForHITErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for CreateAdditionalAssignmentsForHITError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAdditionalAssignmentsForHITErrorKind::RequestError(_inner) => Some(_inner),
            CreateAdditionalAssignmentsForHITErrorKind::ServiceFault(_inner) => Some(_inner),
            CreateAdditionalAssignmentsForHITErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateHITError {
    pub kind: CreateHITErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateHITErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateHITError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateHITErrorKind::RequestError(_inner) => _inner.fmt(f),
            CreateHITErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            CreateHITErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateHITError {
    fn code(&self) -> Option<&str> {
        CreateHITError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateHITError {
    pub fn new(kind: CreateHITErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateHITErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateHITErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, CreateHITErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, CreateHITErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for CreateHITError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateHITErrorKind::RequestError(_inner) => Some(_inner),
            CreateHITErrorKind::ServiceFault(_inner) => Some(_inner),
            CreateHITErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateHITTypeError {
    pub kind: CreateHITTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateHITTypeErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateHITTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateHITTypeErrorKind::RequestError(_inner) => _inner.fmt(f),
            CreateHITTypeErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            CreateHITTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateHITTypeError {
    fn code(&self) -> Option<&str> {
        CreateHITTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateHITTypeError {
    pub fn new(kind: CreateHITTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateHITTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateHITTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, CreateHITTypeErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, CreateHITTypeErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for CreateHITTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateHITTypeErrorKind::RequestError(_inner) => Some(_inner),
            CreateHITTypeErrorKind::ServiceFault(_inner) => Some(_inner),
            CreateHITTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateHITWithHITTypeError {
    pub kind: CreateHITWithHITTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateHITWithHITTypeErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateHITWithHITTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateHITWithHITTypeErrorKind::RequestError(_inner) => _inner.fmt(f),
            CreateHITWithHITTypeErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            CreateHITWithHITTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateHITWithHITTypeError {
    fn code(&self) -> Option<&str> {
        CreateHITWithHITTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateHITWithHITTypeError {
    pub fn new(kind: CreateHITWithHITTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateHITWithHITTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateHITWithHITTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, CreateHITWithHITTypeErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, CreateHITWithHITTypeErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for CreateHITWithHITTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateHITWithHITTypeErrorKind::RequestError(_inner) => Some(_inner),
            CreateHITWithHITTypeErrorKind::ServiceFault(_inner) => Some(_inner),
            CreateHITWithHITTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateQualificationTypeError {
    pub kind: CreateQualificationTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateQualificationTypeErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateQualificationTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateQualificationTypeErrorKind::RequestError(_inner) => _inner.fmt(f),
            CreateQualificationTypeErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            CreateQualificationTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateQualificationTypeError {
    fn code(&self) -> Option<&str> {
        CreateQualificationTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateQualificationTypeError {
    pub fn new(kind: CreateQualificationTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateQualificationTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateQualificationTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateQualificationTypeErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateQualificationTypeErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for CreateQualificationTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateQualificationTypeErrorKind::RequestError(_inner) => Some(_inner),
            CreateQualificationTypeErrorKind::ServiceFault(_inner) => Some(_inner),
            CreateQualificationTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWorkerBlockError {
    pub kind: CreateWorkerBlockErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWorkerBlockErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWorkerBlockError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWorkerBlockErrorKind::RequestError(_inner) => _inner.fmt(f),
            CreateWorkerBlockErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            CreateWorkerBlockErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWorkerBlockError {
    fn code(&self) -> Option<&str> {
        CreateWorkerBlockError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWorkerBlockError {
    pub fn new(kind: CreateWorkerBlockErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWorkerBlockErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWorkerBlockErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, CreateWorkerBlockErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, CreateWorkerBlockErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for CreateWorkerBlockError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWorkerBlockErrorKind::RequestError(_inner) => Some(_inner),
            CreateWorkerBlockErrorKind::ServiceFault(_inner) => Some(_inner),
            CreateWorkerBlockErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteHITError {
    pub kind: DeleteHITErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteHITErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteHITError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteHITErrorKind::RequestError(_inner) => _inner.fmt(f),
            DeleteHITErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            DeleteHITErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteHITError {
    fn code(&self) -> Option<&str> {
        DeleteHITError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteHITError {
    pub fn new(kind: DeleteHITErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteHITErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteHITErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, DeleteHITErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, DeleteHITErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for DeleteHITError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteHITErrorKind::RequestError(_inner) => Some(_inner),
            DeleteHITErrorKind::ServiceFault(_inner) => Some(_inner),
            DeleteHITErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteQualificationTypeError {
    pub kind: DeleteQualificationTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteQualificationTypeErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteQualificationTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteQualificationTypeErrorKind::RequestError(_inner) => _inner.fmt(f),
            DeleteQualificationTypeErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            DeleteQualificationTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteQualificationTypeError {
    fn code(&self) -> Option<&str> {
        DeleteQualificationTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteQualificationTypeError {
    pub fn new(kind: DeleteQualificationTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteQualificationTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteQualificationTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQualificationTypeErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQualificationTypeErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for DeleteQualificationTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteQualificationTypeErrorKind::RequestError(_inner) => Some(_inner),
            DeleteQualificationTypeErrorKind::ServiceFault(_inner) => Some(_inner),
            DeleteQualificationTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteWorkerBlockError {
    pub kind: DeleteWorkerBlockErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWorkerBlockErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteWorkerBlockError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteWorkerBlockErrorKind::RequestError(_inner) => _inner.fmt(f),
            DeleteWorkerBlockErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            DeleteWorkerBlockErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteWorkerBlockError {
    fn code(&self) -> Option<&str> {
        DeleteWorkerBlockError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWorkerBlockError {
    pub fn new(kind: DeleteWorkerBlockErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteWorkerBlockErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteWorkerBlockErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, DeleteWorkerBlockErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, DeleteWorkerBlockErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for DeleteWorkerBlockError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteWorkerBlockErrorKind::RequestError(_inner) => Some(_inner),
            DeleteWorkerBlockErrorKind::ServiceFault(_inner) => Some(_inner),
            DeleteWorkerBlockErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateQualificationFromWorkerError {
    pub kind: DisassociateQualificationFromWorkerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateQualificationFromWorkerErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateQualificationFromWorkerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateQualificationFromWorkerErrorKind::RequestError(_inner) => _inner.fmt(f),
            DisassociateQualificationFromWorkerErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            DisassociateQualificationFromWorkerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateQualificationFromWorkerError {
    fn code(&self) -> Option<&str> {
        DisassociateQualificationFromWorkerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateQualificationFromWorkerError {
    pub fn new(
        kind: DisassociateQualificationFromWorkerErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateQualificationFromWorkerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateQualificationFromWorkerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateQualificationFromWorkerErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateQualificationFromWorkerErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for DisassociateQualificationFromWorkerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateQualificationFromWorkerErrorKind::RequestError(_inner) => Some(_inner),
            DisassociateQualificationFromWorkerErrorKind::ServiceFault(_inner) => Some(_inner),
            DisassociateQualificationFromWorkerErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountBalanceError {
    pub kind: GetAccountBalanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountBalanceErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountBalanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountBalanceErrorKind::RequestError(_inner) => _inner.fmt(f),
            GetAccountBalanceErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            GetAccountBalanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountBalanceError {
    fn code(&self) -> Option<&str> {
        GetAccountBalanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountBalanceError {
    pub fn new(kind: GetAccountBalanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountBalanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountBalanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, GetAccountBalanceErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, GetAccountBalanceErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for GetAccountBalanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountBalanceErrorKind::RequestError(_inner) => Some(_inner),
            GetAccountBalanceErrorKind::ServiceFault(_inner) => Some(_inner),
            GetAccountBalanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAssignmentError {
    pub kind: GetAssignmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAssignmentErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAssignmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAssignmentErrorKind::RequestError(_inner) => _inner.fmt(f),
            GetAssignmentErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            GetAssignmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAssignmentError {
    fn code(&self) -> Option<&str> {
        GetAssignmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAssignmentError {
    pub fn new(kind: GetAssignmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAssignmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAssignmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, GetAssignmentErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, GetAssignmentErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for GetAssignmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAssignmentErrorKind::RequestError(_inner) => Some(_inner),
            GetAssignmentErrorKind::ServiceFault(_inner) => Some(_inner),
            GetAssignmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFileUploadURLError {
    pub kind: GetFileUploadURLErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFileUploadURLErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFileUploadURLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFileUploadURLErrorKind::RequestError(_inner) => _inner.fmt(f),
            GetFileUploadURLErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            GetFileUploadURLErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFileUploadURLError {
    fn code(&self) -> Option<&str> {
        GetFileUploadURLError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFileUploadURLError {
    pub fn new(kind: GetFileUploadURLErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFileUploadURLErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFileUploadURLErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, GetFileUploadURLErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, GetFileUploadURLErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for GetFileUploadURLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFileUploadURLErrorKind::RequestError(_inner) => Some(_inner),
            GetFileUploadURLErrorKind::ServiceFault(_inner) => Some(_inner),
            GetFileUploadURLErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetHITError {
    pub kind: GetHITErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetHITErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetHITError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetHITErrorKind::RequestError(_inner) => _inner.fmt(f),
            GetHITErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            GetHITErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetHITError {
    fn code(&self) -> Option<&str> {
        GetHITError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetHITError {
    pub fn new(kind: GetHITErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetHITErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetHITErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, GetHITErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, GetHITErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for GetHITError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetHITErrorKind::RequestError(_inner) => Some(_inner),
            GetHITErrorKind::ServiceFault(_inner) => Some(_inner),
            GetHITErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetQualificationScoreError {
    pub kind: GetQualificationScoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetQualificationScoreErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetQualificationScoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetQualificationScoreErrorKind::RequestError(_inner) => _inner.fmt(f),
            GetQualificationScoreErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            GetQualificationScoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetQualificationScoreError {
    fn code(&self) -> Option<&str> {
        GetQualificationScoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetQualificationScoreError {
    pub fn new(kind: GetQualificationScoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetQualificationScoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetQualificationScoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, GetQualificationScoreErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, GetQualificationScoreErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for GetQualificationScoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetQualificationScoreErrorKind::RequestError(_inner) => Some(_inner),
            GetQualificationScoreErrorKind::ServiceFault(_inner) => Some(_inner),
            GetQualificationScoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetQualificationTypeError {
    pub kind: GetQualificationTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetQualificationTypeErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetQualificationTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetQualificationTypeErrorKind::RequestError(_inner) => _inner.fmt(f),
            GetQualificationTypeErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            GetQualificationTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetQualificationTypeError {
    fn code(&self) -> Option<&str> {
        GetQualificationTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetQualificationTypeError {
    pub fn new(kind: GetQualificationTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetQualificationTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetQualificationTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, GetQualificationTypeErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, GetQualificationTypeErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for GetQualificationTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetQualificationTypeErrorKind::RequestError(_inner) => Some(_inner),
            GetQualificationTypeErrorKind::ServiceFault(_inner) => Some(_inner),
            GetQualificationTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssignmentsForHITError {
    pub kind: ListAssignmentsForHITErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssignmentsForHITErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssignmentsForHITError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssignmentsForHITErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListAssignmentsForHITErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListAssignmentsForHITErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssignmentsForHITError {
    fn code(&self) -> Option<&str> {
        ListAssignmentsForHITError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssignmentsForHITError {
    pub fn new(kind: ListAssignmentsForHITErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssignmentsForHITErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssignmentsForHITErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, ListAssignmentsForHITErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, ListAssignmentsForHITErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for ListAssignmentsForHITError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssignmentsForHITErrorKind::RequestError(_inner) => Some(_inner),
            ListAssignmentsForHITErrorKind::ServiceFault(_inner) => Some(_inner),
            ListAssignmentsForHITErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBonusPaymentsError {
    pub kind: ListBonusPaymentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBonusPaymentsErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBonusPaymentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBonusPaymentsErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListBonusPaymentsErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListBonusPaymentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBonusPaymentsError {
    fn code(&self) -> Option<&str> {
        ListBonusPaymentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBonusPaymentsError {
    pub fn new(kind: ListBonusPaymentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBonusPaymentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBonusPaymentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, ListBonusPaymentsErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, ListBonusPaymentsErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for ListBonusPaymentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBonusPaymentsErrorKind::RequestError(_inner) => Some(_inner),
            ListBonusPaymentsErrorKind::ServiceFault(_inner) => Some(_inner),
            ListBonusPaymentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListHITsError {
    pub kind: ListHITsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListHITsErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListHITsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListHITsErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListHITsErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListHITsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListHITsError {
    fn code(&self) -> Option<&str> {
        ListHITsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListHITsError {
    pub fn new(kind: ListHITsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListHITsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListHITsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, ListHITsErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, ListHITsErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for ListHITsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListHITsErrorKind::RequestError(_inner) => Some(_inner),
            ListHITsErrorKind::ServiceFault(_inner) => Some(_inner),
            ListHITsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListHITsForQualificationTypeError {
    pub kind: ListHITsForQualificationTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListHITsForQualificationTypeErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListHITsForQualificationTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListHITsForQualificationTypeErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListHITsForQualificationTypeErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListHITsForQualificationTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListHITsForQualificationTypeError {
    fn code(&self) -> Option<&str> {
        ListHITsForQualificationTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListHITsForQualificationTypeError {
    pub fn new(kind: ListHITsForQualificationTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListHITsForQualificationTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListHITsForQualificationTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListHITsForQualificationTypeErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListHITsForQualificationTypeErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for ListHITsForQualificationTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListHITsForQualificationTypeErrorKind::RequestError(_inner) => Some(_inner),
            ListHITsForQualificationTypeErrorKind::ServiceFault(_inner) => Some(_inner),
            ListHITsForQualificationTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListQualificationRequestsError {
    pub kind: ListQualificationRequestsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListQualificationRequestsErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListQualificationRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListQualificationRequestsErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListQualificationRequestsErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListQualificationRequestsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListQualificationRequestsError {
    fn code(&self) -> Option<&str> {
        ListQualificationRequestsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListQualificationRequestsError {
    pub fn new(kind: ListQualificationRequestsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListQualificationRequestsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListQualificationRequestsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListQualificationRequestsErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListQualificationRequestsErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for ListQualificationRequestsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListQualificationRequestsErrorKind::RequestError(_inner) => Some(_inner),
            ListQualificationRequestsErrorKind::ServiceFault(_inner) => Some(_inner),
            ListQualificationRequestsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListQualificationTypesError {
    pub kind: ListQualificationTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListQualificationTypesErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListQualificationTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListQualificationTypesErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListQualificationTypesErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListQualificationTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListQualificationTypesError {
    fn code(&self) -> Option<&str> {
        ListQualificationTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListQualificationTypesError {
    pub fn new(kind: ListQualificationTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListQualificationTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListQualificationTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, ListQualificationTypesErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, ListQualificationTypesErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for ListQualificationTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListQualificationTypesErrorKind::RequestError(_inner) => Some(_inner),
            ListQualificationTypesErrorKind::ServiceFault(_inner) => Some(_inner),
            ListQualificationTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListReviewableHITsError {
    pub kind: ListReviewableHITsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListReviewableHITsErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListReviewableHITsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListReviewableHITsErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListReviewableHITsErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListReviewableHITsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListReviewableHITsError {
    fn code(&self) -> Option<&str> {
        ListReviewableHITsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListReviewableHITsError {
    pub fn new(kind: ListReviewableHITsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListReviewableHITsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListReviewableHITsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, ListReviewableHITsErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, ListReviewableHITsErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for ListReviewableHITsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListReviewableHITsErrorKind::RequestError(_inner) => Some(_inner),
            ListReviewableHITsErrorKind::ServiceFault(_inner) => Some(_inner),
            ListReviewableHITsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListReviewPolicyResultsForHITError {
    pub kind: ListReviewPolicyResultsForHITErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListReviewPolicyResultsForHITErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListReviewPolicyResultsForHITError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListReviewPolicyResultsForHITErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListReviewPolicyResultsForHITErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListReviewPolicyResultsForHITErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListReviewPolicyResultsForHITError {
    fn code(&self) -> Option<&str> {
        ListReviewPolicyResultsForHITError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListReviewPolicyResultsForHITError {
    pub fn new(kind: ListReviewPolicyResultsForHITErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListReviewPolicyResultsForHITErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListReviewPolicyResultsForHITErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListReviewPolicyResultsForHITErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListReviewPolicyResultsForHITErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for ListReviewPolicyResultsForHITError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListReviewPolicyResultsForHITErrorKind::RequestError(_inner) => Some(_inner),
            ListReviewPolicyResultsForHITErrorKind::ServiceFault(_inner) => Some(_inner),
            ListReviewPolicyResultsForHITErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWorkerBlocksError {
    pub kind: ListWorkerBlocksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorkerBlocksErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWorkerBlocksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWorkerBlocksErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListWorkerBlocksErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListWorkerBlocksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWorkerBlocksError {
    fn code(&self) -> Option<&str> {
        ListWorkerBlocksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorkerBlocksError {
    pub fn new(kind: ListWorkerBlocksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWorkerBlocksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWorkerBlocksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, ListWorkerBlocksErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, ListWorkerBlocksErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for ListWorkerBlocksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWorkerBlocksErrorKind::RequestError(_inner) => Some(_inner),
            ListWorkerBlocksErrorKind::ServiceFault(_inner) => Some(_inner),
            ListWorkerBlocksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWorkersWithQualificationTypeError {
    pub kind: ListWorkersWithQualificationTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorkersWithQualificationTypeErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWorkersWithQualificationTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWorkersWithQualificationTypeErrorKind::RequestError(_inner) => _inner.fmt(f),
            ListWorkersWithQualificationTypeErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            ListWorkersWithQualificationTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWorkersWithQualificationTypeError {
    fn code(&self) -> Option<&str> {
        ListWorkersWithQualificationTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorkersWithQualificationTypeError {
    pub fn new(kind: ListWorkersWithQualificationTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWorkersWithQualificationTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWorkersWithQualificationTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkersWithQualificationTypeErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkersWithQualificationTypeErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for ListWorkersWithQualificationTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWorkersWithQualificationTypeErrorKind::RequestError(_inner) => Some(_inner),
            ListWorkersWithQualificationTypeErrorKind::ServiceFault(_inner) => Some(_inner),
            ListWorkersWithQualificationTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct NotifyWorkersError {
    pub kind: NotifyWorkersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum NotifyWorkersErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for NotifyWorkersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            NotifyWorkersErrorKind::RequestError(_inner) => _inner.fmt(f),
            NotifyWorkersErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            NotifyWorkersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for NotifyWorkersError {
    fn code(&self) -> Option<&str> {
        NotifyWorkersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl NotifyWorkersError {
    pub fn new(kind: NotifyWorkersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: NotifyWorkersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: NotifyWorkersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, NotifyWorkersErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, NotifyWorkersErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for NotifyWorkersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            NotifyWorkersErrorKind::RequestError(_inner) => Some(_inner),
            NotifyWorkersErrorKind::ServiceFault(_inner) => Some(_inner),
            NotifyWorkersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RejectAssignmentError {
    pub kind: RejectAssignmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectAssignmentErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RejectAssignmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RejectAssignmentErrorKind::RequestError(_inner) => _inner.fmt(f),
            RejectAssignmentErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            RejectAssignmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RejectAssignmentError {
    fn code(&self) -> Option<&str> {
        RejectAssignmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectAssignmentError {
    pub fn new(kind: RejectAssignmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RejectAssignmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RejectAssignmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, RejectAssignmentErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, RejectAssignmentErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for RejectAssignmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RejectAssignmentErrorKind::RequestError(_inner) => Some(_inner),
            RejectAssignmentErrorKind::ServiceFault(_inner) => Some(_inner),
            RejectAssignmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RejectQualificationRequestError {
    pub kind: RejectQualificationRequestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectQualificationRequestErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RejectQualificationRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RejectQualificationRequestErrorKind::RequestError(_inner) => _inner.fmt(f),
            RejectQualificationRequestErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            RejectQualificationRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RejectQualificationRequestError {
    fn code(&self) -> Option<&str> {
        RejectQualificationRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectQualificationRequestError {
    pub fn new(kind: RejectQualificationRequestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RejectQualificationRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RejectQualificationRequestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            RejectQualificationRequestErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            RejectQualificationRequestErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for RejectQualificationRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RejectQualificationRequestErrorKind::RequestError(_inner) => Some(_inner),
            RejectQualificationRequestErrorKind::ServiceFault(_inner) => Some(_inner),
            RejectQualificationRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendBonusError {
    pub kind: SendBonusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendBonusErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendBonusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendBonusErrorKind::RequestError(_inner) => _inner.fmt(f),
            SendBonusErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            SendBonusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendBonusError {
    fn code(&self) -> Option<&str> {
        SendBonusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendBonusError {
    pub fn new(kind: SendBonusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendBonusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendBonusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, SendBonusErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, SendBonusErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for SendBonusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendBonusErrorKind::RequestError(_inner) => Some(_inner),
            SendBonusErrorKind::ServiceFault(_inner) => Some(_inner),
            SendBonusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendTestEventNotificationError {
    pub kind: SendTestEventNotificationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendTestEventNotificationErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendTestEventNotificationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendTestEventNotificationErrorKind::RequestError(_inner) => _inner.fmt(f),
            SendTestEventNotificationErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            SendTestEventNotificationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendTestEventNotificationError {
    fn code(&self) -> Option<&str> {
        SendTestEventNotificationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendTestEventNotificationError {
    pub fn new(kind: SendTestEventNotificationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendTestEventNotificationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendTestEventNotificationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            SendTestEventNotificationErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            SendTestEventNotificationErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for SendTestEventNotificationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendTestEventNotificationErrorKind::RequestError(_inner) => Some(_inner),
            SendTestEventNotificationErrorKind::ServiceFault(_inner) => Some(_inner),
            SendTestEventNotificationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateExpirationForHITError {
    pub kind: UpdateExpirationForHITErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateExpirationForHITErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateExpirationForHITError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateExpirationForHITErrorKind::RequestError(_inner) => _inner.fmt(f),
            UpdateExpirationForHITErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            UpdateExpirationForHITErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateExpirationForHITError {
    fn code(&self) -> Option<&str> {
        UpdateExpirationForHITError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateExpirationForHITError {
    pub fn new(kind: UpdateExpirationForHITErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateExpirationForHITErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateExpirationForHITErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, UpdateExpirationForHITErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, UpdateExpirationForHITErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for UpdateExpirationForHITError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateExpirationForHITErrorKind::RequestError(_inner) => Some(_inner),
            UpdateExpirationForHITErrorKind::ServiceFault(_inner) => Some(_inner),
            UpdateExpirationForHITErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateHITReviewStatusError {
    pub kind: UpdateHITReviewStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateHITReviewStatusErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateHITReviewStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateHITReviewStatusErrorKind::RequestError(_inner) => _inner.fmt(f),
            UpdateHITReviewStatusErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            UpdateHITReviewStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateHITReviewStatusError {
    fn code(&self) -> Option<&str> {
        UpdateHITReviewStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateHITReviewStatusError {
    pub fn new(kind: UpdateHITReviewStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateHITReviewStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateHITReviewStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, UpdateHITReviewStatusErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, UpdateHITReviewStatusErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for UpdateHITReviewStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateHITReviewStatusErrorKind::RequestError(_inner) => Some(_inner),
            UpdateHITReviewStatusErrorKind::ServiceFault(_inner) => Some(_inner),
            UpdateHITReviewStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateHITTypeOfHITError {
    pub kind: UpdateHITTypeOfHITErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateHITTypeOfHITErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateHITTypeOfHITError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateHITTypeOfHITErrorKind::RequestError(_inner) => _inner.fmt(f),
            UpdateHITTypeOfHITErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            UpdateHITTypeOfHITErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateHITTypeOfHITError {
    fn code(&self) -> Option<&str> {
        UpdateHITTypeOfHITError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateHITTypeOfHITError {
    pub fn new(kind: UpdateHITTypeOfHITErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateHITTypeOfHITErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateHITTypeOfHITErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(&self.kind, UpdateHITTypeOfHITErrorKind::RequestError(_))
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(&self.kind, UpdateHITTypeOfHITErrorKind::ServiceFault(_))
    }
}
impl std::error::Error for UpdateHITTypeOfHITError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateHITTypeOfHITErrorKind::RequestError(_inner) => Some(_inner),
            UpdateHITTypeOfHITErrorKind::ServiceFault(_inner) => Some(_inner),
            UpdateHITTypeOfHITErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateNotificationSettingsError {
    pub kind: UpdateNotificationSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateNotificationSettingsErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateNotificationSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateNotificationSettingsErrorKind::RequestError(_inner) => _inner.fmt(f),
            UpdateNotificationSettingsErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            UpdateNotificationSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateNotificationSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateNotificationSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateNotificationSettingsError {
    pub fn new(kind: UpdateNotificationSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateNotificationSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateNotificationSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateNotificationSettingsErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            UpdateNotificationSettingsErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for UpdateNotificationSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateNotificationSettingsErrorKind::RequestError(_inner) => Some(_inner),
            UpdateNotificationSettingsErrorKind::ServiceFault(_inner) => Some(_inner),
            UpdateNotificationSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateQualificationTypeError {
    pub kind: UpdateQualificationTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateQualificationTypeErrorKind {
    RequestError(crate::error::RequestError),
    ServiceFault(crate::error::ServiceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateQualificationTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateQualificationTypeErrorKind::RequestError(_inner) => _inner.fmt(f),
            UpdateQualificationTypeErrorKind::ServiceFault(_inner) => _inner.fmt(f),
            UpdateQualificationTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateQualificationTypeError {
    fn code(&self) -> Option<&str> {
        UpdateQualificationTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateQualificationTypeError {
    pub fn new(kind: UpdateQualificationTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateQualificationTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateQualificationTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_request_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQualificationTypeErrorKind::RequestError(_)
        )
    }
    pub fn is_service_fault(&self) -> bool {
        matches!(
            &self.kind,
            UpdateQualificationTypeErrorKind::ServiceFault(_)
        )
    }
}
impl std::error::Error for UpdateQualificationTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateQualificationTypeErrorKind::RequestError(_inner) => Some(_inner),
            UpdateQualificationTypeErrorKind::ServiceFault(_inner) => Some(_inner),
            UpdateQualificationTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Amazon Mechanical Turk is temporarily unable to process your request. Try your call again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceFault {
    pub message: std::option::Option<std::string::String>,
    pub turk_error_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceFault");
        formatter.field("message", &self.message);
        formatter.field("turk_error_code", &self.turk_error_code);
        formatter.finish()
    }
}
impl ServiceFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceFault")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceFault {}
/// See [`ServiceFault`](crate::error::ServiceFault)
pub mod service_fault {
    /// A builder for [`ServiceFault`](crate::error::ServiceFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) turk_error_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn turk_error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.turk_error_code = Some(input.into());
            self
        }
        pub fn set_turk_error_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.turk_error_code = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceFault`](crate::error::ServiceFault)
        pub fn build(self) -> crate::error::ServiceFault {
            crate::error::ServiceFault {
                message: self.message,
                turk_error_code: self.turk_error_code,
            }
        }
    }
}
impl ServiceFault {
    /// Creates a new builder-style object to manufacture [`ServiceFault`](crate::error::ServiceFault)
    pub fn builder() -> crate::error::service_fault::Builder {
        crate::error::service_fault::Builder::default()
    }
}

/// <p>Your request is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestError {
    pub message: std::option::Option<std::string::String>,
    pub turk_error_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestError");
        formatter.field("message", &self.message);
        formatter.field("turk_error_code", &self.turk_error_code);
        formatter.finish()
    }
}
impl RequestError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestError")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for RequestError {}
/// See [`RequestError`](crate::error::RequestError)
pub mod request_error {
    /// A builder for [`RequestError`](crate::error::RequestError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) turk_error_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn turk_error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.turk_error_code = Some(input.into());
            self
        }
        pub fn set_turk_error_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.turk_error_code = input;
            self
        }
        /// Consumes the builder and constructs a [`RequestError`](crate::error::RequestError)
        pub fn build(self) -> crate::error::RequestError {
            crate::error::RequestError {
                message: self.message,
                turk_error_code: self.turk_error_code,
            }
        }
    }
}
impl RequestError {
    /// Creates a new builder-style object to manufacture [`RequestError`](crate::error::RequestError)
    pub fn builder() -> crate::error::request_error::Builder {
        crate::error::request_error::Builder::default()
    }
}
