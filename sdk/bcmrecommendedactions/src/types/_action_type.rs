// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ActionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let actiontype = unimplemented!();
/// match actiontype {
///     ActionType::AddAlternateBillingContact => { /* ... */ },
///     ActionType::CreateAnomalyMonitor => { /* ... */ },
///     ActionType::CreateBudget => { /* ... */ },
///     ActionType::EnableCostOptimizationHub => { /* ... */ },
///     ActionType::MigrateToGranularPermissions => { /* ... */ },
///     ActionType::PaymentsDue => { /* ... */ },
///     ActionType::PaymentsPastDue => { /* ... */ },
///     ActionType::ReviewAnomalies => { /* ... */ },
///     ActionType::ReviewBudgetsExceeded => { /* ... */ },
///     ActionType::ReviewBudgetAlerts => { /* ... */ },
///     ActionType::ReviewExpiringRi => { /* ... */ },
///     ActionType::ReviewExpiringSp => { /* ... */ },
///     ActionType::ReviewFreetierCreditsRemaining => { /* ... */ },
///     ActionType::ReviewFreetierDaysRemaining => { /* ... */ },
///     ActionType::ReviewFreetierUsageAlerts => { /* ... */ },
///     ActionType::ReviewSavingsOpportunityRecommendations => { /* ... */ },
///     ActionType::UpdateExpiredPaymentMethod => { /* ... */ },
///     ActionType::UpdateInvalidPaymentMethod => { /* ... */ },
///     ActionType::UpdateTaxExemptionCertificate => { /* ... */ },
///     ActionType::UpdateTaxRegistrationNumber => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `actiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ActionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ActionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ActionType::NewFeature` is defined.
/// Specifically, when `actiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ActionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
///
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub enum ActionType {
    #[allow(missing_docs)] // documentation missing in model
    AddAlternateBillingContact,
    #[allow(missing_docs)] // documentation missing in model
    CreateAnomalyMonitor,
    #[allow(missing_docs)] // documentation missing in model
    CreateBudget,
    #[allow(missing_docs)] // documentation missing in model
    EnableCostOptimizationHub,
    #[allow(missing_docs)] // documentation missing in model
    MigrateToGranularPermissions,
    #[allow(missing_docs)] // documentation missing in model
    PaymentsDue,
    #[allow(missing_docs)] // documentation missing in model
    PaymentsPastDue,
    #[allow(missing_docs)] // documentation missing in model
    ReviewAnomalies,
    #[allow(missing_docs)] // documentation missing in model
    ReviewBudgetsExceeded,
    #[allow(missing_docs)] // documentation missing in model
    ReviewBudgetAlerts,
    #[allow(missing_docs)] // documentation missing in model
    ReviewExpiringRi,
    #[allow(missing_docs)] // documentation missing in model
    ReviewExpiringSp,
    #[allow(missing_docs)] // documentation missing in model
    ReviewFreetierCreditsRemaining,
    #[allow(missing_docs)] // documentation missing in model
    ReviewFreetierDaysRemaining,
    #[allow(missing_docs)] // documentation missing in model
    ReviewFreetierUsageAlerts,
    #[allow(missing_docs)] // documentation missing in model
    ReviewSavingsOpportunityRecommendations,
    #[allow(missing_docs)] // documentation missing in model
    UpdateExpiredPaymentMethod,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInvalidPaymentMethod,
    #[allow(missing_docs)] // documentation missing in model
    UpdateTaxExemptionCertificate,
    #[allow(missing_docs)] // documentation missing in model
    UpdateTaxRegistrationNumber,
    /// `Unknown` contains new variants that have been added since this code was generated.
    #[deprecated(note = "Don't directly match on `Unknown`. See the docs on this enum for the correct way to handle unknown variants.")]
    Unknown(crate::primitives::sealed_enum_unknown::UnknownVariantValue),
}
impl ::std::convert::From<&str> for ActionType {
    fn from(s: &str) -> Self {
        match s {
            "ADD_ALTERNATE_BILLING_CONTACT" => ActionType::AddAlternateBillingContact,
            "CREATE_ANOMALY_MONITOR" => ActionType::CreateAnomalyMonitor,
            "CREATE_BUDGET" => ActionType::CreateBudget,
            "ENABLE_COST_OPTIMIZATION_HUB" => ActionType::EnableCostOptimizationHub,
            "MIGRATE_TO_GRANULAR_PERMISSIONS" => ActionType::MigrateToGranularPermissions,
            "PAYMENTS_DUE" => ActionType::PaymentsDue,
            "PAYMENTS_PAST_DUE" => ActionType::PaymentsPastDue,
            "REVIEW_ANOMALIES" => ActionType::ReviewAnomalies,
            "REVIEW_BUDGETS_EXCEEDED" => ActionType::ReviewBudgetsExceeded,
            "REVIEW_BUDGET_ALERTS" => ActionType::ReviewBudgetAlerts,
            "REVIEW_EXPIRING_RI" => ActionType::ReviewExpiringRi,
            "REVIEW_EXPIRING_SP" => ActionType::ReviewExpiringSp,
            "REVIEW_FREETIER_CREDITS_REMAINING" => ActionType::ReviewFreetierCreditsRemaining,
            "REVIEW_FREETIER_DAYS_REMAINING" => ActionType::ReviewFreetierDaysRemaining,
            "REVIEW_FREETIER_USAGE_ALERTS" => ActionType::ReviewFreetierUsageAlerts,
            "REVIEW_SAVINGS_OPPORTUNITY_RECOMMENDATIONS" => ActionType::ReviewSavingsOpportunityRecommendations,
            "UPDATE_EXPIRED_PAYMENT_METHOD" => ActionType::UpdateExpiredPaymentMethod,
            "UPDATE_INVALID_PAYMENT_METHOD" => ActionType::UpdateInvalidPaymentMethod,
            "UPDATE_TAX_EXEMPTION_CERTIFICATE" => ActionType::UpdateTaxExemptionCertificate,
            "UPDATE_TAX_REGISTRATION_NUMBER" => ActionType::UpdateTaxRegistrationNumber,
            other => ActionType::Unknown(crate::primitives::sealed_enum_unknown::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl ::std::str::FromStr for ActionType {
    type Err = ::std::convert::Infallible;

    fn from_str(s: &str) -> ::std::result::Result<Self, <Self as ::std::str::FromStr>::Err> {
        ::std::result::Result::Ok(ActionType::from(s))
    }
}
impl ActionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ActionType::AddAlternateBillingContact => "ADD_ALTERNATE_BILLING_CONTACT",
            ActionType::CreateAnomalyMonitor => "CREATE_ANOMALY_MONITOR",
            ActionType::CreateBudget => "CREATE_BUDGET",
            ActionType::EnableCostOptimizationHub => "ENABLE_COST_OPTIMIZATION_HUB",
            ActionType::MigrateToGranularPermissions => "MIGRATE_TO_GRANULAR_PERMISSIONS",
            ActionType::PaymentsDue => "PAYMENTS_DUE",
            ActionType::PaymentsPastDue => "PAYMENTS_PAST_DUE",
            ActionType::ReviewAnomalies => "REVIEW_ANOMALIES",
            ActionType::ReviewBudgetsExceeded => "REVIEW_BUDGETS_EXCEEDED",
            ActionType::ReviewBudgetAlerts => "REVIEW_BUDGET_ALERTS",
            ActionType::ReviewExpiringRi => "REVIEW_EXPIRING_RI",
            ActionType::ReviewExpiringSp => "REVIEW_EXPIRING_SP",
            ActionType::ReviewFreetierCreditsRemaining => "REVIEW_FREETIER_CREDITS_REMAINING",
            ActionType::ReviewFreetierDaysRemaining => "REVIEW_FREETIER_DAYS_REMAINING",
            ActionType::ReviewFreetierUsageAlerts => "REVIEW_FREETIER_USAGE_ALERTS",
            ActionType::ReviewSavingsOpportunityRecommendations => "REVIEW_SAVINGS_OPPORTUNITY_RECOMMENDATIONS",
            ActionType::UpdateExpiredPaymentMethod => "UPDATE_EXPIRED_PAYMENT_METHOD",
            ActionType::UpdateInvalidPaymentMethod => "UPDATE_INVALID_PAYMENT_METHOD",
            ActionType::UpdateTaxExemptionCertificate => "UPDATE_TAX_EXEMPTION_CERTIFICATE",
            ActionType::UpdateTaxRegistrationNumber => "UPDATE_TAX_REGISTRATION_NUMBER",
            ActionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ADD_ALTERNATE_BILLING_CONTACT",
            "CREATE_ANOMALY_MONITOR",
            "CREATE_BUDGET",
            "ENABLE_COST_OPTIMIZATION_HUB",
            "MIGRATE_TO_GRANULAR_PERMISSIONS",
            "PAYMENTS_DUE",
            "PAYMENTS_PAST_DUE",
            "REVIEW_ANOMALIES",
            "REVIEW_BUDGETS_EXCEEDED",
            "REVIEW_BUDGET_ALERTS",
            "REVIEW_EXPIRING_RI",
            "REVIEW_EXPIRING_SP",
            "REVIEW_FREETIER_CREDITS_REMAINING",
            "REVIEW_FREETIER_DAYS_REMAINING",
            "REVIEW_FREETIER_USAGE_ALERTS",
            "REVIEW_SAVINGS_OPPORTUNITY_RECOMMENDATIONS",
            "UPDATE_EXPIRED_PAYMENT_METHOD",
            "UPDATE_INVALID_PAYMENT_METHOD",
            "UPDATE_TAX_EXEMPTION_CERTIFICATE",
            "UPDATE_TAX_REGISTRATION_NUMBER",
        ]
    }
}
impl ::std::convert::AsRef<str> for ActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl ActionType {
    /// Parses the enum value while disallowing unknown variants.
    ///
    /// Unknown variants will result in an error.
    pub fn try_parse(value: &str) -> ::std::result::Result<Self, crate::error::UnknownVariantError> {
        match Self::from(value) {
            #[allow(deprecated)]
            Self::Unknown(_) => ::std::result::Result::Err(crate::error::UnknownVariantError::new(value)),
            known => Ok(known),
        }
    }
}
impl ::std::fmt::Display for ActionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            ActionType::AddAlternateBillingContact => write!(f, "ADD_ALTERNATE_BILLING_CONTACT"),
            ActionType::CreateAnomalyMonitor => write!(f, "CREATE_ANOMALY_MONITOR"),
            ActionType::CreateBudget => write!(f, "CREATE_BUDGET"),
            ActionType::EnableCostOptimizationHub => write!(f, "ENABLE_COST_OPTIMIZATION_HUB"),
            ActionType::MigrateToGranularPermissions => write!(f, "MIGRATE_TO_GRANULAR_PERMISSIONS"),
            ActionType::PaymentsDue => write!(f, "PAYMENTS_DUE"),
            ActionType::PaymentsPastDue => write!(f, "PAYMENTS_PAST_DUE"),
            ActionType::ReviewAnomalies => write!(f, "REVIEW_ANOMALIES"),
            ActionType::ReviewBudgetsExceeded => write!(f, "REVIEW_BUDGETS_EXCEEDED"),
            ActionType::ReviewBudgetAlerts => write!(f, "REVIEW_BUDGET_ALERTS"),
            ActionType::ReviewExpiringRi => write!(f, "REVIEW_EXPIRING_RI"),
            ActionType::ReviewExpiringSp => write!(f, "REVIEW_EXPIRING_SP"),
            ActionType::ReviewFreetierCreditsRemaining => write!(f, "REVIEW_FREETIER_CREDITS_REMAINING"),
            ActionType::ReviewFreetierDaysRemaining => write!(f, "REVIEW_FREETIER_DAYS_REMAINING"),
            ActionType::ReviewFreetierUsageAlerts => write!(f, "REVIEW_FREETIER_USAGE_ALERTS"),
            ActionType::ReviewSavingsOpportunityRecommendations => write!(f, "REVIEW_SAVINGS_OPPORTUNITY_RECOMMENDATIONS"),
            ActionType::UpdateExpiredPaymentMethod => write!(f, "UPDATE_EXPIRED_PAYMENT_METHOD"),
            ActionType::UpdateInvalidPaymentMethod => write!(f, "UPDATE_INVALID_PAYMENT_METHOD"),
            ActionType::UpdateTaxExemptionCertificate => write!(f, "UPDATE_TAX_EXEMPTION_CERTIFICATE"),
            ActionType::UpdateTaxRegistrationNumber => write!(f, "UPDATE_TAX_REGISTRATION_NUMBER"),
            ActionType::Unknown(value) => write!(f, "{value}"),
        }
    }
}
