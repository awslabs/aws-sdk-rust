// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An Image Builder image. You must specify exactly one recipe for the image – either a container recipe (<code>containerRecipe</code>), which creates a container image, or an image recipe (<code>imageRecipe</code>), which creates an AMI.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Image {
    /// <p>The Amazon Resource Name (ARN) of the image.</p><note>
    /// <p>Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:</p>
    /// <ol>
    /// <li>
    /// <p>Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.</p></li>
    /// <li>
    /// <p>Version ARNs have only the first three nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch></patch>
    /// </minor>
    /// </major></p></li>
    /// <li>
    /// <p>Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.</p></li>
    /// </ol>
    /// </note>
    pub arn: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether this image produces an AMI or a container image.</p>
    pub r#type: ::std::option::Option<crate::types::ImageType>,
    /// <p>The name of the image.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The semantic version of the image.</p><note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p><b>Assignment:</b> For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node.</p>
    /// <p><b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.</p>
    /// <p><b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub version: ::std::option::Option<::std::string::String>,
    /// <p>The image operating system platform, such as Linux or Windows.</p>
    pub platform: ::std::option::Option<crate::types::Platform>,
    /// <p>Indicates whether Image Builder collects additional information about the image, such as the operating system (OS) version and package list.</p>
    pub enhanced_image_metadata_enabled: ::std::option::Option<bool>,
    /// <p>The operating system version for instances that launch from this image. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.</p>
    pub os_version: ::std::option::Option<::std::string::String>,
    /// <p>The state of the image.</p>
    pub state: ::std::option::Option<crate::types::ImageState>,
    /// <p>For images that distribute an AMI, this is the image recipe that Image Builder used to create the image. For container images, this is empty.</p>
    pub image_recipe: ::std::option::Option<crate::types::ImageRecipe>,
    /// <p>For container images, this is the container recipe that Image Builder used to create the image. For images that distribute an AMI, this is empty.</p>
    pub container_recipe: ::std::option::Option<crate::types::ContainerRecipe>,
    /// <p>The name of the image pipeline that created this image.</p>
    pub source_pipeline_name: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that created this image.</p>
    pub source_pipeline_arn: ::std::option::Option<::std::string::String>,
    /// <p>The infrastructure that Image Builder used to create this image.</p>
    pub infrastructure_configuration: ::std::option::Option<crate::types::InfrastructureConfiguration>,
    /// <p>The distribution configuration that Image Builder used to create this image.</p>
    pub distribution_configuration: ::std::option::Option<crate::types::DistributionConfiguration>,
    /// <p>The image tests that ran when that Image Builder created this image.</p>
    pub image_tests_configuration: ::std::option::Option<crate::types::ImageTestsConfiguration>,
    /// <p>The date on which Image Builder created this image.</p>
    pub date_created: ::std::option::Option<::std::string::String>,
    /// <p>The output resources that Image Builder produces for this image.</p>
    pub output_resources: ::std::option::Option<crate::types::OutputResources>,
    /// <p>The tags that apply to this image.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>Indicates the type of build that created this image. The build can be initiated in the following ways:</p>
    /// <ul>
    /// <li>
    /// <p><b>USER_INITIATED</b> – A manual pipeline build request.</p></li>
    /// <li>
    /// <p><b>SCHEDULED</b> – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.</p></li>
    /// <li>
    /// <p><b>IMPORT</b> – A VM import created the image to use as the base image for the recipe.</p></li>
    /// </ul>
    pub build_type: ::std::option::Option<crate::types::BuildType>,
    /// <p>The origin of the base image that Image Builder used to build this image.</p>
    pub image_source: ::std::option::Option<crate::types::ImageSource>,
    /// <p>Contains information about the current state of scans for this image.</p>
    pub scan_state: ::std::option::Option<crate::types::ImageScanState>,
    /// <p>Contains settings for vulnerability scans.</p>
    pub image_scanning_configuration: ::std::option::Option<crate::types::ImageScanningConfiguration>,
    /// <p>The time when deprecation occurs for an image resource. This can be a past or future date.</p>
    pub deprecation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Identifies the last runtime instance of the lifecycle policy to take action on the image.</p>
    pub lifecycle_execution_id: ::std::option::Option<::std::string::String>,
    /// <p>The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.</p>
    pub execution_role: ::std::option::Option<::std::string::String>,
    /// <p>Contains the build and test workflows that are associated with the image.</p>
    pub workflows: ::std::option::Option<::std::vec::Vec<crate::types::WorkflowConfiguration>>,
}
impl Image {
    /// <p>The Amazon Resource Name (ARN) of the image.</p><note>
    /// <p>Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:</p>
    /// <ol>
    /// <li>
    /// <p>Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.</p></li>
    /// <li>
    /// <p>Version ARNs have only the first three nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch></patch>
    /// </minor>
    /// </major></p></li>
    /// <li>
    /// <p>Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.</p></li>
    /// </ol>
    /// </note>
    pub fn arn(&self) -> ::std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Specifies whether this image produces an AMI or a container image.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::ImageType> {
        self.r#type.as_ref()
    }
    /// <p>The name of the image.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The semantic version of the image.</p><note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p><b>Assignment:</b> For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node.</p>
    /// <p><b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.</p>
    /// <p><b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn version(&self) -> ::std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>The image operating system platform, such as Linux or Windows.</p>
    pub fn platform(&self) -> ::std::option::Option<&crate::types::Platform> {
        self.platform.as_ref()
    }
    /// <p>Indicates whether Image Builder collects additional information about the image, such as the operating system (OS) version and package list.</p>
    pub fn enhanced_image_metadata_enabled(&self) -> ::std::option::Option<bool> {
        self.enhanced_image_metadata_enabled
    }
    /// <p>The operating system version for instances that launch from this image. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.</p>
    pub fn os_version(&self) -> ::std::option::Option<&str> {
        self.os_version.as_deref()
    }
    /// <p>The state of the image.</p>
    pub fn state(&self) -> ::std::option::Option<&crate::types::ImageState> {
        self.state.as_ref()
    }
    /// <p>For images that distribute an AMI, this is the image recipe that Image Builder used to create the image. For container images, this is empty.</p>
    pub fn image_recipe(&self) -> ::std::option::Option<&crate::types::ImageRecipe> {
        self.image_recipe.as_ref()
    }
    /// <p>For container images, this is the container recipe that Image Builder used to create the image. For images that distribute an AMI, this is empty.</p>
    pub fn container_recipe(&self) -> ::std::option::Option<&crate::types::ContainerRecipe> {
        self.container_recipe.as_ref()
    }
    /// <p>The name of the image pipeline that created this image.</p>
    pub fn source_pipeline_name(&self) -> ::std::option::Option<&str> {
        self.source_pipeline_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that created this image.</p>
    pub fn source_pipeline_arn(&self) -> ::std::option::Option<&str> {
        self.source_pipeline_arn.as_deref()
    }
    /// <p>The infrastructure that Image Builder used to create this image.</p>
    pub fn infrastructure_configuration(&self) -> ::std::option::Option<&crate::types::InfrastructureConfiguration> {
        self.infrastructure_configuration.as_ref()
    }
    /// <p>The distribution configuration that Image Builder used to create this image.</p>
    pub fn distribution_configuration(&self) -> ::std::option::Option<&crate::types::DistributionConfiguration> {
        self.distribution_configuration.as_ref()
    }
    /// <p>The image tests that ran when that Image Builder created this image.</p>
    pub fn image_tests_configuration(&self) -> ::std::option::Option<&crate::types::ImageTestsConfiguration> {
        self.image_tests_configuration.as_ref()
    }
    /// <p>The date on which Image Builder created this image.</p>
    pub fn date_created(&self) -> ::std::option::Option<&str> {
        self.date_created.as_deref()
    }
    /// <p>The output resources that Image Builder produces for this image.</p>
    pub fn output_resources(&self) -> ::std::option::Option<&crate::types::OutputResources> {
        self.output_resources.as_ref()
    }
    /// <p>The tags that apply to this image.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Indicates the type of build that created this image. The build can be initiated in the following ways:</p>
    /// <ul>
    /// <li>
    /// <p><b>USER_INITIATED</b> – A manual pipeline build request.</p></li>
    /// <li>
    /// <p><b>SCHEDULED</b> – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.</p></li>
    /// <li>
    /// <p><b>IMPORT</b> – A VM import created the image to use as the base image for the recipe.</p></li>
    /// </ul>
    pub fn build_type(&self) -> ::std::option::Option<&crate::types::BuildType> {
        self.build_type.as_ref()
    }
    /// <p>The origin of the base image that Image Builder used to build this image.</p>
    pub fn image_source(&self) -> ::std::option::Option<&crate::types::ImageSource> {
        self.image_source.as_ref()
    }
    /// <p>Contains information about the current state of scans for this image.</p>
    pub fn scan_state(&self) -> ::std::option::Option<&crate::types::ImageScanState> {
        self.scan_state.as_ref()
    }
    /// <p>Contains settings for vulnerability scans.</p>
    pub fn image_scanning_configuration(&self) -> ::std::option::Option<&crate::types::ImageScanningConfiguration> {
        self.image_scanning_configuration.as_ref()
    }
    /// <p>The time when deprecation occurs for an image resource. This can be a past or future date.</p>
    pub fn deprecation_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.deprecation_time.as_ref()
    }
    /// <p>Identifies the last runtime instance of the lifecycle policy to take action on the image.</p>
    pub fn lifecycle_execution_id(&self) -> ::std::option::Option<&str> {
        self.lifecycle_execution_id.as_deref()
    }
    /// <p>The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.</p>
    pub fn execution_role(&self) -> ::std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>Contains the build and test workflows that are associated with the image.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.workflows.is_none()`.
    pub fn workflows(&self) -> &[crate::types::WorkflowConfiguration] {
        self.workflows.as_deref().unwrap_or_default()
    }
}
impl Image {
    /// Creates a new builder-style object to manufacture [`Image`](crate::types::Image).
    pub fn builder() -> crate::types::builders::ImageBuilder {
        crate::types::builders::ImageBuilder::default()
    }
}

/// A builder for [`Image`](crate::types::Image).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ImageBuilder {
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) r#type: ::std::option::Option<crate::types::ImageType>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) version: ::std::option::Option<::std::string::String>,
    pub(crate) platform: ::std::option::Option<crate::types::Platform>,
    pub(crate) enhanced_image_metadata_enabled: ::std::option::Option<bool>,
    pub(crate) os_version: ::std::option::Option<::std::string::String>,
    pub(crate) state: ::std::option::Option<crate::types::ImageState>,
    pub(crate) image_recipe: ::std::option::Option<crate::types::ImageRecipe>,
    pub(crate) container_recipe: ::std::option::Option<crate::types::ContainerRecipe>,
    pub(crate) source_pipeline_name: ::std::option::Option<::std::string::String>,
    pub(crate) source_pipeline_arn: ::std::option::Option<::std::string::String>,
    pub(crate) infrastructure_configuration: ::std::option::Option<crate::types::InfrastructureConfiguration>,
    pub(crate) distribution_configuration: ::std::option::Option<crate::types::DistributionConfiguration>,
    pub(crate) image_tests_configuration: ::std::option::Option<crate::types::ImageTestsConfiguration>,
    pub(crate) date_created: ::std::option::Option<::std::string::String>,
    pub(crate) output_resources: ::std::option::Option<crate::types::OutputResources>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) build_type: ::std::option::Option<crate::types::BuildType>,
    pub(crate) image_source: ::std::option::Option<crate::types::ImageSource>,
    pub(crate) scan_state: ::std::option::Option<crate::types::ImageScanState>,
    pub(crate) image_scanning_configuration: ::std::option::Option<crate::types::ImageScanningConfiguration>,
    pub(crate) deprecation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) lifecycle_execution_id: ::std::option::Option<::std::string::String>,
    pub(crate) execution_role: ::std::option::Option<::std::string::String>,
    pub(crate) workflows: ::std::option::Option<::std::vec::Vec<crate::types::WorkflowConfiguration>>,
}
impl ImageBuilder {
    /// <p>The Amazon Resource Name (ARN) of the image.</p><note>
    /// <p>Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:</p>
    /// <ol>
    /// <li>
    /// <p>Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.</p></li>
    /// <li>
    /// <p>Version ARNs have only the first three nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch></patch>
    /// </minor>
    /// </major></p></li>
    /// <li>
    /// <p>Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.</p></li>
    /// </ol>
    /// </note>
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the image.</p><note>
    /// <p>Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:</p>
    /// <ol>
    /// <li>
    /// <p>Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.</p></li>
    /// <li>
    /// <p>Version ARNs have only the first three nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch></patch>
    /// </minor>
    /// </major></p></li>
    /// <li>
    /// <p>Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.</p></li>
    /// </ol>
    /// </note>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the image.</p><note>
    /// <p>Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:</p>
    /// <ol>
    /// <li>
    /// <p>Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.</p></li>
    /// <li>
    /// <p>Version ARNs have only the first three nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch></patch>
    /// </minor>
    /// </major></p></li>
    /// <li>
    /// <p>Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.</p></li>
    /// </ol>
    /// </note>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>Specifies whether this image produces an AMI or a container image.</p>
    pub fn r#type(mut self, input: crate::types::ImageType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether this image produces an AMI or a container image.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::ImageType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>Specifies whether this image produces an AMI or a container image.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::ImageType> {
        &self.r#type
    }
    /// <p>The name of the image.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the image.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the image.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The semantic version of the image.</p><note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p><b>Assignment:</b> For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node.</p>
    /// <p><b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.</p>
    /// <p><b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The semantic version of the image.</p><note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p><b>Assignment:</b> For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node.</p>
    /// <p><b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.</p>
    /// <p><b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn set_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.version = input;
        self
    }
    /// <p>The semantic version of the image.</p><note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p><b>Assignment:</b> For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node.</p>
    /// <p><b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.</p>
    /// <p><b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn get_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.version
    }
    /// <p>The image operating system platform, such as Linux or Windows.</p>
    pub fn platform(mut self, input: crate::types::Platform) -> Self {
        self.platform = ::std::option::Option::Some(input);
        self
    }
    /// <p>The image operating system platform, such as Linux or Windows.</p>
    pub fn set_platform(mut self, input: ::std::option::Option<crate::types::Platform>) -> Self {
        self.platform = input;
        self
    }
    /// <p>The image operating system platform, such as Linux or Windows.</p>
    pub fn get_platform(&self) -> &::std::option::Option<crate::types::Platform> {
        &self.platform
    }
    /// <p>Indicates whether Image Builder collects additional information about the image, such as the operating system (OS) version and package list.</p>
    pub fn enhanced_image_metadata_enabled(mut self, input: bool) -> Self {
        self.enhanced_image_metadata_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether Image Builder collects additional information about the image, such as the operating system (OS) version and package list.</p>
    pub fn set_enhanced_image_metadata_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.enhanced_image_metadata_enabled = input;
        self
    }
    /// <p>Indicates whether Image Builder collects additional information about the image, such as the operating system (OS) version and package list.</p>
    pub fn get_enhanced_image_metadata_enabled(&self) -> &::std::option::Option<bool> {
        &self.enhanced_image_metadata_enabled
    }
    /// <p>The operating system version for instances that launch from this image. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.</p>
    pub fn os_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.os_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The operating system version for instances that launch from this image. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.</p>
    pub fn set_os_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.os_version = input;
        self
    }
    /// <p>The operating system version for instances that launch from this image. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.</p>
    pub fn get_os_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.os_version
    }
    /// <p>The state of the image.</p>
    pub fn state(mut self, input: crate::types::ImageState) -> Self {
        self.state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The state of the image.</p>
    pub fn set_state(mut self, input: ::std::option::Option<crate::types::ImageState>) -> Self {
        self.state = input;
        self
    }
    /// <p>The state of the image.</p>
    pub fn get_state(&self) -> &::std::option::Option<crate::types::ImageState> {
        &self.state
    }
    /// <p>For images that distribute an AMI, this is the image recipe that Image Builder used to create the image. For container images, this is empty.</p>
    pub fn image_recipe(mut self, input: crate::types::ImageRecipe) -> Self {
        self.image_recipe = ::std::option::Option::Some(input);
        self
    }
    /// <p>For images that distribute an AMI, this is the image recipe that Image Builder used to create the image. For container images, this is empty.</p>
    pub fn set_image_recipe(mut self, input: ::std::option::Option<crate::types::ImageRecipe>) -> Self {
        self.image_recipe = input;
        self
    }
    /// <p>For images that distribute an AMI, this is the image recipe that Image Builder used to create the image. For container images, this is empty.</p>
    pub fn get_image_recipe(&self) -> &::std::option::Option<crate::types::ImageRecipe> {
        &self.image_recipe
    }
    /// <p>For container images, this is the container recipe that Image Builder used to create the image. For images that distribute an AMI, this is empty.</p>
    pub fn container_recipe(mut self, input: crate::types::ContainerRecipe) -> Self {
        self.container_recipe = ::std::option::Option::Some(input);
        self
    }
    /// <p>For container images, this is the container recipe that Image Builder used to create the image. For images that distribute an AMI, this is empty.</p>
    pub fn set_container_recipe(mut self, input: ::std::option::Option<crate::types::ContainerRecipe>) -> Self {
        self.container_recipe = input;
        self
    }
    /// <p>For container images, this is the container recipe that Image Builder used to create the image. For images that distribute an AMI, this is empty.</p>
    pub fn get_container_recipe(&self) -> &::std::option::Option<crate::types::ContainerRecipe> {
        &self.container_recipe
    }
    /// <p>The name of the image pipeline that created this image.</p>
    pub fn source_pipeline_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.source_pipeline_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the image pipeline that created this image.</p>
    pub fn set_source_pipeline_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.source_pipeline_name = input;
        self
    }
    /// <p>The name of the image pipeline that created this image.</p>
    pub fn get_source_pipeline_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.source_pipeline_name
    }
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that created this image.</p>
    pub fn source_pipeline_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.source_pipeline_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that created this image.</p>
    pub fn set_source_pipeline_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.source_pipeline_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that created this image.</p>
    pub fn get_source_pipeline_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.source_pipeline_arn
    }
    /// <p>The infrastructure that Image Builder used to create this image.</p>
    pub fn infrastructure_configuration(mut self, input: crate::types::InfrastructureConfiguration) -> Self {
        self.infrastructure_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The infrastructure that Image Builder used to create this image.</p>
    pub fn set_infrastructure_configuration(mut self, input: ::std::option::Option<crate::types::InfrastructureConfiguration>) -> Self {
        self.infrastructure_configuration = input;
        self
    }
    /// <p>The infrastructure that Image Builder used to create this image.</p>
    pub fn get_infrastructure_configuration(&self) -> &::std::option::Option<crate::types::InfrastructureConfiguration> {
        &self.infrastructure_configuration
    }
    /// <p>The distribution configuration that Image Builder used to create this image.</p>
    pub fn distribution_configuration(mut self, input: crate::types::DistributionConfiguration) -> Self {
        self.distribution_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The distribution configuration that Image Builder used to create this image.</p>
    pub fn set_distribution_configuration(mut self, input: ::std::option::Option<crate::types::DistributionConfiguration>) -> Self {
        self.distribution_configuration = input;
        self
    }
    /// <p>The distribution configuration that Image Builder used to create this image.</p>
    pub fn get_distribution_configuration(&self) -> &::std::option::Option<crate::types::DistributionConfiguration> {
        &self.distribution_configuration
    }
    /// <p>The image tests that ran when that Image Builder created this image.</p>
    pub fn image_tests_configuration(mut self, input: crate::types::ImageTestsConfiguration) -> Self {
        self.image_tests_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The image tests that ran when that Image Builder created this image.</p>
    pub fn set_image_tests_configuration(mut self, input: ::std::option::Option<crate::types::ImageTestsConfiguration>) -> Self {
        self.image_tests_configuration = input;
        self
    }
    /// <p>The image tests that ran when that Image Builder created this image.</p>
    pub fn get_image_tests_configuration(&self) -> &::std::option::Option<crate::types::ImageTestsConfiguration> {
        &self.image_tests_configuration
    }
    /// <p>The date on which Image Builder created this image.</p>
    pub fn date_created(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.date_created = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The date on which Image Builder created this image.</p>
    pub fn set_date_created(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.date_created = input;
        self
    }
    /// <p>The date on which Image Builder created this image.</p>
    pub fn get_date_created(&self) -> &::std::option::Option<::std::string::String> {
        &self.date_created
    }
    /// <p>The output resources that Image Builder produces for this image.</p>
    pub fn output_resources(mut self, input: crate::types::OutputResources) -> Self {
        self.output_resources = ::std::option::Option::Some(input);
        self
    }
    /// <p>The output resources that Image Builder produces for this image.</p>
    pub fn set_output_resources(mut self, input: ::std::option::Option<crate::types::OutputResources>) -> Self {
        self.output_resources = input;
        self
    }
    /// <p>The output resources that Image Builder produces for this image.</p>
    pub fn get_output_resources(&self) -> &::std::option::Option<crate::types::OutputResources> {
        &self.output_resources
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags that apply to this image.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The tags that apply to this image.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The tags that apply to this image.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>Indicates the type of build that created this image. The build can be initiated in the following ways:</p>
    /// <ul>
    /// <li>
    /// <p><b>USER_INITIATED</b> – A manual pipeline build request.</p></li>
    /// <li>
    /// <p><b>SCHEDULED</b> – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.</p></li>
    /// <li>
    /// <p><b>IMPORT</b> – A VM import created the image to use as the base image for the recipe.</p></li>
    /// </ul>
    pub fn build_type(mut self, input: crate::types::BuildType) -> Self {
        self.build_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the type of build that created this image. The build can be initiated in the following ways:</p>
    /// <ul>
    /// <li>
    /// <p><b>USER_INITIATED</b> – A manual pipeline build request.</p></li>
    /// <li>
    /// <p><b>SCHEDULED</b> – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.</p></li>
    /// <li>
    /// <p><b>IMPORT</b> – A VM import created the image to use as the base image for the recipe.</p></li>
    /// </ul>
    pub fn set_build_type(mut self, input: ::std::option::Option<crate::types::BuildType>) -> Self {
        self.build_type = input;
        self
    }
    /// <p>Indicates the type of build that created this image. The build can be initiated in the following ways:</p>
    /// <ul>
    /// <li>
    /// <p><b>USER_INITIATED</b> – A manual pipeline build request.</p></li>
    /// <li>
    /// <p><b>SCHEDULED</b> – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.</p></li>
    /// <li>
    /// <p><b>IMPORT</b> – A VM import created the image to use as the base image for the recipe.</p></li>
    /// </ul>
    pub fn get_build_type(&self) -> &::std::option::Option<crate::types::BuildType> {
        &self.build_type
    }
    /// <p>The origin of the base image that Image Builder used to build this image.</p>
    pub fn image_source(mut self, input: crate::types::ImageSource) -> Self {
        self.image_source = ::std::option::Option::Some(input);
        self
    }
    /// <p>The origin of the base image that Image Builder used to build this image.</p>
    pub fn set_image_source(mut self, input: ::std::option::Option<crate::types::ImageSource>) -> Self {
        self.image_source = input;
        self
    }
    /// <p>The origin of the base image that Image Builder used to build this image.</p>
    pub fn get_image_source(&self) -> &::std::option::Option<crate::types::ImageSource> {
        &self.image_source
    }
    /// <p>Contains information about the current state of scans for this image.</p>
    pub fn scan_state(mut self, input: crate::types::ImageScanState) -> Self {
        self.scan_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>Contains information about the current state of scans for this image.</p>
    pub fn set_scan_state(mut self, input: ::std::option::Option<crate::types::ImageScanState>) -> Self {
        self.scan_state = input;
        self
    }
    /// <p>Contains information about the current state of scans for this image.</p>
    pub fn get_scan_state(&self) -> &::std::option::Option<crate::types::ImageScanState> {
        &self.scan_state
    }
    /// <p>Contains settings for vulnerability scans.</p>
    pub fn image_scanning_configuration(mut self, input: crate::types::ImageScanningConfiguration) -> Self {
        self.image_scanning_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Contains settings for vulnerability scans.</p>
    pub fn set_image_scanning_configuration(mut self, input: ::std::option::Option<crate::types::ImageScanningConfiguration>) -> Self {
        self.image_scanning_configuration = input;
        self
    }
    /// <p>Contains settings for vulnerability scans.</p>
    pub fn get_image_scanning_configuration(&self) -> &::std::option::Option<crate::types::ImageScanningConfiguration> {
        &self.image_scanning_configuration
    }
    /// <p>The time when deprecation occurs for an image resource. This can be a past or future date.</p>
    pub fn deprecation_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.deprecation_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time when deprecation occurs for an image resource. This can be a past or future date.</p>
    pub fn set_deprecation_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.deprecation_time = input;
        self
    }
    /// <p>The time when deprecation occurs for an image resource. This can be a past or future date.</p>
    pub fn get_deprecation_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.deprecation_time
    }
    /// <p>Identifies the last runtime instance of the lifecycle policy to take action on the image.</p>
    pub fn lifecycle_execution_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.lifecycle_execution_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Identifies the last runtime instance of the lifecycle policy to take action on the image.</p>
    pub fn set_lifecycle_execution_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.lifecycle_execution_id = input;
        self
    }
    /// <p>Identifies the last runtime instance of the lifecycle policy to take action on the image.</p>
    pub fn get_lifecycle_execution_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.lifecycle_execution_id
    }
    /// <p>The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.</p>
    pub fn execution_role(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.execution_role = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.</p>
    pub fn set_execution_role(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.execution_role = input;
        self
    }
    /// <p>The name or Amazon Resource Name (ARN) for the IAM role you create that grants Image Builder access to perform workflow actions.</p>
    pub fn get_execution_role(&self) -> &::std::option::Option<::std::string::String> {
        &self.execution_role
    }
    /// Appends an item to `workflows`.
    ///
    /// To override the contents of this collection use [`set_workflows`](Self::set_workflows).
    ///
    /// <p>Contains the build and test workflows that are associated with the image.</p>
    pub fn workflows(mut self, input: crate::types::WorkflowConfiguration) -> Self {
        let mut v = self.workflows.unwrap_or_default();
        v.push(input);
        self.workflows = ::std::option::Option::Some(v);
        self
    }
    /// <p>Contains the build and test workflows that are associated with the image.</p>
    pub fn set_workflows(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::WorkflowConfiguration>>) -> Self {
        self.workflows = input;
        self
    }
    /// <p>Contains the build and test workflows that are associated with the image.</p>
    pub fn get_workflows(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::WorkflowConfiguration>> {
        &self.workflows
    }
    /// Consumes the builder and constructs a [`Image`](crate::types::Image).
    pub fn build(self) -> crate::types::Image {
        crate::types::Image {
            arn: self.arn,
            r#type: self.r#type,
            name: self.name,
            version: self.version,
            platform: self.platform,
            enhanced_image_metadata_enabled: self.enhanced_image_metadata_enabled,
            os_version: self.os_version,
            state: self.state,
            image_recipe: self.image_recipe,
            container_recipe: self.container_recipe,
            source_pipeline_name: self.source_pipeline_name,
            source_pipeline_arn: self.source_pipeline_arn,
            infrastructure_configuration: self.infrastructure_configuration,
            distribution_configuration: self.distribution_configuration,
            image_tests_configuration: self.image_tests_configuration,
            date_created: self.date_created,
            output_resources: self.output_resources,
            tags: self.tags,
            build_type: self.build_type,
            image_source: self.image_source,
            scan_state: self.scan_state,
            image_scanning_configuration: self.image_scanning_configuration,
            deprecation_time: self.deprecation_time,
            lifecycle_execution_id: self.lifecycle_execution_id,
            execution_role: self.execution_role,
            workflows: self.workflows,
        }
    }
}
