// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A container recipe.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContainerRecipe {
    /// <p>The Amazon Resource Name (ARN) of the container recipe.</p> <note>
    /// <p>Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:</p>
    /// <ol>
    /// <li> <p>Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.</p> </li>
    /// <li> <p>Version ARNs have only the first three nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch></patch>
    /// </minor>
    /// </major></p> </li>
    /// <li> <p>Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.</p> </li>
    /// </ol>
    /// </note>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Specifies the type of container, such as Docker.</p>
    #[doc(hidden)]
    pub container_type: std::option::Option<crate::types::ContainerType>,
    /// <p>The name of the container recipe.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the container recipe.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The system platform for the container, such as Windows or Linux.</p>
    #[doc(hidden)]
    pub platform: std::option::Option<crate::types::Platform>,
    /// <p>The owner of the container recipe.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The semantic version of the container recipe.</p> <note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p> <b>Assignment:</b> For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node.</p>
    /// <p> <b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.</p>
    /// <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
    /// <p>Build and test components that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.</p>
    #[doc(hidden)]
    pub components: std::option::Option<std::vec::Vec<crate::types::ComponentConfiguration>>,
    /// <p>A group of options that can be used to configure an instance for building and testing container images.</p>
    #[doc(hidden)]
    pub instance_configuration: std::option::Option<crate::types::InstanceConfiguration>,
    /// <p>Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.</p>
    #[doc(hidden)]
    pub dockerfile_template_data: std::option::Option<std::string::String>,
    /// <p>Identifies which KMS key is used to encrypt the container image for distribution to the target Region.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>A flag that indicates if the target container is encrypted.</p>
    #[doc(hidden)]
    pub encrypted: std::option::Option<bool>,
    /// <p>The base image for the container recipe.</p>
    #[doc(hidden)]
    pub parent_image: std::option::Option<std::string::String>,
    /// <p>The date when this container recipe was created.</p>
    #[doc(hidden)]
    pub date_created: std::option::Option<std::string::String>,
    /// <p>Tags that are attached to the container recipe.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The working directory for use during build and test workflows.</p>
    #[doc(hidden)]
    pub working_directory: std::option::Option<std::string::String>,
    /// <p>The destination repository for the container image.</p>
    #[doc(hidden)]
    pub target_repository: std::option::Option<crate::types::TargetContainerRepository>,
}
impl ContainerRecipe {
    /// <p>The Amazon Resource Name (ARN) of the container recipe.</p> <note>
    /// <p>Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:</p>
    /// <ol>
    /// <li> <p>Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.</p> </li>
    /// <li> <p>Version ARNs have only the first three nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch></patch>
    /// </minor>
    /// </major></p> </li>
    /// <li> <p>Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.</p> </li>
    /// </ol>
    /// </note>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Specifies the type of container, such as Docker.</p>
    pub fn container_type(&self) -> std::option::Option<&crate::types::ContainerType> {
        self.container_type.as_ref()
    }
    /// <p>The name of the container recipe.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the container recipe.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The system platform for the container, such as Windows or Linux.</p>
    pub fn platform(&self) -> std::option::Option<&crate::types::Platform> {
        self.platform.as_ref()
    }
    /// <p>The owner of the container recipe.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The semantic version of the container recipe.</p> <note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p> <b>Assignment:</b> For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node.</p>
    /// <p> <b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.</p>
    /// <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    /// <p>Build and test components that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.</p>
    pub fn components(&self) -> std::option::Option<&[crate::types::ComponentConfiguration]> {
        self.components.as_deref()
    }
    /// <p>A group of options that can be used to configure an instance for building and testing container images.</p>
    pub fn instance_configuration(
        &self,
    ) -> std::option::Option<&crate::types::InstanceConfiguration> {
        self.instance_configuration.as_ref()
    }
    /// <p>Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.</p>
    pub fn dockerfile_template_data(&self) -> std::option::Option<&str> {
        self.dockerfile_template_data.as_deref()
    }
    /// <p>Identifies which KMS key is used to encrypt the container image for distribution to the target Region.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>A flag that indicates if the target container is encrypted.</p>
    pub fn encrypted(&self) -> std::option::Option<bool> {
        self.encrypted
    }
    /// <p>The base image for the container recipe.</p>
    pub fn parent_image(&self) -> std::option::Option<&str> {
        self.parent_image.as_deref()
    }
    /// <p>The date when this container recipe was created.</p>
    pub fn date_created(&self) -> std::option::Option<&str> {
        self.date_created.as_deref()
    }
    /// <p>Tags that are attached to the container recipe.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The working directory for use during build and test workflows.</p>
    pub fn working_directory(&self) -> std::option::Option<&str> {
        self.working_directory.as_deref()
    }
    /// <p>The destination repository for the container image.</p>
    pub fn target_repository(
        &self,
    ) -> std::option::Option<&crate::types::TargetContainerRepository> {
        self.target_repository.as_ref()
    }
}
impl ContainerRecipe {
    /// Creates a new builder-style object to manufacture [`ContainerRecipe`](crate::types::ContainerRecipe).
    pub fn builder() -> crate::types::builders::ContainerRecipeBuilder {
        crate::types::builders::ContainerRecipeBuilder::default()
    }
}

/// A builder for [`ContainerRecipe`](crate::types::ContainerRecipe).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ContainerRecipeBuilder {
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) container_type: std::option::Option<crate::types::ContainerType>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) platform: std::option::Option<crate::types::Platform>,
    pub(crate) owner: std::option::Option<std::string::String>,
    pub(crate) version: std::option::Option<std::string::String>,
    pub(crate) components: std::option::Option<std::vec::Vec<crate::types::ComponentConfiguration>>,
    pub(crate) instance_configuration: std::option::Option<crate::types::InstanceConfiguration>,
    pub(crate) dockerfile_template_data: std::option::Option<std::string::String>,
    pub(crate) kms_key_id: std::option::Option<std::string::String>,
    pub(crate) encrypted: std::option::Option<bool>,
    pub(crate) parent_image: std::option::Option<std::string::String>,
    pub(crate) date_created: std::option::Option<std::string::String>,
    pub(crate) tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) working_directory: std::option::Option<std::string::String>,
    pub(crate) target_repository: std::option::Option<crate::types::TargetContainerRepository>,
}
impl ContainerRecipeBuilder {
    /// <p>The Amazon Resource Name (ARN) of the container recipe.</p> <note>
    /// <p>Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:</p>
    /// <ol>
    /// <li> <p>Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.</p> </li>
    /// <li> <p>Version ARNs have only the first three nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch></patch>
    /// </minor>
    /// </major></p> </li>
    /// <li> <p>Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.</p> </li>
    /// </ol>
    /// </note>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the container recipe.</p> <note>
    /// <p>Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:</p>
    /// <ol>
    /// <li> <p>Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.</p> </li>
    /// <li> <p>Version ARNs have only the first three nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch></patch>
    /// </minor>
    /// </major></p> </li>
    /// <li> <p>Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.</p> </li>
    /// </ol>
    /// </note>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>Specifies the type of container, such as Docker.</p>
    pub fn container_type(mut self, input: crate::types::ContainerType) -> Self {
        self.container_type = Some(input);
        self
    }
    /// <p>Specifies the type of container, such as Docker.</p>
    pub fn set_container_type(
        mut self,
        input: std::option::Option<crate::types::ContainerType>,
    ) -> Self {
        self.container_type = input;
        self
    }
    /// <p>The name of the container recipe.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the container recipe.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The description of the container recipe.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>The description of the container recipe.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The system platform for the container, such as Windows or Linux.</p>
    pub fn platform(mut self, input: crate::types::Platform) -> Self {
        self.platform = Some(input);
        self
    }
    /// <p>The system platform for the container, such as Windows or Linux.</p>
    pub fn set_platform(mut self, input: std::option::Option<crate::types::Platform>) -> Self {
        self.platform = input;
        self
    }
    /// <p>The owner of the container recipe.</p>
    pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
        self.owner = Some(input.into());
        self
    }
    /// <p>The owner of the container recipe.</p>
    pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.owner = input;
        self
    }
    /// <p>The semantic version of the container recipe.</p> <note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p> <b>Assignment:</b> For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node.</p>
    /// <p> <b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.</p>
    /// <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
        self.version = Some(input.into());
        self
    }
    /// <p>The semantic version of the container recipe.</p> <note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p> <b>Assignment:</b> For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node.</p>
    /// <p> <b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.</p>
    /// <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.version = input;
        self
    }
    /// Appends an item to `components`.
    ///
    /// To override the contents of this collection use [`set_components`](Self::set_components).
    ///
    /// <p>Build and test components that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.</p>
    pub fn components(mut self, input: crate::types::ComponentConfiguration) -> Self {
        let mut v = self.components.unwrap_or_default();
        v.push(input);
        self.components = Some(v);
        self
    }
    /// <p>Build and test components that are included in the container recipe. Recipes require a minimum of one build component, and can have a maximum of 20 build and test components in any combination.</p>
    pub fn set_components(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::ComponentConfiguration>>,
    ) -> Self {
        self.components = input;
        self
    }
    /// <p>A group of options that can be used to configure an instance for building and testing container images.</p>
    pub fn instance_configuration(mut self, input: crate::types::InstanceConfiguration) -> Self {
        self.instance_configuration = Some(input);
        self
    }
    /// <p>A group of options that can be used to configure an instance for building and testing container images.</p>
    pub fn set_instance_configuration(
        mut self,
        input: std::option::Option<crate::types::InstanceConfiguration>,
    ) -> Self {
        self.instance_configuration = input;
        self
    }
    /// <p>Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.</p>
    pub fn dockerfile_template_data(mut self, input: impl Into<std::string::String>) -> Self {
        self.dockerfile_template_data = Some(input.into());
        self
    }
    /// <p>Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.</p>
    pub fn set_dockerfile_template_data(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.dockerfile_template_data = input;
        self
    }
    /// <p>Identifies which KMS key is used to encrypt the container image for distribution to the target Region.</p>
    pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.kms_key_id = Some(input.into());
        self
    }
    /// <p>Identifies which KMS key is used to encrypt the container image for distribution to the target Region.</p>
    pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.kms_key_id = input;
        self
    }
    /// <p>A flag that indicates if the target container is encrypted.</p>
    pub fn encrypted(mut self, input: bool) -> Self {
        self.encrypted = Some(input);
        self
    }
    /// <p>A flag that indicates if the target container is encrypted.</p>
    pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
        self.encrypted = input;
        self
    }
    /// <p>The base image for the container recipe.</p>
    pub fn parent_image(mut self, input: impl Into<std::string::String>) -> Self {
        self.parent_image = Some(input.into());
        self
    }
    /// <p>The base image for the container recipe.</p>
    pub fn set_parent_image(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.parent_image = input;
        self
    }
    /// <p>The date when this container recipe was created.</p>
    pub fn date_created(mut self, input: impl Into<std::string::String>) -> Self {
        self.date_created = Some(input.into());
        self
    }
    /// <p>The date when this container recipe was created.</p>
    pub fn set_date_created(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.date_created = input;
        self
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Tags that are attached to the container recipe.</p>
    pub fn tags(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = Some(hash_map);
        self
    }
    /// <p>Tags that are attached to the container recipe.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.tags = input;
        self
    }
    /// <p>The working directory for use during build and test workflows.</p>
    pub fn working_directory(mut self, input: impl Into<std::string::String>) -> Self {
        self.working_directory = Some(input.into());
        self
    }
    /// <p>The working directory for use during build and test workflows.</p>
    pub fn set_working_directory(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.working_directory = input;
        self
    }
    /// <p>The destination repository for the container image.</p>
    pub fn target_repository(mut self, input: crate::types::TargetContainerRepository) -> Self {
        self.target_repository = Some(input);
        self
    }
    /// <p>The destination repository for the container image.</p>
    pub fn set_target_repository(
        mut self,
        input: std::option::Option<crate::types::TargetContainerRepository>,
    ) -> Self {
        self.target_repository = input;
        self
    }
    /// Consumes the builder and constructs a [`ContainerRecipe`](crate::types::ContainerRecipe).
    pub fn build(self) -> crate::types::ContainerRecipe {
        crate::types::ContainerRecipe {
            arn: self.arn,
            container_type: self.container_type,
            name: self.name,
            description: self.description,
            platform: self.platform,
            owner: self.owner,
            version: self.version,
            components: self.components,
            instance_configuration: self.instance_configuration,
            dockerfile_template_data: self.dockerfile_template_data,
            kms_key_id: self.kms_key_id,
            encrypted: self.encrypted,
            parent_image: self.parent_image,
            date_created: self.date_created,
            tags: self.tags,
            working_directory: self.working_directory,
            target_repository: self.target_repository,
        }
    }
}
