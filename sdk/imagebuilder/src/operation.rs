// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>CancelImageCreation cancels the creation of Image. This operation can only be used on
/// images in a non-terminal state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelImageCreation {
    _private: (),
}
impl CancelImageCreation {
    /// Creates a new builder-style object to manufacture [`CancelImageCreationInput`](crate::input::CancelImageCreationInput)
    pub fn builder() -> crate::input::cancel_image_creation_input::Builder {
        crate::input::cancel_image_creation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelImageCreation {
    type Output = std::result::Result<
        crate::output::CancelImageCreationOutput,
        crate::error::CancelImageCreationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_image_creation_error(response)
        } else {
            crate::operation_deser::parse_cancel_image_creation_response(response)
        }
    }
}

/// <p>Creates a new component that can be used to build, validate, test, and assess your
/// image.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateComponent {
    _private: (),
}
impl CreateComponent {
    /// Creates a new builder-style object to manufacture [`CreateComponentInput`](crate::input::CreateComponentInput)
    pub fn builder() -> crate::input::create_component_input::Builder {
        crate::input::create_component_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateComponent {
    type Output = std::result::Result<
        crate::output::CreateComponentOutput,
        crate::error::CreateComponentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_component_error(response)
        } else {
            crate::operation_deser::parse_create_component_response(response)
        }
    }
}

/// <p>Creates a new container recipe. Container recipes define how images are configured, tested, and assessed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateContainerRecipe {
    _private: (),
}
impl CreateContainerRecipe {
    /// Creates a new builder-style object to manufacture [`CreateContainerRecipeInput`](crate::input::CreateContainerRecipeInput)
    pub fn builder() -> crate::input::create_container_recipe_input::Builder {
        crate::input::create_container_recipe_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateContainerRecipe {
    type Output = std::result::Result<
        crate::output::CreateContainerRecipeOutput,
        crate::error::CreateContainerRecipeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_container_recipe_error(response)
        } else {
            crate::operation_deser::parse_create_container_recipe_response(response)
        }
    }
}

/// <p>Creates a new distribution configuration. Distribution configurations define and configure
/// the outputs of your pipeline.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDistributionConfiguration {
    _private: (),
}
impl CreateDistributionConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateDistributionConfigurationInput`](crate::input::CreateDistributionConfigurationInput)
    pub fn builder() -> crate::input::create_distribution_configuration_input::Builder {
        crate::input::create_distribution_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDistributionConfiguration {
    type Output = std::result::Result<
        crate::output::CreateDistributionConfigurationOutput,
        crate::error::CreateDistributionConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_distribution_configuration_error(response)
        } else {
            crate::operation_deser::parse_create_distribution_configuration_response(response)
        }
    }
}

/// <p> Creates a new image. This request will create a new image along with all of the
/// configured output resources defined in the distribution configuration. You must specify
/// exactly one recipe for your image, using either a ContainerRecipeArn or an ImageRecipeArn.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateImage {
    _private: (),
}
impl CreateImage {
    /// Creates a new builder-style object to manufacture [`CreateImageInput`](crate::input::CreateImageInput)
    pub fn builder() -> crate::input::create_image_input::Builder {
        crate::input::create_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateImage {
    type Output =
        std::result::Result<crate::output::CreateImageOutput, crate::error::CreateImageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_image_error(response)
        } else {
            crate::operation_deser::parse_create_image_response(response)
        }
    }
}

/// <p> Creates a new image pipeline. Image pipelines enable you to automate the creation and
/// distribution of images.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateImagePipeline {
    _private: (),
}
impl CreateImagePipeline {
    /// Creates a new builder-style object to manufacture [`CreateImagePipelineInput`](crate::input::CreateImagePipelineInput)
    pub fn builder() -> crate::input::create_image_pipeline_input::Builder {
        crate::input::create_image_pipeline_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateImagePipeline {
    type Output = std::result::Result<
        crate::output::CreateImagePipelineOutput,
        crate::error::CreateImagePipelineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_image_pipeline_error(response)
        } else {
            crate::operation_deser::parse_create_image_pipeline_response(response)
        }
    }
}

/// <p> Creates a new image recipe. Image recipes define how images are configured, tested, and
/// assessed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateImageRecipe {
    _private: (),
}
impl CreateImageRecipe {
    /// Creates a new builder-style object to manufacture [`CreateImageRecipeInput`](crate::input::CreateImageRecipeInput)
    pub fn builder() -> crate::input::create_image_recipe_input::Builder {
        crate::input::create_image_recipe_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateImageRecipe {
    type Output = std::result::Result<
        crate::output::CreateImageRecipeOutput,
        crate::error::CreateImageRecipeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_image_recipe_error(response)
        } else {
            crate::operation_deser::parse_create_image_recipe_response(response)
        }
    }
}

/// <p> Creates a new infrastructure configuration. An infrastructure configuration defines the
/// environment in which your image will be built and tested.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateInfrastructureConfiguration {
    _private: (),
}
impl CreateInfrastructureConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateInfrastructureConfigurationInput`](crate::input::CreateInfrastructureConfigurationInput)
    pub fn builder() -> crate::input::create_infrastructure_configuration_input::Builder {
        crate::input::create_infrastructure_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateInfrastructureConfiguration {
    type Output = std::result::Result<
        crate::output::CreateInfrastructureConfigurationOutput,
        crate::error::CreateInfrastructureConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_infrastructure_configuration_error(response)
        } else {
            crate::operation_deser::parse_create_infrastructure_configuration_response(response)
        }
    }
}

/// <p> Deletes a component build version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteComponent {
    _private: (),
}
impl DeleteComponent {
    /// Creates a new builder-style object to manufacture [`DeleteComponentInput`](crate::input::DeleteComponentInput)
    pub fn builder() -> crate::input::delete_component_input::Builder {
        crate::input::delete_component_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteComponent {
    type Output = std::result::Result<
        crate::output::DeleteComponentOutput,
        crate::error::DeleteComponentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_component_error(response)
        } else {
            crate::operation_deser::parse_delete_component_response(response)
        }
    }
}

/// <p>Deletes a container recipe.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteContainerRecipe {
    _private: (),
}
impl DeleteContainerRecipe {
    /// Creates a new builder-style object to manufacture [`DeleteContainerRecipeInput`](crate::input::DeleteContainerRecipeInput)
    pub fn builder() -> crate::input::delete_container_recipe_input::Builder {
        crate::input::delete_container_recipe_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteContainerRecipe {
    type Output = std::result::Result<
        crate::output::DeleteContainerRecipeOutput,
        crate::error::DeleteContainerRecipeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_container_recipe_error(response)
        } else {
            crate::operation_deser::parse_delete_container_recipe_response(response)
        }
    }
}

/// <p> Deletes a distribution configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDistributionConfiguration {
    _private: (),
}
impl DeleteDistributionConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteDistributionConfigurationInput`](crate::input::DeleteDistributionConfigurationInput)
    pub fn builder() -> crate::input::delete_distribution_configuration_input::Builder {
        crate::input::delete_distribution_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDistributionConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteDistributionConfigurationOutput,
        crate::error::DeleteDistributionConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_distribution_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_distribution_configuration_response(response)
        }
    }
}

/// <p>Deletes an Image Builder image resource. This does not delete any EC2 AMIs or ECR container images
/// that are created during the image build process. You must clean those up separately,
/// using the appropriate Amazon EC2 or Amazon ECR console actions, or API or CLI commands.</p>
/// <ul>
/// <li>
/// <p>To deregister an EC2 Linux AMI, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/deregister-ami.html">Deregister
/// your Linux AMI</a> in the <i>
/// <i>Amazon EC2 User Guide</i>
/// </i>.</p>
/// </li>
/// <li>
/// <p>To deregister an EC2 Windows AMI, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/deregister-ami.html">Deregister
/// your Windows AMI</a> in the <i>
/// <i>Amazon EC2 Windows Guide</i>
/// </i>.</p>
/// </li>
/// <li>
/// <p>To delete a container image from Amazon ECR, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.comAmazonECR/latest/userguide/delete_image.html">Deleting
/// an image</a> in the <i>Amazon ECR User Guide</i>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteImage {
    _private: (),
}
impl DeleteImage {
    /// Creates a new builder-style object to manufacture [`DeleteImageInput`](crate::input::DeleteImageInput)
    pub fn builder() -> crate::input::delete_image_input::Builder {
        crate::input::delete_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteImage {
    type Output =
        std::result::Result<crate::output::DeleteImageOutput, crate::error::DeleteImageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_image_error(response)
        } else {
            crate::operation_deser::parse_delete_image_response(response)
        }
    }
}

/// <p> Deletes an image pipeline.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteImagePipeline {
    _private: (),
}
impl DeleteImagePipeline {
    /// Creates a new builder-style object to manufacture [`DeleteImagePipelineInput`](crate::input::DeleteImagePipelineInput)
    pub fn builder() -> crate::input::delete_image_pipeline_input::Builder {
        crate::input::delete_image_pipeline_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteImagePipeline {
    type Output = std::result::Result<
        crate::output::DeleteImagePipelineOutput,
        crate::error::DeleteImagePipelineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_image_pipeline_error(response)
        } else {
            crate::operation_deser::parse_delete_image_pipeline_response(response)
        }
    }
}

/// <p> Deletes an image recipe.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteImageRecipe {
    _private: (),
}
impl DeleteImageRecipe {
    /// Creates a new builder-style object to manufacture [`DeleteImageRecipeInput`](crate::input::DeleteImageRecipeInput)
    pub fn builder() -> crate::input::delete_image_recipe_input::Builder {
        crate::input::delete_image_recipe_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteImageRecipe {
    type Output = std::result::Result<
        crate::output::DeleteImageRecipeOutput,
        crate::error::DeleteImageRecipeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_image_recipe_error(response)
        } else {
            crate::operation_deser::parse_delete_image_recipe_response(response)
        }
    }
}

/// <p> Deletes an infrastructure configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteInfrastructureConfiguration {
    _private: (),
}
impl DeleteInfrastructureConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteInfrastructureConfigurationInput`](crate::input::DeleteInfrastructureConfigurationInput)
    pub fn builder() -> crate::input::delete_infrastructure_configuration_input::Builder {
        crate::input::delete_infrastructure_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteInfrastructureConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteInfrastructureConfigurationOutput,
        crate::error::DeleteInfrastructureConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_infrastructure_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_infrastructure_configuration_response(response)
        }
    }
}

/// <p> Gets a component object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetComponent {
    _private: (),
}
impl GetComponent {
    /// Creates a new builder-style object to manufacture [`GetComponentInput`](crate::input::GetComponentInput)
    pub fn builder() -> crate::input::get_component_input::Builder {
        crate::input::get_component_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetComponent {
    type Output =
        std::result::Result<crate::output::GetComponentOutput, crate::error::GetComponentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_component_error(response)
        } else {
            crate::operation_deser::parse_get_component_response(response)
        }
    }
}

/// <p> Gets a component policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetComponentPolicy {
    _private: (),
}
impl GetComponentPolicy {
    /// Creates a new builder-style object to manufacture [`GetComponentPolicyInput`](crate::input::GetComponentPolicyInput)
    pub fn builder() -> crate::input::get_component_policy_input::Builder {
        crate::input::get_component_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetComponentPolicy {
    type Output = std::result::Result<
        crate::output::GetComponentPolicyOutput,
        crate::error::GetComponentPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_component_policy_error(response)
        } else {
            crate::operation_deser::parse_get_component_policy_response(response)
        }
    }
}

/// <p>Retrieves a container recipe.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContainerRecipe {
    _private: (),
}
impl GetContainerRecipe {
    /// Creates a new builder-style object to manufacture [`GetContainerRecipeInput`](crate::input::GetContainerRecipeInput)
    pub fn builder() -> crate::input::get_container_recipe_input::Builder {
        crate::input::get_container_recipe_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContainerRecipe {
    type Output = std::result::Result<
        crate::output::GetContainerRecipeOutput,
        crate::error::GetContainerRecipeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_container_recipe_error(response)
        } else {
            crate::operation_deser::parse_get_container_recipe_response(response)
        }
    }
}

/// <p>Retrieves the policy for a container recipe.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContainerRecipePolicy {
    _private: (),
}
impl GetContainerRecipePolicy {
    /// Creates a new builder-style object to manufacture [`GetContainerRecipePolicyInput`](crate::input::GetContainerRecipePolicyInput)
    pub fn builder() -> crate::input::get_container_recipe_policy_input::Builder {
        crate::input::get_container_recipe_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContainerRecipePolicy {
    type Output = std::result::Result<
        crate::output::GetContainerRecipePolicyOutput,
        crate::error::GetContainerRecipePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_container_recipe_policy_error(response)
        } else {
            crate::operation_deser::parse_get_container_recipe_policy_response(response)
        }
    }
}

/// <p> Gets a distribution configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDistributionConfiguration {
    _private: (),
}
impl GetDistributionConfiguration {
    /// Creates a new builder-style object to manufacture [`GetDistributionConfigurationInput`](crate::input::GetDistributionConfigurationInput)
    pub fn builder() -> crate::input::get_distribution_configuration_input::Builder {
        crate::input::get_distribution_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDistributionConfiguration {
    type Output = std::result::Result<
        crate::output::GetDistributionConfigurationOutput,
        crate::error::GetDistributionConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_distribution_configuration_error(response)
        } else {
            crate::operation_deser::parse_get_distribution_configuration_response(response)
        }
    }
}

/// <p> Gets an image.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetImage {
    _private: (),
}
impl GetImage {
    /// Creates a new builder-style object to manufacture [`GetImageInput`](crate::input::GetImageInput)
    pub fn builder() -> crate::input::get_image_input::Builder {
        crate::input::get_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetImage {
    type Output = std::result::Result<crate::output::GetImageOutput, crate::error::GetImageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_image_error(response)
        } else {
            crate::operation_deser::parse_get_image_response(response)
        }
    }
}

/// <p> Gets an image pipeline.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetImagePipeline {
    _private: (),
}
impl GetImagePipeline {
    /// Creates a new builder-style object to manufacture [`GetImagePipelineInput`](crate::input::GetImagePipelineInput)
    pub fn builder() -> crate::input::get_image_pipeline_input::Builder {
        crate::input::get_image_pipeline_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetImagePipeline {
    type Output = std::result::Result<
        crate::output::GetImagePipelineOutput,
        crate::error::GetImagePipelineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_image_pipeline_error(response)
        } else {
            crate::operation_deser::parse_get_image_pipeline_response(response)
        }
    }
}

/// <p> Gets an image policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetImagePolicy {
    _private: (),
}
impl GetImagePolicy {
    /// Creates a new builder-style object to manufacture [`GetImagePolicyInput`](crate::input::GetImagePolicyInput)
    pub fn builder() -> crate::input::get_image_policy_input::Builder {
        crate::input::get_image_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetImagePolicy {
    type Output =
        std::result::Result<crate::output::GetImagePolicyOutput, crate::error::GetImagePolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_image_policy_error(response)
        } else {
            crate::operation_deser::parse_get_image_policy_response(response)
        }
    }
}

/// <p> Gets an image recipe.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetImageRecipe {
    _private: (),
}
impl GetImageRecipe {
    /// Creates a new builder-style object to manufacture [`GetImageRecipeInput`](crate::input::GetImageRecipeInput)
    pub fn builder() -> crate::input::get_image_recipe_input::Builder {
        crate::input::get_image_recipe_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetImageRecipe {
    type Output =
        std::result::Result<crate::output::GetImageRecipeOutput, crate::error::GetImageRecipeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_image_recipe_error(response)
        } else {
            crate::operation_deser::parse_get_image_recipe_response(response)
        }
    }
}

/// <p> Gets an image recipe policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetImageRecipePolicy {
    _private: (),
}
impl GetImageRecipePolicy {
    /// Creates a new builder-style object to manufacture [`GetImageRecipePolicyInput`](crate::input::GetImageRecipePolicyInput)
    pub fn builder() -> crate::input::get_image_recipe_policy_input::Builder {
        crate::input::get_image_recipe_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetImageRecipePolicy {
    type Output = std::result::Result<
        crate::output::GetImageRecipePolicyOutput,
        crate::error::GetImageRecipePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_image_recipe_policy_error(response)
        } else {
            crate::operation_deser::parse_get_image_recipe_policy_response(response)
        }
    }
}

/// <p> Gets an infrastructure configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInfrastructureConfiguration {
    _private: (),
}
impl GetInfrastructureConfiguration {
    /// Creates a new builder-style object to manufacture [`GetInfrastructureConfigurationInput`](crate::input::GetInfrastructureConfigurationInput)
    pub fn builder() -> crate::input::get_infrastructure_configuration_input::Builder {
        crate::input::get_infrastructure_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInfrastructureConfiguration {
    type Output = std::result::Result<
        crate::output::GetInfrastructureConfigurationOutput,
        crate::error::GetInfrastructureConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_infrastructure_configuration_error(response)
        } else {
            crate::operation_deser::parse_get_infrastructure_configuration_response(response)
        }
    }
}

/// <p>Imports a component and transforms its data into a component document.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ImportComponent {
    _private: (),
}
impl ImportComponent {
    /// Creates a new builder-style object to manufacture [`ImportComponentInput`](crate::input::ImportComponentInput)
    pub fn builder() -> crate::input::import_component_input::Builder {
        crate::input::import_component_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ImportComponent {
    type Output = std::result::Result<
        crate::output::ImportComponentOutput,
        crate::error::ImportComponentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_import_component_error(response)
        } else {
            crate::operation_deser::parse_import_component_response(response)
        }
    }
}

/// <p> Returns the list of component build versions for the specified semantic version.</p>
/// <note>
/// <p>The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
/// You can assign values for the first three, and can filter on all of them.</p>
/// <p>
/// <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x)
/// to specify the most recent versions or nodes when selecting the base image or components for your
/// recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
/// wildcards.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListComponentBuildVersions {
    _private: (),
}
impl ListComponentBuildVersions {
    /// Creates a new builder-style object to manufacture [`ListComponentBuildVersionsInput`](crate::input::ListComponentBuildVersionsInput)
    pub fn builder() -> crate::input::list_component_build_versions_input::Builder {
        crate::input::list_component_build_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListComponentBuildVersions {
    type Output = std::result::Result<
        crate::output::ListComponentBuildVersionsOutput,
        crate::error::ListComponentBuildVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_component_build_versions_error(response)
        } else {
            crate::operation_deser::parse_list_component_build_versions_response(response)
        }
    }
}

/// <p>Returns the list of component build versions for the specified semantic version.</p>
/// <note>
/// <p>The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
/// You can assign values for the first three, and can filter on all of them.</p>
/// <p>
/// <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x)
/// to specify the most recent versions or nodes when selecting the base image or components for your
/// recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
/// wildcards.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListComponents {
    _private: (),
}
impl ListComponents {
    /// Creates a new builder-style object to manufacture [`ListComponentsInput`](crate::input::ListComponentsInput)
    pub fn builder() -> crate::input::list_components_input::Builder {
        crate::input::list_components_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListComponents {
    type Output =
        std::result::Result<crate::output::ListComponentsOutput, crate::error::ListComponentsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_components_error(response)
        } else {
            crate::operation_deser::parse_list_components_response(response)
        }
    }
}

/// <p>Returns a list of container recipes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListContainerRecipes {
    _private: (),
}
impl ListContainerRecipes {
    /// Creates a new builder-style object to manufacture [`ListContainerRecipesInput`](crate::input::ListContainerRecipesInput)
    pub fn builder() -> crate::input::list_container_recipes_input::Builder {
        crate::input::list_container_recipes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListContainerRecipes {
    type Output = std::result::Result<
        crate::output::ListContainerRecipesOutput,
        crate::error::ListContainerRecipesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_container_recipes_error(response)
        } else {
            crate::operation_deser::parse_list_container_recipes_response(response)
        }
    }
}

/// <p>Returns a list of distribution configurations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDistributionConfigurations {
    _private: (),
}
impl ListDistributionConfigurations {
    /// Creates a new builder-style object to manufacture [`ListDistributionConfigurationsInput`](crate::input::ListDistributionConfigurationsInput)
    pub fn builder() -> crate::input::list_distribution_configurations_input::Builder {
        crate::input::list_distribution_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDistributionConfigurations {
    type Output = std::result::Result<
        crate::output::ListDistributionConfigurationsOutput,
        crate::error::ListDistributionConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_distribution_configurations_error(response)
        } else {
            crate::operation_deser::parse_list_distribution_configurations_response(response)
        }
    }
}

/// <p> Returns a list of image build versions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImageBuildVersions {
    _private: (),
}
impl ListImageBuildVersions {
    /// Creates a new builder-style object to manufacture [`ListImageBuildVersionsInput`](crate::input::ListImageBuildVersionsInput)
    pub fn builder() -> crate::input::list_image_build_versions_input::Builder {
        crate::input::list_image_build_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImageBuildVersions {
    type Output = std::result::Result<
        crate::output::ListImageBuildVersionsOutput,
        crate::error::ListImageBuildVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_image_build_versions_error(response)
        } else {
            crate::operation_deser::parse_list_image_build_versions_response(response)
        }
    }
}

/// <p>List the Packages that are associated with an Image Build Version, as determined by Amazon Web Services Systems Manager Inventory at build time.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImagePackages {
    _private: (),
}
impl ListImagePackages {
    /// Creates a new builder-style object to manufacture [`ListImagePackagesInput`](crate::input::ListImagePackagesInput)
    pub fn builder() -> crate::input::list_image_packages_input::Builder {
        crate::input::list_image_packages_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImagePackages {
    type Output = std::result::Result<
        crate::output::ListImagePackagesOutput,
        crate::error::ListImagePackagesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_image_packages_error(response)
        } else {
            crate::operation_deser::parse_list_image_packages_response(response)
        }
    }
}

/// <p> Returns a list of images created by the specified pipeline.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImagePipelineImages {
    _private: (),
}
impl ListImagePipelineImages {
    /// Creates a new builder-style object to manufacture [`ListImagePipelineImagesInput`](crate::input::ListImagePipelineImagesInput)
    pub fn builder() -> crate::input::list_image_pipeline_images_input::Builder {
        crate::input::list_image_pipeline_images_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImagePipelineImages {
    type Output = std::result::Result<
        crate::output::ListImagePipelineImagesOutput,
        crate::error::ListImagePipelineImagesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_image_pipeline_images_error(response)
        } else {
            crate::operation_deser::parse_list_image_pipeline_images_response(response)
        }
    }
}

/// <p>Returns a list of image pipelines.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImagePipelines {
    _private: (),
}
impl ListImagePipelines {
    /// Creates a new builder-style object to manufacture [`ListImagePipelinesInput`](crate::input::ListImagePipelinesInput)
    pub fn builder() -> crate::input::list_image_pipelines_input::Builder {
        crate::input::list_image_pipelines_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImagePipelines {
    type Output = std::result::Result<
        crate::output::ListImagePipelinesOutput,
        crate::error::ListImagePipelinesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_image_pipelines_error(response)
        } else {
            crate::operation_deser::parse_list_image_pipelines_response(response)
        }
    }
}

/// <p> Returns a list of image recipes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImageRecipes {
    _private: (),
}
impl ListImageRecipes {
    /// Creates a new builder-style object to manufacture [`ListImageRecipesInput`](crate::input::ListImageRecipesInput)
    pub fn builder() -> crate::input::list_image_recipes_input::Builder {
        crate::input::list_image_recipes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImageRecipes {
    type Output = std::result::Result<
        crate::output::ListImageRecipesOutput,
        crate::error::ListImageRecipesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_image_recipes_error(response)
        } else {
            crate::operation_deser::parse_list_image_recipes_response(response)
        }
    }
}

/// <p> Returns the list of images that you have access to.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImages {
    _private: (),
}
impl ListImages {
    /// Creates a new builder-style object to manufacture [`ListImagesInput`](crate::input::ListImagesInput)
    pub fn builder() -> crate::input::list_images_input::Builder {
        crate::input::list_images_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImages {
    type Output =
        std::result::Result<crate::output::ListImagesOutput, crate::error::ListImagesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_images_error(response)
        } else {
            crate::operation_deser::parse_list_images_response(response)
        }
    }
}

/// <p> Returns a list of infrastructure configurations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListInfrastructureConfigurations {
    _private: (),
}
impl ListInfrastructureConfigurations {
    /// Creates a new builder-style object to manufacture [`ListInfrastructureConfigurationsInput`](crate::input::ListInfrastructureConfigurationsInput)
    pub fn builder() -> crate::input::list_infrastructure_configurations_input::Builder {
        crate::input::list_infrastructure_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListInfrastructureConfigurations {
    type Output = std::result::Result<
        crate::output::ListInfrastructureConfigurationsOutput,
        crate::error::ListInfrastructureConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_infrastructure_configurations_error(response)
        } else {
            crate::operation_deser::parse_list_infrastructure_configurations_response(response)
        }
    }
}

/// <p> Returns the list of tags for the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p> Applies a policy to a component. We recommend that you call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html">CreateResourceShare</a> to share resources. If you call the Image Builder API
/// <code>PutComponentPolicy</code>, you must also call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html">PromoteResourceShareCreatedFromPolicy</a> in order for the resource to be visible to
/// all principals with whom the resource is shared.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutComponentPolicy {
    _private: (),
}
impl PutComponentPolicy {
    /// Creates a new builder-style object to manufacture [`PutComponentPolicyInput`](crate::input::PutComponentPolicyInput)
    pub fn builder() -> crate::input::put_component_policy_input::Builder {
        crate::input::put_component_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutComponentPolicy {
    type Output = std::result::Result<
        crate::output::PutComponentPolicyOutput,
        crate::error::PutComponentPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_component_policy_error(response)
        } else {
            crate::operation_deser::parse_put_component_policy_response(response)
        }
    }
}

/// <p>Applies a policy to a container image. We recommend that you call the RAM API CreateResourceShare (https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html) to share resources. If you call the Image Builder API <code>PutContainerImagePolicy</code>, you must also call the RAM API PromoteResourceShareCreatedFromPolicy (https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html) in order for the resource to be visible to all principals with whom the resource is shared.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutContainerRecipePolicy {
    _private: (),
}
impl PutContainerRecipePolicy {
    /// Creates a new builder-style object to manufacture [`PutContainerRecipePolicyInput`](crate::input::PutContainerRecipePolicyInput)
    pub fn builder() -> crate::input::put_container_recipe_policy_input::Builder {
        crate::input::put_container_recipe_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutContainerRecipePolicy {
    type Output = std::result::Result<
        crate::output::PutContainerRecipePolicyOutput,
        crate::error::PutContainerRecipePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_container_recipe_policy_error(response)
        } else {
            crate::operation_deser::parse_put_container_recipe_policy_response(response)
        }
    }
}

/// <p>Applies a policy to an image. We recommend that you call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html">CreateResourceShare</a> to share resources. If you call the Image Builder API
/// <code>PutImagePolicy</code>, you must also call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html">PromoteResourceShareCreatedFromPolicy</a> in order for the resource to be visible to
/// all principals with whom the resource is shared.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutImagePolicy {
    _private: (),
}
impl PutImagePolicy {
    /// Creates a new builder-style object to manufacture [`PutImagePolicyInput`](crate::input::PutImagePolicyInput)
    pub fn builder() -> crate::input::put_image_policy_input::Builder {
        crate::input::put_image_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutImagePolicy {
    type Output =
        std::result::Result<crate::output::PutImagePolicyOutput, crate::error::PutImagePolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_image_policy_error(response)
        } else {
            crate::operation_deser::parse_put_image_policy_response(response)
        }
    }
}

/// <p> Applies a policy to an image recipe. We recommend that you call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html">CreateResourceShare</a> to share resources. If you call the Image Builder API
/// <code>PutImageRecipePolicy</code>, you must also call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html">PromoteResourceShareCreatedFromPolicy</a> in order for the resource to be visible to
/// all principals with whom the resource is shared.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutImageRecipePolicy {
    _private: (),
}
impl PutImageRecipePolicy {
    /// Creates a new builder-style object to manufacture [`PutImageRecipePolicyInput`](crate::input::PutImageRecipePolicyInput)
    pub fn builder() -> crate::input::put_image_recipe_policy_input::Builder {
        crate::input::put_image_recipe_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutImageRecipePolicy {
    type Output = std::result::Result<
        crate::output::PutImageRecipePolicyOutput,
        crate::error::PutImageRecipePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_image_recipe_policy_error(response)
        } else {
            crate::operation_deser::parse_put_image_recipe_policy_response(response)
        }
    }
}

/// <p> Manually triggers a pipeline to create an image.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartImagePipelineExecution {
    _private: (),
}
impl StartImagePipelineExecution {
    /// Creates a new builder-style object to manufacture [`StartImagePipelineExecutionInput`](crate::input::StartImagePipelineExecutionInput)
    pub fn builder() -> crate::input::start_image_pipeline_execution_input::Builder {
        crate::input::start_image_pipeline_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartImagePipelineExecution {
    type Output = std::result::Result<
        crate::output::StartImagePipelineExecutionOutput,
        crate::error::StartImagePipelineExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_image_pipeline_execution_error(response)
        } else {
            crate::operation_deser::parse_start_image_pipeline_execution_response(response)
        }
    }
}

/// <p> Adds a tag to a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p> Removes a tag from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p> Updates a new distribution configuration. Distribution configurations define and
/// configure the outputs of your pipeline.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDistributionConfiguration {
    _private: (),
}
impl UpdateDistributionConfiguration {
    /// Creates a new builder-style object to manufacture [`UpdateDistributionConfigurationInput`](crate::input::UpdateDistributionConfigurationInput)
    pub fn builder() -> crate::input::update_distribution_configuration_input::Builder {
        crate::input::update_distribution_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDistributionConfiguration {
    type Output = std::result::Result<
        crate::output::UpdateDistributionConfigurationOutput,
        crate::error::UpdateDistributionConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_distribution_configuration_error(response)
        } else {
            crate::operation_deser::parse_update_distribution_configuration_response(response)
        }
    }
}

/// <p> Updates an image pipeline. Image pipelines enable you to automate the creation and
/// distribution of images.</p>
/// <note>
/// <p>UpdateImagePipeline does not support selective updates for the pipeline.
/// You must specify all of the required properties in the update request, not just
/// the properties that have changed.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateImagePipeline {
    _private: (),
}
impl UpdateImagePipeline {
    /// Creates a new builder-style object to manufacture [`UpdateImagePipelineInput`](crate::input::UpdateImagePipelineInput)
    pub fn builder() -> crate::input::update_image_pipeline_input::Builder {
        crate::input::update_image_pipeline_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateImagePipeline {
    type Output = std::result::Result<
        crate::output::UpdateImagePipelineOutput,
        crate::error::UpdateImagePipelineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_image_pipeline_error(response)
        } else {
            crate::operation_deser::parse_update_image_pipeline_response(response)
        }
    }
}

/// <p> Updates a new infrastructure configuration. An infrastructure configuration defines the
/// environment in which your image will be built and tested.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateInfrastructureConfiguration {
    _private: (),
}
impl UpdateInfrastructureConfiguration {
    /// Creates a new builder-style object to manufacture [`UpdateInfrastructureConfigurationInput`](crate::input::UpdateInfrastructureConfigurationInput)
    pub fn builder() -> crate::input::update_infrastructure_configuration_input::Builder {
        crate::input::update_infrastructure_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateInfrastructureConfiguration {
    type Output = std::result::Result<
        crate::output::UpdateInfrastructureConfigurationOutput,
        crate::error::UpdateInfrastructureConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_infrastructure_configuration_error(response)
        } else {
            crate::operation_deser::parse_update_infrastructure_configuration_response(response)
        }
    }
}
