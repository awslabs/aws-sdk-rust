// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ListImageScanFindingAggregationsOutput {
    /// <p>The request ID that uniquely identifies this request.</p>
    pub request_id: ::std::option::Option<::std::string::String>,
    /// <p>The aggregation type specifies what type of key is used to group the image scan findings. Image Builder returns results based on the request filter. If you didn't specify a filter in the request, the type defaults to <code>accountId</code>.</p>
    /// <p class="title"> <b>Aggregation types</b> </p>
    /// <ul>
    /// <li> <p>accountId</p> </li>
    /// <li> <p>imageBuildVersionArn</p> </li>
    /// <li> <p>imagePipelineArn</p> </li>
    /// <li> <p>vulnerabilityId</p> </li>
    /// </ul>
    /// <p>Each aggregation includes counts by severity level for medium severity and higher level findings, plus a total for all of the findings for each key value.</p>
    pub aggregation_type: ::std::option::Option<::std::string::String>,
    /// <p>An array of image scan finding aggregations that match the filter criteria.</p>
    pub responses: ::std::option::Option<::std::vec::Vec<crate::types::ImageScanFindingAggregation>>,
    /// <p>The next token used for paginated responses. When this field isn't empty, there are additional elements that the service has'ot included in this request. Use this token with the next request to retrieve additional objects.</p>
    pub next_token: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl ListImageScanFindingAggregationsOutput {
    /// <p>The request ID that uniquely identifies this request.</p>
    pub fn request_id(&self) -> ::std::option::Option<&str> {
        self.request_id.as_deref()
    }
    /// <p>The aggregation type specifies what type of key is used to group the image scan findings. Image Builder returns results based on the request filter. If you didn't specify a filter in the request, the type defaults to <code>accountId</code>.</p>
    /// <p class="title"> <b>Aggregation types</b> </p>
    /// <ul>
    /// <li> <p>accountId</p> </li>
    /// <li> <p>imageBuildVersionArn</p> </li>
    /// <li> <p>imagePipelineArn</p> </li>
    /// <li> <p>vulnerabilityId</p> </li>
    /// </ul>
    /// <p>Each aggregation includes counts by severity level for medium severity and higher level findings, plus a total for all of the findings for each key value.</p>
    pub fn aggregation_type(&self) -> ::std::option::Option<&str> {
        self.aggregation_type.as_deref()
    }
    /// <p>An array of image scan finding aggregations that match the filter criteria.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.responses.is_none()`.
    pub fn responses(&self) -> &[crate::types::ImageScanFindingAggregation] {
        self.responses.as_deref().unwrap_or_default()
    }
    /// <p>The next token used for paginated responses. When this field isn't empty, there are additional elements that the service has'ot included in this request. Use this token with the next request to retrieve additional objects.</p>
    pub fn next_token(&self) -> ::std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ::aws_http::request_id::RequestId for ListImageScanFindingAggregationsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl ListImageScanFindingAggregationsOutput {
    /// Creates a new builder-style object to manufacture [`ListImageScanFindingAggregationsOutput`](crate::operation::list_image_scan_finding_aggregations::ListImageScanFindingAggregationsOutput).
    pub fn builder() -> crate::operation::list_image_scan_finding_aggregations::builders::ListImageScanFindingAggregationsOutputBuilder {
        crate::operation::list_image_scan_finding_aggregations::builders::ListImageScanFindingAggregationsOutputBuilder::default()
    }
}

/// A builder for [`ListImageScanFindingAggregationsOutput`](crate::operation::list_image_scan_finding_aggregations::ListImageScanFindingAggregationsOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ListImageScanFindingAggregationsOutputBuilder {
    pub(crate) request_id: ::std::option::Option<::std::string::String>,
    pub(crate) aggregation_type: ::std::option::Option<::std::string::String>,
    pub(crate) responses: ::std::option::Option<::std::vec::Vec<crate::types::ImageScanFindingAggregation>>,
    pub(crate) next_token: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl ListImageScanFindingAggregationsOutputBuilder {
    /// <p>The request ID that uniquely identifies this request.</p>
    pub fn request_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.request_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The request ID that uniquely identifies this request.</p>
    pub fn set_request_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.request_id = input;
        self
    }
    /// <p>The request ID that uniquely identifies this request.</p>
    pub fn get_request_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.request_id
    }
    /// <p>The aggregation type specifies what type of key is used to group the image scan findings. Image Builder returns results based on the request filter. If you didn't specify a filter in the request, the type defaults to <code>accountId</code>.</p>
    /// <p class="title"> <b>Aggregation types</b> </p>
    /// <ul>
    /// <li> <p>accountId</p> </li>
    /// <li> <p>imageBuildVersionArn</p> </li>
    /// <li> <p>imagePipelineArn</p> </li>
    /// <li> <p>vulnerabilityId</p> </li>
    /// </ul>
    /// <p>Each aggregation includes counts by severity level for medium severity and higher level findings, plus a total for all of the findings for each key value.</p>
    pub fn aggregation_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.aggregation_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The aggregation type specifies what type of key is used to group the image scan findings. Image Builder returns results based on the request filter. If you didn't specify a filter in the request, the type defaults to <code>accountId</code>.</p>
    /// <p class="title"> <b>Aggregation types</b> </p>
    /// <ul>
    /// <li> <p>accountId</p> </li>
    /// <li> <p>imageBuildVersionArn</p> </li>
    /// <li> <p>imagePipelineArn</p> </li>
    /// <li> <p>vulnerabilityId</p> </li>
    /// </ul>
    /// <p>Each aggregation includes counts by severity level for medium severity and higher level findings, plus a total for all of the findings for each key value.</p>
    pub fn set_aggregation_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.aggregation_type = input;
        self
    }
    /// <p>The aggregation type specifies what type of key is used to group the image scan findings. Image Builder returns results based on the request filter. If you didn't specify a filter in the request, the type defaults to <code>accountId</code>.</p>
    /// <p class="title"> <b>Aggregation types</b> </p>
    /// <ul>
    /// <li> <p>accountId</p> </li>
    /// <li> <p>imageBuildVersionArn</p> </li>
    /// <li> <p>imagePipelineArn</p> </li>
    /// <li> <p>vulnerabilityId</p> </li>
    /// </ul>
    /// <p>Each aggregation includes counts by severity level for medium severity and higher level findings, plus a total for all of the findings for each key value.</p>
    pub fn get_aggregation_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.aggregation_type
    }
    /// Appends an item to `responses`.
    ///
    /// To override the contents of this collection use [`set_responses`](Self::set_responses).
    ///
    /// <p>An array of image scan finding aggregations that match the filter criteria.</p>
    pub fn responses(mut self, input: crate::types::ImageScanFindingAggregation) -> Self {
        let mut v = self.responses.unwrap_or_default();
        v.push(input);
        self.responses = ::std::option::Option::Some(v);
        self
    }
    /// <p>An array of image scan finding aggregations that match the filter criteria.</p>
    pub fn set_responses(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ImageScanFindingAggregation>>) -> Self {
        self.responses = input;
        self
    }
    /// <p>An array of image scan finding aggregations that match the filter criteria.</p>
    pub fn get_responses(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ImageScanFindingAggregation>> {
        &self.responses
    }
    /// <p>The next token used for paginated responses. When this field isn't empty, there are additional elements that the service has'ot included in this request. Use this token with the next request to retrieve additional objects.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The next token used for paginated responses. When this field isn't empty, there are additional elements that the service has'ot included in this request. Use this token with the next request to retrieve additional objects.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_token = input;
        self
    }
    /// <p>The next token used for paginated responses. When this field isn't empty, there are additional elements that the service has'ot included in this request. Use this token with the next request to retrieve additional objects.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_token
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`ListImageScanFindingAggregationsOutput`](crate::operation::list_image_scan_finding_aggregations::ListImageScanFindingAggregationsOutput).
    pub fn build(self) -> crate::operation::list_image_scan_finding_aggregations::ListImageScanFindingAggregationsOutput {
        crate::operation::list_image_scan_finding_aggregations::ListImageScanFindingAggregationsOutput {
            request_id: self.request_id,
            aggregation_type: self.aggregation_type,
            responses: self.responses,
            next_token: self.next_token,
            _request_id: self._request_id,
        }
    }
}
