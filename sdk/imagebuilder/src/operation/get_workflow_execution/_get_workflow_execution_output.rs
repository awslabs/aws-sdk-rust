// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GetWorkflowExecutionOutput {
    /// <p>The request ID that uniquely identifies this request.</p>
    pub request_id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource that defines the specified runtime instance of the workflow.</p>
    pub workflow_build_version_arn: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.</p>
    pub workflow_execution_id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the image resource build version that the specified runtime instance of the workflow created.</p>
    pub image_build_version_arn: ::std::option::Option<::std::string::String>,
    /// <p>The type of workflow that Image Builder ran for the specified runtime instance of the workflow.</p>
    pub r#type: ::std::option::Option<crate::types::WorkflowType>,
    /// <p>The current runtime status for the specified runtime instance of the workflow.</p>
    pub status: ::std::option::Option<crate::types::WorkflowExecutionStatus>,
    /// <p>The output message from the specified runtime instance of the workflow, if applicable.</p>
    pub message: ::std::option::Option<::std::string::String>,
    /// <p>The total number of steps in the specified runtime instance of the workflow that ran. This number should equal the sum of the step counts for steps that succeeded, were skipped, and failed.</p>
    pub total_step_count: i32,
    /// <p>A runtime count for the number of steps that ran successfully in the specified runtime instance of the workflow.</p>
    pub total_steps_succeeded: i32,
    /// <p>A runtime count for the number of steps that failed in the specified runtime instance of the workflow.</p>
    pub total_steps_failed: i32,
    /// <p>A runtime count for the number of steps that were skipped in the specified runtime instance of the workflow.</p>
    pub total_steps_skipped: i32,
    /// <p>The timestamp when the specified runtime instance of the workflow started.</p>
    pub start_time: ::std::option::Option<::std::string::String>,
    /// <p>The timestamp when the specified runtime instance of the workflow finished.</p>
    pub end_time: ::std::option::Option<::std::string::String>,
    /// <p>Test workflows are defined within named runtime groups. The parallel group is a named group that contains one or more test workflows.</p>
    pub parallel_group: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl GetWorkflowExecutionOutput {
    /// <p>The request ID that uniquely identifies this request.</p>
    pub fn request_id(&self) -> ::std::option::Option<&str> {
        self.request_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource that defines the specified runtime instance of the workflow.</p>
    pub fn workflow_build_version_arn(&self) -> ::std::option::Option<&str> {
        self.workflow_build_version_arn.as_deref()
    }
    /// <p>The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.</p>
    pub fn workflow_execution_id(&self) -> ::std::option::Option<&str> {
        self.workflow_execution_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the image resource build version that the specified runtime instance of the workflow created.</p>
    pub fn image_build_version_arn(&self) -> ::std::option::Option<&str> {
        self.image_build_version_arn.as_deref()
    }
    /// <p>The type of workflow that Image Builder ran for the specified runtime instance of the workflow.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::WorkflowType> {
        self.r#type.as_ref()
    }
    /// <p>The current runtime status for the specified runtime instance of the workflow.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::WorkflowExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>The output message from the specified runtime instance of the workflow, if applicable.</p>
    pub fn message(&self) -> ::std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The total number of steps in the specified runtime instance of the workflow that ran. This number should equal the sum of the step counts for steps that succeeded, were skipped, and failed.</p>
    pub fn total_step_count(&self) -> i32 {
        self.total_step_count
    }
    /// <p>A runtime count for the number of steps that ran successfully in the specified runtime instance of the workflow.</p>
    pub fn total_steps_succeeded(&self) -> i32 {
        self.total_steps_succeeded
    }
    /// <p>A runtime count for the number of steps that failed in the specified runtime instance of the workflow.</p>
    pub fn total_steps_failed(&self) -> i32 {
        self.total_steps_failed
    }
    /// <p>A runtime count for the number of steps that were skipped in the specified runtime instance of the workflow.</p>
    pub fn total_steps_skipped(&self) -> i32 {
        self.total_steps_skipped
    }
    /// <p>The timestamp when the specified runtime instance of the workflow started.</p>
    pub fn start_time(&self) -> ::std::option::Option<&str> {
        self.start_time.as_deref()
    }
    /// <p>The timestamp when the specified runtime instance of the workflow finished.</p>
    pub fn end_time(&self) -> ::std::option::Option<&str> {
        self.end_time.as_deref()
    }
    /// <p>Test workflows are defined within named runtime groups. The parallel group is a named group that contains one or more test workflows.</p>
    pub fn parallel_group(&self) -> ::std::option::Option<&str> {
        self.parallel_group.as_deref()
    }
}
impl ::aws_types::request_id::RequestId for GetWorkflowExecutionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl GetWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`GetWorkflowExecutionOutput`](crate::operation::get_workflow_execution::GetWorkflowExecutionOutput).
    pub fn builder() -> crate::operation::get_workflow_execution::builders::GetWorkflowExecutionOutputBuilder {
        crate::operation::get_workflow_execution::builders::GetWorkflowExecutionOutputBuilder::default()
    }
}

/// A builder for [`GetWorkflowExecutionOutput`](crate::operation::get_workflow_execution::GetWorkflowExecutionOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct GetWorkflowExecutionOutputBuilder {
    pub(crate) request_id: ::std::option::Option<::std::string::String>,
    pub(crate) workflow_build_version_arn: ::std::option::Option<::std::string::String>,
    pub(crate) workflow_execution_id: ::std::option::Option<::std::string::String>,
    pub(crate) image_build_version_arn: ::std::option::Option<::std::string::String>,
    pub(crate) r#type: ::std::option::Option<crate::types::WorkflowType>,
    pub(crate) status: ::std::option::Option<crate::types::WorkflowExecutionStatus>,
    pub(crate) message: ::std::option::Option<::std::string::String>,
    pub(crate) total_step_count: ::std::option::Option<i32>,
    pub(crate) total_steps_succeeded: ::std::option::Option<i32>,
    pub(crate) total_steps_failed: ::std::option::Option<i32>,
    pub(crate) total_steps_skipped: ::std::option::Option<i32>,
    pub(crate) start_time: ::std::option::Option<::std::string::String>,
    pub(crate) end_time: ::std::option::Option<::std::string::String>,
    pub(crate) parallel_group: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl GetWorkflowExecutionOutputBuilder {
    /// <p>The request ID that uniquely identifies this request.</p>
    pub fn request_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.request_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The request ID that uniquely identifies this request.</p>
    pub fn set_request_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.request_id = input;
        self
    }
    /// <p>The request ID that uniquely identifies this request.</p>
    pub fn get_request_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.request_id
    }
    /// <p>The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource that defines the specified runtime instance of the workflow.</p>
    pub fn workflow_build_version_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.workflow_build_version_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource that defines the specified runtime instance of the workflow.</p>
    pub fn set_workflow_build_version_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.workflow_build_version_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the build version for the Image Builder workflow resource that defines the specified runtime instance of the workflow.</p>
    pub fn get_workflow_build_version_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.workflow_build_version_arn
    }
    /// <p>The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.</p>
    pub fn workflow_execution_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.workflow_execution_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.</p>
    pub fn set_workflow_execution_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.workflow_execution_id = input;
        self
    }
    /// <p>The unique identifier that Image Builder assigned to keep track of runtime details when it ran the workflow.</p>
    pub fn get_workflow_execution_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.workflow_execution_id
    }
    /// <p>The Amazon Resource Name (ARN) of the image resource build version that the specified runtime instance of the workflow created.</p>
    pub fn image_build_version_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.image_build_version_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the image resource build version that the specified runtime instance of the workflow created.</p>
    pub fn set_image_build_version_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.image_build_version_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the image resource build version that the specified runtime instance of the workflow created.</p>
    pub fn get_image_build_version_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.image_build_version_arn
    }
    /// <p>The type of workflow that Image Builder ran for the specified runtime instance of the workflow.</p>
    pub fn r#type(mut self, input: crate::types::WorkflowType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of workflow that Image Builder ran for the specified runtime instance of the workflow.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::WorkflowType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The type of workflow that Image Builder ran for the specified runtime instance of the workflow.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::WorkflowType> {
        &self.r#type
    }
    /// <p>The current runtime status for the specified runtime instance of the workflow.</p>
    pub fn status(mut self, input: crate::types::WorkflowExecutionStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current runtime status for the specified runtime instance of the workflow.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::WorkflowExecutionStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The current runtime status for the specified runtime instance of the workflow.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::WorkflowExecutionStatus> {
        &self.status
    }
    /// <p>The output message from the specified runtime instance of the workflow, if applicable.</p>
    pub fn message(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.message = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The output message from the specified runtime instance of the workflow, if applicable.</p>
    pub fn set_message(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.message = input;
        self
    }
    /// <p>The output message from the specified runtime instance of the workflow, if applicable.</p>
    pub fn get_message(&self) -> &::std::option::Option<::std::string::String> {
        &self.message
    }
    /// <p>The total number of steps in the specified runtime instance of the workflow that ran. This number should equal the sum of the step counts for steps that succeeded, were skipped, and failed.</p>
    pub fn total_step_count(mut self, input: i32) -> Self {
        self.total_step_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of steps in the specified runtime instance of the workflow that ran. This number should equal the sum of the step counts for steps that succeeded, were skipped, and failed.</p>
    pub fn set_total_step_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_step_count = input;
        self
    }
    /// <p>The total number of steps in the specified runtime instance of the workflow that ran. This number should equal the sum of the step counts for steps that succeeded, were skipped, and failed.</p>
    pub fn get_total_step_count(&self) -> &::std::option::Option<i32> {
        &self.total_step_count
    }
    /// <p>A runtime count for the number of steps that ran successfully in the specified runtime instance of the workflow.</p>
    pub fn total_steps_succeeded(mut self, input: i32) -> Self {
        self.total_steps_succeeded = ::std::option::Option::Some(input);
        self
    }
    /// <p>A runtime count for the number of steps that ran successfully in the specified runtime instance of the workflow.</p>
    pub fn set_total_steps_succeeded(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_steps_succeeded = input;
        self
    }
    /// <p>A runtime count for the number of steps that ran successfully in the specified runtime instance of the workflow.</p>
    pub fn get_total_steps_succeeded(&self) -> &::std::option::Option<i32> {
        &self.total_steps_succeeded
    }
    /// <p>A runtime count for the number of steps that failed in the specified runtime instance of the workflow.</p>
    pub fn total_steps_failed(mut self, input: i32) -> Self {
        self.total_steps_failed = ::std::option::Option::Some(input);
        self
    }
    /// <p>A runtime count for the number of steps that failed in the specified runtime instance of the workflow.</p>
    pub fn set_total_steps_failed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_steps_failed = input;
        self
    }
    /// <p>A runtime count for the number of steps that failed in the specified runtime instance of the workflow.</p>
    pub fn get_total_steps_failed(&self) -> &::std::option::Option<i32> {
        &self.total_steps_failed
    }
    /// <p>A runtime count for the number of steps that were skipped in the specified runtime instance of the workflow.</p>
    pub fn total_steps_skipped(mut self, input: i32) -> Self {
        self.total_steps_skipped = ::std::option::Option::Some(input);
        self
    }
    /// <p>A runtime count for the number of steps that were skipped in the specified runtime instance of the workflow.</p>
    pub fn set_total_steps_skipped(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_steps_skipped = input;
        self
    }
    /// <p>A runtime count for the number of steps that were skipped in the specified runtime instance of the workflow.</p>
    pub fn get_total_steps_skipped(&self) -> &::std::option::Option<i32> {
        &self.total_steps_skipped
    }
    /// <p>The timestamp when the specified runtime instance of the workflow started.</p>
    pub fn start_time(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.start_time = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The timestamp when the specified runtime instance of the workflow started.</p>
    pub fn set_start_time(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.start_time = input;
        self
    }
    /// <p>The timestamp when the specified runtime instance of the workflow started.</p>
    pub fn get_start_time(&self) -> &::std::option::Option<::std::string::String> {
        &self.start_time
    }
    /// <p>The timestamp when the specified runtime instance of the workflow finished.</p>
    pub fn end_time(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.end_time = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The timestamp when the specified runtime instance of the workflow finished.</p>
    pub fn set_end_time(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.end_time = input;
        self
    }
    /// <p>The timestamp when the specified runtime instance of the workflow finished.</p>
    pub fn get_end_time(&self) -> &::std::option::Option<::std::string::String> {
        &self.end_time
    }
    /// <p>Test workflows are defined within named runtime groups. The parallel group is a named group that contains one or more test workflows.</p>
    pub fn parallel_group(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.parallel_group = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Test workflows are defined within named runtime groups. The parallel group is a named group that contains one or more test workflows.</p>
    pub fn set_parallel_group(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.parallel_group = input;
        self
    }
    /// <p>Test workflows are defined within named runtime groups. The parallel group is a named group that contains one or more test workflows.</p>
    pub fn get_parallel_group(&self) -> &::std::option::Option<::std::string::String> {
        &self.parallel_group
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`GetWorkflowExecutionOutput`](crate::operation::get_workflow_execution::GetWorkflowExecutionOutput).
    pub fn build(self) -> crate::operation::get_workflow_execution::GetWorkflowExecutionOutput {
        crate::operation::get_workflow_execution::GetWorkflowExecutionOutput {
            request_id: self.request_id,
            workflow_build_version_arn: self.workflow_build_version_arn,
            workflow_execution_id: self.workflow_execution_id,
            image_build_version_arn: self.image_build_version_arn,
            r#type: self.r#type,
            status: self.status,
            message: self.message,
            total_step_count: self.total_step_count.unwrap_or_default(),
            total_steps_succeeded: self.total_steps_succeeded.unwrap_or_default(),
            total_steps_failed: self.total_steps_failed.unwrap_or_default(),
            total_steps_skipped: self.total_steps_skipped.unwrap_or_default(),
            start_time: self.start_time,
            end_time: self.end_time,
            parallel_group: self.parallel_group,
            _request_id: self._request_id,
        }
    }
}
