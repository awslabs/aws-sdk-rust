// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportComponentInput {
    /// <p> The name of the component.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The semantic version of the component. This version follows the semantic version syntax.</p> <note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    #[doc(hidden)]
    pub semantic_version: std::option::Option<std::string::String>,
    /// <p>The description of the component. Describes the contents of the component.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.</p>
    #[doc(hidden)]
    pub change_description: std::option::Option<std::string::String>,
    /// <p>The type of the component denotes whether the component is used to build the image, or only to test it.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::types::ComponentType>,
    /// <p>The format of the resource that you want to import as a component.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::types::ComponentFormat>,
    /// <p>The platform of the component.</p>
    #[doc(hidden)]
    pub platform: std::option::Option<crate::types::Platform>,
    /// <p>The data of the component. Used to specify the data inline. Either <code>data</code> or <code>uri</code> can be used to specify the data within the component.</p>
    #[doc(hidden)]
    pub data: std::option::Option<std::string::String>,
    /// <p>The uri of the component. Must be an Amazon S3 URL and the requester must have permission to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service quota. Either <code>data</code> or <code>uri</code> can be used to specify the data within the component.</p>
    #[doc(hidden)]
    pub uri: std::option::Option<std::string::String>,
    /// <p>The ID of the KMS key that should be used to encrypt this component.</p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The tags of the component.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The idempotency token of the component.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl ImportComponentInput {
    /// <p> The name of the component.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The semantic version of the component. This version follows the semantic version syntax.</p> <note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn semantic_version(&self) -> std::option::Option<&str> {
        self.semantic_version.as_deref()
    }
    /// <p>The description of the component. Describes the contents of the component.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.</p>
    pub fn change_description(&self) -> std::option::Option<&str> {
        self.change_description.as_deref()
    }
    /// <p>The type of the component denotes whether the component is used to build the image, or only to test it.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::types::ComponentType> {
        self.r#type.as_ref()
    }
    /// <p>The format of the resource that you want to import as a component.</p>
    pub fn format(&self) -> std::option::Option<&crate::types::ComponentFormat> {
        self.format.as_ref()
    }
    /// <p>The platform of the component.</p>
    pub fn platform(&self) -> std::option::Option<&crate::types::Platform> {
        self.platform.as_ref()
    }
    /// <p>The data of the component. Used to specify the data inline. Either <code>data</code> or <code>uri</code> can be used to specify the data within the component.</p>
    pub fn data(&self) -> std::option::Option<&str> {
        self.data.as_deref()
    }
    /// <p>The uri of the component. Must be an Amazon S3 URL and the requester must have permission to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service quota. Either <code>data</code> or <code>uri</code> can be used to specify the data within the component.</p>
    pub fn uri(&self) -> std::option::Option<&str> {
        self.uri.as_deref()
    }
    /// <p>The ID of the KMS key that should be used to encrypt this component.</p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>The tags of the component.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The idempotency token of the component.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl ImportComponentInput {
    /// Creates a new builder-style object to manufacture [`ImportComponentInput`](crate::operation::import_component::ImportComponentInput).
    pub fn builder() -> crate::operation::import_component::builders::ImportComponentInputBuilder {
        crate::operation::import_component::builders::ImportComponentInputBuilder::default()
    }
}

/// A builder for [`ImportComponentInput`](crate::operation::import_component::ImportComponentInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ImportComponentInputBuilder {
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) semantic_version: std::option::Option<std::string::String>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) change_description: std::option::Option<std::string::String>,
    pub(crate) r#type: std::option::Option<crate::types::ComponentType>,
    pub(crate) format: std::option::Option<crate::types::ComponentFormat>,
    pub(crate) platform: std::option::Option<crate::types::Platform>,
    pub(crate) data: std::option::Option<std::string::String>,
    pub(crate) uri: std::option::Option<std::string::String>,
    pub(crate) kms_key_id: std::option::Option<std::string::String>,
    pub(crate) tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) client_token: std::option::Option<std::string::String>,
}
impl ImportComponentInputBuilder {
    /// <p> The name of the component.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p> The name of the component.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The semantic version of the component. This version follows the semantic version syntax.</p> <note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn semantic_version(mut self, input: impl Into<std::string::String>) -> Self {
        self.semantic_version = Some(input.into());
        self
    }
    /// <p>The semantic version of the component. This version follows the semantic version syntax.</p> <note>
    /// <p>The semantic version has four nodes: <major>
    /// .
    /// <minor>
    /// .
    /// <patch>
    /// /
    /// <build>
    /// . You can assign values for the first three, and can filter on all of them.
    /// </build>
    /// </patch>
    /// </minor>
    /// </major></p>
    /// <p> <b>Filtering:</b> With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.</p>
    /// </note>
    pub fn set_semantic_version(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.semantic_version = input;
        self
    }
    /// <p>The description of the component. Describes the contents of the component.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>The description of the component. Describes the contents of the component.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.</p>
    pub fn change_description(mut self, input: impl Into<std::string::String>) -> Self {
        self.change_description = Some(input.into());
        self
    }
    /// <p>The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.</p>
    pub fn set_change_description(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.change_description = input;
        self
    }
    /// <p>The type of the component denotes whether the component is used to build the image, or only to test it.</p>
    pub fn r#type(mut self, input: crate::types::ComponentType) -> Self {
        self.r#type = Some(input);
        self
    }
    /// <p>The type of the component denotes whether the component is used to build the image, or only to test it.</p>
    pub fn set_type(mut self, input: std::option::Option<crate::types::ComponentType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The format of the resource that you want to import as a component.</p>
    pub fn format(mut self, input: crate::types::ComponentFormat) -> Self {
        self.format = Some(input);
        self
    }
    /// <p>The format of the resource that you want to import as a component.</p>
    pub fn set_format(mut self, input: std::option::Option<crate::types::ComponentFormat>) -> Self {
        self.format = input;
        self
    }
    /// <p>The platform of the component.</p>
    pub fn platform(mut self, input: crate::types::Platform) -> Self {
        self.platform = Some(input);
        self
    }
    /// <p>The platform of the component.</p>
    pub fn set_platform(mut self, input: std::option::Option<crate::types::Platform>) -> Self {
        self.platform = input;
        self
    }
    /// <p>The data of the component. Used to specify the data inline. Either <code>data</code> or <code>uri</code> can be used to specify the data within the component.</p>
    pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
        self.data = Some(input.into());
        self
    }
    /// <p>The data of the component. Used to specify the data inline. Either <code>data</code> or <code>uri</code> can be used to specify the data within the component.</p>
    pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.data = input;
        self
    }
    /// <p>The uri of the component. Must be an Amazon S3 URL and the requester must have permission to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service quota. Either <code>data</code> or <code>uri</code> can be used to specify the data within the component.</p>
    pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
        self.uri = Some(input.into());
        self
    }
    /// <p>The uri of the component. Must be an Amazon S3 URL and the requester must have permission to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service quota. Either <code>data</code> or <code>uri</code> can be used to specify the data within the component.</p>
    pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.uri = input;
        self
    }
    /// <p>The ID of the KMS key that should be used to encrypt this component.</p>
    pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.kms_key_id = Some(input.into());
        self
    }
    /// <p>The ID of the KMS key that should be used to encrypt this component.</p>
    pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.kms_key_id = input;
        self
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags of the component.</p>
    pub fn tags(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = Some(hash_map);
        self
    }
    /// <p>The tags of the component.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.tags = input;
        self
    }
    /// <p>The idempotency token of the component.</p>
    pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
        self.client_token = Some(input.into());
        self
    }
    /// <p>The idempotency token of the component.</p>
    pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// Consumes the builder and constructs a [`ImportComponentInput`](crate::operation::import_component::ImportComponentInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::import_component::ImportComponentInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(crate::operation::import_component::ImportComponentInput {
            name: self.name,
            semantic_version: self.semantic_version,
            description: self.description,
            change_description: self.change_description,
            r#type: self.r#type,
            format: self.format,
            platform: self.platform,
            data: self.data,
            uri: self.uri,
            kms_key_id: self.kms_key_id,
            tags: self.tags,
            client_token: self.client_token,
        })
    }
}
