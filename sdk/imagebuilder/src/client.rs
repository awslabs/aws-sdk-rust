// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn cancel_image_creation(&self) -> fluent_builders::CancelImageCreation<C> {
        fluent_builders::CancelImageCreation::new(self.handle.clone())
    }
    pub fn create_component(&self) -> fluent_builders::CreateComponent<C> {
        fluent_builders::CreateComponent::new(self.handle.clone())
    }
    pub fn create_container_recipe(&self) -> fluent_builders::CreateContainerRecipe<C> {
        fluent_builders::CreateContainerRecipe::new(self.handle.clone())
    }
    pub fn create_distribution_configuration(
        &self,
    ) -> fluent_builders::CreateDistributionConfiguration<C> {
        fluent_builders::CreateDistributionConfiguration::new(self.handle.clone())
    }
    pub fn create_image(&self) -> fluent_builders::CreateImage<C> {
        fluent_builders::CreateImage::new(self.handle.clone())
    }
    pub fn create_image_pipeline(&self) -> fluent_builders::CreateImagePipeline<C> {
        fluent_builders::CreateImagePipeline::new(self.handle.clone())
    }
    pub fn create_image_recipe(&self) -> fluent_builders::CreateImageRecipe<C> {
        fluent_builders::CreateImageRecipe::new(self.handle.clone())
    }
    pub fn create_infrastructure_configuration(
        &self,
    ) -> fluent_builders::CreateInfrastructureConfiguration<C> {
        fluent_builders::CreateInfrastructureConfiguration::new(self.handle.clone())
    }
    pub fn delete_component(&self) -> fluent_builders::DeleteComponent<C> {
        fluent_builders::DeleteComponent::new(self.handle.clone())
    }
    pub fn delete_container_recipe(&self) -> fluent_builders::DeleteContainerRecipe<C> {
        fluent_builders::DeleteContainerRecipe::new(self.handle.clone())
    }
    pub fn delete_distribution_configuration(
        &self,
    ) -> fluent_builders::DeleteDistributionConfiguration<C> {
        fluent_builders::DeleteDistributionConfiguration::new(self.handle.clone())
    }
    pub fn delete_image(&self) -> fluent_builders::DeleteImage<C> {
        fluent_builders::DeleteImage::new(self.handle.clone())
    }
    pub fn delete_image_pipeline(&self) -> fluent_builders::DeleteImagePipeline<C> {
        fluent_builders::DeleteImagePipeline::new(self.handle.clone())
    }
    pub fn delete_image_recipe(&self) -> fluent_builders::DeleteImageRecipe<C> {
        fluent_builders::DeleteImageRecipe::new(self.handle.clone())
    }
    pub fn delete_infrastructure_configuration(
        &self,
    ) -> fluent_builders::DeleteInfrastructureConfiguration<C> {
        fluent_builders::DeleteInfrastructureConfiguration::new(self.handle.clone())
    }
    pub fn get_component(&self) -> fluent_builders::GetComponent<C> {
        fluent_builders::GetComponent::new(self.handle.clone())
    }
    pub fn get_component_policy(&self) -> fluent_builders::GetComponentPolicy<C> {
        fluent_builders::GetComponentPolicy::new(self.handle.clone())
    }
    pub fn get_container_recipe(&self) -> fluent_builders::GetContainerRecipe<C> {
        fluent_builders::GetContainerRecipe::new(self.handle.clone())
    }
    pub fn get_container_recipe_policy(&self) -> fluent_builders::GetContainerRecipePolicy<C> {
        fluent_builders::GetContainerRecipePolicy::new(self.handle.clone())
    }
    pub fn get_distribution_configuration(
        &self,
    ) -> fluent_builders::GetDistributionConfiguration<C> {
        fluent_builders::GetDistributionConfiguration::new(self.handle.clone())
    }
    pub fn get_image(&self) -> fluent_builders::GetImage<C> {
        fluent_builders::GetImage::new(self.handle.clone())
    }
    pub fn get_image_pipeline(&self) -> fluent_builders::GetImagePipeline<C> {
        fluent_builders::GetImagePipeline::new(self.handle.clone())
    }
    pub fn get_image_policy(&self) -> fluent_builders::GetImagePolicy<C> {
        fluent_builders::GetImagePolicy::new(self.handle.clone())
    }
    pub fn get_image_recipe(&self) -> fluent_builders::GetImageRecipe<C> {
        fluent_builders::GetImageRecipe::new(self.handle.clone())
    }
    pub fn get_image_recipe_policy(&self) -> fluent_builders::GetImageRecipePolicy<C> {
        fluent_builders::GetImageRecipePolicy::new(self.handle.clone())
    }
    pub fn get_infrastructure_configuration(
        &self,
    ) -> fluent_builders::GetInfrastructureConfiguration<C> {
        fluent_builders::GetInfrastructureConfiguration::new(self.handle.clone())
    }
    pub fn import_component(&self) -> fluent_builders::ImportComponent<C> {
        fluent_builders::ImportComponent::new(self.handle.clone())
    }
    pub fn list_component_build_versions(&self) -> fluent_builders::ListComponentBuildVersions<C> {
        fluent_builders::ListComponentBuildVersions::new(self.handle.clone())
    }
    pub fn list_components(&self) -> fluent_builders::ListComponents<C> {
        fluent_builders::ListComponents::new(self.handle.clone())
    }
    pub fn list_container_recipes(&self) -> fluent_builders::ListContainerRecipes<C> {
        fluent_builders::ListContainerRecipes::new(self.handle.clone())
    }
    pub fn list_distribution_configurations(
        &self,
    ) -> fluent_builders::ListDistributionConfigurations<C> {
        fluent_builders::ListDistributionConfigurations::new(self.handle.clone())
    }
    pub fn list_image_build_versions(&self) -> fluent_builders::ListImageBuildVersions<C> {
        fluent_builders::ListImageBuildVersions::new(self.handle.clone())
    }
    pub fn list_image_packages(&self) -> fluent_builders::ListImagePackages<C> {
        fluent_builders::ListImagePackages::new(self.handle.clone())
    }
    pub fn list_image_pipeline_images(&self) -> fluent_builders::ListImagePipelineImages<C> {
        fluent_builders::ListImagePipelineImages::new(self.handle.clone())
    }
    pub fn list_image_pipelines(&self) -> fluent_builders::ListImagePipelines<C> {
        fluent_builders::ListImagePipelines::new(self.handle.clone())
    }
    pub fn list_image_recipes(&self) -> fluent_builders::ListImageRecipes<C> {
        fluent_builders::ListImageRecipes::new(self.handle.clone())
    }
    pub fn list_images(&self) -> fluent_builders::ListImages<C> {
        fluent_builders::ListImages::new(self.handle.clone())
    }
    pub fn list_infrastructure_configurations(
        &self,
    ) -> fluent_builders::ListInfrastructureConfigurations<C> {
        fluent_builders::ListInfrastructureConfigurations::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_component_policy(&self) -> fluent_builders::PutComponentPolicy<C> {
        fluent_builders::PutComponentPolicy::new(self.handle.clone())
    }
    pub fn put_container_recipe_policy(&self) -> fluent_builders::PutContainerRecipePolicy<C> {
        fluent_builders::PutContainerRecipePolicy::new(self.handle.clone())
    }
    pub fn put_image_policy(&self) -> fluent_builders::PutImagePolicy<C> {
        fluent_builders::PutImagePolicy::new(self.handle.clone())
    }
    pub fn put_image_recipe_policy(&self) -> fluent_builders::PutImageRecipePolicy<C> {
        fluent_builders::PutImageRecipePolicy::new(self.handle.clone())
    }
    pub fn start_image_pipeline_execution(
        &self,
    ) -> fluent_builders::StartImagePipelineExecution<C> {
        fluent_builders::StartImagePipelineExecution::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_distribution_configuration(
        &self,
    ) -> fluent_builders::UpdateDistributionConfiguration<C> {
        fluent_builders::UpdateDistributionConfiguration::new(self.handle.clone())
    }
    pub fn update_image_pipeline(&self) -> fluent_builders::UpdateImagePipeline<C> {
        fluent_builders::UpdateImagePipeline::new(self.handle.clone())
    }
    pub fn update_infrastructure_configuration(
        &self,
    ) -> fluent_builders::UpdateInfrastructureConfiguration<C> {
        fluent_builders::UpdateInfrastructureConfiguration::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CancelImageCreation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_image_creation_input::Builder,
    }
    impl<C> CancelImageCreation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelImageCreationOutput,
            smithy_http::result::SdkError<crate::error::CancelImageCreationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image whose creation you want to cancel.</p>
        pub fn image_build_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_build_version_arn(input);
            self
        }
        pub fn set_image_build_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_build_version_arn(input);
            self
        }
        /// <p>The idempotency token used to make this request idempotent.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateComponent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_component_input::Builder,
    }
    impl<C> CreateComponent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateComponentOutput,
            smithy_http::result::SdkError<crate::error::CreateComponentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The semantic version of the component. This version follows the semantic version syntax.</p>
        /// <note>
        /// <p>The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
        /// You can assign values for the first three, and can filter on all of them.</p>
        /// <p>
        /// <b>Assignment:</b> For the first three nodes you can assign any positive integer value, including
        /// zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// build number, and that is not open for updates.</p>
        /// <p>
        /// <b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for
        /// the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// a date, such as 2021.01.01.</p>
        /// </note>
        pub fn semantic_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.semantic_version(input);
            self
        }
        pub fn set_semantic_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_semantic_version(input);
            self
        }
        /// <p>The description of the component. Describes the contents of the component.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The change description of the component. Describes what change has been made in this
        /// version, or what makes this version different from other versions of this component.</p>
        pub fn change_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.change_description(input);
            self
        }
        pub fn set_change_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_change_description(input);
            self
        }
        /// <p>The platform of the component.</p>
        pub fn platform(mut self, input: crate::model::Platform) -> Self {
            self.inner = self.inner.platform(input);
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<crate::model::Platform>) -> Self {
            self.inner = self.inner.set_platform(input);
            self
        }
        /// <p> The operating system (OS) version supported by the component. If the OS information is
        /// available, a prefix match is performed against the parent image OS version during image recipe
        /// creation.</p>
        pub fn supported_os_versions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.supported_os_versions(inp);
            self
        }
        pub fn set_supported_os_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_supported_os_versions(input);
            self
        }
        /// <p>The data of the component. Used to specify the data inline. Either <code>data</code> or
        /// <code>uri</code> can be used to specify the data within the component.</p>
        pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data(input);
            self
        }
        pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_data(input);
            self
        }
        /// <p>The uri of the component. Must be an Amazon S3 URL and the requester must have permission to
        /// access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service
        /// quota. Either <code>data</code> or <code>uri</code> can be used to specify the data within the
        /// component.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.uri(input);
            self
        }
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_uri(input);
            self
        }
        /// <p>The ID of the KMS key that should be used to encrypt this component.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>The tags of the component.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The idempotency token of the component.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateContainerRecipe<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_container_recipe_input::Builder,
    }
    impl<C> CreateContainerRecipe<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateContainerRecipeOutput,
            smithy_http::result::SdkError<crate::error::CreateContainerRecipeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of container to create.</p>
        pub fn container_type(mut self, input: crate::model::ContainerType) -> Self {
            self.inner = self.inner.container_type(input);
            self
        }
        pub fn set_container_type(
            mut self,
            input: std::option::Option<crate::model::ContainerType>,
        ) -> Self {
            self.inner = self.inner.set_container_type(input);
            self
        }
        /// <p>The name of the container recipe.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The description of the container recipe.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The semantic version of the container recipe. This version follows the semantic version syntax.</p>
        /// <note>
        /// <p>The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
        /// You can assign values for the first three, and can filter on all of them.</p>
        /// <p>
        /// <b>Assignment:</b> For the first three nodes you can assign any positive integer value, including
        /// zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// build number, and that is not open for updates.</p>
        /// <p>
        /// <b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for
        /// the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// a date, such as 2021.01.01.</p>
        /// </note>
        pub fn semantic_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.semantic_version(input);
            self
        }
        pub fn set_semantic_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_semantic_version(input);
            self
        }
        /// <p>Components for build and test that are included in the container recipe.</p>
        pub fn components(mut self, inp: impl Into<crate::model::ComponentConfiguration>) -> Self {
            self.inner = self.inner.components(inp);
            self
        }
        pub fn set_components(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_components(input);
            self
        }
        /// <p>A group of options that can be used to configure an instance for building and testing container images.</p>
        pub fn instance_configuration(
            mut self,
            input: crate::model::InstanceConfiguration,
        ) -> Self {
            self.inner = self.inner.instance_configuration(input);
            self
        }
        pub fn set_instance_configuration(
            mut self,
            input: std::option::Option<crate::model::InstanceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_instance_configuration(input);
            self
        }
        /// <p>The Dockerfile template used to build your image as an inline data blob.</p>
        pub fn dockerfile_template_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dockerfile_template_data(input);
            self
        }
        pub fn set_dockerfile_template_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dockerfile_template_data(input);
            self
        }
        /// <p>The Amazon S3 URI for the Dockerfile that will be used to build your container image.</p>
        pub fn dockerfile_template_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dockerfile_template_uri(input);
            self
        }
        pub fn set_dockerfile_template_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dockerfile_template_uri(input);
            self
        }
        /// <p>Specifies the operating system platform when you use a custom source image.</p>
        pub fn platform_override(mut self, input: crate::model::Platform) -> Self {
            self.inner = self.inner.platform_override(input);
            self
        }
        pub fn set_platform_override(
            mut self,
            input: std::option::Option<crate::model::Platform>,
        ) -> Self {
            self.inner = self.inner.set_platform_override(input);
            self
        }
        /// <p>Specifies the operating system version for the source image.</p>
        pub fn image_os_version_override(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_os_version_override(input);
            self
        }
        pub fn set_image_os_version_override(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_os_version_override(input);
            self
        }
        /// <p>The source image for the container recipe.</p>
        pub fn parent_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parent_image(input);
            self
        }
        pub fn set_parent_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_parent_image(input);
            self
        }
        /// <p>Tags that are attached to the container recipe.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The working directory for use during build and test workflows.</p>
        pub fn working_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.working_directory(input);
            self
        }
        pub fn set_working_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_working_directory(input);
            self
        }
        /// <p>The destination repository for the container image.</p>
        pub fn target_repository(mut self, input: crate::model::TargetContainerRepository) -> Self {
            self.inner = self.inner.target_repository(input);
            self
        }
        pub fn set_target_repository(
            mut self,
            input: std::option::Option<crate::model::TargetContainerRepository>,
        ) -> Self {
            self.inner = self.inner.set_target_repository(input);
            self
        }
        /// <p>Identifies which KMS key is used to encrypt the container image.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>The client token used to make this request idempotent.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDistributionConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_distribution_configuration_input::Builder,
    }
    impl<C> CreateDistributionConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDistributionConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateDistributionConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of the distribution configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p> The description of the distribution configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p> The distributions of the distribution configuration.</p>
        pub fn distributions(mut self, inp: impl Into<crate::model::Distribution>) -> Self {
            self.inner = self.inner.distributions(inp);
            self
        }
        pub fn set_distributions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Distribution>>,
        ) -> Self {
            self.inner = self.inner.set_distributions(input);
            self
        }
        /// <p> The tags of the distribution configuration.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p> The idempotency token of the distribution configuration.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_image_input::Builder,
    }
    impl<C> CreateImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateImageOutput,
            smithy_http::result::SdkError<crate::error::CreateImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The Amazon Resource Name (ARN) of the image recipe that defines how images are
        /// configured, tested, and assessed.</p>
        pub fn image_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_recipe_arn(input);
            self
        }
        pub fn set_image_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_recipe_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.</p>
        pub fn container_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_recipe_arn(input);
            self
        }
        pub fn set_container_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_recipe_arn(input);
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the distribution configuration that defines and
        /// configures the outputs of your pipeline.</p>
        pub fn distribution_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.distribution_configuration_arn(input);
            self
        }
        pub fn set_distribution_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_configuration_arn(input);
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the infrastructure configuration that defines the
        /// environment in which your image will be built and tested.</p>
        pub fn infrastructure_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.infrastructure_configuration_arn(input);
            self
        }
        pub fn set_infrastructure_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_infrastructure_configuration_arn(input);
            self
        }
        /// <p> The image tests configuration of the image.</p>
        pub fn image_tests_configuration(
            mut self,
            input: crate::model::ImageTestsConfiguration,
        ) -> Self {
            self.inner = self.inner.image_tests_configuration(input);
            self
        }
        pub fn set_image_tests_configuration(
            mut self,
            input: std::option::Option<crate::model::ImageTestsConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_image_tests_configuration(input);
            self
        }
        /// <p> Collects additional information about the image being created, including the operating
        /// system (OS) version and package list. This information is used to enhance the overall
        /// experience of using EC2 Image Builder. Enabled by default.</p>
        pub fn enhanced_image_metadata_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enhanced_image_metadata_enabled(input);
            self
        }
        pub fn set_enhanced_image_metadata_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_enhanced_image_metadata_enabled(input);
            self
        }
        /// <p> The tags of the image.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p> The idempotency token used to make this request idempotent.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateImagePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_image_pipeline_input::Builder,
    }
    impl<C> CreateImagePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateImagePipelineOutput,
            smithy_http::result::SdkError<crate::error::CreateImagePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of the image pipeline.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p> The description of the image pipeline.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the image recipe that will be used to configure images
        /// created by this image pipeline.</p>
        pub fn image_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_recipe_arn(input);
            self
        }
        pub fn set_image_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_recipe_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the container recipe that is used to configure images created by this container pipeline.</p>
        pub fn container_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_recipe_arn(input);
            self
        }
        pub fn set_container_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_recipe_arn(input);
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to
        /// build images created by this image pipeline.</p>
        pub fn infrastructure_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.infrastructure_configuration_arn(input);
            self
        }
        pub fn set_infrastructure_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_infrastructure_configuration_arn(input);
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the distribution configuration that will be used to
        /// configure and distribute images created by this image pipeline.</p>
        pub fn distribution_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.distribution_configuration_arn(input);
            self
        }
        pub fn set_distribution_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_configuration_arn(input);
            self
        }
        /// <p> The image test configuration of the image pipeline.</p>
        pub fn image_tests_configuration(
            mut self,
            input: crate::model::ImageTestsConfiguration,
        ) -> Self {
            self.inner = self.inner.image_tests_configuration(input);
            self
        }
        pub fn set_image_tests_configuration(
            mut self,
            input: std::option::Option<crate::model::ImageTestsConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_image_tests_configuration(input);
            self
        }
        /// <p> Collects additional information about the image being created, including the operating
        /// system (OS) version and package list. This information is used to enhance the overall
        /// experience of using EC2 Image Builder. Enabled by default.</p>
        pub fn enhanced_image_metadata_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enhanced_image_metadata_enabled(input);
            self
        }
        pub fn set_enhanced_image_metadata_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_enhanced_image_metadata_enabled(input);
            self
        }
        /// <p> The schedule of the image pipeline.</p>
        pub fn schedule(mut self, input: crate::model::Schedule) -> Self {
            self.inner = self.inner.schedule(input);
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<crate::model::Schedule>) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// <p> The status of the image pipeline.</p>
        pub fn status(mut self, input: crate::model::PipelineStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PipelineStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p> The tags of the image pipeline.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p> The idempotency token used to make this request idempotent.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateImageRecipe<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_image_recipe_input::Builder,
    }
    impl<C> CreateImageRecipe<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateImageRecipeOutput,
            smithy_http::result::SdkError<crate::error::CreateImageRecipeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of the image recipe.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p> The description of the image recipe.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The semantic version of the image recipe. This version follows the semantic version syntax.</p>
        /// <note>
        /// <p>The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
        /// You can assign values for the first three, and can filter on all of them.</p>
        /// <p>
        /// <b>Assignment:</b> For the first three nodes you can assign any positive integer value, including
        /// zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// build number, and that is not open for updates.</p>
        /// <p>
        /// <b>Patterns:</b> You can use any numeric pattern that adheres to the assignment requirements for
        /// the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// a date, such as 2021.01.01.</p>
        /// </note>
        pub fn semantic_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.semantic_version(input);
            self
        }
        pub fn set_semantic_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_semantic_version(input);
            self
        }
        /// <p>The components of the image recipe.</p>
        pub fn components(mut self, inp: impl Into<crate::model::ComponentConfiguration>) -> Self {
            self.inner = self.inner.components(inp);
            self
        }
        pub fn set_components(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ComponentConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_components(input);
            self
        }
        /// <p>The parent image of the image recipe. The value of the string can be the ARN of the parent
        /// image or an AMI ID. The format for the ARN follows this example:
        /// <code>arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/x.x.x</code>.
        /// You can provide the specific version that you want to use, or you can use a wildcard in
        /// all of the fields. If you enter an AMI ID for the string value, you must have access to the AMI,
        /// and the AMI must be in the same Region in which you are using Image Builder.</p>
        pub fn parent_image(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parent_image(input);
            self
        }
        pub fn set_parent_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_parent_image(input);
            self
        }
        /// <p>The block device mappings of the image recipe.</p>
        pub fn block_device_mappings(
            mut self,
            inp: impl Into<crate::model::InstanceBlockDeviceMapping>,
        ) -> Self {
            self.inner = self.inner.block_device_mappings(inp);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceBlockDeviceMapping>>,
        ) -> Self {
            self.inner = self.inner.set_block_device_mappings(input);
            self
        }
        /// <p> The tags of the image recipe.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The working directory used during build and test workflows.</p>
        pub fn working_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.working_directory(input);
            self
        }
        pub fn set_working_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_working_directory(input);
            self
        }
        /// <p>Specify additional settings and launch scripts for your build instances.</p>
        pub fn additional_instance_configuration(
            mut self,
            input: crate::model::AdditionalInstanceConfiguration,
        ) -> Self {
            self.inner = self.inner.additional_instance_configuration(input);
            self
        }
        pub fn set_additional_instance_configuration(
            mut self,
            input: std::option::Option<crate::model::AdditionalInstanceConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_additional_instance_configuration(input);
            self
        }
        /// <p>The idempotency token used to make this request idempotent.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInfrastructureConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_infrastructure_configuration_input::Builder,
    }
    impl<C> CreateInfrastructureConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateInfrastructureConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateInfrastructureConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the infrastructure configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The description of the infrastructure configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The instance types of the infrastructure configuration. You can specify one or more
        /// instance types to use for this build. The service will pick one of these instance types based
        /// on availability.</p>
        pub fn instance_types(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_types(inp);
            self
        }
        pub fn set_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_types(input);
            self
        }
        /// <p>The instance profile to associate with the instance used to customize your Amazon EC2 AMI.</p>
        pub fn instance_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(input);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(input);
            self
        }
        /// <p>The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>The subnet ID in which to place the instance used to customize your Amazon EC2 AMI.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>The logging configuration of the infrastructure configuration.</p>
        pub fn logging(mut self, input: crate::model::Logging) -> Self {
            self.inner = self.inner.logging(input);
            self
        }
        pub fn set_logging(mut self, input: std::option::Option<crate::model::Logging>) -> Self {
            self.inner = self.inner.set_logging(input);
            self
        }
        /// <p>The key pair of the infrastructure configuration. This can be used to log on to and debug
        /// the instance used to create your image.</p>
        pub fn key_pair(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair(input);
            self
        }
        pub fn set_key_pair(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_pair(input);
            self
        }
        /// <p>The terminate instance on failure setting of the infrastructure configuration. Set to
        /// false if you want Image Builder to retain the instance used to configure your AMI if the build
        /// or test phase of your workflow fails.</p>
        pub fn terminate_instance_on_failure(mut self, input: bool) -> Self {
            self.inner = self.inner.terminate_instance_on_failure(input);
            self
        }
        pub fn set_terminate_instance_on_failure(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_terminate_instance_on_failure(input);
            self
        }
        /// <p>The SNS topic on which to send image build events.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sns_topic_arn(input);
            self
        }
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sns_topic_arn(input);
            self
        }
        /// <p>The tags attached to the resource created by Image Builder.</p>
        pub fn resource_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.resource_tags(k, v);
            self
        }
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_resource_tags(input);
            self
        }
        /// <p>The tags of the infrastructure configuration.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The idempotency token used to make this request idempotent.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteComponent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_component_input::Builder,
    }
    impl<C> DeleteComponent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteComponentOutput,
            smithy_http::result::SdkError<crate::error::DeleteComponentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the component build version to delete.</p>
        pub fn component_build_version_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.component_build_version_arn(input);
            self
        }
        pub fn set_component_build_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_component_build_version_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteContainerRecipe<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_container_recipe_input::Builder,
    }
    impl<C> DeleteContainerRecipe<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteContainerRecipeOutput,
            smithy_http::result::SdkError<crate::error::DeleteContainerRecipeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the container recipe to delete.</p>
        pub fn container_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_recipe_arn(input);
            self
        }
        pub fn set_container_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_recipe_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDistributionConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_distribution_configuration_input::Builder,
    }
    impl<C> DeleteDistributionConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDistributionConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteDistributionConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the distribution configuration to delete.</p>
        pub fn distribution_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.distribution_configuration_arn(input);
            self
        }
        pub fn set_distribution_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_configuration_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_image_input::Builder,
    }
    impl<C> DeleteImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteImageOutput,
            smithy_http::result::SdkError<crate::error::DeleteImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image to delete.</p>
        pub fn image_build_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_build_version_arn(input);
            self
        }
        pub fn set_image_build_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_build_version_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteImagePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_image_pipeline_input::Builder,
    }
    impl<C> DeleteImagePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteImagePipelineOutput,
            smithy_http::result::SdkError<crate::error::DeleteImagePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image pipeline to delete.</p>
        pub fn image_pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_pipeline_arn(input);
            self
        }
        pub fn set_image_pipeline_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_pipeline_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteImageRecipe<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_image_recipe_input::Builder,
    }
    impl<C> DeleteImageRecipe<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteImageRecipeOutput,
            smithy_http::result::SdkError<crate::error::DeleteImageRecipeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image recipe to delete.</p>
        pub fn image_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_recipe_arn(input);
            self
        }
        pub fn set_image_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_recipe_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteInfrastructureConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_infrastructure_configuration_input::Builder,
    }
    impl<C> DeleteInfrastructureConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteInfrastructureConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteInfrastructureConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration to delete.</p>
        pub fn infrastructure_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.infrastructure_configuration_arn(input);
            self
        }
        pub fn set_infrastructure_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_infrastructure_configuration_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetComponent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_component_input::Builder,
    }
    impl<C> GetComponent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetComponentOutput,
            smithy_http::result::SdkError<crate::error::GetComponentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the component that you want to retrieve. Regex requires
        /// "/\d+$" suffix.</p>
        pub fn component_build_version_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.component_build_version_arn(input);
            self
        }
        pub fn set_component_build_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_component_build_version_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetComponentPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_component_policy_input::Builder,
    }
    impl<C> GetComponentPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetComponentPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetComponentPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the component whose policy you want to retrieve.</p>
        pub fn component_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.component_arn(input);
            self
        }
        pub fn set_component_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_component_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContainerRecipe<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_container_recipe_input::Builder,
    }
    impl<C> GetContainerRecipe<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContainerRecipeOutput,
            smithy_http::result::SdkError<crate::error::GetContainerRecipeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the container recipe to retrieve.</p>
        pub fn container_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_recipe_arn(input);
            self
        }
        pub fn set_container_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_recipe_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContainerRecipePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_container_recipe_policy_input::Builder,
    }
    impl<C> GetContainerRecipePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContainerRecipePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetContainerRecipePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the container recipe for the policy being requested.</p>
        pub fn container_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_recipe_arn(input);
            self
        }
        pub fn set_container_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_recipe_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDistributionConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_distribution_configuration_input::Builder,
    }
    impl<C> GetDistributionConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDistributionConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetDistributionConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the distribution configuration that you want to
        /// retrieve.</p>
        pub fn distribution_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.distribution_configuration_arn(input);
            self
        }
        pub fn set_distribution_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_configuration_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_image_input::Builder,
    }
    impl<C> GetImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetImageOutput,
            smithy_http::result::SdkError<crate::error::GetImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image that you want to retrieve.</p>
        pub fn image_build_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_build_version_arn(input);
            self
        }
        pub fn set_image_build_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_build_version_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetImagePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_image_pipeline_input::Builder,
    }
    impl<C> GetImagePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetImagePipelineOutput,
            smithy_http::result::SdkError<crate::error::GetImagePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.</p>
        pub fn image_pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_pipeline_arn(input);
            self
        }
        pub fn set_image_pipeline_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_pipeline_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetImagePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_image_policy_input::Builder,
    }
    impl<C> GetImagePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetImagePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetImagePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.</p>
        pub fn image_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_arn(input);
            self
        }
        pub fn set_image_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetImageRecipe<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_image_recipe_input::Builder,
    }
    impl<C> GetImageRecipe<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetImageRecipeOutput,
            smithy_http::result::SdkError<crate::error::GetImageRecipeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.</p>
        pub fn image_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_recipe_arn(input);
            self
        }
        pub fn set_image_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_recipe_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetImageRecipePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_image_recipe_policy_input::Builder,
    }
    impl<C> GetImageRecipePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetImageRecipePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetImageRecipePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image recipe whose policy you want to retrieve.</p>
        pub fn image_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_recipe_arn(input);
            self
        }
        pub fn set_image_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_recipe_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInfrastructureConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_infrastructure_configuration_input::Builder,
    }
    impl<C> GetInfrastructureConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInfrastructureConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetInfrastructureConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
        /// retrieve.</p>
        pub fn infrastructure_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.infrastructure_configuration_arn(input);
            self
        }
        pub fn set_infrastructure_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_infrastructure_configuration_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportComponent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_component_input::Builder,
    }
    impl<C> ImportComponent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportComponentOutput,
            smithy_http::result::SdkError<crate::error::ImportComponentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of the component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The semantic version of the component. This version follows the semantic version syntax.</p>
        /// <note>
        /// <p>The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
        /// You can assign values for the first three, and can filter on all of them.</p>
        /// <p>
        /// <b>Filtering:</b> When you retrieve or reference a resource with a semantic version, you can use
        /// wildcards (x) to filter your results. When you use a wildcard in any node, all nodes to the right of the
        /// first wildcard must also be wildcards. For example, specifying "1.2.x", or "1.x.x" works to filter list
        /// results, but neither "1.x.2", nor "x.2.x" will work. You do not have to specify the build - Image Builder
        /// automatically uses a wildcard for that, if applicable.</p>
        /// </note>
        pub fn semantic_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.semantic_version(input);
            self
        }
        pub fn set_semantic_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_semantic_version(input);
            self
        }
        /// <p>The description of the component. Describes the contents of the component.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The change description of the component. Describes what change has been made in this
        /// version, or what makes this version different from other versions of this component.</p>
        pub fn change_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.change_description(input);
            self
        }
        pub fn set_change_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_change_description(input);
            self
        }
        /// <p>The type of the component denotes whether the component is used to build the image, or only
        /// to test it.</p>
        pub fn r#type(mut self, input: crate::model::ComponentType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::ComponentType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The format of the resource that you want to import as a component.</p>
        pub fn format(mut self, input: crate::model::ComponentFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::ComponentFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>The platform of the component.</p>
        pub fn platform(mut self, input: crate::model::Platform) -> Self {
            self.inner = self.inner.platform(input);
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<crate::model::Platform>) -> Self {
            self.inner = self.inner.set_platform(input);
            self
        }
        /// <p>The data of the component. Used to specify the data inline. Either <code>data</code> or
        /// <code>uri</code> can be used to specify the data within the component.</p>
        pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data(input);
            self
        }
        pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_data(input);
            self
        }
        /// <p>The uri of the component. Must be an Amazon S3 URL and the requester must have permission to
        /// access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service
        /// quota. Either <code>data</code> or <code>uri</code> can be used to specify the data within the
        /// component.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.uri(input);
            self
        }
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_uri(input);
            self
        }
        /// <p>The ID of the KMS key that should be used to encrypt this component.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>The tags of the component.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The idempotency token of the component.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListComponentBuildVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_component_build_versions_input::Builder,
    }
    impl<C> ListComponentBuildVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListComponentBuildVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListComponentBuildVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The component version Amazon Resource Name (ARN) whose versions you want to list.</p>
        pub fn component_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.component_version_arn(input);
            self
        }
        pub fn set_component_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_component_version_arn(input);
            self
        }
        /// <p>The maximum items to return in a request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously
        /// truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListComponents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_components_input::Builder,
    }
    impl<C> ListComponents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListComponentsOutput,
            smithy_http::result::SdkError<crate::error::ListComponentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The owner defines which components you want to list. By default, this request will only
        /// show components owned by your account. You can use this field to specify if you want to view
        /// components owned by yourself, by Amazon, or those components that have been shared with you by
        /// other customers.</p>
        pub fn owner(mut self, input: crate::model::Ownership) -> Self {
            self.inner = self.inner.owner(input);
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<crate::model::Ownership>) -> Self {
            self.inner = self.inner.set_owner(input);
            self
        }
        /// <p>Use the following filters to streamline results:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>description</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>name</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>supportedOsVersion</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>version</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Returns the list of component build versions for the specified name.</p>
        pub fn by_name(mut self, input: bool) -> Self {
            self.inner = self.inner.by_name(input);
            self
        }
        pub fn set_by_name(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_by_name(input);
            self
        }
        /// <p>The maximum items to return in a request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously
        /// truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListContainerRecipes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_container_recipes_input::Builder,
    }
    impl<C> ListContainerRecipes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListContainerRecipesOutput,
            smithy_http::result::SdkError<crate::error::ListContainerRecipesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Returns container recipes belonging to the specified owner, that have been shared with you. You can omit this field to return container recipes belonging to your account.</p>
        pub fn owner(mut self, input: crate::model::Ownership) -> Self {
            self.inner = self.inner.owner(input);
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<crate::model::Ownership>) -> Self {
            self.inner = self.inner.set_owner(input);
            self
        }
        /// <p>Use the following filters to streamline results:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>containerType</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>name</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>parentImage</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return in the list.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Provides a token for pagination, which determines where to begin the next set of results when the current set reaches the maximum for one request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributionConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_distribution_configurations_input::Builder,
    }
    impl<C> ListDistributionConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributionConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListDistributionConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>You can filter on <code>name</code> to streamline results.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum items to return in a request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously
        /// truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListImageBuildVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_image_build_versions_input::Builder,
    }
    impl<C> ListImageBuildVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListImageBuildVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListImageBuildVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image whose build versions you want to retrieve.</p>
        pub fn image_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_version_arn(input);
            self
        }
        pub fn set_image_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_version_arn(input);
            self
        }
        /// <p>Use the following filters to streamline results:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>name</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>osVersion</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>version</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum items to return in a request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously
        /// truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListImagePackages<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_image_packages_input::Builder,
    }
    impl<C> ListImagePackages<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListImagePackagesOutput,
            smithy_http::result::SdkError<crate::error::ListImagePackagesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filter results for the ListImagePackages request by the Image Build Version ARN</p>
        pub fn image_build_version_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_build_version_arn(input);
            self
        }
        pub fn set_image_build_version_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_build_version_arn(input);
            self
        }
        /// <p>The maxiumum number of results to return from the ListImagePackages request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListImagePipelineImages<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_image_pipeline_images_input::Builder,
    }
    impl<C> ListImagePipelineImages<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListImagePipelineImagesOutput,
            smithy_http::result::SdkError<crate::error::ListImagePipelineImagesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image pipeline whose images you want to view.</p>
        pub fn image_pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_pipeline_arn(input);
            self
        }
        pub fn set_image_pipeline_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_pipeline_arn(input);
            self
        }
        /// <p>Use the following filters to streamline results:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>name</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>version</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum items to return in a request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously
        /// truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListImagePipelines<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_image_pipelines_input::Builder,
    }
    impl<C> ListImagePipelines<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListImagePipelinesOutput,
            smithy_http::result::SdkError<crate::error::ListImagePipelinesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use the following filters to streamline results:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>description</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>distributionConfigurationArn</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>imageRecipeArn</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>infrastructureConfigurationArn</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>name</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum items to return in a request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously
        /// truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListImageRecipes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_image_recipes_input::Builder,
    }
    impl<C> ListImageRecipes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListImageRecipesOutput,
            smithy_http::result::SdkError<crate::error::ListImageRecipesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The owner defines which image recipes you want to list. By default, this request will only
        /// show image recipes owned by your account. You can use this field to specify if you want to
        /// view image recipes owned by yourself, by Amazon, or those image recipes that have been shared
        /// with you by other customers.</p>
        pub fn owner(mut self, input: crate::model::Ownership) -> Self {
            self.inner = self.inner.owner(input);
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<crate::model::Ownership>) -> Self {
            self.inner = self.inner.set_owner(input);
            self
        }
        /// <p>Use the following filters to streamline results:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>name</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>parentImage</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum items to return in a request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously
        /// truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListImages<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_images_input::Builder,
    }
    impl<C> ListImages<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListImagesOutput,
            smithy_http::result::SdkError<crate::error::ListImagesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The owner defines which images you want to list. By default, this request will only show
        /// images owned by your account. You can use this field to specify if you want to view images
        /// owned by yourself, by Amazon, or those images that have been shared with you by other
        /// customers.</p>
        pub fn owner(mut self, input: crate::model::Ownership) -> Self {
            self.inner = self.inner.owner(input);
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<crate::model::Ownership>) -> Self {
            self.inner = self.inner.set_owner(input);
            self
        }
        /// <p>Use the following filters to streamline results:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>name</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>osVersion</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>version</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Requests a list of images with a specific recipe name.</p>
        pub fn by_name(mut self, input: bool) -> Self {
            self.inner = self.inner.by_name(input);
            self
        }
        pub fn set_by_name(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_by_name(input);
            self
        }
        /// <p>The maximum items to return in a request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously
        /// truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Includes deprecated images in the response list.</p>
        pub fn include_deprecated(mut self, input: bool) -> Self {
            self.inner = self.inner.include_deprecated(input);
            self
        }
        pub fn set_include_deprecated(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_deprecated(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInfrastructureConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_infrastructure_configurations_input::Builder,
    }
    impl<C> ListInfrastructureConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListInfrastructureConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListInfrastructureConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>You can filter on <code>name</code> to streamline results.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum items to return in a request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the NextToken from a previously
        /// truncated response.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutComponentPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_component_policy_input::Builder,
    }
    impl<C> PutComponentPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutComponentPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutComponentPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the component that this policy should be applied to.</p>
        pub fn component_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.component_arn(input);
            self
        }
        pub fn set_component_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_component_arn(input);
            self
        }
        /// <p>The policy to apply.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutContainerRecipePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_container_recipe_policy_input::Builder,
    }
    impl<C> PutContainerRecipePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutContainerRecipePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutContainerRecipePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the container recipe that this policy should be applied to.</p>
        pub fn container_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_recipe_arn(input);
            self
        }
        pub fn set_container_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_recipe_arn(input);
            self
        }
        /// <p>The policy to apply to the container recipe.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutImagePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_image_policy_input::Builder,
    }
    impl<C> PutImagePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutImagePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutImagePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image that this policy should be applied to.</p>
        pub fn image_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_arn(input);
            self
        }
        pub fn set_image_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_arn(input);
            self
        }
        /// <p>The policy to apply.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutImageRecipePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_image_recipe_policy_input::Builder,
    }
    impl<C> PutImageRecipePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutImageRecipePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutImageRecipePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image recipe that this policy should be applied to.</p>
        pub fn image_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_recipe_arn(input);
            self
        }
        pub fn set_image_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_recipe_arn(input);
            self
        }
        /// <p>The policy to apply.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartImagePipelineExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_image_pipeline_execution_input::Builder,
    }
    impl<C> StartImagePipelineExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartImagePipelineExecutionOutput,
            smithy_http::result::SdkError<crate::error::StartImagePipelineExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image pipeline that you want to manually invoke.</p>
        pub fn image_pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_pipeline_arn(input);
            self
        }
        pub fn set_image_pipeline_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_pipeline_arn(input);
            self
        }
        /// <p>The idempotency token used to make this request idempotent.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to tag.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tags to apply to the resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to untag.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tag keys to remove from the resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDistributionConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_distribution_configuration_input::Builder,
    }
    impl<C> UpdateDistributionConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDistributionConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateDistributionConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the distribution configuration that you want to update.</p>
        pub fn distribution_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.distribution_configuration_arn(input);
            self
        }
        pub fn set_distribution_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_configuration_arn(input);
            self
        }
        /// <p>The description of the distribution configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The distributions of the distribution configuration.</p>
        pub fn distributions(mut self, inp: impl Into<crate::model::Distribution>) -> Self {
            self.inner = self.inner.distributions(inp);
            self
        }
        pub fn set_distributions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Distribution>>,
        ) -> Self {
            self.inner = self.inner.set_distributions(input);
            self
        }
        /// <p>The idempotency token of the distribution configuration.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateImagePipeline<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_image_pipeline_input::Builder,
    }
    impl<C> UpdateImagePipeline<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateImagePipelineOutput,
            smithy_http::result::SdkError<crate::error::UpdateImagePipelineError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the image pipeline that you want to update.</p>
        pub fn image_pipeline_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_pipeline_arn(input);
            self
        }
        pub fn set_image_pipeline_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_pipeline_arn(input);
            self
        }
        /// <p>The description of the image pipeline.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the image recipe that will be used to configure images
        /// updated by this image pipeline.</p>
        pub fn image_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_recipe_arn(input);
            self
        }
        pub fn set_image_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_recipe_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the container pipeline to update.</p>
        pub fn container_recipe_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_recipe_arn(input);
            self
        }
        pub fn set_container_recipe_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_recipe_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to
        /// build images updated by this image pipeline.</p>
        pub fn infrastructure_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.infrastructure_configuration_arn(input);
            self
        }
        pub fn set_infrastructure_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_infrastructure_configuration_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the distribution configuration that will be used to
        /// configure and distribute images updated by this image pipeline.</p>
        pub fn distribution_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.distribution_configuration_arn(input);
            self
        }
        pub fn set_distribution_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_configuration_arn(input);
            self
        }
        /// <p>The image test configuration of the image pipeline.</p>
        pub fn image_tests_configuration(
            mut self,
            input: crate::model::ImageTestsConfiguration,
        ) -> Self {
            self.inner = self.inner.image_tests_configuration(input);
            self
        }
        pub fn set_image_tests_configuration(
            mut self,
            input: std::option::Option<crate::model::ImageTestsConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_image_tests_configuration(input);
            self
        }
        /// <p> Collects additional information about the image being created, including the operating
        /// system (OS) version and package list. This information is used to enhance the overall
        /// experience of using EC2 Image Builder. Enabled by default.</p>
        pub fn enhanced_image_metadata_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enhanced_image_metadata_enabled(input);
            self
        }
        pub fn set_enhanced_image_metadata_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_enhanced_image_metadata_enabled(input);
            self
        }
        /// <p>The schedule of the image pipeline.</p>
        pub fn schedule(mut self, input: crate::model::Schedule) -> Self {
            self.inner = self.inner.schedule(input);
            self
        }
        pub fn set_schedule(mut self, input: std::option::Option<crate::model::Schedule>) -> Self {
            self.inner = self.inner.set_schedule(input);
            self
        }
        /// <p>The status of the image pipeline.</p>
        pub fn status(mut self, input: crate::model::PipelineStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PipelineStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>The idempotency token used to make this request idempotent.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateInfrastructureConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_infrastructure_configuration_input::Builder,
    }
    impl<C> UpdateInfrastructureConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateInfrastructureConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateInfrastructureConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
        /// update.</p>
        pub fn infrastructure_configuration_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.infrastructure_configuration_arn(input);
            self
        }
        pub fn set_infrastructure_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_infrastructure_configuration_arn(input);
            self
        }
        /// <p>The description of the infrastructure configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The instance types of the infrastructure configuration. You can specify one or more
        /// instance types to use for this build. The service will pick one of these instance types based
        /// on availability.</p>
        pub fn instance_types(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_types(inp);
            self
        }
        pub fn set_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_types(input);
            self
        }
        /// <p>The instance profile to associate with the instance used to customize your Amazon EC2 AMI.</p>
        pub fn instance_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_profile_name(input);
            self
        }
        pub fn set_instance_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_profile_name(input);
            self
        }
        /// <p>The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>The subnet ID to place the instance used to customize your Amazon EC2 AMI in.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>The logging configuration of the infrastructure configuration.</p>
        pub fn logging(mut self, input: crate::model::Logging) -> Self {
            self.inner = self.inner.logging(input);
            self
        }
        pub fn set_logging(mut self, input: std::option::Option<crate::model::Logging>) -> Self {
            self.inner = self.inner.set_logging(input);
            self
        }
        /// <p>The key pair of the infrastructure configuration. This can be used to log on to and debug
        /// the instance used to create your image.</p>
        pub fn key_pair(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair(input);
            self
        }
        pub fn set_key_pair(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_pair(input);
            self
        }
        /// <p>The terminate instance on failure setting of the infrastructure configuration. Set to
        /// false if you want Image Builder to retain the instance used to configure your AMI if the build
        /// or test phase of your workflow fails.</p>
        pub fn terminate_instance_on_failure(mut self, input: bool) -> Self {
            self.inner = self.inner.terminate_instance_on_failure(input);
            self
        }
        pub fn set_terminate_instance_on_failure(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_terminate_instance_on_failure(input);
            self
        }
        /// <p>The SNS topic on which to send image build events.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sns_topic_arn(input);
            self
        }
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sns_topic_arn(input);
            self
        }
        /// <p>The idempotency token used to make this request idempotent.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The tags attached to the resource created by Image Builder.</p>
        pub fn resource_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.resource_tags(k, v);
            self
        }
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_resource_tags(input);
            self
        }
    }
}
