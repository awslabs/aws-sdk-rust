// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_device_pool(&self) -> fluent_builders::CreateDevicePool<C> {
        fluent_builders::CreateDevicePool::new(self.handle.clone())
    }
    pub fn create_instance_profile(&self) -> fluent_builders::CreateInstanceProfile<C> {
        fluent_builders::CreateInstanceProfile::new(self.handle.clone())
    }
    pub fn create_network_profile(&self) -> fluent_builders::CreateNetworkProfile<C> {
        fluent_builders::CreateNetworkProfile::new(self.handle.clone())
    }
    pub fn create_project(&self) -> fluent_builders::CreateProject<C> {
        fluent_builders::CreateProject::new(self.handle.clone())
    }
    pub fn create_remote_access_session(&self) -> fluent_builders::CreateRemoteAccessSession<C> {
        fluent_builders::CreateRemoteAccessSession::new(self.handle.clone())
    }
    pub fn create_test_grid_project(&self) -> fluent_builders::CreateTestGridProject<C> {
        fluent_builders::CreateTestGridProject::new(self.handle.clone())
    }
    pub fn create_test_grid_url(&self) -> fluent_builders::CreateTestGridUrl<C> {
        fluent_builders::CreateTestGridUrl::new(self.handle.clone())
    }
    pub fn create_upload(&self) -> fluent_builders::CreateUpload<C> {
        fluent_builders::CreateUpload::new(self.handle.clone())
    }
    pub fn create_vpce_configuration(&self) -> fluent_builders::CreateVPCEConfiguration<C> {
        fluent_builders::CreateVPCEConfiguration::new(self.handle.clone())
    }
    pub fn delete_device_pool(&self) -> fluent_builders::DeleteDevicePool<C> {
        fluent_builders::DeleteDevicePool::new(self.handle.clone())
    }
    pub fn delete_instance_profile(&self) -> fluent_builders::DeleteInstanceProfile<C> {
        fluent_builders::DeleteInstanceProfile::new(self.handle.clone())
    }
    pub fn delete_network_profile(&self) -> fluent_builders::DeleteNetworkProfile<C> {
        fluent_builders::DeleteNetworkProfile::new(self.handle.clone())
    }
    pub fn delete_project(&self) -> fluent_builders::DeleteProject<C> {
        fluent_builders::DeleteProject::new(self.handle.clone())
    }
    pub fn delete_remote_access_session(&self) -> fluent_builders::DeleteRemoteAccessSession<C> {
        fluent_builders::DeleteRemoteAccessSession::new(self.handle.clone())
    }
    pub fn delete_run(&self) -> fluent_builders::DeleteRun<C> {
        fluent_builders::DeleteRun::new(self.handle.clone())
    }
    pub fn delete_test_grid_project(&self) -> fluent_builders::DeleteTestGridProject<C> {
        fluent_builders::DeleteTestGridProject::new(self.handle.clone())
    }
    pub fn delete_upload(&self) -> fluent_builders::DeleteUpload<C> {
        fluent_builders::DeleteUpload::new(self.handle.clone())
    }
    pub fn delete_vpce_configuration(&self) -> fluent_builders::DeleteVPCEConfiguration<C> {
        fluent_builders::DeleteVPCEConfiguration::new(self.handle.clone())
    }
    pub fn get_account_settings(&self) -> fluent_builders::GetAccountSettings<C> {
        fluent_builders::GetAccountSettings::new(self.handle.clone())
    }
    pub fn get_device(&self) -> fluent_builders::GetDevice<C> {
        fluent_builders::GetDevice::new(self.handle.clone())
    }
    pub fn get_device_instance(&self) -> fluent_builders::GetDeviceInstance<C> {
        fluent_builders::GetDeviceInstance::new(self.handle.clone())
    }
    pub fn get_device_pool(&self) -> fluent_builders::GetDevicePool<C> {
        fluent_builders::GetDevicePool::new(self.handle.clone())
    }
    pub fn get_device_pool_compatibility(&self) -> fluent_builders::GetDevicePoolCompatibility<C> {
        fluent_builders::GetDevicePoolCompatibility::new(self.handle.clone())
    }
    pub fn get_instance_profile(&self) -> fluent_builders::GetInstanceProfile<C> {
        fluent_builders::GetInstanceProfile::new(self.handle.clone())
    }
    pub fn get_job(&self) -> fluent_builders::GetJob<C> {
        fluent_builders::GetJob::new(self.handle.clone())
    }
    pub fn get_network_profile(&self) -> fluent_builders::GetNetworkProfile<C> {
        fluent_builders::GetNetworkProfile::new(self.handle.clone())
    }
    pub fn get_offering_status(&self) -> fluent_builders::GetOfferingStatus<C> {
        fluent_builders::GetOfferingStatus::new(self.handle.clone())
    }
    pub fn get_project(&self) -> fluent_builders::GetProject<C> {
        fluent_builders::GetProject::new(self.handle.clone())
    }
    pub fn get_remote_access_session(&self) -> fluent_builders::GetRemoteAccessSession<C> {
        fluent_builders::GetRemoteAccessSession::new(self.handle.clone())
    }
    pub fn get_run(&self) -> fluent_builders::GetRun<C> {
        fluent_builders::GetRun::new(self.handle.clone())
    }
    pub fn get_suite(&self) -> fluent_builders::GetSuite<C> {
        fluent_builders::GetSuite::new(self.handle.clone())
    }
    pub fn get_test(&self) -> fluent_builders::GetTest<C> {
        fluent_builders::GetTest::new(self.handle.clone())
    }
    pub fn get_test_grid_project(&self) -> fluent_builders::GetTestGridProject<C> {
        fluent_builders::GetTestGridProject::new(self.handle.clone())
    }
    pub fn get_test_grid_session(&self) -> fluent_builders::GetTestGridSession<C> {
        fluent_builders::GetTestGridSession::new(self.handle.clone())
    }
    pub fn get_upload(&self) -> fluent_builders::GetUpload<C> {
        fluent_builders::GetUpload::new(self.handle.clone())
    }
    pub fn get_vpce_configuration(&self) -> fluent_builders::GetVPCEConfiguration<C> {
        fluent_builders::GetVPCEConfiguration::new(self.handle.clone())
    }
    pub fn install_to_remote_access_session(
        &self,
    ) -> fluent_builders::InstallToRemoteAccessSession<C> {
        fluent_builders::InstallToRemoteAccessSession::new(self.handle.clone())
    }
    pub fn list_artifacts(&self) -> fluent_builders::ListArtifacts<C> {
        fluent_builders::ListArtifacts::new(self.handle.clone())
    }
    pub fn list_device_instances(&self) -> fluent_builders::ListDeviceInstances<C> {
        fluent_builders::ListDeviceInstances::new(self.handle.clone())
    }
    pub fn list_device_pools(&self) -> fluent_builders::ListDevicePools<C> {
        fluent_builders::ListDevicePools::new(self.handle.clone())
    }
    pub fn list_devices(&self) -> fluent_builders::ListDevices<C> {
        fluent_builders::ListDevices::new(self.handle.clone())
    }
    pub fn list_instance_profiles(&self) -> fluent_builders::ListInstanceProfiles<C> {
        fluent_builders::ListInstanceProfiles::new(self.handle.clone())
    }
    pub fn list_jobs(&self) -> fluent_builders::ListJobs<C> {
        fluent_builders::ListJobs::new(self.handle.clone())
    }
    pub fn list_network_profiles(&self) -> fluent_builders::ListNetworkProfiles<C> {
        fluent_builders::ListNetworkProfiles::new(self.handle.clone())
    }
    pub fn list_offering_promotions(&self) -> fluent_builders::ListOfferingPromotions<C> {
        fluent_builders::ListOfferingPromotions::new(self.handle.clone())
    }
    pub fn list_offerings(&self) -> fluent_builders::ListOfferings<C> {
        fluent_builders::ListOfferings::new(self.handle.clone())
    }
    pub fn list_offering_transactions(&self) -> fluent_builders::ListOfferingTransactions<C> {
        fluent_builders::ListOfferingTransactions::new(self.handle.clone())
    }
    pub fn list_projects(&self) -> fluent_builders::ListProjects<C> {
        fluent_builders::ListProjects::new(self.handle.clone())
    }
    pub fn list_remote_access_sessions(&self) -> fluent_builders::ListRemoteAccessSessions<C> {
        fluent_builders::ListRemoteAccessSessions::new(self.handle.clone())
    }
    pub fn list_runs(&self) -> fluent_builders::ListRuns<C> {
        fluent_builders::ListRuns::new(self.handle.clone())
    }
    pub fn list_samples(&self) -> fluent_builders::ListSamples<C> {
        fluent_builders::ListSamples::new(self.handle.clone())
    }
    pub fn list_suites(&self) -> fluent_builders::ListSuites<C> {
        fluent_builders::ListSuites::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_test_grid_projects(&self) -> fluent_builders::ListTestGridProjects<C> {
        fluent_builders::ListTestGridProjects::new(self.handle.clone())
    }
    pub fn list_test_grid_session_actions(&self) -> fluent_builders::ListTestGridSessionActions<C> {
        fluent_builders::ListTestGridSessionActions::new(self.handle.clone())
    }
    pub fn list_test_grid_session_artifacts(
        &self,
    ) -> fluent_builders::ListTestGridSessionArtifacts<C> {
        fluent_builders::ListTestGridSessionArtifacts::new(self.handle.clone())
    }
    pub fn list_test_grid_sessions(&self) -> fluent_builders::ListTestGridSessions<C> {
        fluent_builders::ListTestGridSessions::new(self.handle.clone())
    }
    pub fn list_tests(&self) -> fluent_builders::ListTests<C> {
        fluent_builders::ListTests::new(self.handle.clone())
    }
    pub fn list_unique_problems(&self) -> fluent_builders::ListUniqueProblems<C> {
        fluent_builders::ListUniqueProblems::new(self.handle.clone())
    }
    pub fn list_uploads(&self) -> fluent_builders::ListUploads<C> {
        fluent_builders::ListUploads::new(self.handle.clone())
    }
    pub fn list_vpce_configurations(&self) -> fluent_builders::ListVPCEConfigurations<C> {
        fluent_builders::ListVPCEConfigurations::new(self.handle.clone())
    }
    pub fn purchase_offering(&self) -> fluent_builders::PurchaseOffering<C> {
        fluent_builders::PurchaseOffering::new(self.handle.clone())
    }
    pub fn renew_offering(&self) -> fluent_builders::RenewOffering<C> {
        fluent_builders::RenewOffering::new(self.handle.clone())
    }
    pub fn schedule_run(&self) -> fluent_builders::ScheduleRun<C> {
        fluent_builders::ScheduleRun::new(self.handle.clone())
    }
    pub fn stop_job(&self) -> fluent_builders::StopJob<C> {
        fluent_builders::StopJob::new(self.handle.clone())
    }
    pub fn stop_remote_access_session(&self) -> fluent_builders::StopRemoteAccessSession<C> {
        fluent_builders::StopRemoteAccessSession::new(self.handle.clone())
    }
    pub fn stop_run(&self) -> fluent_builders::StopRun<C> {
        fluent_builders::StopRun::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_device_instance(&self) -> fluent_builders::UpdateDeviceInstance<C> {
        fluent_builders::UpdateDeviceInstance::new(self.handle.clone())
    }
    pub fn update_device_pool(&self) -> fluent_builders::UpdateDevicePool<C> {
        fluent_builders::UpdateDevicePool::new(self.handle.clone())
    }
    pub fn update_instance_profile(&self) -> fluent_builders::UpdateInstanceProfile<C> {
        fluent_builders::UpdateInstanceProfile::new(self.handle.clone())
    }
    pub fn update_network_profile(&self) -> fluent_builders::UpdateNetworkProfile<C> {
        fluent_builders::UpdateNetworkProfile::new(self.handle.clone())
    }
    pub fn update_project(&self) -> fluent_builders::UpdateProject<C> {
        fluent_builders::UpdateProject::new(self.handle.clone())
    }
    pub fn update_test_grid_project(&self) -> fluent_builders::UpdateTestGridProject<C> {
        fluent_builders::UpdateTestGridProject::new(self.handle.clone())
    }
    pub fn update_upload(&self) -> fluent_builders::UpdateUpload<C> {
        fluent_builders::UpdateUpload::new(self.handle.clone())
    }
    pub fn update_vpce_configuration(&self) -> fluent_builders::UpdateVPCEConfiguration<C> {
        fluent_builders::UpdateVPCEConfiguration::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateDevicePool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_device_pool_input::Builder,
    }
    impl<C> CreateDevicePool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDevicePoolOutput,
            smithy_http::result::SdkError<crate::error::CreateDevicePoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the project for the device pool.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>The device pool's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The device pool's description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The device pool's rules.</p>
        pub fn rules(mut self, inp: impl Into<crate::model::Rule>) -> Self {
            self.inner = self.inner.rules(inp);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are
        /// available and meet the criteria that you assign for the <code>rules</code> parameter. Depending on how many
        /// devices meet these constraints, your device pool might contain fewer devices than the value for this
        /// parameter.</p>
        /// <p>By specifying the maximum number of devices, you can control the costs that you incur
        /// by running tests.</p>
        pub fn max_devices(mut self, input: i32) -> Self {
            self.inner = self.inner.max_devices(input);
            self
        }
        pub fn set_max_devices(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_devices(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInstanceProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_instance_profile_input::Builder,
    }
    impl<C> CreateInstanceProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateInstanceProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your instance profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The description of your instance profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>When set to <code>true</code>, Device Farm removes app packages after a test run. The default value is
        /// <code>false</code> for private devices.</p>
        pub fn package_cleanup(mut self, input: bool) -> Self {
            self.inner = self.inner.package_cleanup(input);
            self
        }
        pub fn set_package_cleanup(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_package_cleanup(input);
            self
        }
        /// <p>An array of strings that specifies the list of app packages that should not be cleaned up from the device
        /// after a test run.</p>
        /// <p>The list of packages is considered only if you set <code>packageCleanup</code> to
        /// <code>true</code>.</p>
        pub fn exclude_app_packages_from_cleanup(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.exclude_app_packages_from_cleanup(inp);
            self
        }
        pub fn set_exclude_app_packages_from_cleanup(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_exclude_app_packages_from_cleanup(input);
            self
        }
        /// <p>When set to <code>true</code>, Device Farm reboots the instance after a test run. The default value is
        /// <code>true</code>.</p>
        pub fn reboot_after_use(mut self, input: bool) -> Self {
            self.inner = self.inner.reboot_after_use(input);
            self
        }
        pub fn set_reboot_after_use(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reboot_after_use(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNetworkProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_network_profile_input::Builder,
    }
    impl<C> CreateNetworkProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNetworkProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateNetworkProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project for which you want to create a
        /// network profile.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>The name for the new network profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The description of the network profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The type of network profile to create. Valid values are listed here.</p>
        pub fn r#type(mut self, input: crate::model::NetworkProfileType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::NetworkProfileType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The data throughput rate in bits per second, as an integer from 0 to
        /// 104857600.</p>
        pub fn uplink_bandwidth_bits(mut self, input: i64) -> Self {
            self.inner = self.inner.uplink_bandwidth_bits(input);
            self
        }
        pub fn set_uplink_bandwidth_bits(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_uplink_bandwidth_bits(input);
            self
        }
        /// <p>The data throughput rate in bits per second, as an integer from 0 to
        /// 104857600.</p>
        pub fn downlink_bandwidth_bits(mut self, input: i64) -> Self {
            self.inner = self.inner.downlink_bandwidth_bits(input);
            self
        }
        pub fn set_downlink_bandwidth_bits(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_downlink_bandwidth_bits(input);
            self
        }
        /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
        /// 2000.</p>
        pub fn uplink_delay_ms(mut self, input: i64) -> Self {
            self.inner = self.inner.uplink_delay_ms(input);
            self
        }
        pub fn set_uplink_delay_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_uplink_delay_ms(input);
            self
        }
        /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
        /// 2000.</p>
        pub fn downlink_delay_ms(mut self, input: i64) -> Self {
            self.inner = self.inner.downlink_delay_ms(input);
            self
        }
        pub fn set_downlink_delay_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_downlink_delay_ms(input);
            self
        }
        /// <p>Time variation in the delay of received packets in milliseconds as an integer from
        /// 0 to 2000.</p>
        pub fn uplink_jitter_ms(mut self, input: i64) -> Self {
            self.inner = self.inner.uplink_jitter_ms(input);
            self
        }
        pub fn set_uplink_jitter_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_uplink_jitter_ms(input);
            self
        }
        /// <p>Time variation in the delay of received packets in milliseconds as an integer from
        /// 0 to 2000.</p>
        pub fn downlink_jitter_ms(mut self, input: i64) -> Self {
            self.inner = self.inner.downlink_jitter_ms(input);
            self
        }
        pub fn set_downlink_jitter_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_downlink_jitter_ms(input);
            self
        }
        /// <p>Proportion of transmitted packets that fail to arrive from 0 to 100
        /// percent.</p>
        pub fn uplink_loss_percent(mut self, input: i32) -> Self {
            self.inner = self.inner.uplink_loss_percent(input);
            self
        }
        pub fn set_uplink_loss_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_uplink_loss_percent(input);
            self
        }
        /// <p>Proportion of received packets that fail to arrive from 0 to 100 percent.</p>
        pub fn downlink_loss_percent(mut self, input: i32) -> Self {
            self.inner = self.inner.downlink_loss_percent(input);
            self
        }
        pub fn set_downlink_loss_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_downlink_loss_percent(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateProject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_project_input::Builder,
    }
    impl<C> CreateProject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateProjectOutput,
            smithy_http::result::SdkError<crate::error::CreateProjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The project's name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Sets the execution timeout value (in minutes) for a project. All test runs in this project use the
        /// specified execution timeout value unless overridden when scheduling a run.</p>
        pub fn default_job_timeout_minutes(mut self, input: i32) -> Self {
            self.inner = self.inner.default_job_timeout_minutes(input);
            self
        }
        pub fn set_default_job_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_default_job_timeout_minutes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRemoteAccessSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_remote_access_session_input::Builder,
    }
    impl<C> CreateRemoteAccessSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRemoteAccessSessionOutput,
            smithy_http::result::SdkError<crate::error::CreateRemoteAccessSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project for which you want to create a remote
        /// access session.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>The ARN of the device for which you want to create a remote access session.</p>
        pub fn device_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_arn(input);
            self
        }
        pub fn set_device_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_device_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the device instance for which you want to create a
        /// remote access session.</p>
        pub fn instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_arn(input);
            self
        }
        pub fn set_instance_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_arn(input);
            self
        }
        /// <p>Ignored. The public key of the <code>ssh</code> key pair you want to use for connecting to remote
        /// devices in your remote debugging session. This key is required only if <code>remoteDebugEnabled</code> is
        /// set to <code>true</code>.</p>
        /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        /// longer supported</a>.</p>
        pub fn ssh_public_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key(input);
            self
        }
        pub fn set_ssh_public_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key(input);
            self
        }
        /// <p>Set to <code>true</code> if you want to access devices remotely for debugging in
        /// your remote access session.</p>
        /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        /// longer supported</a>.</p>
        pub fn remote_debug_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.remote_debug_enabled(input);
            self
        }
        pub fn set_remote_debug_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_remote_debug_enabled(input);
            self
        }
        /// <p>Set to <code>true</code> to enable remote recording for the remote access
        /// session.</p>
        pub fn remote_record_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.remote_record_enabled(input);
            self
        }
        pub fn set_remote_record_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_remote_record_enabled(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the app to be recorded in the remote access
        /// session.</p>
        pub fn remote_record_app_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remote_record_app_arn(input);
            self
        }
        pub fn set_remote_record_app_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remote_record_app_arn(input);
            self
        }
        /// <p>The name of the remote access session to create.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Unique identifier for the client. If you want access to multiple devices on the same client, you should
        /// pass the same <code>clientId</code> value in each call to <code>CreateRemoteAccessSession</code>. This
        /// identifier is required only if <code>remoteDebugEnabled</code> is set to <code>true</code>.</p>
        /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        /// longer supported</a>.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_id(input);
            self
        }
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_id(input);
            self
        }
        /// <p>The configuration information for the remote access session request.</p>
        pub fn configuration(
            mut self,
            input: crate::model::CreateRemoteAccessSessionConfiguration,
        ) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::CreateRemoteAccessSessionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The interaction mode of the remote access session. Valid values are:</p>
        /// <ul>
        /// <li>
        /// <p>INTERACTIVE: You can interact with the iOS device by viewing, touching, and
        /// rotating the screen. You cannot run XCUITest framework-based tests in this
        /// mode.</p>
        /// </li>
        /// <li>
        /// <p>NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This
        /// mode has the fastest test execution speed. You can run XCUITest framework-based tests in this
        /// mode.</p>
        /// </li>
        /// <li>
        /// <p>VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest
        /// framework-based tests and watch the screen in this mode.</p>
        /// </li>
        /// </ul>
        pub fn interaction_mode(mut self, input: crate::model::InteractionMode) -> Self {
            self.inner = self.inner.interaction_mode(input);
            self
        }
        pub fn set_interaction_mode(
            mut self,
            input: std::option::Option<crate::model::InteractionMode>,
        ) -> Self {
            self.inner = self.inner.set_interaction_mode(input);
            self
        }
        /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public
        /// devices, Device Farm always signs your apps again.</p>
        /// <p>For more information on how Device Farm modifies your uploads during tests, see <a href="https://aws.amazon.com/device-farm/faq/">Do you modify my app?</a>
        /// </p>
        pub fn skip_app_resign(mut self, input: bool) -> Self {
            self.inner = self.inner.skip_app_resign(input);
            self
        }
        pub fn set_skip_app_resign(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_skip_app_resign(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTestGridProject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_test_grid_project_input::Builder,
    }
    impl<C> CreateTestGridProject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTestGridProjectOutput,
            smithy_http::result::SdkError<crate::error::CreateTestGridProjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Human-readable name of the Selenium testing project.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Human-readable description of the project.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The VPC security groups and subnets that are attached to a project.</p>
        pub fn vpc_config(mut self, input: crate::model::TestGridVpcConfig) -> Self {
            self.inner = self.inner.vpc_config(input);
            self
        }
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::TestGridVpcConfig>,
        ) -> Self {
            self.inner = self.inner.set_vpc_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTestGridUrl<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_test_grid_url_input::Builder,
    }
    impl<C> CreateTestGridUrl<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTestGridUrlOutput,
            smithy_http::result::SdkError<crate::error::CreateTestGridUrlError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ARN (from <a>CreateTestGridProject</a> or <a>ListTestGridProjects</a>) to associate
        /// with the short-term URL. </p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>Lifetime, in seconds, of the URL.</p>
        pub fn expires_in_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.expires_in_seconds(input);
            self
        }
        pub fn set_expires_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_expires_in_seconds(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateUpload<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_upload_input::Builder,
    }
    impl<C> CreateUpload<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateUploadOutput,
            smithy_http::result::SdkError<crate::error::CreateUploadError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the project for the upload.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>The upload's file name. The name should not contain any forward slashes (<code>/</code>). If you are
        /// uploading an iOS app, the file name must end with the <code>.ipa</code> extension. If you are uploading an
        /// Android app, the file name must end with the <code>.apk</code> extension. For all others, the file name must
        /// end with the <code>.zip</code> file extension.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The upload's upload type.</p>
        /// <p>Must be one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>ANDROID_APP</p>
        /// </li>
        /// <li>
        /// <p>IOS_APP</p>
        /// </li>
        /// <li>
        /// <p>WEB_APP</p>
        /// </li>
        /// <li>
        /// <p>EXTERNAL_DATA</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_JUNIT_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_TESTNG_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_PYTHON_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_NODE_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_RUBY_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_PYTHON_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_NODE_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_RUBY_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>CALABASH_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>INSTRUMENTATION_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>UIAUTOMATION_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>UIAUTOMATOR_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>XCTEST_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>XCTEST_UI_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_JUNIT_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_TESTNG_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_PYTHON_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_NODE_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_RUBY_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_JUNIT_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_TESTNG_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_PYTHON_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_NODE_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_RUBY_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>INSTRUMENTATION_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>XCTEST_UI_TEST_SPEC</p>
        /// </li>
        /// </ul>
        /// <p> If you call <code>CreateUpload</code> with <code>WEB_APP</code> specified, AWS
        /// Device Farm throws an <code>ArgumentException</code> error.</p>
        pub fn r#type(mut self, input: crate::model::UploadType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::UploadType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The upload's content type (for example, <code>application/octet-stream</code>).</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_type(input);
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVPCEConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpce_configuration_input::Builder,
    }
    impl<C> CreateVPCEConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpceConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateVPCEConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The friendly name you give to your VPC endpoint configuration, to manage your
        /// configurations more easily.</p>
        pub fn vpce_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpce_configuration_name(input);
            self
        }
        pub fn set_vpce_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpce_configuration_name(input);
            self
        }
        /// <p>The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.</p>
        pub fn vpce_service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpce_service_name(input);
            self
        }
        pub fn set_vpce_service_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpce_service_name(input);
            self
        }
        /// <p>The DNS name of the service running in your VPC that you want Device Farm to
        /// test.</p>
        pub fn service_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_dns_name(input);
            self
        }
        pub fn set_service_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_dns_name(input);
            self
        }
        /// <p>An optional description that provides details about your VPC endpoint configuration.</p>
        pub fn vpce_configuration_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.vpce_configuration_description(input);
            self
        }
        pub fn set_vpce_configuration_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpce_configuration_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDevicePool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_device_pool_input::Builder,
    }
    impl<C> DeleteDevicePool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDevicePoolOutput,
            smithy_http::result::SdkError<crate::error::DeleteDevicePoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm device pool to delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteInstanceProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_instance_profile_input::Builder,
    }
    impl<C> DeleteInstanceProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteInstanceProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the instance profile you are requesting to
        /// delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNetworkProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_network_profile_input::Builder,
    }
    impl<C> DeleteNetworkProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNetworkProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteNetworkProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the network profile to delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteProject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_project_input::Builder,
    }
    impl<C> DeleteProject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteProjectOutput,
            smithy_http::result::SdkError<crate::error::DeleteProjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm project to delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRemoteAccessSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_remote_access_session_input::Builder,
    }
    impl<C> DeleteRemoteAccessSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRemoteAccessSessionOutput,
            smithy_http::result::SdkError<crate::error::DeleteRemoteAccessSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the session for which you want to delete remote
        /// access.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_run_input::Builder,
    }
    impl<C> DeleteRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRunOutput,
            smithy_http::result::SdkError<crate::error::DeleteRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the run to delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTestGridProject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_test_grid_project_input::Builder,
    }
    impl<C> DeleteTestGridProject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTestGridProjectOutput,
            smithy_http::result::SdkError<crate::error::DeleteTestGridProjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the project to delete, from <a>CreateTestGridProject</a> or <a>ListTestGridProjects</a>.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteUpload<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_upload_input::Builder,
    }
    impl<C> DeleteUpload<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteUploadOutput,
            smithy_http::result::SdkError<crate::error::DeleteUploadError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm upload to delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVPCEConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpce_configuration_input::Builder,
    }
    impl<C> DeleteVPCEConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpceConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteVPCEConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to
        /// delete.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccountSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_account_settings_input::Builder,
    }
    impl<C> GetAccountSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccountSettingsOutput,
            smithy_http::result::SdkError<crate::error::GetAccountSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDevice<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_device_input::Builder,
    }
    impl<C> GetDevice<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDeviceOutput,
            smithy_http::result::SdkError<crate::error::GetDeviceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The device type's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDeviceInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_device_instance_input::Builder,
    }
    impl<C> GetDeviceInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDeviceInstanceOutput,
            smithy_http::result::SdkError<crate::error::GetDeviceInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the instance you're requesting information
        /// about.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDevicePool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_device_pool_input::Builder,
    }
    impl<C> GetDevicePool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDevicePoolOutput,
            smithy_http::result::SdkError<crate::error::GetDevicePoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The device pool's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDevicePoolCompatibility<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_device_pool_compatibility_input::Builder,
    }
    impl<C> GetDevicePoolCompatibility<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDevicePoolCompatibilityOutput,
            smithy_http::result::SdkError<crate::error::GetDevicePoolCompatibilityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The device pool's ARN.</p>
        pub fn device_pool_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_pool_arn(input);
            self
        }
        pub fn set_device_pool_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_device_pool_arn(input);
            self
        }
        /// <p>The ARN of the app that is associated with the specified device pool.</p>
        pub fn app_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.app_arn(input);
            self
        }
        pub fn set_app_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_app_arn(input);
            self
        }
        /// <p>The test type for the specified device pool.</p>
        /// <p>Allowed values include the following:</p>
        /// <ul>
        /// <li>
        /// <p>BUILTIN_FUZZ.</p>
        /// </li>
        /// <li>
        /// <p>BUILTIN_EXPLORER. For Android, an app explorer that traverses an Android app, interacting with
        /// it and capturing screenshots at the same time.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_JUNIT.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_TESTNG.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_PYTHON.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_NODE.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_RUBY.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_JUNIT.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_TESTNG.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_PYTHON.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_NODE.</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_RUBY.</p>
        /// </li>
        /// <li>
        /// <p>CALABASH.</p>
        /// </li>
        /// <li>
        /// <p>INSTRUMENTATION.</p>
        /// </li>
        /// <li>
        /// <p>UIAUTOMATION.</p>
        /// </li>
        /// <li>
        /// <p>UIAUTOMATOR.</p>
        /// </li>
        /// <li>
        /// <p>XCTEST.</p>
        /// </li>
        /// <li>
        /// <p>XCTEST_UI.</p>
        /// </li>
        /// </ul>
        pub fn test_type(mut self, input: crate::model::TestType) -> Self {
            self.inner = self.inner.test_type(input);
            self
        }
        pub fn set_test_type(mut self, input: std::option::Option<crate::model::TestType>) -> Self {
            self.inner = self.inner.set_test_type(input);
            self
        }
        /// <p>Information about the uploaded test to be run against the device pool.</p>
        pub fn test(mut self, input: crate::model::ScheduleRunTest) -> Self {
            self.inner = self.inner.test(input);
            self
        }
        pub fn set_test(
            mut self,
            input: std::option::Option<crate::model::ScheduleRunTest>,
        ) -> Self {
            self.inner = self.inner.set_test(input);
            self
        }
        /// <p>An object that contains information about the settings for a run.</p>
        pub fn configuration(mut self, input: crate::model::ScheduleRunConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ScheduleRunConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstanceProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_instance_profile_input::Builder,
    }
    impl<C> GetInstanceProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of an instance profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_input::Builder,
    }
    impl<C> GetJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobOutput,
            smithy_http::result::SdkError<crate::error::GetJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The job's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetNetworkProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_network_profile_input::Builder,
    }
    impl<C> GetNetworkProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetNetworkProfileOutput,
            smithy_http::result::SdkError<crate::error::GetNetworkProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the network profile to return information about.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOfferingStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_offering_status_input::Builder,
    }
    impl<C> GetOfferingStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOfferingStatusOutput,
            smithy_http::result::SdkError<crate::error::GetOfferingStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetProject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_project_input::Builder,
    }
    impl<C> GetProject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetProjectOutput,
            smithy_http::result::SdkError<crate::error::GetProjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The project's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRemoteAccessSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_remote_access_session_input::Builder,
    }
    impl<C> GetRemoteAccessSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRemoteAccessSessionOutput,
            smithy_http::result::SdkError<crate::error::GetRemoteAccessSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the remote access session about which you want to
        /// get session information.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_run_input::Builder,
    }
    impl<C> GetRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRunOutput,
            smithy_http::result::SdkError<crate::error::GetRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The run's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSuite<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_suite_input::Builder,
    }
    impl<C> GetSuite<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSuiteOutput,
            smithy_http::result::SdkError<crate::error::GetSuiteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The suite's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_test_input::Builder,
    }
    impl<C> GetTest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTestOutput,
            smithy_http::result::SdkError<crate::error::GetTestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The test's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTestGridProject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_test_grid_project_input::Builder,
    }
    impl<C> GetTestGridProject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTestGridProjectOutput,
            smithy_http::result::SdkError<crate::error::GetTestGridProjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the Selenium testing project, from either <a>CreateTestGridProject</a> or <a>ListTestGridProjects</a>.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTestGridSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_test_grid_session_input::Builder,
    }
    impl<C> GetTestGridSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTestGridSessionOutput,
            smithy_http::result::SdkError<crate::error::GetTestGridSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN for the project that this session belongs to. See <a>CreateTestGridProject</a> and <a>ListTestGridProjects</a>.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>An ID associated with this session.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(input);
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(input);
            self
        }
        /// <p>An ARN that uniquely identifies a <a>TestGridSession</a>.</p>
        pub fn session_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_arn(input);
            self
        }
        pub fn set_session_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetUpload<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_upload_input::Builder,
    }
    impl<C> GetUpload<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetUploadOutput,
            smithy_http::result::SdkError<crate::error::GetUploadError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The upload's ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetVPCEConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_vpce_configuration_input::Builder,
    }
    impl<C> GetVPCEConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetVpceConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetVPCEConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to
        /// describe.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct InstallToRemoteAccessSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::install_to_remote_access_session_input::Builder,
    }
    impl<C> InstallToRemoteAccessSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::InstallToRemoteAccessSessionOutput,
            smithy_http::result::SdkError<crate::error::InstallToRemoteAccessSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the remote access session about which you are
        /// requesting information.</p>
        pub fn remote_access_session_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remote_access_session_arn(input);
            self
        }
        pub fn set_remote_access_session_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remote_access_session_arn(input);
            self
        }
        /// <p>The ARN of the app about which you are requesting information.</p>
        pub fn app_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.app_arn(input);
            self
        }
        pub fn set_app_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_app_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListArtifacts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_artifacts_input::Builder,
    }
    impl<C> ListArtifacts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListArtifactsOutput,
            smithy_http::result::SdkError<crate::error::ListArtifactsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The run, job, suite, or test ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The artifacts' type.</p>
        /// <p>Allowed values include:</p>
        /// <ul>
        /// <li>
        /// <p>FILE</p>
        /// </li>
        /// <li>
        /// <p>LOG</p>
        /// </li>
        /// <li>
        /// <p>SCREENSHOT</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::ArtifactCategory) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ArtifactCategory>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDeviceInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_device_instances_input::Builder,
    }
    impl<C> ListDeviceInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDeviceInstancesOutput,
            smithy_http::result::SdkError<crate::error::ListDeviceInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An integer that specifies the maximum number of items you want to return in the API response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDevicePools<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_device_pools_input::Builder,
    }
    impl<C> ListDevicePools<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDevicePoolsOutput,
            smithy_http::result::SdkError<crate::error::ListDevicePoolsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The project ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The device pools' type.</p>
        /// <p>Allowed values include:</p>
        /// <ul>
        /// <li>
        /// <p>CURATED: A device pool that is created and managed by AWS Device
        /// Farm.</p>
        /// </li>
        /// <li>
        /// <p>PRIVATE: A device pool that is created and managed by the device pool
        /// developer.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::DevicePoolType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DevicePoolType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDevices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_devices_input::Builder,
    }
    impl<C> ListDevices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDevicesOutput,
            smithy_http::result::SdkError<crate::error::ListDevicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Used to select a set of devices. A filter is made up of an attribute, an operator, and
        /// one or more values.</p>
        /// <ul>
        /// <li>
        /// <p>Attribute: The aspect of a device such as platform or model used as the
        /// selection criteria in a device filter.</p>
        /// <p>Allowed values include:</p>
        /// <ul>
        /// <li>
        /// <p>ARN: The Amazon Resource Name (ARN) of the device (for example,
        /// <code>arn:aws:devicefarm:us-west-2::device:12345Example</code>).</p>
        /// </li>
        /// <li>
        /// <p>PLATFORM: The device platform. Valid values are ANDROID or IOS.</p>
        /// </li>
        /// <li>
        /// <p>OS_VERSION: The operating system version (for example, 10.3.2).</p>
        /// </li>
        /// <li>
        /// <p>MODEL: The device model (for example, iPad 5th Gen).</p>
        /// </li>
        /// <li>
        /// <p>AVAILABILITY: The current availability of the device. Valid values are AVAILABLE,
        /// HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.</p>
        /// </li>
        /// <li>
        /// <p>FORM_FACTOR: The device form factor. Valid values are PHONE or TABLET.</p>
        /// </li>
        /// <li>
        /// <p>MANUFACTURER: The device manufacturer (for example, Apple).</p>
        /// </li>
        /// <li>
        /// <p>REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access. Valid values
        /// are TRUE or FALSE.</p>
        /// </li>
        /// <li>
        /// <p>REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values
        /// are TRUE or FALSE. Because remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no
        /// longer supported</a>, this attribute is ignored.</p>
        /// </li>
        /// <li>
        /// <p>INSTANCE_ARN: The Amazon Resource Name (ARN) of the device
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>INSTANCE_LABELS: The label of the device instance.</p>
        /// </li>
        /// <li>
        /// <p>FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Operator: The filter operator.</p>
        /// <ul>
        /// <li>
        /// <p>The EQUALS operator is available for every attribute except
        /// INSTANCE_LABELS.</p>
        /// </li>
        /// <li>
        /// <p>The CONTAINS operator is available for the INSTANCE_LABELS and MODEL
        /// attributes.</p>
        /// </li>
        /// <li>
        /// <p>The IN and NOT_IN operators are available for the ARN, OS_VERSION,
        /// MODEL, MANUFACTURER, and INSTANCE_ARN attributes.</p>
        /// </li>
        /// <li>
        /// <p>The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and
        /// GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION
        /// attribute.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>Values: An array of one or more filter values.</p>
        /// <ul>
        /// <li>
        /// <p>The IN and NOT_IN operators take a values array that has one or more
        /// elements.</p>
        /// </li>
        /// <li>
        /// <p>The other operators require an array with a single element.</p>
        /// </li>
        /// <li>
        /// <p>In a request, the AVAILABILITY attribute takes the following values: AVAILABLE,
        /// HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::DeviceFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeviceFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInstanceProfiles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_instance_profiles_input::Builder,
    }
    impl<C> ListInstanceProfiles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListInstanceProfilesOutput,
            smithy_http::result::SdkError<crate::error::ListInstanceProfilesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An integer that specifies the maximum number of items you want to return in the API response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_jobs_input::Builder,
    }
    impl<C> ListJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobsOutput,
            smithy_http::result::SdkError<crate::error::ListJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The run's Amazon Resource Name (ARN).</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListNetworkProfiles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_network_profiles_input::Builder,
    }
    impl<C> ListNetworkProfiles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListNetworkProfilesOutput,
            smithy_http::result::SdkError<crate::error::ListNetworkProfilesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project for which you want to list network
        /// profiles.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The type of network profile to return information about. Valid values are listed here.</p>
        pub fn r#type(mut self, input: crate::model::NetworkProfileType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::NetworkProfileType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOfferingPromotions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_offering_promotions_input::Builder,
    }
    impl<C> ListOfferingPromotions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOfferingPromotionsOutput,
            smithy_http::result::SdkError<crate::error::ListOfferingPromotionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOfferings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_offerings_input::Builder,
    }
    impl<C> ListOfferings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOfferingsOutput,
            smithy_http::result::SdkError<crate::error::ListOfferingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOfferingTransactions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_offering_transactions_input::Builder,
    }
    impl<C> ListOfferingTransactions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOfferingTransactionsOutput,
            smithy_http::result::SdkError<crate::error::ListOfferingTransactionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListProjects<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_projects_input::Builder,
    }
    impl<C> ListProjects<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListProjectsOutput,
            smithy_http::result::SdkError<crate::error::ListProjectsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm
        /// returns a list of all projects for the AWS account. You can also specify a project
        /// ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRemoteAccessSessions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_remote_access_sessions_input::Builder,
    }
    impl<C> ListRemoteAccessSessions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRemoteAccessSessionsOutput,
            smithy_http::result::SdkError<crate::error::ListRemoteAccessSessionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project about which you are requesting
        /// information.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRuns<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_runs_input::Builder,
    }
    impl<C> ListRuns<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRunsOutput,
            smithy_http::result::SdkError<crate::error::ListRunsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project for which you want to list
        /// runs.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSamples<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_samples_input::Builder,
    }
    impl<C> ListSamples<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSamplesOutput,
            smithy_http::result::SdkError<crate::error::ListSamplesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the job used to list samples.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSuites<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_suites_input::Builder,
    }
    impl<C> ListSuites<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSuitesOutput,
            smithy_http::result::SdkError<crate::error::ListSuitesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The job's Amazon Resource Name (ARN).</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource or resources for which to list tags. You can associate tags
        /// with the following Device Farm resources: <code>PROJECT</code>, <code>RUN</code>,
        /// <code>NETWORK_PROFILE</code>, <code>INSTANCE_PROFILE</code>, <code>DEVICE_INSTANCE</code>,
        /// <code>SESSION</code>, <code>DEVICE_POOL</code>, <code>DEVICE</code>, and
        /// <code>VPCE_CONFIGURATION</code>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTestGridProjects<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_test_grid_projects_input::Builder,
    }
    impl<C> ListTestGridProjects<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTestGridProjectsOutput,
            smithy_http::result::SdkError<crate::error::ListTestGridProjectsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Return no more than this number of results.</p>
        pub fn max_result(mut self, input: i32) -> Self {
            self.inner = self.inner.max_result(input);
            self
        }
        pub fn set_max_result(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_result(input);
            self
        }
        /// <p>From a response, used to continue a paginated listing. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTestGridSessionActions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_test_grid_session_actions_input::Builder,
    }
    impl<C> ListTestGridSessionActions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTestGridSessionActionsOutput,
            smithy_http::result::SdkError<crate::error::ListTestGridSessionActionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the session to retrieve.</p>
        pub fn session_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_arn(input);
            self
        }
        pub fn set_session_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_arn(input);
            self
        }
        /// <p>The maximum number of sessions to return per response.</p>
        pub fn max_result(mut self, input: i32) -> Self {
            self.inner = self.inner.max_result(input);
            self
        }
        pub fn set_max_result(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_result(input);
            self
        }
        /// <p>Pagination token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTestGridSessionArtifacts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_test_grid_session_artifacts_input::Builder,
    }
    impl<C> ListTestGridSessionArtifacts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTestGridSessionArtifactsOutput,
            smithy_http::result::SdkError<crate::error::ListTestGridSessionArtifactsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of a <a>TestGridSession</a>. </p>
        pub fn session_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_arn(input);
            self
        }
        pub fn set_session_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_arn(input);
            self
        }
        /// <p>Limit results to a specified type of artifact.</p>
        pub fn r#type(mut self, input: crate::model::TestGridSessionArtifactCategory) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::TestGridSessionArtifactCategory>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The maximum number of results to be returned by a request.</p>
        pub fn max_result(mut self, input: i32) -> Self {
            self.inner = self.inner.max_result(input);
            self
        }
        pub fn set_max_result(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_result(input);
            self
        }
        /// <p>Pagination token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTestGridSessions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_test_grid_sessions_input::Builder,
    }
    impl<C> ListTestGridSessions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTestGridSessionsOutput,
            smithy_http::result::SdkError<crate::error::ListTestGridSessionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ARN of a <a>TestGridProject</a>.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>Return only sessions in this state.</p>
        pub fn status(mut self, input: crate::model::TestGridSessionStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TestGridSessionStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>Return only sessions created after this time.</p>
        pub fn creation_time_after(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.creation_time_after(input);
            self
        }
        pub fn set_creation_time_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_creation_time_after(input);
            self
        }
        /// <p>Return only  sessions created before this time.</p>
        pub fn creation_time_before(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.creation_time_before(input);
            self
        }
        pub fn set_creation_time_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_creation_time_before(input);
            self
        }
        /// <p>Return only sessions that ended after this time.</p>
        pub fn end_time_after(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time_after(input);
            self
        }
        pub fn set_end_time_after(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_end_time_after(input);
            self
        }
        /// <p>Return only sessions that ended before this time.</p>
        pub fn end_time_before(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time_before(input);
            self
        }
        pub fn set_end_time_before(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_end_time_before(input);
            self
        }
        /// <p>Return only this many results at a time.</p>
        pub fn max_result(mut self, input: i32) -> Self {
            self.inner = self.inner.max_result(input);
            self
        }
        pub fn set_max_result(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_result(input);
            self
        }
        /// <p>Pagination token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTests<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tests_input::Builder,
    }
    impl<C> ListTests<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTestsOutput,
            smithy_http::result::SdkError<crate::error::ListTestsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The test suite's Amazon Resource Name (ARN).</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListUniqueProblems<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_unique_problems_input::Builder,
    }
    impl<C> ListUniqueProblems<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListUniqueProblemsOutput,
            smithy_http::result::SdkError<crate::error::ListUniqueProblemsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique problems' ARNs.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListUploads<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_uploads_input::Builder,
    }
    impl<C> ListUploads<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListUploadsOutput,
            smithy_http::result::SdkError<crate::error::ListUploadsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project for which you want to list
        /// uploads.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The type of upload.</p>
        /// <p>Must be one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>ANDROID_APP</p>
        /// </li>
        /// <li>
        /// <p>IOS_APP</p>
        /// </li>
        /// <li>
        /// <p>WEB_APP</p>
        /// </li>
        /// <li>
        /// <p>EXTERNAL_DATA</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_JUNIT_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_TESTNG_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_PYTHON_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_NODE_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_RUBY_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_PYTHON_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_NODE_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_RUBY_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>CALABASH_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>INSTRUMENTATION_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>UIAUTOMATION_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>UIAUTOMATOR_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>XCTEST_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>XCTEST_UI_TEST_PACKAGE</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_JUNIT_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_JAVA_TESTNG_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_PYTHON_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_NODE_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p> APPIUM_RUBY_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_JUNIT_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_JAVA_TESTNG_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_PYTHON_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_NODE_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>APPIUM_WEB_RUBY_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>INSTRUMENTATION_TEST_SPEC</p>
        /// </li>
        /// <li>
        /// <p>XCTEST_UI_TEST_SPEC</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::UploadType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::UploadType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can
        /// be used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVPCEConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_vpce_configurations_input::Builder,
    }
    impl<C> ListVPCEConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListVpceConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListVPCEConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An integer that specifies the maximum number of items you want to return in the API response.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PurchaseOffering<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::purchase_offering_input::Builder,
    }
    impl<C> PurchaseOffering<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PurchaseOfferingOutput,
            smithy_http::result::SdkError<crate::error::PurchaseOfferingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the offering.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_id(input);
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_offering_id(input);
            self
        }
        /// <p>The number of device slots to purchase in an offering request.</p>
        pub fn quantity(mut self, input: i32) -> Self {
            self.inner = self.inner.quantity(input);
            self
        }
        pub fn set_quantity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_quantity(input);
            self
        }
        /// <p>The ID of the offering promotion to be applied to the purchase.</p>
        pub fn offering_promotion_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_promotion_id(input);
            self
        }
        pub fn set_offering_promotion_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_offering_promotion_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RenewOffering<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::renew_offering_input::Builder,
    }
    impl<C> RenewOffering<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RenewOfferingOutput,
            smithy_http::result::SdkError<crate::error::RenewOfferingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of a request to renew an offering.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_id(input);
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_offering_id(input);
            self
        }
        /// <p>The quantity requested in an offering renewal.</p>
        pub fn quantity(mut self, input: i32) -> Self {
            self.inner = self.inner.quantity(input);
            self
        }
        pub fn set_quantity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_quantity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ScheduleRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::schedule_run_input::Builder,
    }
    impl<C> ScheduleRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ScheduleRunOutput,
            smithy_http::result::SdkError<crate::error::ScheduleRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the project for the run to be scheduled.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>The ARN of an application package to run tests against, created with <a>CreateUpload</a>.
        /// See <a>ListUploads</a>.</p>
        pub fn app_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.app_arn(input);
            self
        }
        pub fn set_app_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_app_arn(input);
            self
        }
        /// <p>The ARN of the device pool for the run to be scheduled.</p>
        pub fn device_pool_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_pool_arn(input);
            self
        }
        pub fn set_device_pool_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_device_pool_arn(input);
            self
        }
        /// <p>The filter criteria used to dynamically select a set of devices for a test run and the maximum number of
        /// devices to be included in the run.</p>
        /// <p>Either <b>
        /// <code>devicePoolArn</code>
        /// </b> or <b>
        /// <code>deviceSelectionConfiguration</code>
        /// </b> is required in a
        /// request.</p>
        pub fn device_selection_configuration(
            mut self,
            input: crate::model::DeviceSelectionConfiguration,
        ) -> Self {
            self.inner = self.inner.device_selection_configuration(input);
            self
        }
        pub fn set_device_selection_configuration(
            mut self,
            input: std::option::Option<crate::model::DeviceSelectionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_device_selection_configuration(input);
            self
        }
        /// <p>The name for the run to be scheduled.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Information about the test for the run to be scheduled.</p>
        pub fn test(mut self, input: crate::model::ScheduleRunTest) -> Self {
            self.inner = self.inner.test(input);
            self
        }
        pub fn set_test(
            mut self,
            input: std::option::Option<crate::model::ScheduleRunTest>,
        ) -> Self {
            self.inner = self.inner.set_test(input);
            self
        }
        /// <p>Information about the settings for the run to be scheduled.</p>
        pub fn configuration(mut self, input: crate::model::ScheduleRunConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ScheduleRunConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>Specifies configuration information about a test run, such as the execution timeout
        /// (in minutes).</p>
        pub fn execution_configuration(
            mut self,
            input: crate::model::ExecutionConfiguration,
        ) -> Self {
            self.inner = self.inner.execution_configuration(input);
            self
        }
        pub fn set_execution_configuration(
            mut self,
            input: std::option::Option<crate::model::ExecutionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_execution_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_job_input::Builder,
    }
    impl<C> StopJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopJobOutput,
            smithy_http::result::SdkError<crate::error::StopJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm job to stop.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopRemoteAccessSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_remote_access_session_input::Builder,
    }
    impl<C> StopRemoteAccessSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopRemoteAccessSessionOutput,
            smithy_http::result::SdkError<crate::error::StopRemoteAccessSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the remote access session to stop.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopRun<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_run_input::Builder,
    }
    impl<C> StopRun<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopRunOutput,
            smithy_http::result::SdkError<crate::error::StopRunError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Represents the Amazon Resource Name (ARN) of the Device Farm run to stop.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource or resources to which to add tags. You can associate tags
        /// with the following Device Farm resources: <code>PROJECT</code>, <code>RUN</code>,
        /// <code>NETWORK_PROFILE</code>, <code>INSTANCE_PROFILE</code>, <code>DEVICE_INSTANCE</code>,
        /// <code>SESSION</code>, <code>DEVICE_POOL</code>, <code>DEVICE</code>, and
        /// <code>VPCE_CONFIGURATION</code>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum
        /// character length of 128 characters. Tag values can have a maximum length of 256 characters.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource or resources from which to delete tags. You can associate
        /// tags with the following Device Farm resources: <code>PROJECT</code>, <code>RUN</code>,
        /// <code>NETWORK_PROFILE</code>, <code>INSTANCE_PROFILE</code>, <code>DEVICE_INSTANCE</code>,
        /// <code>SESSION</code>, <code>DEVICE_POOL</code>, <code>DEVICE</code>, and
        /// <code>VPCE_CONFIGURATION</code>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The keys of the tags to be removed.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDeviceInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_device_instance_input::Builder,
    }
    impl<C> UpdateDeviceInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDeviceInstanceOutput,
            smithy_http::result::SdkError<crate::error::UpdateDeviceInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the device instance.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The ARN of the profile that you want to associate with the device instance.</p>
        pub fn profile_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.profile_arn(input);
            self
        }
        pub fn set_profile_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_profile_arn(input);
            self
        }
        /// <p>An array of strings that you want to associate with the device instance.</p>
        pub fn labels(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.labels(inp);
            self
        }
        pub fn set_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_labels(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDevicePool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_device_pool_input::Builder,
    }
    impl<C> UpdateDevicePool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDevicePoolOutput,
            smithy_http::result::SdkError<crate::error::UpdateDevicePoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the Device Farm device pool to update.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>A string that represents the name of the device pool to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A description of the device pool to update.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Represents the rules to modify for the device pool. Updating rules is optional. If you update rules for
        /// your request, the update replaces the existing rules.</p>
        pub fn rules(mut self, inp: impl Into<crate::model::Rule>) -> Self {
            self.inner = self.inner.rules(inp);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Rule>>,
        ) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>The number of devices that Device Farm can add to your device pool. Device Farm adds
        /// devices that are available and that meet the criteria that you assign for the
        /// <code>rules</code> parameter. Depending on how many devices meet these constraints,
        /// your device pool might contain fewer devices than the value for this parameter.</p>
        /// <p>By specifying the maximum number of devices, you can control the costs that you incur
        /// by running tests.</p>
        /// <p>If you use this parameter in your request, you cannot use the
        /// <code>clearMaxDevices</code> parameter in the same request.</p>
        pub fn max_devices(mut self, input: i32) -> Self {
            self.inner = self.inner.max_devices(input);
            self
        }
        pub fn set_max_devices(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_devices(input);
            self
        }
        /// <p>Sets whether the <code>maxDevices</code> parameter applies to your device pool. If you set this parameter
        /// to <code>true</code>, the <code>maxDevices</code> parameter does not apply, and Device Farm does not limit
        /// the number of devices that it adds to your device pool. In this case, Device Farm adds all available devices
        /// that meet the criteria specified in the <code>rules</code> parameter.</p>
        /// <p>If you use this parameter in your request, you cannot use the <code>maxDevices</code>
        /// parameter in the same request.</p>
        pub fn clear_max_devices(mut self, input: bool) -> Self {
            self.inner = self.inner.clear_max_devices(input);
            self
        }
        pub fn set_clear_max_devices(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_clear_max_devices(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateInstanceProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_instance_profile_input::Builder,
    }
    impl<C> UpdateInstanceProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::UpdateInstanceProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the instance profile.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The updated name for your instance profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The updated description for your instance profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The updated choice for whether you want to specify package cleanup. The default value
        /// is <code>false</code> for private devices.</p>
        pub fn package_cleanup(mut self, input: bool) -> Self {
            self.inner = self.inner.package_cleanup(input);
            self
        }
        pub fn set_package_cleanup(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_package_cleanup(input);
            self
        }
        /// <p>An array of strings that specifies the list of app packages that should not be cleaned up from the device
        /// after a test run is over.</p>
        /// <p>The list of packages is only considered if you set <code>packageCleanup</code> to
        /// <code>true</code>.</p>
        pub fn exclude_app_packages_from_cleanup(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.exclude_app_packages_from_cleanup(inp);
            self
        }
        pub fn set_exclude_app_packages_from_cleanup(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_exclude_app_packages_from_cleanup(input);
            self
        }
        /// <p>The updated choice for whether you want to reboot the device after use. The default
        /// value is <code>true</code>.</p>
        pub fn reboot_after_use(mut self, input: bool) -> Self {
            self.inner = self.inner.reboot_after_use(input);
            self
        }
        pub fn set_reboot_after_use(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reboot_after_use(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateNetworkProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_network_profile_input::Builder,
    }
    impl<C> UpdateNetworkProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateNetworkProfileOutput,
            smithy_http::result::SdkError<crate::error::UpdateNetworkProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project for which you want to update network
        /// profile settings.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The name of the network profile about which you are returning
        /// information.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The description of the network profile about which you are returning
        /// information.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The type of network profile to return information about. Valid values are listed here.</p>
        pub fn r#type(mut self, input: crate::model::NetworkProfileType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::NetworkProfileType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The data throughput rate in bits per second, as an integer from 0 to
        /// 104857600.</p>
        pub fn uplink_bandwidth_bits(mut self, input: i64) -> Self {
            self.inner = self.inner.uplink_bandwidth_bits(input);
            self
        }
        pub fn set_uplink_bandwidth_bits(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_uplink_bandwidth_bits(input);
            self
        }
        /// <p>The data throughput rate in bits per second, as an integer from 0 to
        /// 104857600.</p>
        pub fn downlink_bandwidth_bits(mut self, input: i64) -> Self {
            self.inner = self.inner.downlink_bandwidth_bits(input);
            self
        }
        pub fn set_downlink_bandwidth_bits(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_downlink_bandwidth_bits(input);
            self
        }
        /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
        /// 2000.</p>
        pub fn uplink_delay_ms(mut self, input: i64) -> Self {
            self.inner = self.inner.uplink_delay_ms(input);
            self
        }
        pub fn set_uplink_delay_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_uplink_delay_ms(input);
            self
        }
        /// <p>Delay time for all packets to destination in milliseconds as an integer from 0 to
        /// 2000.</p>
        pub fn downlink_delay_ms(mut self, input: i64) -> Self {
            self.inner = self.inner.downlink_delay_ms(input);
            self
        }
        pub fn set_downlink_delay_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_downlink_delay_ms(input);
            self
        }
        /// <p>Time variation in the delay of received packets in milliseconds as an integer from
        /// 0 to 2000.</p>
        pub fn uplink_jitter_ms(mut self, input: i64) -> Self {
            self.inner = self.inner.uplink_jitter_ms(input);
            self
        }
        pub fn set_uplink_jitter_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_uplink_jitter_ms(input);
            self
        }
        /// <p>Time variation in the delay of received packets in milliseconds as an integer from
        /// 0 to 2000.</p>
        pub fn downlink_jitter_ms(mut self, input: i64) -> Self {
            self.inner = self.inner.downlink_jitter_ms(input);
            self
        }
        pub fn set_downlink_jitter_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_downlink_jitter_ms(input);
            self
        }
        /// <p>Proportion of transmitted packets that fail to arrive from 0 to 100
        /// percent.</p>
        pub fn uplink_loss_percent(mut self, input: i32) -> Self {
            self.inner = self.inner.uplink_loss_percent(input);
            self
        }
        pub fn set_uplink_loss_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_uplink_loss_percent(input);
            self
        }
        /// <p>Proportion of received packets that fail to arrive from 0 to 100 percent.</p>
        pub fn downlink_loss_percent(mut self, input: i32) -> Self {
            self.inner = self.inner.downlink_loss_percent(input);
            self
        }
        pub fn set_downlink_loss_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_downlink_loss_percent(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateProject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_project_input::Builder,
    }
    impl<C> UpdateProject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateProjectOutput,
            smithy_http::result::SdkError<crate::error::UpdateProjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the project whose name to update.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>A string that represents the new name of the project that you are updating.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The number of minutes a test run in the project executes before it times out.</p>
        pub fn default_job_timeout_minutes(mut self, input: i32) -> Self {
            self.inner = self.inner.default_job_timeout_minutes(input);
            self
        }
        pub fn set_default_job_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_default_job_timeout_minutes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateTestGridProject<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_test_grid_project_input::Builder,
    }
    impl<C> UpdateTestGridProject<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTestGridProjectOutput,
            smithy_http::result::SdkError<crate::error::UpdateTestGridProjectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ARN of the project to update.</p>
        pub fn project_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.project_arn(input);
            self
        }
        pub fn set_project_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_project_arn(input);
            self
        }
        /// <p>Human-readable name for the project.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Human-readable description for the project.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The VPC security groups and subnets that are attached to a project.</p>
        pub fn vpc_config(mut self, input: crate::model::TestGridVpcConfig) -> Self {
            self.inner = self.inner.vpc_config(input);
            self
        }
        pub fn set_vpc_config(
            mut self,
            input: std::option::Option<crate::model::TestGridVpcConfig>,
        ) -> Self {
            self.inner = self.inner.set_vpc_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateUpload<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_upload_input::Builder,
    }
    impl<C> UpdateUpload<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateUploadOutput,
            smithy_http::result::SdkError<crate::error::UpdateUploadError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the uploaded test spec.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The upload's test spec file name. The name must not contain any forward slashes (/). The test spec file
        /// name must end with the <code>.yaml</code> or <code>.yml</code> file extension.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The upload's content type (for example, <code>application/x-yaml</code>).</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content_type(input);
            self
        }
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content_type(input);
            self
        }
        /// <p>Set to true if the YAML file has changed and must be updated. Otherwise, set to false.</p>
        pub fn edit_content(mut self, input: bool) -> Self {
            self.inner = self.inner.edit_content(input);
            self
        }
        pub fn set_edit_content(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_edit_content(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateVPCEConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_vpce_configuration_input::Builder,
    }
    impl<C> UpdateVPCEConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateVpceConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateVPCEConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to
        /// update.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The friendly name you give to your VPC endpoint configuration to manage your configurations more
        /// easily.</p>
        pub fn vpce_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpce_configuration_name(input);
            self
        }
        pub fn set_vpce_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpce_configuration_name(input);
            self
        }
        /// <p>The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.</p>
        pub fn vpce_service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpce_service_name(input);
            self
        }
        pub fn set_vpce_service_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpce_service_name(input);
            self
        }
        /// <p>The DNS (domain) name used to connect to your private service in your VPC. The DNS name must not already
        /// be in use on the internet.</p>
        pub fn service_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_dns_name(input);
            self
        }
        pub fn set_service_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_dns_name(input);
            self
        }
        /// <p>An optional description that provides details about your VPC endpoint configuration.</p>
        pub fn vpce_configuration_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.vpce_configuration_description(input);
            self
        }
        pub fn set_vpce_configuration_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpce_configuration_description(input);
            self
        }
    }
}
