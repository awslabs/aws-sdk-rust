// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a test run on a set of devices with a given app package, test parameters, and so on.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Run {
    /// <p>The run's ARN.</p>
    pub arn: ::std::option::Option<::std::string::String>,
    /// <p>The run's name.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The run's type.</p>
    /// <p>Must be one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>BUILTIN_FUZZ</p></li>
    /// <li>
    /// <p>BUILTIN_EXPLORER</p><note>
    /// <p>For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.</p>
    /// </note></li>
    /// <li>
    /// <p>APPIUM_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_NODE</p></li>
    /// <li>
    /// <p>APPIUM_RUBY</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_WEB_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_WEB_NODE</p></li>
    /// <li>
    /// <p>APPIUM_WEB_RUBY</p></li>
    /// <li>
    /// <p>CALABASH</p></li>
    /// <li>
    /// <p>INSTRUMENTATION</p></li>
    /// <li>
    /// <p>UIAUTOMATION</p></li>
    /// <li>
    /// <p>UIAUTOMATOR</p></li>
    /// <li>
    /// <p>XCTEST</p></li>
    /// <li>
    /// <p>XCTEST_UI</p></li>
    /// </ul>
    pub r#type: ::std::option::Option<crate::types::TestType>,
    /// <p>The run's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>ANDROID</p></li>
    /// <li>
    /// <p>IOS</p></li>
    /// </ul>
    pub platform: ::std::option::Option<crate::types::DevicePlatform>,
    /// <p>When the run was created.</p>
    pub created: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The run's status.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PENDING_CONCURRENCY</p></li>
    /// <li>
    /// <p>PENDING_DEVICE</p></li>
    /// <li>
    /// <p>PROCESSING</p></li>
    /// <li>
    /// <p>SCHEDULING</p></li>
    /// <li>
    /// <p>PREPARING</p></li>
    /// <li>
    /// <p>RUNNING</p></li>
    /// <li>
    /// <p>COMPLETED</p></li>
    /// <li>
    /// <p>STOPPING</p></li>
    /// </ul>
    pub status: ::std::option::Option<crate::types::ExecutionStatus>,
    /// <p>The run's result.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PASSED</p></li>
    /// <li>
    /// <p>WARNED</p></li>
    /// <li>
    /// <p>FAILED</p></li>
    /// <li>
    /// <p>SKIPPED</p></li>
    /// <li>
    /// <p>ERRORED</p></li>
    /// <li>
    /// <p>STOPPED</p></li>
    /// </ul>
    pub result: ::std::option::Option<crate::types::ExecutionResult>,
    /// <p>The run's start time.</p>
    pub started: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The run's stop time.</p>
    pub stopped: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The run's result counters.</p>
    pub counters: ::std::option::Option<crate::types::Counters>,
    /// <p>A message about the run's result.</p>
    pub message: ::std::option::Option<::std::string::String>,
    /// <p>The total number of jobs for the run.</p>
    pub total_jobs: ::std::option::Option<i32>,
    /// <p>The total number of completed jobs.</p>
    pub completed_jobs: ::std::option::Option<i32>,
    /// <p>Specifies the billing method for a test run: <code>metered</code> or <code>unmetered</code>. If the parameter is not specified, the default value is <code>metered</code>.</p><note>
    /// <p>If you have unmetered device slots, you must set this to <code>unmetered</code> to use them. Otherwise, the run is counted toward metered device minutes.</p>
    /// </note>
    pub billing_method: ::std::option::Option<crate::types::BillingMethod>,
    /// <p>Represents the total (metered or unmetered) minutes used by the test run.</p>
    pub device_minutes: ::std::option::Option<crate::types::DeviceMinutes>,
    /// <p>The network profile being used for a test run.</p>
    pub network_profile: ::std::option::Option<crate::types::NetworkProfile>,
    /// <p>Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package. If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points to.</p>
    pub parsing_result_url: ::std::option::Option<::std::string::String>,
    /// <p>Supporting field for the result field. Set only if <code>result</code> is <code>SKIPPED</code>. <code>PARSING_FAILED</code> if the result is skipped because of test package parsing failure.</p>
    pub result_code: ::std::option::Option<crate::types::ExecutionResultCode>,
    /// <p>For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.</p>
    pub seed: ::std::option::Option<i32>,
    /// <p>An app to upload or that has been uploaded.</p>
    pub app_upload: ::std::option::Option<::std::string::String>,
    /// <p>For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz test should perform.</p>
    pub event_count: ::std::option::Option<i32>,
    /// <p>The number of minutes the job executes before it times out.</p>
    pub job_timeout_minutes: ::std::option::Option<i32>,
    /// <p>The ARN of the device pool for the run.</p>
    pub device_pool_arn: ::std::option::Option<::std::string::String>,
    /// <p>Information about the locale that is used for the run.</p>
    pub locale: ::std::option::Option<::std::string::String>,
    /// <p>Information about the radio states for the run.</p>
    pub radios: ::std::option::Option<crate::types::Radios>,
    /// <p>Information about the location that is used for the run.</p>
    pub location: ::std::option::Option<crate::types::Location>,
    /// <p>Output <code>CustomerArtifactPaths</code> object for the test run.</p>
    pub customer_artifact_paths: ::std::option::Option<crate::types::CustomerArtifactPaths>,
    /// <p>The Device Farm console URL for the recording of the run.</p>
    pub web_url: ::std::option::Option<::std::string::String>,
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again.</p>
    /// <p>For more information about how Device Farm re-signs your apps, see <a href="http://aws.amazon.com/device-farm/faqs/">Do you modify my app?</a> in the <i>AWS Device Farm FAQs</i>.</p>
    pub skip_app_resign: ::std::option::Option<bool>,
    /// <p>The ARN of the YAML-formatted test specification for the run.</p>
    pub test_spec_arn: ::std::option::Option<::std::string::String>,
    /// <p>The results of a device filter used to select the devices for a test run.</p>
    pub device_selection_result: ::std::option::Option<crate::types::DeviceSelectionResult>,
    /// <p>The VPC security groups and subnets that are attached to a project.</p>
    pub vpc_config: ::std::option::Option<crate::types::VpcConfig>,
}
impl Run {
    /// <p>The run's ARN.</p>
    pub fn arn(&self) -> ::std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The run's name.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The run's type.</p>
    /// <p>Must be one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>BUILTIN_FUZZ</p></li>
    /// <li>
    /// <p>BUILTIN_EXPLORER</p><note>
    /// <p>For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.</p>
    /// </note></li>
    /// <li>
    /// <p>APPIUM_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_NODE</p></li>
    /// <li>
    /// <p>APPIUM_RUBY</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_WEB_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_WEB_NODE</p></li>
    /// <li>
    /// <p>APPIUM_WEB_RUBY</p></li>
    /// <li>
    /// <p>CALABASH</p></li>
    /// <li>
    /// <p>INSTRUMENTATION</p></li>
    /// <li>
    /// <p>UIAUTOMATION</p></li>
    /// <li>
    /// <p>UIAUTOMATOR</p></li>
    /// <li>
    /// <p>XCTEST</p></li>
    /// <li>
    /// <p>XCTEST_UI</p></li>
    /// </ul>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::TestType> {
        self.r#type.as_ref()
    }
    /// <p>The run's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>ANDROID</p></li>
    /// <li>
    /// <p>IOS</p></li>
    /// </ul>
    pub fn platform(&self) -> ::std::option::Option<&crate::types::DevicePlatform> {
        self.platform.as_ref()
    }
    /// <p>When the run was created.</p>
    pub fn created(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created.as_ref()
    }
    /// <p>The run's status.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PENDING_CONCURRENCY</p></li>
    /// <li>
    /// <p>PENDING_DEVICE</p></li>
    /// <li>
    /// <p>PROCESSING</p></li>
    /// <li>
    /// <p>SCHEDULING</p></li>
    /// <li>
    /// <p>PREPARING</p></li>
    /// <li>
    /// <p>RUNNING</p></li>
    /// <li>
    /// <p>COMPLETED</p></li>
    /// <li>
    /// <p>STOPPING</p></li>
    /// </ul>
    pub fn status(&self) -> ::std::option::Option<&crate::types::ExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>The run's result.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PASSED</p></li>
    /// <li>
    /// <p>WARNED</p></li>
    /// <li>
    /// <p>FAILED</p></li>
    /// <li>
    /// <p>SKIPPED</p></li>
    /// <li>
    /// <p>ERRORED</p></li>
    /// <li>
    /// <p>STOPPED</p></li>
    /// </ul>
    pub fn result(&self) -> ::std::option::Option<&crate::types::ExecutionResult> {
        self.result.as_ref()
    }
    /// <p>The run's start time.</p>
    pub fn started(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.started.as_ref()
    }
    /// <p>The run's stop time.</p>
    pub fn stopped(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.stopped.as_ref()
    }
    /// <p>The run's result counters.</p>
    pub fn counters(&self) -> ::std::option::Option<&crate::types::Counters> {
        self.counters.as_ref()
    }
    /// <p>A message about the run's result.</p>
    pub fn message(&self) -> ::std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The total number of jobs for the run.</p>
    pub fn total_jobs(&self) -> ::std::option::Option<i32> {
        self.total_jobs
    }
    /// <p>The total number of completed jobs.</p>
    pub fn completed_jobs(&self) -> ::std::option::Option<i32> {
        self.completed_jobs
    }
    /// <p>Specifies the billing method for a test run: <code>metered</code> or <code>unmetered</code>. If the parameter is not specified, the default value is <code>metered</code>.</p><note>
    /// <p>If you have unmetered device slots, you must set this to <code>unmetered</code> to use them. Otherwise, the run is counted toward metered device minutes.</p>
    /// </note>
    pub fn billing_method(&self) -> ::std::option::Option<&crate::types::BillingMethod> {
        self.billing_method.as_ref()
    }
    /// <p>Represents the total (metered or unmetered) minutes used by the test run.</p>
    pub fn device_minutes(&self) -> ::std::option::Option<&crate::types::DeviceMinutes> {
        self.device_minutes.as_ref()
    }
    /// <p>The network profile being used for a test run.</p>
    pub fn network_profile(&self) -> ::std::option::Option<&crate::types::NetworkProfile> {
        self.network_profile.as_ref()
    }
    /// <p>Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package. If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points to.</p>
    pub fn parsing_result_url(&self) -> ::std::option::Option<&str> {
        self.parsing_result_url.as_deref()
    }
    /// <p>Supporting field for the result field. Set only if <code>result</code> is <code>SKIPPED</code>. <code>PARSING_FAILED</code> if the result is skipped because of test package parsing failure.</p>
    pub fn result_code(&self) -> ::std::option::Option<&crate::types::ExecutionResultCode> {
        self.result_code.as_ref()
    }
    /// <p>For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.</p>
    pub fn seed(&self) -> ::std::option::Option<i32> {
        self.seed
    }
    /// <p>An app to upload or that has been uploaded.</p>
    pub fn app_upload(&self) -> ::std::option::Option<&str> {
        self.app_upload.as_deref()
    }
    /// <p>For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz test should perform.</p>
    pub fn event_count(&self) -> ::std::option::Option<i32> {
        self.event_count
    }
    /// <p>The number of minutes the job executes before it times out.</p>
    pub fn job_timeout_minutes(&self) -> ::std::option::Option<i32> {
        self.job_timeout_minutes
    }
    /// <p>The ARN of the device pool for the run.</p>
    pub fn device_pool_arn(&self) -> ::std::option::Option<&str> {
        self.device_pool_arn.as_deref()
    }
    /// <p>Information about the locale that is used for the run.</p>
    pub fn locale(&self) -> ::std::option::Option<&str> {
        self.locale.as_deref()
    }
    /// <p>Information about the radio states for the run.</p>
    pub fn radios(&self) -> ::std::option::Option<&crate::types::Radios> {
        self.radios.as_ref()
    }
    /// <p>Information about the location that is used for the run.</p>
    pub fn location(&self) -> ::std::option::Option<&crate::types::Location> {
        self.location.as_ref()
    }
    /// <p>Output <code>CustomerArtifactPaths</code> object for the test run.</p>
    pub fn customer_artifact_paths(&self) -> ::std::option::Option<&crate::types::CustomerArtifactPaths> {
        self.customer_artifact_paths.as_ref()
    }
    /// <p>The Device Farm console URL for the recording of the run.</p>
    pub fn web_url(&self) -> ::std::option::Option<&str> {
        self.web_url.as_deref()
    }
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again.</p>
    /// <p>For more information about how Device Farm re-signs your apps, see <a href="http://aws.amazon.com/device-farm/faqs/">Do you modify my app?</a> in the <i>AWS Device Farm FAQs</i>.</p>
    pub fn skip_app_resign(&self) -> ::std::option::Option<bool> {
        self.skip_app_resign
    }
    /// <p>The ARN of the YAML-formatted test specification for the run.</p>
    pub fn test_spec_arn(&self) -> ::std::option::Option<&str> {
        self.test_spec_arn.as_deref()
    }
    /// <p>The results of a device filter used to select the devices for a test run.</p>
    pub fn device_selection_result(&self) -> ::std::option::Option<&crate::types::DeviceSelectionResult> {
        self.device_selection_result.as_ref()
    }
    /// <p>The VPC security groups and subnets that are attached to a project.</p>
    pub fn vpc_config(&self) -> ::std::option::Option<&crate::types::VpcConfig> {
        self.vpc_config.as_ref()
    }
}
impl Run {
    /// Creates a new builder-style object to manufacture [`Run`](crate::types::Run).
    pub fn builder() -> crate::types::builders::RunBuilder {
        crate::types::builders::RunBuilder::default()
    }
}

/// A builder for [`Run`](crate::types::Run).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct RunBuilder {
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) r#type: ::std::option::Option<crate::types::TestType>,
    pub(crate) platform: ::std::option::Option<crate::types::DevicePlatform>,
    pub(crate) created: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) status: ::std::option::Option<crate::types::ExecutionStatus>,
    pub(crate) result: ::std::option::Option<crate::types::ExecutionResult>,
    pub(crate) started: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) stopped: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) counters: ::std::option::Option<crate::types::Counters>,
    pub(crate) message: ::std::option::Option<::std::string::String>,
    pub(crate) total_jobs: ::std::option::Option<i32>,
    pub(crate) completed_jobs: ::std::option::Option<i32>,
    pub(crate) billing_method: ::std::option::Option<crate::types::BillingMethod>,
    pub(crate) device_minutes: ::std::option::Option<crate::types::DeviceMinutes>,
    pub(crate) network_profile: ::std::option::Option<crate::types::NetworkProfile>,
    pub(crate) parsing_result_url: ::std::option::Option<::std::string::String>,
    pub(crate) result_code: ::std::option::Option<crate::types::ExecutionResultCode>,
    pub(crate) seed: ::std::option::Option<i32>,
    pub(crate) app_upload: ::std::option::Option<::std::string::String>,
    pub(crate) event_count: ::std::option::Option<i32>,
    pub(crate) job_timeout_minutes: ::std::option::Option<i32>,
    pub(crate) device_pool_arn: ::std::option::Option<::std::string::String>,
    pub(crate) locale: ::std::option::Option<::std::string::String>,
    pub(crate) radios: ::std::option::Option<crate::types::Radios>,
    pub(crate) location: ::std::option::Option<crate::types::Location>,
    pub(crate) customer_artifact_paths: ::std::option::Option<crate::types::CustomerArtifactPaths>,
    pub(crate) web_url: ::std::option::Option<::std::string::String>,
    pub(crate) skip_app_resign: ::std::option::Option<bool>,
    pub(crate) test_spec_arn: ::std::option::Option<::std::string::String>,
    pub(crate) device_selection_result: ::std::option::Option<crate::types::DeviceSelectionResult>,
    pub(crate) vpc_config: ::std::option::Option<crate::types::VpcConfig>,
}
impl RunBuilder {
    /// <p>The run's ARN.</p>
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The run's ARN.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The run's ARN.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The run's name.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The run's name.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The run's name.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The run's type.</p>
    /// <p>Must be one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>BUILTIN_FUZZ</p></li>
    /// <li>
    /// <p>BUILTIN_EXPLORER</p><note>
    /// <p>For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.</p>
    /// </note></li>
    /// <li>
    /// <p>APPIUM_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_NODE</p></li>
    /// <li>
    /// <p>APPIUM_RUBY</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_WEB_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_WEB_NODE</p></li>
    /// <li>
    /// <p>APPIUM_WEB_RUBY</p></li>
    /// <li>
    /// <p>CALABASH</p></li>
    /// <li>
    /// <p>INSTRUMENTATION</p></li>
    /// <li>
    /// <p>UIAUTOMATION</p></li>
    /// <li>
    /// <p>UIAUTOMATOR</p></li>
    /// <li>
    /// <p>XCTEST</p></li>
    /// <li>
    /// <p>XCTEST_UI</p></li>
    /// </ul>
    pub fn r#type(mut self, input: crate::types::TestType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The run's type.</p>
    /// <p>Must be one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>BUILTIN_FUZZ</p></li>
    /// <li>
    /// <p>BUILTIN_EXPLORER</p><note>
    /// <p>For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.</p>
    /// </note></li>
    /// <li>
    /// <p>APPIUM_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_NODE</p></li>
    /// <li>
    /// <p>APPIUM_RUBY</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_WEB_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_WEB_NODE</p></li>
    /// <li>
    /// <p>APPIUM_WEB_RUBY</p></li>
    /// <li>
    /// <p>CALABASH</p></li>
    /// <li>
    /// <p>INSTRUMENTATION</p></li>
    /// <li>
    /// <p>UIAUTOMATION</p></li>
    /// <li>
    /// <p>UIAUTOMATOR</p></li>
    /// <li>
    /// <p>XCTEST</p></li>
    /// <li>
    /// <p>XCTEST_UI</p></li>
    /// </ul>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::TestType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The run's type.</p>
    /// <p>Must be one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p>BUILTIN_FUZZ</p></li>
    /// <li>
    /// <p>BUILTIN_EXPLORER</p><note>
    /// <p>For Android, an app explorer that traverses an Android app, interacting with it and capturing screenshots at the same time.</p>
    /// </note></li>
    /// <li>
    /// <p>APPIUM_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_NODE</p></li>
    /// <li>
    /// <p>APPIUM_RUBY</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_JUNIT</p></li>
    /// <li>
    /// <p>APPIUM_WEB_JAVA_TESTNG</p></li>
    /// <li>
    /// <p>APPIUM_WEB_PYTHON</p></li>
    /// <li>
    /// <p>APPIUM_WEB_NODE</p></li>
    /// <li>
    /// <p>APPIUM_WEB_RUBY</p></li>
    /// <li>
    /// <p>CALABASH</p></li>
    /// <li>
    /// <p>INSTRUMENTATION</p></li>
    /// <li>
    /// <p>UIAUTOMATION</p></li>
    /// <li>
    /// <p>UIAUTOMATOR</p></li>
    /// <li>
    /// <p>XCTEST</p></li>
    /// <li>
    /// <p>XCTEST_UI</p></li>
    /// </ul>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::TestType> {
        &self.r#type
    }
    /// <p>The run's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>ANDROID</p></li>
    /// <li>
    /// <p>IOS</p></li>
    /// </ul>
    pub fn platform(mut self, input: crate::types::DevicePlatform) -> Self {
        self.platform = ::std::option::Option::Some(input);
        self
    }
    /// <p>The run's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>ANDROID</p></li>
    /// <li>
    /// <p>IOS</p></li>
    /// </ul>
    pub fn set_platform(mut self, input: ::std::option::Option<crate::types::DevicePlatform>) -> Self {
        self.platform = input;
        self
    }
    /// <p>The run's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>ANDROID</p></li>
    /// <li>
    /// <p>IOS</p></li>
    /// </ul>
    pub fn get_platform(&self) -> &::std::option::Option<crate::types::DevicePlatform> {
        &self.platform
    }
    /// <p>When the run was created.</p>
    pub fn created(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created = ::std::option::Option::Some(input);
        self
    }
    /// <p>When the run was created.</p>
    pub fn set_created(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created = input;
        self
    }
    /// <p>When the run was created.</p>
    pub fn get_created(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created
    }
    /// <p>The run's status.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PENDING_CONCURRENCY</p></li>
    /// <li>
    /// <p>PENDING_DEVICE</p></li>
    /// <li>
    /// <p>PROCESSING</p></li>
    /// <li>
    /// <p>SCHEDULING</p></li>
    /// <li>
    /// <p>PREPARING</p></li>
    /// <li>
    /// <p>RUNNING</p></li>
    /// <li>
    /// <p>COMPLETED</p></li>
    /// <li>
    /// <p>STOPPING</p></li>
    /// </ul>
    pub fn status(mut self, input: crate::types::ExecutionStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The run's status.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PENDING_CONCURRENCY</p></li>
    /// <li>
    /// <p>PENDING_DEVICE</p></li>
    /// <li>
    /// <p>PROCESSING</p></li>
    /// <li>
    /// <p>SCHEDULING</p></li>
    /// <li>
    /// <p>PREPARING</p></li>
    /// <li>
    /// <p>RUNNING</p></li>
    /// <li>
    /// <p>COMPLETED</p></li>
    /// <li>
    /// <p>STOPPING</p></li>
    /// </ul>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::ExecutionStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The run's status.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PENDING_CONCURRENCY</p></li>
    /// <li>
    /// <p>PENDING_DEVICE</p></li>
    /// <li>
    /// <p>PROCESSING</p></li>
    /// <li>
    /// <p>SCHEDULING</p></li>
    /// <li>
    /// <p>PREPARING</p></li>
    /// <li>
    /// <p>RUNNING</p></li>
    /// <li>
    /// <p>COMPLETED</p></li>
    /// <li>
    /// <p>STOPPING</p></li>
    /// </ul>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::ExecutionStatus> {
        &self.status
    }
    /// <p>The run's result.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PASSED</p></li>
    /// <li>
    /// <p>WARNED</p></li>
    /// <li>
    /// <p>FAILED</p></li>
    /// <li>
    /// <p>SKIPPED</p></li>
    /// <li>
    /// <p>ERRORED</p></li>
    /// <li>
    /// <p>STOPPED</p></li>
    /// </ul>
    pub fn result(mut self, input: crate::types::ExecutionResult) -> Self {
        self.result = ::std::option::Option::Some(input);
        self
    }
    /// <p>The run's result.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PASSED</p></li>
    /// <li>
    /// <p>WARNED</p></li>
    /// <li>
    /// <p>FAILED</p></li>
    /// <li>
    /// <p>SKIPPED</p></li>
    /// <li>
    /// <p>ERRORED</p></li>
    /// <li>
    /// <p>STOPPED</p></li>
    /// </ul>
    pub fn set_result(mut self, input: ::std::option::Option<crate::types::ExecutionResult>) -> Self {
        self.result = input;
        self
    }
    /// <p>The run's result.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li>
    /// <p>PENDING</p></li>
    /// <li>
    /// <p>PASSED</p></li>
    /// <li>
    /// <p>WARNED</p></li>
    /// <li>
    /// <p>FAILED</p></li>
    /// <li>
    /// <p>SKIPPED</p></li>
    /// <li>
    /// <p>ERRORED</p></li>
    /// <li>
    /// <p>STOPPED</p></li>
    /// </ul>
    pub fn get_result(&self) -> &::std::option::Option<crate::types::ExecutionResult> {
        &self.result
    }
    /// <p>The run's start time.</p>
    pub fn started(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.started = ::std::option::Option::Some(input);
        self
    }
    /// <p>The run's start time.</p>
    pub fn set_started(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.started = input;
        self
    }
    /// <p>The run's start time.</p>
    pub fn get_started(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.started
    }
    /// <p>The run's stop time.</p>
    pub fn stopped(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.stopped = ::std::option::Option::Some(input);
        self
    }
    /// <p>The run's stop time.</p>
    pub fn set_stopped(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.stopped = input;
        self
    }
    /// <p>The run's stop time.</p>
    pub fn get_stopped(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.stopped
    }
    /// <p>The run's result counters.</p>
    pub fn counters(mut self, input: crate::types::Counters) -> Self {
        self.counters = ::std::option::Option::Some(input);
        self
    }
    /// <p>The run's result counters.</p>
    pub fn set_counters(mut self, input: ::std::option::Option<crate::types::Counters>) -> Self {
        self.counters = input;
        self
    }
    /// <p>The run's result counters.</p>
    pub fn get_counters(&self) -> &::std::option::Option<crate::types::Counters> {
        &self.counters
    }
    /// <p>A message about the run's result.</p>
    pub fn message(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.message = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A message about the run's result.</p>
    pub fn set_message(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.message = input;
        self
    }
    /// <p>A message about the run's result.</p>
    pub fn get_message(&self) -> &::std::option::Option<::std::string::String> {
        &self.message
    }
    /// <p>The total number of jobs for the run.</p>
    pub fn total_jobs(mut self, input: i32) -> Self {
        self.total_jobs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of jobs for the run.</p>
    pub fn set_total_jobs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_jobs = input;
        self
    }
    /// <p>The total number of jobs for the run.</p>
    pub fn get_total_jobs(&self) -> &::std::option::Option<i32> {
        &self.total_jobs
    }
    /// <p>The total number of completed jobs.</p>
    pub fn completed_jobs(mut self, input: i32) -> Self {
        self.completed_jobs = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of completed jobs.</p>
    pub fn set_completed_jobs(mut self, input: ::std::option::Option<i32>) -> Self {
        self.completed_jobs = input;
        self
    }
    /// <p>The total number of completed jobs.</p>
    pub fn get_completed_jobs(&self) -> &::std::option::Option<i32> {
        &self.completed_jobs
    }
    /// <p>Specifies the billing method for a test run: <code>metered</code> or <code>unmetered</code>. If the parameter is not specified, the default value is <code>metered</code>.</p><note>
    /// <p>If you have unmetered device slots, you must set this to <code>unmetered</code> to use them. Otherwise, the run is counted toward metered device minutes.</p>
    /// </note>
    pub fn billing_method(mut self, input: crate::types::BillingMethod) -> Self {
        self.billing_method = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the billing method for a test run: <code>metered</code> or <code>unmetered</code>. If the parameter is not specified, the default value is <code>metered</code>.</p><note>
    /// <p>If you have unmetered device slots, you must set this to <code>unmetered</code> to use them. Otherwise, the run is counted toward metered device minutes.</p>
    /// </note>
    pub fn set_billing_method(mut self, input: ::std::option::Option<crate::types::BillingMethod>) -> Self {
        self.billing_method = input;
        self
    }
    /// <p>Specifies the billing method for a test run: <code>metered</code> or <code>unmetered</code>. If the parameter is not specified, the default value is <code>metered</code>.</p><note>
    /// <p>If you have unmetered device slots, you must set this to <code>unmetered</code> to use them. Otherwise, the run is counted toward metered device minutes.</p>
    /// </note>
    pub fn get_billing_method(&self) -> &::std::option::Option<crate::types::BillingMethod> {
        &self.billing_method
    }
    /// <p>Represents the total (metered or unmetered) minutes used by the test run.</p>
    pub fn device_minutes(mut self, input: crate::types::DeviceMinutes) -> Self {
        self.device_minutes = ::std::option::Option::Some(input);
        self
    }
    /// <p>Represents the total (metered or unmetered) minutes used by the test run.</p>
    pub fn set_device_minutes(mut self, input: ::std::option::Option<crate::types::DeviceMinutes>) -> Self {
        self.device_minutes = input;
        self
    }
    /// <p>Represents the total (metered or unmetered) minutes used by the test run.</p>
    pub fn get_device_minutes(&self) -> &::std::option::Option<crate::types::DeviceMinutes> {
        &self.device_minutes
    }
    /// <p>The network profile being used for a test run.</p>
    pub fn network_profile(mut self, input: crate::types::NetworkProfile) -> Self {
        self.network_profile = ::std::option::Option::Some(input);
        self
    }
    /// <p>The network profile being used for a test run.</p>
    pub fn set_network_profile(mut self, input: ::std::option::Option<crate::types::NetworkProfile>) -> Self {
        self.network_profile = input;
        self
    }
    /// <p>The network profile being used for a test run.</p>
    pub fn get_network_profile(&self) -> &::std::option::Option<crate::types::NetworkProfile> {
        &self.network_profile
    }
    /// <p>Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package. If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points to.</p>
    pub fn parsing_result_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.parsing_result_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package. If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points to.</p>
    pub fn set_parsing_result_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.parsing_result_url = input;
        self
    }
    /// <p>Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package. If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points to.</p>
    pub fn get_parsing_result_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.parsing_result_url
    }
    /// <p>Supporting field for the result field. Set only if <code>result</code> is <code>SKIPPED</code>. <code>PARSING_FAILED</code> if the result is skipped because of test package parsing failure.</p>
    pub fn result_code(mut self, input: crate::types::ExecutionResultCode) -> Self {
        self.result_code = ::std::option::Option::Some(input);
        self
    }
    /// <p>Supporting field for the result field. Set only if <code>result</code> is <code>SKIPPED</code>. <code>PARSING_FAILED</code> if the result is skipped because of test package parsing failure.</p>
    pub fn set_result_code(mut self, input: ::std::option::Option<crate::types::ExecutionResultCode>) -> Self {
        self.result_code = input;
        self
    }
    /// <p>Supporting field for the result field. Set only if <code>result</code> is <code>SKIPPED</code>. <code>PARSING_FAILED</code> if the result is skipped because of test package parsing failure.</p>
    pub fn get_result_code(&self) -> &::std::option::Option<crate::types::ExecutionResultCode> {
        &self.result_code
    }
    /// <p>For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.</p>
    pub fn seed(mut self, input: i32) -> Self {
        self.seed = ::std::option::Option::Some(input);
        self
    }
    /// <p>For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.</p>
    pub fn set_seed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.seed = input;
        self
    }
    /// <p>For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.</p>
    pub fn get_seed(&self) -> &::std::option::Option<i32> {
        &self.seed
    }
    /// <p>An app to upload or that has been uploaded.</p>
    pub fn app_upload(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.app_upload = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>An app to upload or that has been uploaded.</p>
    pub fn set_app_upload(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.app_upload = input;
        self
    }
    /// <p>An app to upload or that has been uploaded.</p>
    pub fn get_app_upload(&self) -> &::std::option::Option<::std::string::String> {
        &self.app_upload
    }
    /// <p>For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz test should perform.</p>
    pub fn event_count(mut self, input: i32) -> Self {
        self.event_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz test should perform.</p>
    pub fn set_event_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.event_count = input;
        self
    }
    /// <p>For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz test should perform.</p>
    pub fn get_event_count(&self) -> &::std::option::Option<i32> {
        &self.event_count
    }
    /// <p>The number of minutes the job executes before it times out.</p>
    pub fn job_timeout_minutes(mut self, input: i32) -> Self {
        self.job_timeout_minutes = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of minutes the job executes before it times out.</p>
    pub fn set_job_timeout_minutes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.job_timeout_minutes = input;
        self
    }
    /// <p>The number of minutes the job executes before it times out.</p>
    pub fn get_job_timeout_minutes(&self) -> &::std::option::Option<i32> {
        &self.job_timeout_minutes
    }
    /// <p>The ARN of the device pool for the run.</p>
    pub fn device_pool_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.device_pool_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the device pool for the run.</p>
    pub fn set_device_pool_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.device_pool_arn = input;
        self
    }
    /// <p>The ARN of the device pool for the run.</p>
    pub fn get_device_pool_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.device_pool_arn
    }
    /// <p>Information about the locale that is used for the run.</p>
    pub fn locale(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.locale = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Information about the locale that is used for the run.</p>
    pub fn set_locale(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.locale = input;
        self
    }
    /// <p>Information about the locale that is used for the run.</p>
    pub fn get_locale(&self) -> &::std::option::Option<::std::string::String> {
        &self.locale
    }
    /// <p>Information about the radio states for the run.</p>
    pub fn radios(mut self, input: crate::types::Radios) -> Self {
        self.radios = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the radio states for the run.</p>
    pub fn set_radios(mut self, input: ::std::option::Option<crate::types::Radios>) -> Self {
        self.radios = input;
        self
    }
    /// <p>Information about the radio states for the run.</p>
    pub fn get_radios(&self) -> &::std::option::Option<crate::types::Radios> {
        &self.radios
    }
    /// <p>Information about the location that is used for the run.</p>
    pub fn location(mut self, input: crate::types::Location) -> Self {
        self.location = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the location that is used for the run.</p>
    pub fn set_location(mut self, input: ::std::option::Option<crate::types::Location>) -> Self {
        self.location = input;
        self
    }
    /// <p>Information about the location that is used for the run.</p>
    pub fn get_location(&self) -> &::std::option::Option<crate::types::Location> {
        &self.location
    }
    /// <p>Output <code>CustomerArtifactPaths</code> object for the test run.</p>
    pub fn customer_artifact_paths(mut self, input: crate::types::CustomerArtifactPaths) -> Self {
        self.customer_artifact_paths = ::std::option::Option::Some(input);
        self
    }
    /// <p>Output <code>CustomerArtifactPaths</code> object for the test run.</p>
    pub fn set_customer_artifact_paths(mut self, input: ::std::option::Option<crate::types::CustomerArtifactPaths>) -> Self {
        self.customer_artifact_paths = input;
        self
    }
    /// <p>Output <code>CustomerArtifactPaths</code> object for the test run.</p>
    pub fn get_customer_artifact_paths(&self) -> &::std::option::Option<crate::types::CustomerArtifactPaths> {
        &self.customer_artifact_paths
    }
    /// <p>The Device Farm console URL for the recording of the run.</p>
    pub fn web_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.web_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Device Farm console URL for the recording of the run.</p>
    pub fn set_web_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.web_url = input;
        self
    }
    /// <p>The Device Farm console URL for the recording of the run.</p>
    pub fn get_web_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.web_url
    }
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again.</p>
    /// <p>For more information about how Device Farm re-signs your apps, see <a href="http://aws.amazon.com/device-farm/faqs/">Do you modify my app?</a> in the <i>AWS Device Farm FAQs</i>.</p>
    pub fn skip_app_resign(mut self, input: bool) -> Self {
        self.skip_app_resign = ::std::option::Option::Some(input);
        self
    }
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again.</p>
    /// <p>For more information about how Device Farm re-signs your apps, see <a href="http://aws.amazon.com/device-farm/faqs/">Do you modify my app?</a> in the <i>AWS Device Farm FAQs</i>.</p>
    pub fn set_skip_app_resign(mut self, input: ::std::option::Option<bool>) -> Self {
        self.skip_app_resign = input;
        self
    }
    /// <p>When set to <code>true</code>, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again.</p>
    /// <p>For more information about how Device Farm re-signs your apps, see <a href="http://aws.amazon.com/device-farm/faqs/">Do you modify my app?</a> in the <i>AWS Device Farm FAQs</i>.</p>
    pub fn get_skip_app_resign(&self) -> &::std::option::Option<bool> {
        &self.skip_app_resign
    }
    /// <p>The ARN of the YAML-formatted test specification for the run.</p>
    pub fn test_spec_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.test_spec_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the YAML-formatted test specification for the run.</p>
    pub fn set_test_spec_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.test_spec_arn = input;
        self
    }
    /// <p>The ARN of the YAML-formatted test specification for the run.</p>
    pub fn get_test_spec_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.test_spec_arn
    }
    /// <p>The results of a device filter used to select the devices for a test run.</p>
    pub fn device_selection_result(mut self, input: crate::types::DeviceSelectionResult) -> Self {
        self.device_selection_result = ::std::option::Option::Some(input);
        self
    }
    /// <p>The results of a device filter used to select the devices for a test run.</p>
    pub fn set_device_selection_result(mut self, input: ::std::option::Option<crate::types::DeviceSelectionResult>) -> Self {
        self.device_selection_result = input;
        self
    }
    /// <p>The results of a device filter used to select the devices for a test run.</p>
    pub fn get_device_selection_result(&self) -> &::std::option::Option<crate::types::DeviceSelectionResult> {
        &self.device_selection_result
    }
    /// <p>The VPC security groups and subnets that are attached to a project.</p>
    pub fn vpc_config(mut self, input: crate::types::VpcConfig) -> Self {
        self.vpc_config = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VPC security groups and subnets that are attached to a project.</p>
    pub fn set_vpc_config(mut self, input: ::std::option::Option<crate::types::VpcConfig>) -> Self {
        self.vpc_config = input;
        self
    }
    /// <p>The VPC security groups and subnets that are attached to a project.</p>
    pub fn get_vpc_config(&self) -> &::std::option::Option<crate::types::VpcConfig> {
        &self.vpc_config
    }
    /// Consumes the builder and constructs a [`Run`](crate::types::Run).
    pub fn build(self) -> crate::types::Run {
        crate::types::Run {
            arn: self.arn,
            name: self.name,
            r#type: self.r#type,
            platform: self.platform,
            created: self.created,
            status: self.status,
            result: self.result,
            started: self.started,
            stopped: self.stopped,
            counters: self.counters,
            message: self.message,
            total_jobs: self.total_jobs,
            completed_jobs: self.completed_jobs,
            billing_method: self.billing_method,
            device_minutes: self.device_minutes,
            network_profile: self.network_profile,
            parsing_result_url: self.parsing_result_url,
            result_code: self.result_code,
            seed: self.seed,
            app_upload: self.app_upload,
            event_count: self.event_count,
            job_timeout_minutes: self.job_timeout_minutes,
            device_pool_arn: self.device_pool_arn,
            locale: self.locale,
            radios: self.radios,
            location: self.location,
            customer_artifact_paths: self.customer_artifact_paths,
            web_url: self.web_url,
            skip_app_resign: self.skip_app_resign,
            test_spec_arn: self.test_spec_arn,
            device_selection_result: self.device_selection_result,
            vpc_config: self.vpc_config,
        }
    }
}
