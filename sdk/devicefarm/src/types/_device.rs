// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a device type that an app is tested against.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Device {
    /// <p>The device's ARN.</p>
    pub arn: ::std::option::Option<::std::string::String>,
    /// <p>The device's display name.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The device's manufacturer name.</p>
    pub manufacturer: ::std::option::Option<::std::string::String>,
    /// <p>The device's model name.</p>
    pub model: ::std::option::Option<::std::string::String>,
    /// <p>The device's model ID.</p>
    pub model_id: ::std::option::Option<::std::string::String>,
    /// <p>The device's form factor.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>PHONE</p> </li>
    /// <li> <p>TABLET</p> </li>
    /// </ul>
    pub form_factor: ::std::option::Option<crate::types::DeviceFormFactor>,
    /// <p>The device's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>ANDROID</p> </li>
    /// <li> <p>IOS</p> </li>
    /// </ul>
    pub platform: ::std::option::Option<crate::types::DevicePlatform>,
    /// <p>The device's operating system type.</p>
    pub os: ::std::option::Option<::std::string::String>,
    /// <p>Information about the device's CPU.</p>
    pub cpu: ::std::option::Option<crate::types::Cpu>,
    /// <p>The resolution of the device.</p>
    pub resolution: ::std::option::Option<crate::types::Resolution>,
    /// <p>The device's heap size, expressed in bytes.</p>
    pub heap_size: ::std::option::Option<i64>,
    /// <p>The device's total memory size, expressed in bytes.</p>
    pub memory: ::std::option::Option<i64>,
    /// <p>The device's image name.</p>
    pub image: ::std::option::Option<::std::string::String>,
    /// <p>The device's carrier.</p>
    pub carrier: ::std::option::Option<::std::string::String>,
    /// <p>The device's radio.</p>
    pub radio: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether remote access has been enabled for the specified device.</p>
    pub remote_access_enabled: ::std::option::Option<bool>,
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the device.</p>
    /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer supported</a>.</p>
    pub remote_debug_enabled: ::std::option::Option<bool>,
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    pub fleet_type: ::std::option::Option<::std::string::String>,
    /// <p>The name of the fleet to which this device belongs.</p>
    pub fleet_name: ::std::option::Option<::std::string::String>,
    /// <p>The instances that belong to this device.</p>
    pub instances: ::std::option::Option<::std::vec::Vec<crate::types::DeviceInstance>>,
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <code>ListDevices</code> and GetDevice API methods.</p>
    pub availability: ::std::option::Option<crate::types::DeviceAvailability>,
}
impl Device {
    /// <p>The device's ARN.</p>
    pub fn arn(&self) -> ::std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The device's display name.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The device's manufacturer name.</p>
    pub fn manufacturer(&self) -> ::std::option::Option<&str> {
        self.manufacturer.as_deref()
    }
    /// <p>The device's model name.</p>
    pub fn model(&self) -> ::std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The device's model ID.</p>
    pub fn model_id(&self) -> ::std::option::Option<&str> {
        self.model_id.as_deref()
    }
    /// <p>The device's form factor.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>PHONE</p> </li>
    /// <li> <p>TABLET</p> </li>
    /// </ul>
    pub fn form_factor(&self) -> ::std::option::Option<&crate::types::DeviceFormFactor> {
        self.form_factor.as_ref()
    }
    /// <p>The device's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>ANDROID</p> </li>
    /// <li> <p>IOS</p> </li>
    /// </ul>
    pub fn platform(&self) -> ::std::option::Option<&crate::types::DevicePlatform> {
        self.platform.as_ref()
    }
    /// <p>The device's operating system type.</p>
    pub fn os(&self) -> ::std::option::Option<&str> {
        self.os.as_deref()
    }
    /// <p>Information about the device's CPU.</p>
    pub fn cpu(&self) -> ::std::option::Option<&crate::types::Cpu> {
        self.cpu.as_ref()
    }
    /// <p>The resolution of the device.</p>
    pub fn resolution(&self) -> ::std::option::Option<&crate::types::Resolution> {
        self.resolution.as_ref()
    }
    /// <p>The device's heap size, expressed in bytes.</p>
    pub fn heap_size(&self) -> ::std::option::Option<i64> {
        self.heap_size
    }
    /// <p>The device's total memory size, expressed in bytes.</p>
    pub fn memory(&self) -> ::std::option::Option<i64> {
        self.memory
    }
    /// <p>The device's image name.</p>
    pub fn image(&self) -> ::std::option::Option<&str> {
        self.image.as_deref()
    }
    /// <p>The device's carrier.</p>
    pub fn carrier(&self) -> ::std::option::Option<&str> {
        self.carrier.as_deref()
    }
    /// <p>The device's radio.</p>
    pub fn radio(&self) -> ::std::option::Option<&str> {
        self.radio.as_deref()
    }
    /// <p>Specifies whether remote access has been enabled for the specified device.</p>
    pub fn remote_access_enabled(&self) -> ::std::option::Option<bool> {
        self.remote_access_enabled
    }
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the device.</p>
    /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer supported</a>.</p>
    pub fn remote_debug_enabled(&self) -> ::std::option::Option<bool> {
        self.remote_debug_enabled
    }
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    pub fn fleet_type(&self) -> ::std::option::Option<&str> {
        self.fleet_type.as_deref()
    }
    /// <p>The name of the fleet to which this device belongs.</p>
    pub fn fleet_name(&self) -> ::std::option::Option<&str> {
        self.fleet_name.as_deref()
    }
    /// <p>The instances that belong to this device.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.instances.is_none()`.
    pub fn instances(&self) -> &[crate::types::DeviceInstance] {
        self.instances.as_deref().unwrap_or_default()
    }
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <code>ListDevices</code> and GetDevice API methods.</p>
    pub fn availability(&self) -> ::std::option::Option<&crate::types::DeviceAvailability> {
        self.availability.as_ref()
    }
}
impl Device {
    /// Creates a new builder-style object to manufacture [`Device`](crate::types::Device).
    pub fn builder() -> crate::types::builders::DeviceBuilder {
        crate::types::builders::DeviceBuilder::default()
    }
}

/// A builder for [`Device`](crate::types::Device).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct DeviceBuilder {
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) manufacturer: ::std::option::Option<::std::string::String>,
    pub(crate) model: ::std::option::Option<::std::string::String>,
    pub(crate) model_id: ::std::option::Option<::std::string::String>,
    pub(crate) form_factor: ::std::option::Option<crate::types::DeviceFormFactor>,
    pub(crate) platform: ::std::option::Option<crate::types::DevicePlatform>,
    pub(crate) os: ::std::option::Option<::std::string::String>,
    pub(crate) cpu: ::std::option::Option<crate::types::Cpu>,
    pub(crate) resolution: ::std::option::Option<crate::types::Resolution>,
    pub(crate) heap_size: ::std::option::Option<i64>,
    pub(crate) memory: ::std::option::Option<i64>,
    pub(crate) image: ::std::option::Option<::std::string::String>,
    pub(crate) carrier: ::std::option::Option<::std::string::String>,
    pub(crate) radio: ::std::option::Option<::std::string::String>,
    pub(crate) remote_access_enabled: ::std::option::Option<bool>,
    pub(crate) remote_debug_enabled: ::std::option::Option<bool>,
    pub(crate) fleet_type: ::std::option::Option<::std::string::String>,
    pub(crate) fleet_name: ::std::option::Option<::std::string::String>,
    pub(crate) instances: ::std::option::Option<::std::vec::Vec<crate::types::DeviceInstance>>,
    pub(crate) availability: ::std::option::Option<crate::types::DeviceAvailability>,
}
impl DeviceBuilder {
    /// <p>The device's ARN.</p>
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's ARN.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The device's ARN.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The device's display name.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's display name.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The device's display name.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The device's manufacturer name.</p>
    pub fn manufacturer(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.manufacturer = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's manufacturer name.</p>
    pub fn set_manufacturer(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.manufacturer = input;
        self
    }
    /// <p>The device's manufacturer name.</p>
    pub fn get_manufacturer(&self) -> &::std::option::Option<::std::string::String> {
        &self.manufacturer
    }
    /// <p>The device's model name.</p>
    pub fn model(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.model = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's model name.</p>
    pub fn set_model(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.model = input;
        self
    }
    /// <p>The device's model name.</p>
    pub fn get_model(&self) -> &::std::option::Option<::std::string::String> {
        &self.model
    }
    /// <p>The device's model ID.</p>
    pub fn model_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.model_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's model ID.</p>
    pub fn set_model_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.model_id = input;
        self
    }
    /// <p>The device's model ID.</p>
    pub fn get_model_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.model_id
    }
    /// <p>The device's form factor.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>PHONE</p> </li>
    /// <li> <p>TABLET</p> </li>
    /// </ul>
    pub fn form_factor(mut self, input: crate::types::DeviceFormFactor) -> Self {
        self.form_factor = ::std::option::Option::Some(input);
        self
    }
    /// <p>The device's form factor.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>PHONE</p> </li>
    /// <li> <p>TABLET</p> </li>
    /// </ul>
    pub fn set_form_factor(mut self, input: ::std::option::Option<crate::types::DeviceFormFactor>) -> Self {
        self.form_factor = input;
        self
    }
    /// <p>The device's form factor.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>PHONE</p> </li>
    /// <li> <p>TABLET</p> </li>
    /// </ul>
    pub fn get_form_factor(&self) -> &::std::option::Option<crate::types::DeviceFormFactor> {
        &self.form_factor
    }
    /// <p>The device's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>ANDROID</p> </li>
    /// <li> <p>IOS</p> </li>
    /// </ul>
    pub fn platform(mut self, input: crate::types::DevicePlatform) -> Self {
        self.platform = ::std::option::Option::Some(input);
        self
    }
    /// <p>The device's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>ANDROID</p> </li>
    /// <li> <p>IOS</p> </li>
    /// </ul>
    pub fn set_platform(mut self, input: ::std::option::Option<crate::types::DevicePlatform>) -> Self {
        self.platform = input;
        self
    }
    /// <p>The device's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>ANDROID</p> </li>
    /// <li> <p>IOS</p> </li>
    /// </ul>
    pub fn get_platform(&self) -> &::std::option::Option<crate::types::DevicePlatform> {
        &self.platform
    }
    /// <p>The device's operating system type.</p>
    pub fn os(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.os = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's operating system type.</p>
    pub fn set_os(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.os = input;
        self
    }
    /// <p>The device's operating system type.</p>
    pub fn get_os(&self) -> &::std::option::Option<::std::string::String> {
        &self.os
    }
    /// <p>Information about the device's CPU.</p>
    pub fn cpu(mut self, input: crate::types::Cpu) -> Self {
        self.cpu = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the device's CPU.</p>
    pub fn set_cpu(mut self, input: ::std::option::Option<crate::types::Cpu>) -> Self {
        self.cpu = input;
        self
    }
    /// <p>Information about the device's CPU.</p>
    pub fn get_cpu(&self) -> &::std::option::Option<crate::types::Cpu> {
        &self.cpu
    }
    /// <p>The resolution of the device.</p>
    pub fn resolution(mut self, input: crate::types::Resolution) -> Self {
        self.resolution = ::std::option::Option::Some(input);
        self
    }
    /// <p>The resolution of the device.</p>
    pub fn set_resolution(mut self, input: ::std::option::Option<crate::types::Resolution>) -> Self {
        self.resolution = input;
        self
    }
    /// <p>The resolution of the device.</p>
    pub fn get_resolution(&self) -> &::std::option::Option<crate::types::Resolution> {
        &self.resolution
    }
    /// <p>The device's heap size, expressed in bytes.</p>
    pub fn heap_size(mut self, input: i64) -> Self {
        self.heap_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>The device's heap size, expressed in bytes.</p>
    pub fn set_heap_size(mut self, input: ::std::option::Option<i64>) -> Self {
        self.heap_size = input;
        self
    }
    /// <p>The device's heap size, expressed in bytes.</p>
    pub fn get_heap_size(&self) -> &::std::option::Option<i64> {
        &self.heap_size
    }
    /// <p>The device's total memory size, expressed in bytes.</p>
    pub fn memory(mut self, input: i64) -> Self {
        self.memory = ::std::option::Option::Some(input);
        self
    }
    /// <p>The device's total memory size, expressed in bytes.</p>
    pub fn set_memory(mut self, input: ::std::option::Option<i64>) -> Self {
        self.memory = input;
        self
    }
    /// <p>The device's total memory size, expressed in bytes.</p>
    pub fn get_memory(&self) -> &::std::option::Option<i64> {
        &self.memory
    }
    /// <p>The device's image name.</p>
    pub fn image(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.image = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's image name.</p>
    pub fn set_image(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.image = input;
        self
    }
    /// <p>The device's image name.</p>
    pub fn get_image(&self) -> &::std::option::Option<::std::string::String> {
        &self.image
    }
    /// <p>The device's carrier.</p>
    pub fn carrier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.carrier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's carrier.</p>
    pub fn set_carrier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.carrier = input;
        self
    }
    /// <p>The device's carrier.</p>
    pub fn get_carrier(&self) -> &::std::option::Option<::std::string::String> {
        &self.carrier
    }
    /// <p>The device's radio.</p>
    pub fn radio(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.radio = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device's radio.</p>
    pub fn set_radio(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.radio = input;
        self
    }
    /// <p>The device's radio.</p>
    pub fn get_radio(&self) -> &::std::option::Option<::std::string::String> {
        &self.radio
    }
    /// <p>Specifies whether remote access has been enabled for the specified device.</p>
    pub fn remote_access_enabled(mut self, input: bool) -> Self {
        self.remote_access_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether remote access has been enabled for the specified device.</p>
    pub fn set_remote_access_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.remote_access_enabled = input;
        self
    }
    /// <p>Specifies whether remote access has been enabled for the specified device.</p>
    pub fn get_remote_access_enabled(&self) -> &::std::option::Option<bool> {
        &self.remote_access_enabled
    }
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the device.</p>
    /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer supported</a>.</p>
    pub fn remote_debug_enabled(mut self, input: bool) -> Self {
        self.remote_debug_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the device.</p>
    /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer supported</a>.</p>
    pub fn set_remote_debug_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.remote_debug_enabled = input;
        self
    }
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the device.</p>
    /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer supported</a>.</p>
    pub fn get_remote_debug_enabled(&self) -> &::std::option::Option<bool> {
        &self.remote_debug_enabled
    }
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    pub fn fleet_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.fleet_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    pub fn set_fleet_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.fleet_type = input;
        self
    }
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    pub fn get_fleet_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.fleet_type
    }
    /// <p>The name of the fleet to which this device belongs.</p>
    pub fn fleet_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.fleet_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the fleet to which this device belongs.</p>
    pub fn set_fleet_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.fleet_name = input;
        self
    }
    /// <p>The name of the fleet to which this device belongs.</p>
    pub fn get_fleet_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.fleet_name
    }
    /// Appends an item to `instances`.
    ///
    /// To override the contents of this collection use [`set_instances`](Self::set_instances).
    ///
    /// <p>The instances that belong to this device.</p>
    pub fn instances(mut self, input: crate::types::DeviceInstance) -> Self {
        let mut v = self.instances.unwrap_or_default();
        v.push(input);
        self.instances = ::std::option::Option::Some(v);
        self
    }
    /// <p>The instances that belong to this device.</p>
    pub fn set_instances(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DeviceInstance>>) -> Self {
        self.instances = input;
        self
    }
    /// <p>The instances that belong to this device.</p>
    pub fn get_instances(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DeviceInstance>> {
        &self.instances
    }
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <code>ListDevices</code> and GetDevice API methods.</p>
    pub fn availability(mut self, input: crate::types::DeviceAvailability) -> Self {
        self.availability = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <code>ListDevices</code> and GetDevice API methods.</p>
    pub fn set_availability(mut self, input: ::std::option::Option<crate::types::DeviceAvailability>) -> Self {
        self.availability = input;
        self
    }
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <code>ListDevices</code> and GetDevice API methods.</p>
    pub fn get_availability(&self) -> &::std::option::Option<crate::types::DeviceAvailability> {
        &self.availability
    }
    /// Consumes the builder and constructs a [`Device`](crate::types::Device).
    pub fn build(self) -> crate::types::Device {
        crate::types::Device {
            arn: self.arn,
            name: self.name,
            manufacturer: self.manufacturer,
            model: self.model,
            model_id: self.model_id,
            form_factor: self.form_factor,
            platform: self.platform,
            os: self.os,
            cpu: self.cpu,
            resolution: self.resolution,
            heap_size: self.heap_size,
            memory: self.memory,
            image: self.image,
            carrier: self.carrier,
            radio: self.radio,
            remote_access_enabled: self.remote_access_enabled,
            remote_debug_enabled: self.remote_debug_enabled,
            fleet_type: self.fleet_type,
            fleet_name: self.fleet_name,
            instances: self.instances,
            availability: self.availability,
        }
    }
}
