// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a device type that an app is tested against.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Device {
    /// <p>The device's ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The device's display name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The device's manufacturer name.</p>
    #[doc(hidden)]
    pub manufacturer: std::option::Option<std::string::String>,
    /// <p>The device's model name.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>The device's model ID.</p>
    #[doc(hidden)]
    pub model_id: std::option::Option<std::string::String>,
    /// <p>The device's form factor.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>PHONE</p> </li>
    /// <li> <p>TABLET</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub form_factor: std::option::Option<crate::types::DeviceFormFactor>,
    /// <p>The device's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>ANDROID</p> </li>
    /// <li> <p>IOS</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub platform: std::option::Option<crate::types::DevicePlatform>,
    /// <p>The device's operating system type.</p>
    #[doc(hidden)]
    pub os: std::option::Option<std::string::String>,
    /// <p>Information about the device's CPU.</p>
    #[doc(hidden)]
    pub cpu: std::option::Option<crate::types::Cpu>,
    /// <p>The resolution of the device.</p>
    #[doc(hidden)]
    pub resolution: std::option::Option<crate::types::Resolution>,
    /// <p>The device's heap size, expressed in bytes.</p>
    #[doc(hidden)]
    pub heap_size: std::option::Option<i64>,
    /// <p>The device's total memory size, expressed in bytes.</p>
    #[doc(hidden)]
    pub memory: std::option::Option<i64>,
    /// <p>The device's image name.</p>
    #[doc(hidden)]
    pub image: std::option::Option<std::string::String>,
    /// <p>The device's carrier.</p>
    #[doc(hidden)]
    pub carrier: std::option::Option<std::string::String>,
    /// <p>The device's radio.</p>
    #[doc(hidden)]
    pub radio: std::option::Option<std::string::String>,
    /// <p>Specifies whether remote access has been enabled for the specified device.</p>
    #[doc(hidden)]
    pub remote_access_enabled: std::option::Option<bool>,
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the device.</p>
    /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer supported</a>.</p>
    #[doc(hidden)]
    pub remote_debug_enabled: std::option::Option<bool>,
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    #[doc(hidden)]
    pub fleet_type: std::option::Option<std::string::String>,
    /// <p>The name of the fleet to which this device belongs.</p>
    #[doc(hidden)]
    pub fleet_name: std::option::Option<std::string::String>,
    /// <p>The instances that belong to this device.</p>
    #[doc(hidden)]
    pub instances: std::option::Option<std::vec::Vec<crate::types::DeviceInstance>>,
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <code>ListDevices</code> and GetDevice API methods.</p>
    #[doc(hidden)]
    pub availability: std::option::Option<crate::types::DeviceAvailability>,
}
impl Device {
    /// <p>The device's ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The device's display name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The device's manufacturer name.</p>
    pub fn manufacturer(&self) -> std::option::Option<&str> {
        self.manufacturer.as_deref()
    }
    /// <p>The device's model name.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The device's model ID.</p>
    pub fn model_id(&self) -> std::option::Option<&str> {
        self.model_id.as_deref()
    }
    /// <p>The device's form factor.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>PHONE</p> </li>
    /// <li> <p>TABLET</p> </li>
    /// </ul>
    pub fn form_factor(&self) -> std::option::Option<&crate::types::DeviceFormFactor> {
        self.form_factor.as_ref()
    }
    /// <p>The device's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>ANDROID</p> </li>
    /// <li> <p>IOS</p> </li>
    /// </ul>
    pub fn platform(&self) -> std::option::Option<&crate::types::DevicePlatform> {
        self.platform.as_ref()
    }
    /// <p>The device's operating system type.</p>
    pub fn os(&self) -> std::option::Option<&str> {
        self.os.as_deref()
    }
    /// <p>Information about the device's CPU.</p>
    pub fn cpu(&self) -> std::option::Option<&crate::types::Cpu> {
        self.cpu.as_ref()
    }
    /// <p>The resolution of the device.</p>
    pub fn resolution(&self) -> std::option::Option<&crate::types::Resolution> {
        self.resolution.as_ref()
    }
    /// <p>The device's heap size, expressed in bytes.</p>
    pub fn heap_size(&self) -> std::option::Option<i64> {
        self.heap_size
    }
    /// <p>The device's total memory size, expressed in bytes.</p>
    pub fn memory(&self) -> std::option::Option<i64> {
        self.memory
    }
    /// <p>The device's image name.</p>
    pub fn image(&self) -> std::option::Option<&str> {
        self.image.as_deref()
    }
    /// <p>The device's carrier.</p>
    pub fn carrier(&self) -> std::option::Option<&str> {
        self.carrier.as_deref()
    }
    /// <p>The device's radio.</p>
    pub fn radio(&self) -> std::option::Option<&str> {
        self.radio.as_deref()
    }
    /// <p>Specifies whether remote access has been enabled for the specified device.</p>
    pub fn remote_access_enabled(&self) -> std::option::Option<bool> {
        self.remote_access_enabled
    }
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the device.</p>
    /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer supported</a>.</p>
    pub fn remote_debug_enabled(&self) -> std::option::Option<bool> {
        self.remote_debug_enabled
    }
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    pub fn fleet_type(&self) -> std::option::Option<&str> {
        self.fleet_type.as_deref()
    }
    /// <p>The name of the fleet to which this device belongs.</p>
    pub fn fleet_name(&self) -> std::option::Option<&str> {
        self.fleet_name.as_deref()
    }
    /// <p>The instances that belong to this device.</p>
    pub fn instances(&self) -> std::option::Option<&[crate::types::DeviceInstance]> {
        self.instances.as_deref()
    }
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <code>ListDevices</code> and GetDevice API methods.</p>
    pub fn availability(&self) -> std::option::Option<&crate::types::DeviceAvailability> {
        self.availability.as_ref()
    }
}
impl Device {
    /// Creates a new builder-style object to manufacture [`Device`](crate::types::Device).
    pub fn builder() -> crate::types::builders::DeviceBuilder {
        crate::types::builders::DeviceBuilder::default()
    }
}

/// A builder for [`Device`](crate::types::Device).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct DeviceBuilder {
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) manufacturer: std::option::Option<std::string::String>,
    pub(crate) model: std::option::Option<std::string::String>,
    pub(crate) model_id: std::option::Option<std::string::String>,
    pub(crate) form_factor: std::option::Option<crate::types::DeviceFormFactor>,
    pub(crate) platform: std::option::Option<crate::types::DevicePlatform>,
    pub(crate) os: std::option::Option<std::string::String>,
    pub(crate) cpu: std::option::Option<crate::types::Cpu>,
    pub(crate) resolution: std::option::Option<crate::types::Resolution>,
    pub(crate) heap_size: std::option::Option<i64>,
    pub(crate) memory: std::option::Option<i64>,
    pub(crate) image: std::option::Option<std::string::String>,
    pub(crate) carrier: std::option::Option<std::string::String>,
    pub(crate) radio: std::option::Option<std::string::String>,
    pub(crate) remote_access_enabled: std::option::Option<bool>,
    pub(crate) remote_debug_enabled: std::option::Option<bool>,
    pub(crate) fleet_type: std::option::Option<std::string::String>,
    pub(crate) fleet_name: std::option::Option<std::string::String>,
    pub(crate) instances: std::option::Option<std::vec::Vec<crate::types::DeviceInstance>>,
    pub(crate) availability: std::option::Option<crate::types::DeviceAvailability>,
}
impl DeviceBuilder {
    /// <p>The device's ARN.</p>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>The device's ARN.</p>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The device's display name.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The device's display name.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The device's manufacturer name.</p>
    pub fn manufacturer(mut self, input: impl Into<std::string::String>) -> Self {
        self.manufacturer = Some(input.into());
        self
    }
    /// <p>The device's manufacturer name.</p>
    pub fn set_manufacturer(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.manufacturer = input;
        self
    }
    /// <p>The device's model name.</p>
    pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
        self.model = Some(input.into());
        self
    }
    /// <p>The device's model name.</p>
    pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.model = input;
        self
    }
    /// <p>The device's model ID.</p>
    pub fn model_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.model_id = Some(input.into());
        self
    }
    /// <p>The device's model ID.</p>
    pub fn set_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.model_id = input;
        self
    }
    /// <p>The device's form factor.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>PHONE</p> </li>
    /// <li> <p>TABLET</p> </li>
    /// </ul>
    pub fn form_factor(mut self, input: crate::types::DeviceFormFactor) -> Self {
        self.form_factor = Some(input);
        self
    }
    /// <p>The device's form factor.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>PHONE</p> </li>
    /// <li> <p>TABLET</p> </li>
    /// </ul>
    pub fn set_form_factor(
        mut self,
        input: std::option::Option<crate::types::DeviceFormFactor>,
    ) -> Self {
        self.form_factor = input;
        self
    }
    /// <p>The device's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>ANDROID</p> </li>
    /// <li> <p>IOS</p> </li>
    /// </ul>
    pub fn platform(mut self, input: crate::types::DevicePlatform) -> Self {
        self.platform = Some(input);
        self
    }
    /// <p>The device's platform.</p>
    /// <p>Allowed values include:</p>
    /// <ul>
    /// <li> <p>ANDROID</p> </li>
    /// <li> <p>IOS</p> </li>
    /// </ul>
    pub fn set_platform(
        mut self,
        input: std::option::Option<crate::types::DevicePlatform>,
    ) -> Self {
        self.platform = input;
        self
    }
    /// <p>The device's operating system type.</p>
    pub fn os(mut self, input: impl Into<std::string::String>) -> Self {
        self.os = Some(input.into());
        self
    }
    /// <p>The device's operating system type.</p>
    pub fn set_os(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.os = input;
        self
    }
    /// <p>Information about the device's CPU.</p>
    pub fn cpu(mut self, input: crate::types::Cpu) -> Self {
        self.cpu = Some(input);
        self
    }
    /// <p>Information about the device's CPU.</p>
    pub fn set_cpu(mut self, input: std::option::Option<crate::types::Cpu>) -> Self {
        self.cpu = input;
        self
    }
    /// <p>The resolution of the device.</p>
    pub fn resolution(mut self, input: crate::types::Resolution) -> Self {
        self.resolution = Some(input);
        self
    }
    /// <p>The resolution of the device.</p>
    pub fn set_resolution(mut self, input: std::option::Option<crate::types::Resolution>) -> Self {
        self.resolution = input;
        self
    }
    /// <p>The device's heap size, expressed in bytes.</p>
    pub fn heap_size(mut self, input: i64) -> Self {
        self.heap_size = Some(input);
        self
    }
    /// <p>The device's heap size, expressed in bytes.</p>
    pub fn set_heap_size(mut self, input: std::option::Option<i64>) -> Self {
        self.heap_size = input;
        self
    }
    /// <p>The device's total memory size, expressed in bytes.</p>
    pub fn memory(mut self, input: i64) -> Self {
        self.memory = Some(input);
        self
    }
    /// <p>The device's total memory size, expressed in bytes.</p>
    pub fn set_memory(mut self, input: std::option::Option<i64>) -> Self {
        self.memory = input;
        self
    }
    /// <p>The device's image name.</p>
    pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
        self.image = Some(input.into());
        self
    }
    /// <p>The device's image name.</p>
    pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.image = input;
        self
    }
    /// <p>The device's carrier.</p>
    pub fn carrier(mut self, input: impl Into<std::string::String>) -> Self {
        self.carrier = Some(input.into());
        self
    }
    /// <p>The device's carrier.</p>
    pub fn set_carrier(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.carrier = input;
        self
    }
    /// <p>The device's radio.</p>
    pub fn radio(mut self, input: impl Into<std::string::String>) -> Self {
        self.radio = Some(input.into());
        self
    }
    /// <p>The device's radio.</p>
    pub fn set_radio(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.radio = input;
        self
    }
    /// <p>Specifies whether remote access has been enabled for the specified device.</p>
    pub fn remote_access_enabled(mut self, input: bool) -> Self {
        self.remote_access_enabled = Some(input);
        self
    }
    /// <p>Specifies whether remote access has been enabled for the specified device.</p>
    pub fn set_remote_access_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.remote_access_enabled = input;
        self
    }
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the device.</p>
    /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer supported</a>.</p>
    pub fn remote_debug_enabled(mut self, input: bool) -> Self {
        self.remote_debug_enabled = Some(input);
        self
    }
    /// <p>This flag is set to <code>true</code> if remote debugging is enabled for the device.</p>
    /// <p>Remote debugging is <a href="https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html">no longer supported</a>.</p>
    pub fn set_remote_debug_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.remote_debug_enabled = input;
        self
    }
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    pub fn fleet_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.fleet_type = Some(input.into());
        self
    }
    /// <p>The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.</p>
    pub fn set_fleet_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.fleet_type = input;
        self
    }
    /// <p>The name of the fleet to which this device belongs.</p>
    pub fn fleet_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.fleet_name = Some(input.into());
        self
    }
    /// <p>The name of the fleet to which this device belongs.</p>
    pub fn set_fleet_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.fleet_name = input;
        self
    }
    /// Appends an item to `instances`.
    ///
    /// To override the contents of this collection use [`set_instances`](Self::set_instances).
    ///
    /// <p>The instances that belong to this device.</p>
    pub fn instances(mut self, input: crate::types::DeviceInstance) -> Self {
        let mut v = self.instances.unwrap_or_default();
        v.push(input);
        self.instances = Some(v);
        self
    }
    /// <p>The instances that belong to this device.</p>
    pub fn set_instances(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::DeviceInstance>>,
    ) -> Self {
        self.instances = input;
        self
    }
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <code>ListDevices</code> and GetDevice API methods.</p>
    pub fn availability(mut self, input: crate::types::DeviceAvailability) -> Self {
        self.availability = Some(input);
        self
    }
    /// <p>Indicates how likely a device is available for a test run. Currently available in the <code>ListDevices</code> and GetDevice API methods.</p>
    pub fn set_availability(
        mut self,
        input: std::option::Option<crate::types::DeviceAvailability>,
    ) -> Self {
        self.availability = input;
        self
    }
    /// Consumes the builder and constructs a [`Device`](crate::types::Device).
    pub fn build(self) -> crate::types::Device {
        crate::types::Device {
            arn: self.arn,
            name: self.name,
            manufacturer: self.manufacturer,
            model: self.model,
            model_id: self.model_id,
            form_factor: self.form_factor,
            platform: self.platform,
            os: self.os,
            cpu: self.cpu,
            resolution: self.resolution,
            heap_size: self.heap_size,
            memory: self.memory,
            image: self.image,
            carrier: self.carrier,
            radio: self.radio,
            remote_access_enabled: self.remote_access_enabled,
            remote_debug_enabled: self.remote_debug_enabled,
            fleet_type: self.fleet_type,
            fleet_name: self.fleet_name,
            instances: self.instances,
            availability: self.availability,
        }
    }
}
