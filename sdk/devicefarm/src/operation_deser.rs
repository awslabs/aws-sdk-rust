// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDevicePoolOutput, crate::error::CreateDevicePoolError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDevicePoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDevicePoolError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateDevicePoolError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDevicePoolError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::CreateDevicePoolError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDevicePoolError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::CreateDevicePoolError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDevicePoolError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::CreateDevicePoolError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDevicePoolError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateDevicePoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDevicePoolOutput, crate::error::CreateDevicePoolError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_device_pool_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_device_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDevicePoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceProfileOutput,
    crate::error::CreateInstanceProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateInstanceProfileError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::CreateInstanceProfileError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::CreateInstanceProfileError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::CreateInstanceProfileError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceProfileOutput,
    crate::error::CreateInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkProfileOutput,
    crate::error::CreateNetworkProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateNetworkProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateNetworkProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateNetworkProfileError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateNetworkProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::CreateNetworkProfileError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::CreateNetworkProfileError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::CreateNetworkProfileError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateNetworkProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkProfileOutput,
    crate::error::CreateNetworkProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_network_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateNetworkProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateProjectError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::CreateProjectError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::CreateProjectError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::CreateProjectError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TagOperationException" => crate::error::CreateProjectError::TagOperationException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::tag_operation_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_tag_operation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateProjectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRemoteAccessSessionOutput,
    crate::error::CreateRemoteAccessSessionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateRemoteAccessSessionError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::CreateRemoteAccessSessionError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::CreateRemoteAccessSessionError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::CreateRemoteAccessSessionError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRemoteAccessSessionOutput,
    crate::error::CreateRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_remote_access_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_remote_access_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_test_grid_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTestGridProjectOutput,
    crate::error::CreateTestGridProjectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTestGridProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTestGridProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateTestGridProjectError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTestGridProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServiceException" => {
            crate::error::CreateTestGridProjectError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "LimitExceededException" => {
            crate::error::CreateTestGridProjectError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateTestGridProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_test_grid_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTestGridProjectOutput,
    crate::error::CreateTestGridProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_test_grid_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_test_grid_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTestGridProjectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_test_grid_url_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTestGridUrlOutput, crate::error::CreateTestGridUrlError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTestGridUrlError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTestGridUrlError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateTestGridUrlError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTestGridUrlError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServiceException" => {
            crate::error::CreateTestGridUrlError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTestGridUrlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::CreateTestGridUrlError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTestGridUrlError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateTestGridUrlError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_test_grid_url_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTestGridUrlOutput, crate::error::CreateTestGridUrlError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_test_grid_url_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_test_grid_url(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTestGridUrlError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUploadOutput, crate::error::CreateUploadError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateUploadError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateUploadError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateUploadError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::CreateUploadError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::CreateUploadError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUploadError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::CreateUploadError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateUploadError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUploadOutput, crate::error::CreateUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_upload_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_upload(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateUploadError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpce_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpceConfigurationOutput,
    crate::error::CreateVPCEConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateVPCEConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateVPCEConfigurationError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::CreateVPCEConfigurationError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::CreateVPCEConfigurationError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateVPCEConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpce_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpceConfigurationOutput,
    crate::error::CreateVPCEConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpce_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_vpce_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_device_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDevicePoolOutput, crate::error::DeleteDevicePoolError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDevicePoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDevicePoolError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteDevicePoolError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDevicePoolError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::DeleteDevicePoolError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDevicePoolError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::DeleteDevicePoolError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDevicePoolError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::DeleteDevicePoolError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDevicePoolError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteDevicePoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_device_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDevicePoolOutput, crate::error::DeleteDevicePoolError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_device_pool_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstanceProfileOutput,
    crate::error::DeleteInstanceProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteInstanceProfileError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::DeleteInstanceProfileError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::DeleteInstanceProfileError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::DeleteInstanceProfileError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstanceProfileOutput,
    crate::error::DeleteInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_instance_profile_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkProfileOutput,
    crate::error::DeleteNetworkProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteNetworkProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteNetworkProfileError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::DeleteNetworkProfileError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::DeleteNetworkProfileError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::DeleteNetworkProfileError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteNetworkProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkProfileOutput,
    crate::error::DeleteNetworkProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_profile_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteProjectError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::DeleteProjectError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::DeleteProjectError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::DeleteProjectError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_project_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRemoteAccessSessionOutput,
    crate::error::DeleteRemoteAccessSessionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteRemoteAccessSessionError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::DeleteRemoteAccessSessionError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::DeleteRemoteAccessSessionError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::DeleteRemoteAccessSessionError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRemoteAccessSessionOutput,
    crate::error::DeleteRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_remote_access_session_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_run_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRunOutput, crate::error::DeleteRunError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteRunError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRunError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteRunError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::DeleteRunError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::DeleteRunError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRunError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::DeleteRunError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteRunError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_run_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRunOutput, crate::error::DeleteRunError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_run_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_test_grid_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTestGridProjectOutput,
    crate::error::DeleteTestGridProjectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteTestGridProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteTestGridProjectError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CannotDeleteException" => {
            crate::error::DeleteTestGridProjectError::CannotDeleteException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cannot_delete_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_cannot_delete_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServiceException" => {
            crate::error::DeleteTestGridProjectError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::DeleteTestGridProjectError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteTestGridProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_test_grid_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTestGridProjectOutput,
    crate::error::DeleteTestGridProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_test_grid_project_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUploadOutput, crate::error::DeleteUploadError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteUploadError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUploadError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteUploadError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::DeleteUploadError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::DeleteUploadError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteUploadError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::DeleteUploadError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DeleteUploadError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUploadOutput, crate::error::DeleteUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_upload_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpce_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpceConfigurationOutput,
    crate::error::DeleteVPCEConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteVPCEConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteVPCEConfigurationError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidOperationException" => {
            crate::error::DeleteVPCEConfigurationError::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_operation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::DeleteVPCEConfigurationError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::DeleteVPCEConfigurationError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteVPCEConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpce_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpceConfigurationOutput,
    crate::error::DeleteVPCEConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpce_configuration_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_settings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountSettingsOutput,
    crate::error::GetAccountSettingsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetAccountSettingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountSettingsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetAccountSettingsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetAccountSettingsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::GetAccountSettingsError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAccountSettingsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::GetAccountSettingsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAccountSettingsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::GetAccountSettingsError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetAccountSettingsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetAccountSettingsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_settings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountSettingsOutput,
    crate::error::GetAccountSettingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_settings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_account_settings(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccountSettingsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeviceOutput, crate::error::GetDeviceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDeviceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDeviceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetDeviceError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetDeviceError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeviceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetDeviceError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeviceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::GetDeviceError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeviceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetDeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeviceOutput, crate::error::GetDeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_device(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDeviceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeviceInstanceOutput, crate::error::GetDeviceInstanceError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDeviceInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDeviceInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetDeviceInstanceError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceInstanceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetDeviceInstanceError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeviceInstanceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetDeviceInstanceError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeviceInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::GetDeviceInstanceError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDeviceInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetDeviceInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeviceInstanceOutput, crate::error::GetDeviceInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_device_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDeviceInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDevicePoolOutput, crate::error::GetDevicePoolError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDevicePoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDevicePoolError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetDevicePoolError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetDevicePoolError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDevicePoolError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetDevicePoolError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDevicePoolError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::GetDevicePoolError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDevicePoolError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetDevicePoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDevicePoolOutput, crate::error::GetDevicePoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_pool_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_device_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDevicePoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_pool_compatibility_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDevicePoolCompatibilityOutput,
    crate::error::GetDevicePoolCompatibilityError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDevicePoolCompatibilityError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetDevicePoolCompatibilityError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::GetDevicePoolCompatibilityError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::GetDevicePoolCompatibilityError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::GetDevicePoolCompatibilityError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetDevicePoolCompatibilityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_pool_compatibility_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDevicePoolCompatibilityOutput,
    crate::error::GetDevicePoolCompatibilityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_pool_compatibility_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_device_pool_compatibility(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceProfileOutput,
    crate::error::GetInstanceProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetInstanceProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetInstanceProfileError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetInstanceProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::GetInstanceProfileError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::GetInstanceProfileError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::GetInstanceProfileError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceProfileOutput,
    crate::error::GetInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetInstanceProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetJobOutput, crate::error::GetJobError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetJobError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetJobError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetJobError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::GetJobError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetJobOutput, crate::error::GetJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetNetworkProfileOutput, crate::error::GetNetworkProfileError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetNetworkProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetNetworkProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetNetworkProfileError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetNetworkProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetNetworkProfileError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetNetworkProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetNetworkProfileError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::GetNetworkProfileError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetNetworkProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetNetworkProfileOutput, crate::error::GetNetworkProfileError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_network_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_network_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetNetworkProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_offering_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOfferingStatusOutput, crate::error::GetOfferingStatusError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetOfferingStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetOfferingStatusError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetOfferingStatusError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetOfferingStatusError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetOfferingStatusError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOfferingStatusError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotEligibleException" => {
            crate::error::GetOfferingStatusError::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_eligible_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOfferingStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::GetOfferingStatusError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOfferingStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::GetOfferingStatusError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetOfferingStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetOfferingStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_offering_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOfferingStatusOutput, crate::error::GetOfferingStatusError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_offering_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_offering_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOfferingStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetProjectOutput, crate::error::GetProjectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetProjectError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetProjectError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetProjectError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::GetProjectError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetProjectOutput, crate::error::GetProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetProjectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRemoteAccessSessionOutput,
    crate::error::GetRemoteAccessSessionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetRemoteAccessSessionError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::GetRemoteAccessSessionError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::GetRemoteAccessSessionError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::GetRemoteAccessSessionError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRemoteAccessSessionOutput,
    crate::error::GetRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_remote_access_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_remote_access_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_run_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRunOutput, crate::error::GetRunError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetRunError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRunError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetRunError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetRunError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetRunError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRunError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::GetRunError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetRunError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_run_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRunOutput, crate::error::GetRunError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_run_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_run(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRunError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_suite_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSuiteOutput, crate::error::GetSuiteError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetSuiteError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetSuiteError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetSuiteError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetSuiteError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetSuiteError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetSuiteError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetSuiteError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetSuiteError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::GetSuiteError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetSuiteError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetSuiteError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_suite_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSuiteOutput, crate::error::GetSuiteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_suite_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_suite(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSuiteError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTestOutput, crate::error::GetTestError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTestError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetTestError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetTestError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTestError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetTestError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::GetTestError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTestError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetTestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTestOutput, crate::error::GetTestError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_test_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_test(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTestError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_grid_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTestGridProjectOutput,
    crate::error::GetTestGridProjectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTestGridProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTestGridProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetTestGridProjectError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestGridProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServiceException" => {
            crate::error::GetTestGridProjectError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::GetTestGridProjectError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetTestGridProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_grid_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTestGridProjectOutput,
    crate::error::GetTestGridProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_test_grid_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_test_grid_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTestGridProjectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_grid_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTestGridSessionOutput,
    crate::error::GetTestGridSessionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTestGridSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTestGridSessionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetTestGridSessionError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestGridSessionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServiceException" => {
            crate::error::GetTestGridSessionError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTestGridSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::GetTestGridSessionError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetTestGridSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetTestGridSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_grid_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTestGridSessionOutput,
    crate::error::GetTestGridSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_test_grid_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_test_grid_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTestGridSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUploadOutput, crate::error::GetUploadError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetUploadError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUploadError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetUploadError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::GetUploadError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetUploadError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetUploadError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::GetUploadError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetUploadError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUploadOutput, crate::error::GetUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_upload_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_upload(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetUploadError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpce_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVpceConfigurationOutput,
    crate::error::GetVPCEConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetVPCEConfigurationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetVPCEConfigurationError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::GetVPCEConfigurationError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::GetVPCEConfigurationError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetVPCEConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpce_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVpceConfigurationOutput,
    crate::error::GetVPCEConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_vpce_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_vpce_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_install_to_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::InstallToRemoteAccessSessionOutput,
    crate::error::InstallToRemoteAccessSessionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::InstallToRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => {
            crate::error::InstallToRemoteAccessSessionError::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "LimitExceededException" => {
            crate::error::InstallToRemoteAccessSessionError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::InstallToRemoteAccessSessionError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::InstallToRemoteAccessSessionError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::InstallToRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_install_to_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::InstallToRemoteAccessSessionOutput,
    crate::error::InstallToRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::install_to_remote_access_session_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_install_to_remote_access_session(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_artifacts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListArtifactsOutput, crate::error::ListArtifactsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListArtifactsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListArtifactsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListArtifactsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListArtifactsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListArtifactsError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListArtifactsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListArtifactsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListArtifactsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListArtifactsError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListArtifactsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListArtifactsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_artifacts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListArtifactsOutput, crate::error::ListArtifactsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_artifacts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_artifacts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListArtifactsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeviceInstancesOutput,
    crate::error::ListDeviceInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDeviceInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDeviceInstancesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListDeviceInstancesError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDeviceInstancesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::ListDeviceInstancesError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDeviceInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListDeviceInstancesError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDeviceInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::ListDeviceInstancesError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDeviceInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListDeviceInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeviceInstancesOutput,
    crate::error::ListDeviceInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_device_instances_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_device_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDeviceInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_pools_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicePoolsOutput, crate::error::ListDevicePoolsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDevicePoolsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDevicePoolsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListDevicePoolsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicePoolsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListDevicePoolsError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDevicePoolsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListDevicePoolsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDevicePoolsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListDevicePoolsError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDevicePoolsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListDevicePoolsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_pools_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicePoolsOutput, crate::error::ListDevicePoolsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_device_pools_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_device_pools(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDevicePoolsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicesOutput, crate::error::ListDevicesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListDevicesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDevicesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListDevicesError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListDevicesError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDevicesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListDevicesError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDevicesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListDevicesError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListDevicesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListDevicesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicesOutput, crate::error::ListDevicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_devices_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_devices(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDevicesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfilesOutput,
    crate::error::ListInstanceProfilesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInstanceProfilesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListInstanceProfilesError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::ListInstanceProfilesError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListInstanceProfilesError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::ListInstanceProfilesError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListInstanceProfilesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfilesOutput,
    crate::error::ListInstanceProfilesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_profiles_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_instance_profiles(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListJobsOutput, crate::error::ListJobsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListJobsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListJobsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListJobsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListJobsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListJobsError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListJobsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListJobsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListJobsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListJobsError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListJobsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListJobsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListJobsOutput, crate::error::ListJobsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_jobs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListJobsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_network_profiles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNetworkProfilesOutput,
    crate::error::ListNetworkProfilesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListNetworkProfilesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListNetworkProfilesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListNetworkProfilesError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListNetworkProfilesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::ListNetworkProfilesError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListNetworkProfilesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListNetworkProfilesError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListNetworkProfilesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::ListNetworkProfilesError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListNetworkProfilesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListNetworkProfilesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_network_profiles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNetworkProfilesOutput,
    crate::error::ListNetworkProfilesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_network_profiles_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_network_profiles(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListNetworkProfilesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offering_promotions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOfferingPromotionsOutput,
    crate::error::ListOfferingPromotionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOfferingPromotionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListOfferingPromotionsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::ListOfferingPromotionsError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotEligibleException" => {
            crate::error::ListOfferingPromotionsError::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_eligible_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListOfferingPromotionsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::ListOfferingPromotionsError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListOfferingPromotionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offering_promotions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOfferingPromotionsOutput,
    crate::error::ListOfferingPromotionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_offering_promotions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_offering_promotions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offerings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOfferingsOutput, crate::error::ListOfferingsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListOfferingsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListOfferingsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListOfferingsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListOfferingsError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotEligibleException" => {
            crate::error::ListOfferingsError::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_eligible_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListOfferingsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListOfferingsError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListOfferingsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offerings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOfferingsOutput, crate::error::ListOfferingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_offerings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_offerings(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOfferingsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offering_transactions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOfferingTransactionsOutput,
    crate::error::ListOfferingTransactionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOfferingTransactionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListOfferingTransactionsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::ListOfferingTransactionsError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotEligibleException" => {
            crate::error::ListOfferingTransactionsError::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_eligible_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListOfferingTransactionsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::ListOfferingTransactionsError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListOfferingTransactionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offering_transactions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOfferingTransactionsOutput,
    crate::error::ListOfferingTransactionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_offering_transactions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_offering_transactions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListProjectsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListProjectsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListProjectsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListProjectsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListProjectsError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListProjectsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListProjectsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListProjectsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListProjectsError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListProjectsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListProjectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_projects(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListProjectsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_remote_access_sessions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRemoteAccessSessionsOutput,
    crate::error::ListRemoteAccessSessionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListRemoteAccessSessionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListRemoteAccessSessionsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::ListRemoteAccessSessionsError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListRemoteAccessSessionsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::ListRemoteAccessSessionsError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListRemoteAccessSessionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_remote_access_sessions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRemoteAccessSessionsOutput,
    crate::error::ListRemoteAccessSessionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_remote_access_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_remote_access_sessions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_runs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRunsOutput, crate::error::ListRunsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListRunsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRunsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListRunsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRunsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListRunsError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRunsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListRunsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRunsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListRunsError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRunsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListRunsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_runs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRunsOutput, crate::error::ListRunsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_runs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_runs(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListRunsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_samples_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSamplesOutput, crate::error::ListSamplesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListSamplesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSamplesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListSamplesError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSamplesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListSamplesError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSamplesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListSamplesError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSamplesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListSamplesError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSamplesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListSamplesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_samples_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSamplesOutput, crate::error::ListSamplesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_samples_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_samples(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSamplesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_suites_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSuitesOutput, crate::error::ListSuitesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListSuitesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSuitesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListSuitesError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSuitesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListSuitesError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSuitesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListSuitesError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSuitesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListSuitesError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSuitesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListSuitesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_suites_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSuitesOutput, crate::error::ListSuitesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_suites_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_suites(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSuitesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTagsForResourceError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListTagsForResourceError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TagOperationException" => crate::error::ListTagsForResourceError::TagOperationException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::tag_operation_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_tag_operation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_projects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridProjectsOutput,
    crate::error::ListTestGridProjectsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTestGridProjectsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTestGridProjectsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTestGridProjectsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridProjectsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServiceException" => {
            crate::error::ListTestGridProjectsError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestGridProjectsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTestGridProjectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_projects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridProjectsOutput,
    crate::error::ListTestGridProjectsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_test_grid_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_test_grid_projects(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTestGridProjectsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_session_actions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionActionsOutput,
    crate::error::ListTestGridSessionActionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListTestGridSessionActionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTestGridSessionActionsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServiceException" => {
            crate::error::ListTestGridSessionActionsError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListTestGridSessionActionsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTestGridSessionActionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_session_actions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionActionsOutput,
    crate::error::ListTestGridSessionActionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_test_grid_session_actions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_test_grid_session_actions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_session_artifacts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionArtifactsOutput,
    crate::error::ListTestGridSessionArtifactsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListTestGridSessionArtifactsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => {
            crate::error::ListTestGridSessionArtifactsError::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InternalServiceException" => {
            crate::error::ListTestGridSessionArtifactsError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListTestGridSessionArtifactsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTestGridSessionArtifactsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_session_artifacts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionArtifactsOutput,
    crate::error::ListTestGridSessionArtifactsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_test_grid_session_artifacts_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_test_grid_session_artifacts(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_sessions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionsOutput,
    crate::error::ListTestGridSessionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTestGridSessionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTestGridSessionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTestGridSessionsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServiceException" => {
            crate::error::ListTestGridSessionsError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestGridSessionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListTestGridSessionsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestGridSessionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTestGridSessionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_sessions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionsOutput,
    crate::error::ListTestGridSessionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_test_grid_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_test_grid_sessions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTestGridSessionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tests_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTestsOutput, crate::error::ListTestsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTestsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTestsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListTestsError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListTestsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListTestsError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTestsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListTestsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tests_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTestsOutput, crate::error::ListTestsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tests_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tests(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTestsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_unique_problems_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListUniqueProblemsOutput,
    crate::error::ListUniqueProblemsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListUniqueProblemsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUniqueProblemsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListUniqueProblemsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUniqueProblemsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::ListUniqueProblemsError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListUniqueProblemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::ListUniqueProblemsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListUniqueProblemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::ListUniqueProblemsError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListUniqueProblemsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListUniqueProblemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_unique_problems_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListUniqueProblemsOutput,
    crate::error::ListUniqueProblemsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_unique_problems_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_unique_problems(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListUniqueProblemsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_uploads_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUploadsOutput, crate::error::ListUploadsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListUploadsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUploadsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListUploadsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUploadsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::ListUploadsError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListUploadsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ListUploadsError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListUploadsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ListUploadsError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListUploadsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListUploadsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_uploads_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUploadsOutput, crate::error::ListUploadsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_uploads_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_uploads(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListUploadsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_vpce_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVpceConfigurationsOutput,
    crate::error::ListVPCEConfigurationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListVPCEConfigurationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListVPCEConfigurationsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListVPCEConfigurationsError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListVPCEConfigurationsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ServiceAccountException" => {
            crate::error::ListVPCEConfigurationsError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListVPCEConfigurationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListVPCEConfigurationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_vpce_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVpceConfigurationsOutput,
    crate::error::ListVPCEConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_vpce_configurations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_vpce_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListVPCEConfigurationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_offering_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PurchaseOfferingOutput, crate::error::PurchaseOfferingError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PurchaseOfferingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PurchaseOfferingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::PurchaseOfferingError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PurchaseOfferingError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::PurchaseOfferingError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PurchaseOfferingError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotEligibleException" => {
            crate::error::PurchaseOfferingError::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_eligible_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PurchaseOfferingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::PurchaseOfferingError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PurchaseOfferingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::PurchaseOfferingError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PurchaseOfferingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::PurchaseOfferingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_offering_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PurchaseOfferingOutput, crate::error::PurchaseOfferingError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::purchase_offering_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_purchase_offering(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PurchaseOfferingError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_renew_offering_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RenewOfferingOutput, crate::error::RenewOfferingError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RenewOfferingError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RenewOfferingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::RenewOfferingError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RenewOfferingError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::RenewOfferingError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RenewOfferingError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotEligibleException" => {
            crate::error::RenewOfferingError::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_eligible_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RenewOfferingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::RenewOfferingError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RenewOfferingError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::RenewOfferingError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RenewOfferingError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::RenewOfferingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_renew_offering_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RenewOfferingOutput, crate::error::RenewOfferingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::renew_offering_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_renew_offering(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RenewOfferingError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_schedule_run_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ScheduleRunOutput, crate::error::ScheduleRunError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ScheduleRunError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ScheduleRunError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ScheduleRunError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ScheduleRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "IdempotencyException" => {
            crate::error::ScheduleRunError::IdempotencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotency_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotency_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ScheduleRunError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "LimitExceededException" => crate::error::ScheduleRunError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ScheduleRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::ScheduleRunError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ScheduleRunError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::ScheduleRunError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ScheduleRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ScheduleRunError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_schedule_run_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ScheduleRunOutput, crate::error::ScheduleRunError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::schedule_run_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_schedule_run(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ScheduleRunError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopJobOutput, crate::error::StopJobError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopJobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::StopJobError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::StopJobError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::StopJobError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopJobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::StopJobError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopJobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopJobOutput, crate::error::StopJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_job(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopJobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopRemoteAccessSessionOutput,
    crate::error::StopRemoteAccessSessionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StopRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::StopRemoteAccessSessionError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::StopRemoteAccessSessionError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::StopRemoteAccessSessionError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::StopRemoteAccessSessionError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::StopRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopRemoteAccessSessionOutput,
    crate::error::StopRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_remote_access_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_remote_access_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_run_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopRunOutput, crate::error::StopRunError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopRunError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopRunError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::StopRunError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::StopRunError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::StopRunError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopRunError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::StopRunError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopRunError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::StopRunError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_run_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopRunOutput, crate::error::StopRunError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_run_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_run(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopRunError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::TagResourceError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::TagResourceError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TagOperationException" => crate::error::TagResourceError::TagOperationException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::tag_operation_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_tag_operation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TagPolicyException" => {
            crate::error::TagResourceError::TagPolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tag_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => crate::error::TagResourceError::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_tags_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UntagResourceError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::UntagResourceError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TagOperationException" => crate::error::UntagResourceError::TagOperationException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::tag_operation_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_tag_operation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDeviceInstanceOutput,
    crate::error::UpdateDeviceInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDeviceInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateDeviceInstanceError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::UpdateDeviceInstanceError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::UpdateDeviceInstanceError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::UpdateDeviceInstanceError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateDeviceInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDeviceInstanceOutput,
    crate::error::UpdateDeviceInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_device_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_device_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDevicePoolOutput, crate::error::UpdateDevicePoolError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDevicePoolError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDevicePoolError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateDevicePoolError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDevicePoolError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::UpdateDevicePoolError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDevicePoolError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::UpdateDevicePoolError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDevicePoolError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::UpdateDevicePoolError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDevicePoolError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateDevicePoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDevicePoolOutput, crate::error::UpdateDevicePoolError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_device_pool_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_device_pool(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDevicePoolError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateInstanceProfileOutput,
    crate::error::UpdateInstanceProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateInstanceProfileError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::UpdateInstanceProfileError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::UpdateInstanceProfileError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::UpdateInstanceProfileError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateInstanceProfileOutput,
    crate::error::UpdateInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_network_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateNetworkProfileOutput,
    crate::error::UpdateNetworkProfileError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateNetworkProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateNetworkProfileError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => {
            crate::error::UpdateNetworkProfileError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::UpdateNetworkProfileError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::UpdateNetworkProfileError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateNetworkProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_network_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateNetworkProfileOutput,
    crate::error::UpdateNetworkProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_network_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_network_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateProjectError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::UpdateProjectError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::UpdateProjectError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::UpdateProjectError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateProjectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_test_grid_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTestGridProjectOutput,
    crate::error::UpdateTestGridProjectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateTestGridProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateTestGridProjectError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InternalServiceException" => {
            crate::error::UpdateTestGridProjectError::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_service_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "LimitExceededException" => {
            crate::error::UpdateTestGridProjectError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::UpdateTestGridProjectError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateTestGridProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_test_grid_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTestGridProjectOutput,
    crate::error::UpdateTestGridProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_test_grid_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_test_grid_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUploadOutput, crate::error::UpdateUploadError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateUploadError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateUploadError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateUploadError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "LimitExceededException" => crate::error::UpdateUploadError::LimitExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "NotFoundException" => {
            crate::error::UpdateUploadError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateUploadError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => crate::error::UpdateUploadError::ServiceAccountException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::service_account_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateUploadError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UpdateUploadError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUploadOutput, crate::error::UpdateUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_upload_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_upload(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateUploadError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_vpce_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateVpceConfigurationOutput,
    crate::error::UpdateVPCEConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateVPCEConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateVPCEConfigurationError::ArgumentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::argument_exception::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::deser_structure_crate_error_argument_exception_json_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidOperationException" => {
            crate::error::UpdateVPCEConfigurationError::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_operation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NotFoundException" => {
            crate::error::UpdateVPCEConfigurationError::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ServiceAccountException" => {
            crate::error::UpdateVPCEConfigurationError::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_service_account_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateVPCEConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_vpce_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateVpceConfigurationOutput,
    crate::error::UpdateVPCEConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_vpce_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_vpce_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}
